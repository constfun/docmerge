//# 1 "index.bc.runtime.js"
// Generated by js_of_ocaml 3.2.1
(function(joo_global_object)
   {"use strict";
     /*<<stdlib.js 1115 0>>*/  /*<<stdlib.js 1115 20>>*/ var
     caml_oo_last_id=
      0;
     /*<<mlString.js 633 0>>*/ function caml_ml_string_length(s)
     { /*<<mlString.js 633 36>>*/ return s.l /*<<mlString.js 633 47>>*/ }
     /*<<mlString.js 192 0>>*/ function caml_string_unsafe_get(s,i)
     { /*<<mlString.js 193 2>>*/ switch(s.t & 6)
       {default:
          /*<<mlString.js 195 4>>*/ if(i >= s.c.length)
           /*<<mlString.js 195 25>>*/ return 0;case 0:
          /*<<mlString.js 197 4>>*/ return  /*<<mlString.js 197 11>>*/ s.c.charCodeAt
                 (i);
        case 4: /*<<mlString.js 199 4>>*/ return s.c[i]
        } /*<<mlString.js 201 0>>*/ }
     /*<<int64.js 60 0>>*/ function caml_int64_add(x,y)
     { /*<<int64.js 61 2>>*/ var
        /*<<int64.js 61 9>>*/ z1=x[1] + y[1],
        /*<<int64.js 62 9>>*/ z2=x[2] + y[2] + (z1 >> 24),
        /*<<int64.js 63 9>>*/ z3=x[3] + y[3] + (z2 >> 24);
       /*<<int64.js 64 2>>*/ return [255,
              z1 & 16777215,
              z2 & 16777215,
              z3 & 65535] /*<<int64.js 65 0>>*/ }
     /*<<int64.js 21 0>>*/  /*<<int64.js 21 22>>*/ var
     caml_int64_offset=
       /*<<int64.js 21 24>>*/ Math.pow(2,- 24);
     /*<<int64.js 77 0>>*/ function caml_int64_mul(x,y)
     { /*<<int64.js 78 2>>*/ var
        /*<<int64.js 78 9>>*/ z1=x[1] * y[1],
        /*<<int64.js 79 9>>*/ z2=
        (z1 * caml_int64_offset | 0)
        +
        x[2]
        *
        y[1]
        +
        x[1]
        *
        y[2],
        /*<<int64.js 80 9>>*/ z3=
        (z2 * caml_int64_offset | 0)
        +
        x[3]
        *
        y[1]
        +
        x[2]
        *
        y[2]
        +
        x[1]
        *
        y[3];
       /*<<int64.js 81 2>>*/ return [255,
              z1 & 16777215,
              z2 & 16777215,
              z3 & 65535] /*<<int64.js 82 0>>*/ }
     /*<<int64.js 52 0>>*/ function caml_int64_neg(x)
     { /*<<int64.js 53 2>>*/ var
        /*<<int64.js 53 9>>*/ y1=- x[1],
        /*<<int64.js 54 9>>*/ y2=- x[2] + (y1 >> 24),
        /*<<int64.js 55 9>>*/ y3=- x[3] + (y2 >> 24);
       /*<<int64.js 56 2>>*/ return [255,
              y1 & 16777215,
              y2 & 16777215,
              y3 & 65535] /*<<int64.js 57 0>>*/ }
     /*<<int64.js 241 0>>*/ function caml_int64_of_int32(x)
     { /*<<int64.js 242 2>>*/ return [255,
              x & 16777215,
              x >> 24 & 16777215,
              x >> 31 & 65535] /*<<int64.js 243 0>>*/ }
     /*<<stdlib.js 235 0>>*/ function caml_obj_dup(x)
     { /*<<stdlib.js 236 2>>*/ var
        /*<<stdlib.js 236 8>>*/ l=x.length,
        /*<<stdlib.js 237 8>>*/ a=new Array(l);
       /*<<stdlib.js 238 2>>*/ for
       ( /*<<stdlib.js 238 12>>*/ var i=0;i < l;i++)
       a[i] = x[i];
       /*<<stdlib.js 239 2>>*/ return a /*<<stdlib.js 240 0>>*/ }
     /*<<int64.js 68 0>>*/ function caml_int64_sub(x,y)
     { /*<<int64.js 69 2>>*/ var
        /*<<int64.js 69 9>>*/ z1=x[1] - y[1],
        /*<<int64.js 70 9>>*/ z2=x[2] - y[2] + (z1 >> 24),
        /*<<int64.js 71 9>>*/ z3=x[3] - y[3] + (z2 >> 24);
       /*<<int64.js 72 2>>*/ return [255,
              z1 & 16777215,
              z2 & 16777215,
              z3 & 65535] /*<<int64.js 73 0>>*/ }
     /*<<int64.js 24 0>>*/ function caml_int64_ucompare(x,y)
     { /*<<int64.js 25 2>>*/ if(x[3] > y[3]) /*<<int64.js 25 19>>*/ return 1;
       /*<<int64.js 26 2>>*/ if(x[3] < y[3])
        /*<<int64.js 26 19>>*/ return - 1;
       /*<<int64.js 27 2>>*/ if(x[2] > y[2]) /*<<int64.js 27 19>>*/ return 1;
       /*<<int64.js 28 2>>*/ if(x[2] < y[2])
        /*<<int64.js 28 19>>*/ return - 1;
       /*<<int64.js 29 2>>*/ if(x[1] > y[1]) /*<<int64.js 29 19>>*/ return 1;
       /*<<int64.js 30 2>>*/ if(x[1] < y[1])
        /*<<int64.js 30 19>>*/ return - 1;
       /*<<int64.js 31 2>>*/ return 0 /*<<int64.js 32 0>>*/ }
     /*<<int64.js 174 0>>*/ function caml_int64_lsl1(x)
     {x[3] = x[3] << 1 | x[2] >> 23;
      x[2] = (x[2] << 1 | x[1] >> 23) & 16777215;
      x[1] = x[1] << 1 & 16777215 /*<<int64.js 178 0>>*/ }
     /*<<int64.js 181 0>>*/ function caml_int64_lsr1(x)
     {x[1] = (x[1] >>> 1 | x[2] << 23) & 16777215;
      x[2] = (x[2] >>> 1 | x[3] << 23) & 16777215;
      x[3] = x[3] >>> 1 /*<<int64.js 185 0>>*/ }
     /*<<int64.js 191 0>>*/ function caml_int64_udivmod(x,y)
     { /*<<int64.js 192 2>>*/ var
        /*<<int64.js 192 13>>*/ offset=0,
        /*<<int64.js 193 14>>*/ modulus=
         /*<<int64.js 193 16>>*/ caml_obj_dup(x),
        /*<<int64.js 194 14>>*/ divisor=
         /*<<int64.js 194 16>>*/ caml_obj_dup(y),
        /*<<int64.js 195 15>>*/ quotient=[255,0,0,0];
       /*<<int64.js 196 2>>*/ while
       ( /*<<int64.js 196 9>>*/ caml_int64_ucompare(modulus,divisor) > 0)
        /*<<int64.js 196 53>>*/ {offset++;
         /*<<int64.js 198 4>>*/ caml_int64_lsl1(divisor)}
       /*<<int64.js 200 2>>*/ while(offset >= 0)
        /*<<int64.js 200 22>>*/ {offset--;
         /*<<int64.js 202 4>>*/ caml_int64_lsl1(quotient);
         /*<<int64.js 203 4>>*/ if
         ( /*<<int64.js 203 8>>*/ caml_int64_ucompare(modulus,divisor) >= 0)
          /*<<int64.js 203 53>>*/ {quotient[1]++;
          modulus =  /*<<int64.js 205 16>>*/ caml_int64_sub(modulus,divisor)}
         /*<<int64.js 207 4>>*/ caml_int64_lsr1(divisor)}
       /*<<int64.js 209 2>>*/ return [0,quotient,modulus] /*<<int64.js 210 0>>*/ }
     /*<<int64.js 36 0>>*/ function caml_int64_ult(x,y)
     { /*<<int64.js 36 31>>*/ return  /*<<int64.js 36 38>>*/ caml_int64_ucompare
              (x,y)
             <
             0 /*<<int64.js 36 68>>*/ }
     /*<<stdlib.js 442 0>>*/ function caml_parse_sign_and_base(s)
     { /*<<stdlib.js 443 2>>*/ var
        /*<<stdlib.js 443 8>>*/ i=0,
        /*<<stdlib.js 443 17>>*/ len=
         /*<<stdlib.js 443 19>>*/ caml_ml_string_length(s),
        /*<<stdlib.js 443 50>>*/ base=10,
        /*<<stdlib.js 443 61>>*/ sign=1;
       /*<<stdlib.js 444 2>>*/ if(len > 0)
        /*<<stdlib.js 444 15>>*/ switch
        ( /*<<stdlib.js 445 12>>*/ caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1; /*<<stdlib.js 446 29>>*/ break;
         case 43:i++;sign = 1; /*<<stdlib.js 447 28>>*/ break
         }
       /*<<stdlib.js 450 2>>*/ if
       (i
        +
        1
        <
        len
        &&
         /*<<stdlib.js 450 21>>*/ caml_string_unsafe_get(s,i)
        ==
        48)
        /*<<stdlib.js 451 4>>*/ switch
        ( /*<<stdlib.js 451 12>>*/ caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2; /*<<stdlib.js 452 42>>*/ break;
         case 111:
         case 79:base = 8;i += 2; /*<<stdlib.js 453 42>>*/ break;
         case 98:
         case 66:base = 2;i += 2; /*<<stdlib.js 454 42>>*/ break
         }
       /*<<stdlib.js 456 2>>*/ return [i,sign,base] /*<<stdlib.js 457 0>>*/ }
     /*<<stdlib.js 125 0>>*/ function caml_raise_with_arg(tag,arg)
     { /*<<stdlib.js 125 42>>*/ throw [0,tag,arg] /*<<stdlib.js 125 63>>*/ }
     /*<<mlString.js 50 0>>*/ function caml_str_repeat(n,s)
     { /*<<mlString.js 51 2>>*/ if(s.repeat)
        /*<<mlString.js 51 16>>*/ return  /*<<mlString.js 51 23>>*/ s.repeat
               (n);
       /*<<mlString.js 52 2>>*/ var
        /*<<mlString.js 52 8>>*/ r="",
        /*<<mlString.js 52 16>>*/ l=0;
       /*<<mlString.js 53 2>>*/ if(n == 0) /*<<mlString.js 53 14>>*/ return r;
       /*<<mlString.js 54 2>>*/ for(;;)
        /*<<mlString.js 54 10>>*/ { /*<<mlString.js 55 4>>*/ if(n & 1)r += s;
        n >>= 1;
         /*<<mlString.js 57 4>>*/ if(n == 0)
          /*<<mlString.js 57 16>>*/ return r;
        s += s;
        l++;
         /*<<mlString.js 60 4>>*/ if(l == 9)
          /*<<mlString.js 60 16>>*/  /*<<mlString.js 61 6>>*/ s.slice(0,1)} /*<<mlString.js 66 0>>*/ }
     /*<<stdlib.js 23 0>>*/ function raw_array_sub(a,i,l)
     { /*<<stdlib.js 24 2>>*/  /*<<stdlib.js 24 8>>*/ var b=new Array(l);
       /*<<stdlib.js 25 2>>*/ for( /*<<stdlib.js 25 12>>*/ var j=0;j < l;j++)
       b[j] = a[i + j];
       /*<<stdlib.js 26 2>>*/ return b /*<<stdlib.js 27 0>>*/ }
     /*<<mlString.js 70 0>>*/ function caml_subarray_to_string(a,i,len)
     { /*<<mlString.js 71 2>>*/  /*<<mlString.js 71 8>>*/ var
       f=
        String.fromCharCode;
       /*<<mlString.js 72 2>>*/ if(i == 0 && len <= 4096 && len == a.length)
        /*<<mlString.js 72 48>>*/ return  /*<<mlString.js 72 55>>*/ f.apply
               (null,a);
       /*<<mlString.js 71 2>>*/  /*<<mlString.js 73 8>>*/ var s="";
       /*<<mlString.js 74 2>>*/ for(;0 < len;i += 1024,len -= 1024)
       s
       +=
        /*<<mlString.js 75 9>>*/ f.apply
        (null,
          /*<<mlString.js 75 24>>*/ raw_array_sub
          (a,i, /*<<mlString.js 75 43>>*/ Math.min(len,1024)));
       /*<<mlString.js 76 2>>*/ return s /*<<mlString.js 77 0>>*/ }
     /*<<mlString.js 401 0>>*/ function caml_convert_string_to_bytes(s)
     { /*<<mlString.js 403 2>>*/ if(s.t == 2)
       s.c
       +=
        /*<<mlString.js 404 11>>*/ caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c
       =
        /*<<mlString.js 406 10>>*/ caml_subarray_to_string(s.c,0,s.c.length);
      s.t = 0 /*<<mlString.js 408 0>>*/ }
     /*<<mlString.js 162 0>>*/ function caml_is_ascii(s)
     { /*<<mlString.js 164 2>>*/ if(s.length < 24)
        /*<<mlString.js 164 21>>*/ { /*<<mlString.js 166 4>>*/ for
         ( /*<<mlString.js 166 15>>*/ var i=0;i < s.length;i++)
          /*<<mlString.js 166 39>>*/ if
          ( /*<<mlString.js 166 43>>*/ s.charCodeAt(i) > 127)
           /*<<mlString.js 166 66>>*/ return false;
         /*<<mlString.js 167 4>>*/ return true}
      else
        /*<<mlString.js 169 4>>*/ return !
               /*<<mlString.js 169 12>>*/ /[^\x00-\x7f]/.test(s) /*<<mlString.js 170 0>>*/ }
     /*<<mlString.js 115 0>>*/ function caml_utf16_of_utf8(s)
     { /*<<mlString.js 116 2>>*/ for
       (var
          /*<<mlString.js 116 13>>*/ b="",
          /*<<mlString.js 116 21>>*/ t="",
         c,
         c1,
         c2,
         v,
          /*<<mlString.js 116 43>>*/ i=0,
          /*<<mlString.js 116 50>>*/ l=s.length;
        i
        <
        l;
        i++)
        /*<<mlString.js 116 74>>*/ {c1
        =
         /*<<mlString.js 117 9>>*/ s.charCodeAt(i);
         /*<<mlString.js 118 4>>*/ if(c1 < 128)
          /*<<mlString.js 118 19>>*/ { /*<<mlString.js 119 6>>*/ for
           ( /*<<mlString.js 119 17>>*/ var j=i + 1;
            j
            <
            l
            &&
            (c1 =  /*<<mlString.js 119 43>>*/ s.charCodeAt(j))
            <
            128;
            j++)
            /*<<mlString.js 119 72>>*/ ;
           /*<<mlString.js 120 6>>*/ if(j - i > 512)
            /*<<mlString.js 120 23>>*/ { /*<<mlString.js 120 25>>*/ t.substr
             (0,1);
            b += t;
            t = "";
            b +=  /*<<mlString.js 120 62>>*/ s.slice(i,j)}
          else
           t +=  /*<<mlString.js 121 16>>*/ s.slice(i,j);
           /*<<mlString.js 122 6>>*/ if(j == l)
            /*<<mlString.js 122 18>>*/ break;
          i = j}
        v = 1;
         /*<<mlString.js 126 4>>*/ if
         (++i
          <
          l
          &&
          ((c2 =  /*<<mlString.js 126 29>>*/ s.charCodeAt(i)) & - 64)
          ==
          128)
          /*<<mlString.js 126 62>>*/ {c = c2 + (c1 << 6);
           /*<<mlString.js 128 6>>*/ if(c1 < 224)
            /*<<mlString.js 128 21>>*/ {v = c - 12416;
             /*<<mlString.js 130 8>>*/ if(v < 128)v = 1}
          else
            /*<<mlString.js 131 13>>*/ {v = 2;
             /*<<mlString.js 133 8>>*/ if
             (++i
              <
              l
              &&
              ((c2 =  /*<<mlString.js 133 33>>*/ s.charCodeAt(i)) & - 64)
              ==
              128)
              /*<<mlString.js 133 66>>*/ {c = c2 + (c << 6);
               /*<<mlString.js 135 10>>*/ if(c1 < 240)
                /*<<mlString.js 135 25>>*/ {v = c - 925824;
                 /*<<mlString.js 137 12>>*/ if
                 (v < 2048 || v >= 55295 && v < 57344)
                 v = 2}
              else
                /*<<mlString.js 138 17>>*/ {v = 3;
                 /*<<mlString.js 140 14>>*/ if
                 (++i
                  <
                  l
                  &&
                  ((c2 =  /*<<mlString.js 140 39>>*/ s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  245)
                  /*<<mlString.js 141 31>>*/ {v = c2 - 63447168 + (c << 6);
                   /*<<mlString.js 143 16>>*/ if(v < 65536 || v > 1114111)
                   v = 3}}}}}
         /*<<mlString.js 149 4>>*/ if(v < 4)
          /*<<mlString.js 149 15>>*/ {i -= v;t += "\ufffd"}
        else
          /*<<mlString.js 152 11>>*/ if(v > 65535)
          t
          +=
           /*<<mlString.js 153 11>>*/ String.fromCharCode
           (55232 + (v >> 10),56320 + (v & 1023));
         else
          t +=  /*<<mlString.js 155 11>>*/ String.fromCharCode(v);
         /*<<mlString.js 156 4>>*/ if(t.length > 1024)
          /*<<mlString.js 156 25>>*/ { /*<<mlString.js 156 26>>*/ t.substr
           (0,1);
          b += t;
          t = ""}}
       /*<<mlString.js 158 2>>*/ return b + t /*<<mlString.js 159 0>>*/ }
     /*<<mlString.js 174 0>>*/ function caml_to_js_string(s)
     { /*<<mlString.js 175 2>>*/ switch(s.t)
       {case 9: /*<<mlString.js 177 4>>*/ return s.c;
        default: /*<<mlString.js 179 4>>*/ caml_convert_string_to_bytes(s);case 0:
          /*<<mlString.js 181 4>>*/ if
          ( /*<<mlString.js 181 8>>*/ caml_is_ascii(s.c))
           /*<<mlString.js 181 28>>*/ {s.t = 9;
            /*<<mlString.js 183 6>>*/ return s.c}
         s.t = 8;
        case 8:
          /*<<mlString.js 187 4>>*/ return  /*<<mlString.js 187 11>>*/ caml_utf16_of_utf8
                 (s.c)
        } /*<<mlString.js 189 0>>*/ }
     /*<<mlString.js 394 0>>*/ function MlBytes(tag,contents,length)
     {this.t = tag;
      this.c = contents;
      this.l = length /*<<mlString.js 396 0>>*/ }
    MlBytes.prototype.toString
    =
    function()
     { /*<<mlString.js 397 40>>*/ return  /*<<mlString.js 397 47>>*/ caml_to_js_string
              (this) /*<<mlString.js 397 29>>*/ };
     /*<<mlString.js 464 0>>*/ function caml_new_string(s)
     { /*<<mlString.js 464 31>>*/ return new MlBytes(0,s,s.length) /*<<mlString.js 464 65>>*/ }
     /*<<stdlib.js 129 0>>*/ function caml_raise_with_string(tag,msg)
     { /*<<stdlib.js 130 2>>*/ caml_raise_with_arg
       (tag, /*<<stdlib.js 130 28>>*/ caml_new_string(msg)) /*<<stdlib.js 131 0>>*/ }
     /*<<stdlib.js 92 0>>*/  /*<<stdlib.js 92 21>>*/ var caml_global_data=[0];
     /*<<stdlib.js 141 0>>*/ function caml_failwith(msg)
     { /*<<stdlib.js 142 2>>*/ caml_raise_with_string
       (caml_global_data.Failure,msg) /*<<stdlib.js 143 0>>*/ }
     /*<<stdlib.js 460 0>>*/ function caml_parse_digit(c)
     { /*<<stdlib.js 461 2>>*/ if(c >= 48 && c <= 57)
        /*<<stdlib.js 461 27>>*/ return c - 48;
       /*<<stdlib.js 462 2>>*/ if(c >= 65 && c <= 90)
        /*<<stdlib.js 462 27>>*/ return c - 55;
       /*<<stdlib.js 463 2>>*/ if(c >= 97 && c <= 122)
        /*<<stdlib.js 463 27>>*/ return c - 87;
       /*<<stdlib.js 464 2>>*/ return - 1 /*<<stdlib.js 465 0>>*/ }
     /*<<int64.js 296 0>>*/ function caml_int64_of_string(s)
     { /*<<int64.js 297 2>>*/ var
        /*<<int64.js 297 8>>*/ r=
         /*<<int64.js 297 10>>*/ caml_parse_sign_and_base(s),
        /*<<int64.js 298 8>>*/ i=r[0],
        /*<<int64.js 298 21>>*/ sign=r[1],
        /*<<int64.js 298 34>>*/ base=r[2],
        /*<<int64.js 299 13>>*/ base64=
         /*<<int64.js 299 15>>*/ caml_int64_of_int32(base),
        /*<<int64.js 300 16>>*/ threshold=
         /*<<int64.js 301 4>>*/ caml_int64_udivmod
          ([255,16777215,268435455,65535],base64)
         [1],
        /*<<int64.js 302 8>>*/ c=
         /*<<int64.js 302 10>>*/ caml_string_unsafe_get(s,i),
        /*<<int64.js 303 8>>*/ d= /*<<int64.js 303 10>>*/ caml_parse_digit(c);
       /*<<int64.js 304 2>>*/ if(d < 0 || d >= base)
        /*<<int64.js 304 26>>*/ caml_failwith("int_of_string");
       /*<<int64.js 297 2>>*/  /*<<int64.js 305 10>>*/ var
       res=
         /*<<int64.js 305 12>>*/ caml_int64_of_int32(d);
       /*<<int64.js 306 2>>*/ for(;;)
        /*<<int64.js 306 11>>*/ {i++;
        c =  /*<<int64.js 308 8>>*/ caml_string_unsafe_get(s,i);
         /*<<int64.js 309 4>>*/ if(c == 95) /*<<int64.js 309 17>>*/ continue;
        d =  /*<<int64.js 310 8>>*/ caml_parse_digit(c);
         /*<<int64.js 311 4>>*/ if(d < 0 || d >= base)
          /*<<int64.js 311 28>>*/ break;
         /*<<int64.js 313 4>>*/ if
         ( /*<<int64.js 313 8>>*/ caml_int64_ult(threshold,res))
          /*<<int64.js 313 40>>*/ caml_failwith("int_of_string");
        d =  /*<<int64.js 314 8>>*/ caml_int64_of_int32(d);
        res
        =
         /*<<int64.js 315 10>>*/ caml_int64_add
         ( /*<<int64.js 315 25>>*/ caml_int64_mul(base64,res),d);
         /*<<int64.js 317 4>>*/ if
         ( /*<<int64.js 317 8>>*/ caml_int64_ult(res,d))
          /*<<int64.js 317 32>>*/ caml_failwith("int_of_string")}
       /*<<int64.js 319 2>>*/ if
       (i !=  /*<<int64.js 319 11>>*/ caml_ml_string_length(s))
        /*<<int64.js 319 37>>*/ caml_failwith("int_of_string");
       /*<<int64.js 320 2>>*/ if
       (r[2]
        ==
        10
        &&
         /*<<int64.js 320 20>>*/ caml_int64_ult([255,0,0,32768],res))
        /*<<int64.js 321 4>>*/ caml_failwith("int_of_string");
       /*<<int64.js 322 2>>*/ if(sign < 0)
       res =  /*<<int64.js 322 22>>*/ caml_int64_neg(res);
       /*<<int64.js 323 2>>*/ return res /*<<int64.js 324 0>>*/ }
     /*<<int64.js 85 0>>*/ function caml_int64_is_zero(x)
     { /*<<int64.js 86 2>>*/ return (x[3] | x[2] | x[1]) == 0 /*<<int64.js 87 0>>*/ }
     /*<<int64.js 246 0>>*/ function caml_int64_to_int32(x)
     { /*<<int64.js 247 2>>*/ return x[1] | x[2] << 24 /*<<int64.js 248 0>>*/ }
     /*<<int64.js 90 0>>*/ function caml_int64_is_negative(x)
     { /*<<int64.js 91 2>>*/ return x[3] << 16 < 0 /*<<int64.js 92 0>>*/ }
     /*<<mlString.js 435 0>>*/ function caml_jsbytes_of_string(s)
     { /*<<mlString.js 436 2>>*/ if((s.t & 6) != 0)
        /*<<mlString.js 436 34>>*/ caml_convert_string_to_bytes(s);
       /*<<mlString.js 437 2>>*/ return s.c /*<<mlString.js 438 0>>*/ }
     /*<<stdlib.js 185 0>>*/ function caml_invalid_argument(msg)
     { /*<<stdlib.js 186 2>>*/ caml_raise_with_string
       (caml_global_data.Invalid_argument,msg) /*<<stdlib.js 187 0>>*/ }
     /*<<stdlib.js 528 0>>*/ function caml_parse_format(fmt)
     {fmt =  /*<<stdlib.js 529 8>>*/ caml_jsbytes_of_string(fmt);
       /*<<stdlib.js 530 2>>*/  /*<<stdlib.js 530 10>>*/ var len=fmt.length;
       /*<<stdlib.js 531 2>>*/ if(len > 31)
        /*<<stdlib.js 531 16>>*/ caml_invalid_argument
        ("format_int: format too long");
       /*<<stdlib.js 530 2>>*/  /*<<stdlib.js 532 8>>*/ var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
       /*<<stdlib.js 536 2>>*/ for
       ( /*<<stdlib.js 536 13>>*/ var i=0;i < len;i++)
        /*<<stdlib.js 536 32>>*/ { /*<<stdlib.js 537 4>>*/  /*<<stdlib.js 537 10>>*/ var
         c=
           /*<<stdlib.js 537 12>>*/ fmt.charAt(i);
         /*<<stdlib.js 538 4>>*/ switch(c)
         {case "-":f.justify = "-"; /*<<stdlib.js 540 23>>*/ break;
          case "+":
          case " ":f.signstyle = c; /*<<stdlib.js 542 23>>*/ break;
          case "0":f.filler = "0"; /*<<stdlib.js 544 22>>*/ break;
          case "#":f.alternate = true; /*<<stdlib.js 546 26>>*/ break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
            /*<<stdlib.js 550 6>>*/ while
            (c
             =
              /*<<stdlib.js 550 15>>*/ fmt.charCodeAt(i)
             -
             48,
             c
             >=
             0
             &&
             c
             <=
             9)
             /*<<stdlib.js 550 57>>*/ {f.width = f.width * 10 + c;i++}
           i--;
            /*<<stdlib.js 554 5>>*/ break;
          case ".":
           f.prec = 0;
           i++;
            /*<<stdlib.js 558 6>>*/ while
            (c
             =
              /*<<stdlib.js 558 15>>*/ fmt.charCodeAt(i)
             -
             48,
             c
             >=
             0
             &&
             c
             <=
             9)
             /*<<stdlib.js 558 57>>*/ {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10; /*<<stdlib.js 565 19>>*/ break;
          case "x":f.base = 16; /*<<stdlib.js 567 19>>*/ break;
          case "X":
           f.base = 16;f.uppercase = true; /*<<stdlib.js 569 39>>*/ break;
          case "o":f.base = 8; /*<<stdlib.js 571 18>>*/ break;
          case "e":
          case "f":
          case "g":
           f.signedconv = true;f.conv = c; /*<<stdlib.js 573 39>>*/ break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv =  /*<<stdlib.js 576 15>>*/ c.toLowerCase();
            /*<<stdlib.js 576 33>>*/ break
          }}
       /*<<stdlib.js 579 2>>*/ return f /*<<stdlib.js 580 0>>*/ }
     /*<<stdlib.js 584 0>>*/ function caml_finish_formatting(f,rawbuffer)
     { /*<<stdlib.js 585 2>>*/ if(f.uppercase)
       rawbuffer =  /*<<stdlib.js 585 31>>*/ rawbuffer.toUpperCase();
       /*<<stdlib.js 586 2>>*/  /*<<stdlib.js 586 10>>*/ var
       len=
        rawbuffer.length;
       /*<<stdlib.js 588 2>>*/ if
       (f.signedconv && (f.sign < 0 || f.signstyle != "-"))
       len++;
       /*<<stdlib.js 589 2>>*/ if(f.alternate)
        /*<<stdlib.js 589 19>>*/ { /*<<stdlib.js 590 4>>*/ if(f.base == 8)
         len += 1;
         /*<<stdlib.js 591 4>>*/ if(f.base == 16)len += 2}
       /*<<stdlib.js 586 2>>*/  /*<<stdlib.js 594 13>>*/ var buffer="";
       /*<<stdlib.js 595 2>>*/ if(f.justify == "+" && f.filler == " ")
        /*<<stdlib.js 596 4>>*/ for
        ( /*<<stdlib.js 596 15>>*/ var i=len;i < f.width;i++)
        buffer += " ";
       /*<<stdlib.js 597 2>>*/ if(f.signedconv)
        /*<<stdlib.js 597 20>>*/ if(f.sign < 0)
        buffer += "-";
       else
         /*<<stdlib.js 599 9>>*/ if(f.signstyle != "-")buffer += f.signstyle;
       /*<<stdlib.js 601 2>>*/ if(f.alternate && f.base == 8)buffer += "0";
       /*<<stdlib.js 602 2>>*/ if(f.alternate && f.base == 16)buffer += "0x";
       /*<<stdlib.js 603 2>>*/ if(f.justify == "+" && f.filler == "0")
        /*<<stdlib.js 604 4>>*/ for
        ( /*<<stdlib.js 604 15>>*/ var i=len;i < f.width;i++)
        buffer += "0";
      buffer += rawbuffer;
       /*<<stdlib.js 606 2>>*/ if(f.justify == "-")
        /*<<stdlib.js 607 4>>*/ for
        ( /*<<stdlib.js 607 15>>*/ var i=len;i < f.width;i++)
        buffer += " ";
       /*<<stdlib.js 608 2>>*/ return  /*<<stdlib.js 608 9>>*/ caml_new_string
              (buffer) /*<<stdlib.js 609 0>>*/ }
     /*<<int64.js 270 0>>*/ function caml_int64_format(fmt,x)
     { /*<<int64.js 271 2>>*/  /*<<int64.js 271 8>>*/ var
       f=
         /*<<int64.js 271 10>>*/ caml_parse_format(fmt);
       /*<<int64.js 272 2>>*/ if
       (f.signedconv &&  /*<<int64.js 272 22>>*/ caml_int64_is_negative(x))
        /*<<int64.js 272 49>>*/ {f.sign = - 1;
        x =  /*<<int64.js 273 21>>*/ caml_int64_neg(x)}
       /*<<int64.js 271 2>>*/ var
        /*<<int64.js 275 13>>*/ buffer="",
        /*<<int64.js 276 12>>*/ wbase=
         /*<<int64.js 276 14>>*/ caml_int64_of_int32(f.base),
        /*<<int64.js 277 12>>*/ cvtbl="0123456789abcdef";
       /*<<int64.js 278 2>>*/ do
        /*<<int64.js 278 5>>*/ { /*<<int64.js 279 4>>*/  /*<<int64.js 279 10>>*/ var
         p=
           /*<<int64.js 279 12>>*/ caml_int64_udivmod(x,wbase);
        x = p[1];
        buffer
        =
         /*<<int64.js 281 13>>*/ cvtbl.charAt
         ( /*<<int64.js 281 26>>*/ caml_int64_to_int32(p[2]))
        +
        buffer}
      while
       (!  /*<<int64.js 282 13>>*/ caml_int64_is_zero(x));
       /*<<int64.js 283 2>>*/ if(f.prec >= 0)
        /*<<int64.js 283 19>>*/ {f.filler = " ";
         /*<<int64.js 285 4>>*/  /*<<int64.js 285 10>>*/ var
         n=
          f.prec - buffer.length;
         /*<<int64.js 286 4>>*/ if(n > 0)
         buffer =  /*<<int64.js 286 24>>*/ caml_str_repeat(n,"0") + buffer}
       /*<<int64.js 288 2>>*/ return  /*<<int64.js 288 9>>*/ caml_finish_formatting
              (f,buffer) /*<<int64.js 289 0>>*/ }
     /*<<ieee_754.js 222 0>>*/ function caml_expm1_float(x)
     { /*<<ieee_754.js 223 2>>*/ var
        /*<<ieee_754.js 223 8>>*/ y= /*<<ieee_754.js 223 10>>*/ Math.exp(x),
        /*<<ieee_754.js 223 25>>*/ z=y - 1;
       /*<<ieee_754.js 224 2>>*/ return  /*<<ieee_754.js 224 10>>*/ Math.abs
               (x)
              >
              1
              ?z
              :z == 0?x:x * z /  /*<<ieee_754.js 224 38>>*/ Math.log(y) /*<<ieee_754.js 225 0>>*/ }
     /*<<fs.js 23 0>>*/ if
     (joo_global_object.process && joo_global_object.process.cwd)
      /*<<fs.js 24 2>>*/  /*<<fs.js 24 23>>*/ var
      caml_current_dir=
        /*<<fs.js 24 25>>*/  /*<<fs.js 24 25>>*/ joo_global_object.process.cwd
         ().replace
        (/\\/g,"/");
    else
      /*<<fs.js 26 2>>*/  /*<<fs.js 26 23>>*/ var caml_current_dir="/static";
     /*<<fs.js 27 0>>*/ if
     ( /*<<fs.js 27 3>>*/ caml_current_dir.slice(- 1) !== "/")
     caml_current_dir += "/";
     /*<<fs.js 39 0>>*/ function caml_make_path(name)
     {name
      =
      name instanceof MlBytes? /*<<fs.js 40 33>>*/ name.toString():name;
       /*<<fs.js 41 2>>*/ if( /*<<fs.js 41 5>>*/ name.charCodeAt(0) != 47)
       name = caml_current_dir + name;
       /*<<fs.js 43 2>>*/ var
        /*<<fs.js 43 11>>*/ comp= /*<<fs.js 43 13>>*/ name.split("/"),
        /*<<fs.js 44 12>>*/ ncomp=[];
       /*<<fs.js 45 2>>*/ for
       ( /*<<fs.js 45 12>>*/ var i=0;i < comp.length;i++)
        /*<<fs.js 45 36>>*/ switch(comp[i])
        {case "..":
           /*<<fs.js 47 15>>*/ if(ncomp.length > 1)
            /*<<fs.js 47 34>>*/ ncomp.pop();
           /*<<fs.js 47 47>>*/ break;
         case ".": /*<<fs.js 48 14>>*/ break;
         case "":
           /*<<fs.js 49 13>>*/ if(ncomp.length == 0)
            /*<<fs.js 49 35>>*/ ncomp.push("");
           /*<<fs.js 49 51>>*/ break;
         default:
           /*<<fs.js 50 13>>*/ ncomp.push(comp[i]); /*<<fs.js 50 33>>*/ break}
      ncomp.orig = name;
       /*<<fs.js 54 2>>*/ return ncomp /*<<fs.js 55 0>>*/ }
     /*<<stdlib.js 135 0>>*/ function caml_raise_sys_error(msg)
     { /*<<stdlib.js 136 2>>*/ caml_raise_with_string
       (caml_global_data.Sys_error,msg) /*<<stdlib.js 137 0>>*/ }
     /*<<fs.js 137 0>>*/ function caml_raise_no_such_file(name)
     {name
      =
      name instanceof MlBytes? /*<<fs.js 138 35>>*/ name.toString():name;
       /*<<fs.js 139 2>>*/ caml_raise_sys_error
       (name + ": No such file or directory") /*<<fs.js 140 0>>*/ }
     /*<<mlString.js 468 0>>*/ function caml_string_of_array(a)
     { /*<<mlString.js 468 36>>*/ return new MlBytes(4,a,a.length) /*<<mlString.js 468 70>>*/ }
     /*<<mlString.js 240 0>>*/ function caml_string_bound_error()
     { /*<<mlString.js 241 2>>*/ caml_invalid_argument("index out of bounds") /*<<mlString.js 242 0>>*/ }
     /*<<mlString.js 204 0>>*/ function caml_bytes_unsafe_get(s,i)
     { /*<<mlString.js 205 2>>*/ switch(s.t & 6)
       {default:
          /*<<mlString.js 207 4>>*/ if(i >= s.c.length)
           /*<<mlString.js 207 25>>*/ return 0;case 0:
          /*<<mlString.js 209 4>>*/ return  /*<<mlString.js 209 11>>*/ s.c.charCodeAt
                 (i);
        case 4: /*<<mlString.js 211 4>>*/ return s.c[i]
        } /*<<mlString.js 213 0>>*/ }
     /*<<mlString.js 317 0>>*/ function caml_bytes_get(s,i)
     { /*<<mlString.js 318 2>>*/ if(i >>> 0 >= s.l)
        /*<<mlString.js 318 22>>*/ caml_string_bound_error();
       /*<<mlString.js 319 2>>*/ return  /*<<mlString.js 319 9>>*/ caml_bytes_unsafe_get
              (s,i) /*<<mlString.js 320 0>>*/ }
     /*<<mlString.js 457 0>>*/ function caml_create_bytes(len)
     { /*<<mlString.js 458 2>>*/ if(len < 0)
        /*<<mlString.js 458 15>>*/ caml_invalid_argument("Bytes.create");
       /*<<mlString.js 459 2>>*/ return new MlBytes(len?2:9,"",len) /*<<mlString.js 460 0>>*/ }
     /*<<mlString.js 636 0>>*/ function caml_ml_bytes_length(s)
     { /*<<mlString.js 636 35>>*/ return s.l /*<<mlString.js 636 46>>*/ }
     /*<<mlString.js 411 0>>*/ function caml_convert_string_to_array(s)
     { /*<<mlString.js 413 2>>*/ if(joo_global_object.Uint8Array)
        /*<<mlString.js 413 35>>*/  /*<<mlString.js 414 10>>*/ var
        a=
         new (joo_global_object.Uint8Array)(s.l);
      else
        /*<<mlString.js 415 9>>*/  /*<<mlString.js 416 10>>*/ var
        a=
         new Array(s.l);
       /*<<mlString.js 418 2>>*/ var
        /*<<mlString.js 418 8>>*/ b=s.c,
        /*<<mlString.js 418 17>>*/ l=b.length,
        /*<<mlString.js 418 31>>*/ i=0;
       /*<<mlString.js 419 2>>*/ for(;i < l;i++)
       a[i] =  /*<<mlString.js 419 28>>*/ b.charCodeAt(i);
       /*<<mlString.js 420 2>>*/ for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
       /*<<mlString.js 423 2>>*/ return a /*<<mlString.js 424 0>>*/ }
     /*<<mlString.js 594 0>>*/ function caml_blit_bytes(s1,i1,s2,i2,len)
     { /*<<mlString.js 595 2>>*/ if(len == 0)
        /*<<mlString.js 595 16>>*/ return 0;
       /*<<mlString.js 596 2>>*/ if
       (i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
        /*<<mlString.js 597 72>>*/ {s2.c
        =
        s1.t == 4
         ? /*<<mlString.js 599 13>>*/ caml_subarray_to_string(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len
           ?s1.c
           : /*<<mlString.js 600 50>>*/ s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
        /*<<mlString.js 602 9>>*/ if(s2.t == 2 && i2 == s2.c.length)
         /*<<mlString.js 602 59>>*/ {s2.c
         +=
         s1.t == 4
          ? /*<<mlString.js 604 13>>*/ caml_subarray_to_string(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len
            ?s1.c
            : /*<<mlString.js 605 50>>*/ s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
         /*<<mlString.js 607 9>>*/ { /*<<mlString.js 608 4>>*/ if(s2.t != 4)
           /*<<mlString.js 608 31>>*/ caml_convert_string_to_array(s2);
          /*<<mlString.js 609 4>>*/ var
           /*<<mlString.js 609 11>>*/ c1=s1.c,
           /*<<mlString.js 609 22>>*/ c2=s2.c;
          /*<<mlString.js 610 4>>*/ if(s1.t == 4)
           /*<<mlString.js 610 31>>*/ if(i2 <= i1)
            /*<<mlString.js 611 22>>*/ for
            ( /*<<mlString.js 612 21>>*/ var i=0;i < len;i++)
            c2[i2 + i] = c1[i1 + i];
          else
            /*<<mlString.js 613 15>>*/ for
            ( /*<<mlString.js 614 21>>*/ var i=len - 1;i >= 0;i--)
            c2[i2 + i] = c1[i1 + i];
         else
           /*<<mlString.js 616 10>>*/ { /*<<mlString.js 617 6>>*/  /*<<mlString.js 617 12>>*/ var
            l=
              /*<<mlString.js 617 14>>*/ Math.min(len,c1.length - i1);
            /*<<mlString.js 618 6>>*/ for
            ( /*<<mlString.js 618 17>>*/ var i=0;i < l;i++)
            c2[i2 + i] =  /*<<mlString.js 618 48>>*/ c1.charCodeAt(i1 + i);
            /*<<mlString.js 619 6>>*/ for(;i < len;i++)c2[i2 + i] = 0}}
       /*<<mlString.js 622 2>>*/ return 0 /*<<mlString.js 623 0>>*/ }
     /*<<fs.js 35 0>>*/ function MlFile(){ /*<<fs.js 35 20>>*/ }
     /*<<fs_fake.js 115 0>>*/ function MlFakeFile(content)
     {this.data = content /*<<fs_fake.js 117 0>>*/ }
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     { /*<<fs_fake.js 120 2>>*/  /*<<fs_fake.js 120 10>>*/ var old=this.data;
      this.data =  /*<<fs_fake.js 121 14>>*/ caml_create_bytes(len | 0);
       /*<<fs_fake.js 122 2>>*/ caml_blit_bytes(old,0,this.data,0,len) /*<<fs_fake.js 119 32>>*/ };
    MlFakeFile.prototype.length
    =
    function()
     { /*<<fs_fake.js 125 2>>*/ return  /*<<fs_fake.js 125 9>>*/ caml_ml_bytes_length
              (this.data) /*<<fs_fake.js 124 30>>*/ };
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     { /*<<fs_fake.js 128 2>>*/  /*<<fs_fake.js 128 11>>*/ var
       clen=
         /*<<fs_fake.js 128 13>>*/ this.length();
       /*<<fs_fake.js 129 2>>*/ if(offset + len >= clen)
        /*<<fs_fake.js 129 27>>*/ { /*<<fs_fake.js 130 4>>*/ var
          /*<<fs_fake.js 130 16>>*/ new_str=
           /*<<fs_fake.js 130 18>>*/ caml_create_bytes(offset + len),
          /*<<fs_fake.js 131 17>>*/ old_data=this.data;
        this.data = new_str;
         /*<<fs_fake.js 133 4>>*/ caml_blit_bytes(old_data,0,this.data,0,clen)}
       /*<<fs_fake.js 135 2>>*/ caml_blit_bytes(buf,pos,this.data,offset,len);
       /*<<fs_fake.js 136 2>>*/ return 0 /*<<fs_fake.js 127 29>>*/ };
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     { /*<<fs_fake.js 139 2>>*/  /*<<fs_fake.js 139 11>>*/ var
       clen=
         /*<<fs_fake.js 139 13>>*/ this.length();
       /*<<fs_fake.js 140 2>>*/ caml_blit_bytes(this.data,offset,buf,pos,len);
       /*<<fs_fake.js 141 2>>*/ return 0 /*<<fs_fake.js 138 28>>*/ };
    MlFakeFile.prototype.read_one
    =
    function(offset)
     { /*<<fs_fake.js 144 2>>*/ return  /*<<fs_fake.js 144 9>>*/ caml_bytes_get
              (this.data,offset) /*<<fs_fake.js 143 32>>*/ };
    MlFakeFile.prototype.close = function(){ /*<<fs_fake.js 146 29>>*/ };
    MlFakeFile.prototype.constructor = MlFakeFile;
     /*<<fs_fake.js 24 0>>*/ function MlFakeDevice(root,f)
     {this.content = {};
      this.root = root;
      this.lookupFun = f /*<<fs_fake.js 28 0>>*/ }
    MlFakeDevice.prototype.nm
    =
    function(name)
     { /*<<fs_fake.js 30 2>>*/ return this.root + name /*<<fs_fake.js 29 28>>*/ };
    MlFakeDevice.prototype.lookup
    =
    function(name)
     { /*<<fs_fake.js 33 2>>*/ if(! this.content[name] && this.lookupFun)
        /*<<fs_fake.js 33 44>>*/ { /*<<fs_fake.js 34 4>>*/  /*<<fs_fake.js 34 12>>*/ var
         res=
           /*<<fs_fake.js 34 14>>*/ this.lookupFun
           ( /*<<fs_fake.js 34 29>>*/ caml_new_string(this.root),
             /*<<fs_fake.js 34 57>>*/ caml_new_string(name));
         /*<<fs_fake.js 35 4>>*/ if(res != 0)
         this.content[name] = new MlFakeFile(res[1])} /*<<fs_fake.js 32 32>>*/ };
    MlFakeDevice.prototype.exists
    =
    function(name)
     { /*<<fs_fake.js 40 2>>*/ if(name == "")
        /*<<fs_fake.js 40 17>>*/ return 1;
       /*<<fs_fake.js 42 2>>*/ var
        /*<<fs_fake.js 42 17>>*/ name_slash=name + "/",
        /*<<fs_fake.js 43 8>>*/ r=new RegExp("^" + name_slash);
       /*<<fs_fake.js 44 2>>*/ for(var n in this.content)
        /*<<fs_fake.js 44 29>>*/ if( /*<<fs_fake.js 45 8>>*/ n.match(r))
         /*<<fs_fake.js 45 20>>*/ return 1;
       /*<<fs_fake.js 48 2>>*/ this.lookup(name);
       /*<<fs_fake.js 49 2>>*/ return this.content[name]?1:0 /*<<fs_fake.js 38 32>>*/ };
    MlFakeDevice.prototype.readdir
    =
    function(name)
     { /*<<fs_fake.js 52 2>>*/ var
        /*<<fs_fake.js 52 17>>*/ name_slash=name == ""?"":name + "/",
        /*<<fs_fake.js 53 8>>*/ r=new RegExp("^" + name_slash + "([^/]*)"),
        /*<<fs_fake.js 54 11>>*/ seen={},
        /*<<fs_fake.js 55 8>>*/ a=[];
       /*<<fs_fake.js 56 2>>*/ for(var n in this.content)
        /*<<fs_fake.js 56 29>>*/ { /*<<fs_fake.js 57 4>>*/  /*<<fs_fake.js 57 10>>*/ var
         m=
           /*<<fs_fake.js 57 12>>*/ n.match(r);
         /*<<fs_fake.js 58 4>>*/ if(m && ! seen[m[1]])
          /*<<fs_fake.js 58 25>>*/ {seen[m[1]] = true;
           /*<<fs_fake.js 58 45>>*/ a.push(m[1])}}
       /*<<fs_fake.js 60 2>>*/ return a /*<<fs_fake.js 51 33>>*/ };
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     { /*<<fs_fake.js 63 2>>*/ var
        /*<<fs_fake.js 63 17>>*/ name_slash=name == ""?"":name + "/",
        /*<<fs_fake.js 64 8>>*/ r=new RegExp("^" + name_slash + "([^/]*)"),
        /*<<fs_fake.js 65 8>>*/ a=[];
       /*<<fs_fake.js 66 2>>*/ for(var n in this.content)
        /*<<fs_fake.js 66 29>>*/ { /*<<fs_fake.js 67 4>>*/  /*<<fs_fake.js 67 10>>*/ var
         m=
           /*<<fs_fake.js 67 12>>*/ n.match(r);
         /*<<fs_fake.js 68 4>>*/ if(m) /*<<fs_fake.js 68 10>>*/ return 1}
       /*<<fs_fake.js 70 2>>*/ return 0 /*<<fs_fake.js 62 32>>*/ };
    MlFakeDevice.prototype.unlink
    =
    function(name)
     { /*<<fs_fake.js 73 2>>*/  /*<<fs_fake.js 73 9>>*/ var
       ok=
        this.content[name]?true:false;
      delete this.content[name];
       /*<<fs_fake.js 75 2>>*/ return ok /*<<fs_fake.js 72 32>>*/ };
    MlFakeDevice.prototype.open
    =
    function(name,f)
     { /*<<fs_fake.js 78 2>>*/ if(f.rdonly && f.wronly)
        /*<<fs_fake.js 79 4>>*/ caml_raise_sys_error
        ( /*<<fs_fake.js 79 25>>*/ this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
       /*<<fs_fake.js 80 2>>*/ if(f.text && f.binary)
        /*<<fs_fake.js 81 4>>*/ caml_raise_sys_error
        ( /*<<fs_fake.js 81 25>>*/ this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
       /*<<fs_fake.js 82 2>>*/ this.lookup(name);
       /*<<fs_fake.js 83 2>>*/ if(this.content[name])
        /*<<fs_fake.js 83 26>>*/ { /*<<fs_fake.js 84 4>>*/ if
         ( /*<<fs_fake.js 84 8>>*/ this.is_dir(name))
          /*<<fs_fake.js 84 27>>*/ caml_raise_sys_error
          ( /*<<fs_fake.js 84 48>>*/ this.nm(name) + " : is a directory");
         /*<<fs_fake.js 85 4>>*/ if(f.create && f.excl)
          /*<<fs_fake.js 85 28>>*/ caml_raise_sys_error
          ( /*<<fs_fake.js 85 49>>*/ this.nm(name) + " : file already exists");
         /*<<fs_fake.js 86 4>>*/  /*<<fs_fake.js 86 13>>*/ var
         file=
          this.content[name];
         /*<<fs_fake.js 87 4>>*/ if(f.truncate)
          /*<<fs_fake.js 87 19>>*/ file.truncate();
         /*<<fs_fake.js 88 4>>*/ return file}
      else
        /*<<fs_fake.js 89 9>>*/ if(f.create)
         /*<<fs_fake.js 89 23>>*/ {this.content[name]
         =
         new MlFakeFile( /*<<fs_fake.js 90 40>>*/ caml_create_bytes(0));
          /*<<fs_fake.js 91 4>>*/ return this.content[name]}
       else
         /*<<fs_fake.js 92 9>>*/  /*<<fs_fake.js 93 4>>*/ caml_raise_no_such_file
         ( /*<<fs_fake.js 93 29>>*/ this.nm(name)) /*<<fs_fake.js 77 30>>*/ };
    MlFakeDevice.prototype.register
    =
    function(name,content)
     { /*<<fs_fake.js 98 2>>*/ if(this.content[name])
        /*<<fs_fake.js 98 25>>*/ caml_raise_sys_error
        ( /*<<fs_fake.js 98 46>>*/ this.nm(name) + " : file already exists");
       /*<<fs_fake.js 99 2>>*/ if(content instanceof MlBytes)
       this.content[name] = new MlFakeFile(content);
      else
        /*<<fs_fake.js 101 7>>*/ if(content instanceof Array)
        this.content[name]
        =
        new
         MlFakeFile
         ( /*<<fs_fake.js 102 40>>*/ caml_string_of_array(content));
       else
         /*<<fs_fake.js 103 7>>*/ if(content.toString)
          /*<<fs_fake.js 103 28>>*/ { /*<<fs_fake.js 104 4>>*/  /*<<fs_fake.js 104 17>>*/ var
           mlstring=
             /*<<fs_fake.js 104 19>>*/ caml_new_string
             ( /*<<fs_fake.js 104 35>>*/ content.toString());
          this.content[name] = new MlFakeFile(mlstring)} /*<<fs_fake.js 97 33>>*/ };
    MlFakeDevice.prototype.constructor = MlFakeDevice;
     /*<<mlString.js 428 0>>*/ function caml_array_of_string(s)
     { /*<<mlString.js 429 2>>*/ if(s.t != 4)
        /*<<mlString.js 429 28>>*/ caml_convert_string_to_array(s);
       /*<<mlString.js 430 2>>*/ return s.c /*<<mlString.js 431 0>>*/ }
     /*<<mlString.js 217 0>>*/ function caml_bytes_unsafe_set(s,i,c)
     {c &= 255;
       /*<<mlString.js 220 2>>*/ if(s.t != 4)
        /*<<mlString.js 220 28>>*/ { /*<<mlString.js 221 4>>*/ if
         (i == s.c.length)
          /*<<mlString.js 221 25>>*/ {s.c
          +=
           /*<<mlString.js 222 13>>*/ String.fromCharCode(c);
           /*<<mlString.js 223 6>>*/ if(i + 1 == s.l)s.t = 0;
           /*<<mlString.js 224 6>>*/ return 0}
         /*<<mlString.js 226 4>>*/ caml_convert_string_to_array(s)}
      s.c[i] = c;
       /*<<mlString.js 229 2>>*/ return 0 /*<<mlString.js 230 0>>*/ }
     /*<<mlString.js 387 0>>*/ function caml_bytes_set(s,i,c)
     { /*<<mlString.js 388 2>>*/ if(i >>> 0 >= s.l)
        /*<<mlString.js 388 22>>*/ caml_string_bound_error();
       /*<<mlString.js 389 2>>*/ return  /*<<mlString.js 389 9>>*/ caml_bytes_unsafe_set
              (s,i,c) /*<<mlString.js 390 0>>*/ }
     /*<<fs_node.js 82 0>>*/  /*<<fs_node.js 82 11>>*/ var
     Buffer=
      joo_global_object.Buffer;
     /*<<fs_node.js 84 0>>*/ function MlNodeFile(fd)
     {this.fs =  /*<<fs_node.js 85 12>>*/ require("fs");
      this.fd = fd /*<<fs_node.js 87 0>>*/ }
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     { /*<<fs_node.js 91 2>>*/ this.fs.ftruncateSync(this.fd,len | 0) /*<<fs_node.js 90 32>>*/ };
    MlNodeFile.prototype.length
    =
    function()
     { /*<<fs_node.js 94 2>>*/ return  /*<<fs_node.js 94 9>>*/ this.fs.fstatSync
              (this.fd).size /*<<fs_node.js 93 30>>*/ };
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     { /*<<fs_node.js 97 2>>*/  /*<<fs_node.js 97 8>>*/ var
       a=
         /*<<fs_node.js 97 10>>*/ caml_array_of_string(buf);
       /*<<fs_node.js 98 2>>*/ if
       (! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
       /*<<fs_node.js 97 2>>*/  /*<<fs_node.js 100 13>>*/ var
       buffer=
        new Buffer(a);
       /*<<fs_node.js 101 2>>*/ this.fs.writeSync
       (this.fd,buffer,buf_offset,len,offset);
       /*<<fs_node.js 102 2>>*/ return 0 /*<<fs_node.js 96 29>>*/ };
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     { /*<<fs_node.js 105 2>>*/  /*<<fs_node.js 105 8>>*/ var
       a=
         /*<<fs_node.js 105 10>>*/ caml_array_of_string(buf);
       /*<<fs_node.js 106 2>>*/ if
       (! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
       /*<<fs_node.js 105 2>>*/  /*<<fs_node.js 108 13>>*/ var
       buffer=
        new Buffer(a);
       /*<<fs_node.js 109 2>>*/ this.fs.readSync
       (this.fd,buffer,buf_offset,len,offset);
       /*<<fs_node.js 110 2>>*/ for
       ( /*<<fs_node.js 110 12>>*/ var i=0;i < len;i++)
        /*<<fs_node.js 110 30>>*/  /*<<fs_node.js 111 4>>*/ caml_bytes_set
        (buf,buf_offset + i,buffer[buf_offset + i]);
       /*<<fs_node.js 113 2>>*/ return 0 /*<<fs_node.js 104 28>>*/ };
    MlNodeFile.prototype.read_one
    =
    function(offset)
     { /*<<fs_node.js 116 2>>*/ var
        /*<<fs_node.js 116 8>>*/ a=new (joo_global_object.Uint8Array)(1),
        /*<<fs_node.js 117 13>>*/ buffer=new Buffer(a);
       /*<<fs_node.js 118 2>>*/ this.fs.readSync(this.fd,buffer,0,1,offset);
       /*<<fs_node.js 119 2>>*/ return buffer[0] /*<<fs_node.js 115 32>>*/ };
    MlNodeFile.prototype.close
    =
    function()
     { /*<<fs_node.js 122 2>>*/ this.fs.closeSync(this.fd) /*<<fs_node.js 121 29>>*/ };
    MlNodeFile.prototype.constructor = MlNodeFile;
     /*<<fs_node.js 30 0>>*/ function MlNodeDevice(root)
     {this.fs =  /*<<fs_node.js 31 12>>*/ require("fs");
      this.root = root /*<<fs_node.js 33 0>>*/ }
    MlNodeDevice.prototype.nm
    =
    function(name)
     { /*<<fs_node.js 35 2>>*/ return this.root + name /*<<fs_node.js 34 28>>*/ };
    MlNodeDevice.prototype.exists
    =
    function(name)
     { /*<<fs_node.js 38 2>>*/ return  /*<<fs_node.js 38 9>>*/ this.fs.existsSync
               ( /*<<fs_node.js 38 28>>*/ this.nm(name))
              ?1
              :0 /*<<fs_node.js 37 32>>*/ };
    MlNodeDevice.prototype.readdir
    =
    function(name)
     { /*<<fs_node.js 41 2>>*/ return  /*<<fs_node.js 41 9>>*/ this.fs.readdirSync
              ( /*<<fs_node.js 41 29>>*/ this.nm(name)) /*<<fs_node.js 40 33>>*/ };
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     { /*<<fs_node.js 44 2>>*/ return  /*<<fs_node.js 44 9>>*/  /*<<fs_node.js 44 9>>*/ this.fs.statSync
                ( /*<<fs_node.js 44 26>>*/ this.nm(name)).isDirectory
               ()
              ?1
              :0 /*<<fs_node.js 43 32>>*/ };
    MlNodeDevice.prototype.unlink
    =
    function(name)
     { /*<<fs_node.js 47 2>>*/  /*<<fs_node.js 47 8>>*/ var
       b=
         /*<<fs_node.js 47 10>>*/ this.fs.existsSync
          ( /*<<fs_node.js 47 29>>*/ this.nm(name))
         ?1
         :0;
       /*<<fs_node.js 48 2>>*/ this.fs.unlinkSync
       ( /*<<fs_node.js 48 21>>*/ this.nm(name));
       /*<<fs_node.js 49 2>>*/ return b /*<<fs_node.js 46 32>>*/ };
    MlNodeDevice.prototype.open
    =
    function(name,f)
     { /*<<fs_node.js 52 2>>*/ var
        /*<<fs_node.js 52 13>>*/ consts=
         /*<<fs_node.js 52 15>>*/ require("constants"),
        /*<<fs_node.js 53 10>>*/ res=0;
       /*<<fs_node.js 54 2>>*/ for(var key in f)
        /*<<fs_node.js 54 19>>*/ switch(key)
        {case "rdonly":res |= consts.O_RDONLY; /*<<fs_node.js 56 45>>*/ break;
         case "wronly":res |= consts.O_WRONLY; /*<<fs_node.js 57 45>>*/ break;
         case "append":
          res |= consts.O_WRONLY | consts.O_APPEND;
           /*<<fs_node.js 60 6>>*/ break;
         case "create":res |= consts.O_CREAT; /*<<fs_node.js 61 48>>*/ break;
         case "truncate":
          res |= consts.O_TRUNC; /*<<fs_node.js 62 48>>*/ break;
         case "excl":res |= consts.O_EXCL; /*<<fs_node.js 63 48>>*/ break;
         case "binary":res |= consts.O_BINARY; /*<<fs_node.js 64 48>>*/ break;
         case "text":res |= consts.O_TEXT; /*<<fs_node.js 65 48>>*/ break;
         case "nonblock":
          res |= consts.O_NONBLOCK; /*<<fs_node.js 66 48>>*/ break
         }
       /*<<fs_node.js 52 2>>*/  /*<<fs_node.js 69 9>>*/ var
       fd=
         /*<<fs_node.js 69 11>>*/ this.fs.openSync
         ( /*<<fs_node.js 69 28>>*/ this.nm(name),res);
       /*<<fs_node.js 70 2>>*/ return new MlNodeFile(fd) /*<<fs_node.js 51 30>>*/ };
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     { /*<<fs_node.js 74 2>>*/ this.fs.renameSync
       ( /*<<fs_node.js 74 21>>*/ this.nm(o),
         /*<<fs_node.js 74 33>>*/ this.nm(n)) /*<<fs_node.js 73 32>>*/ };
    MlNodeDevice.prototype.constructor = MlNodeDevice;
     /*<<fs.js 31 0>>*/  /*<<fs.js 31 14>>*/ var
     caml_root=
       /*<<fs.js 31 16>>*/ caml_current_dir.match(/[^\/]*\//)[0];
     /*<<fs_node.js 21 0>>*/ function fs_node_supported()
     { /*<<fs_node.js 22 2>>*/ return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined" /*<<fs_node.js 26 0>>*/ }
     /*<<fs.js 59 0>>*/  /*<<fs.js 59 21>>*/ var jsoo_mount_point=[];
     /*<<fs.js 60 0>>*/ if( /*<<fs.js 60 4>>*/ fs_node_supported())
      /*<<fs.js 60 25>>*/  /*<<fs.js 61 4>>*/ jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
      /*<<fs.js 62 7>>*/  /*<<fs.js 63 4>>*/ jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
     /*<<fs.js 65 0>>*/ jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
     /*<<fs.js 80 0>>*/ function resolve_fs_device(name)
     { /*<<fs.js 81 2>>*/ var
        /*<<fs.js 81 11>>*/ path= /*<<fs.js 81 13>>*/ caml_make_path(name),
        /*<<fs.js 82 11>>*/ name= /*<<fs.js 82 13>>*/ path.join("/"),
        /*<<fs.js 83 17>>*/ name_slash=name + "/",
       res;
       /*<<fs.js 85 2>>*/ for
       ( /*<<fs.js 85 12>>*/ var i=0;i < jsoo_mount_point.length;i++)
        /*<<fs.js 85 51>>*/ { /*<<fs.js 86 4>>*/  /*<<fs.js 86 10>>*/ var
         m=
          jsoo_mount_point[i];
         /*<<fs.js 87 4>>*/ if
         ( /*<<fs.js 87 7>>*/ name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest: /*<<fs.js 89 48>>*/ name.substring(m.path.length,name.length)}}
       /*<<fs.js 91 2>>*/ return res /*<<fs.js 92 0>>*/ }
     /*<<fs.js 180 0>>*/ function caml_sys_is_directory(name)
     { /*<<fs.js 181 2>>*/ var
        /*<<fs.js 181 11>>*/ root=
         /*<<fs.js 181 13>>*/ resolve_fs_device(name),
        /*<<fs.js 182 8>>*/ a=
         /*<<fs.js 182 10>>*/ root.device.is_dir(root.rest);
       /*<<fs.js 183 2>>*/ return a?1:0 /*<<fs.js 184 0>>*/ }
     /*<<mlString.js 246 0>>*/ function caml_string_get(s,i)
     { /*<<mlString.js 247 2>>*/ if(i >>> 0 >= s.l)
        /*<<mlString.js 247 22>>*/ caml_string_bound_error();
       /*<<mlString.js 248 2>>*/ return  /*<<mlString.js 248 9>>*/ caml_string_unsafe_get
              (s,i) /*<<mlString.js 249 0>>*/ }
     /*<<bigarray.js 591 0>>*/ function caml_ba_set_1(ba,i0,v)
     { /*<<bigarray.js 592 4>>*/ return  /*<<bigarray.js 592 11>>*/ ba.set1
              (i0,v) /*<<bigarray.js 593 0>>*/ }
     /*<<bigstring.js 51 0>>*/ function bigstring_blit_string_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     { /*<<bigstring.js 52 2>>*/ for
       ( /*<<bigstring.js 52 13>>*/ var i=0;i < v_len;i++)
        /*<<bigstring.js 52 34>>*/ caml_ba_set_1
        (v_bstr,
         v_dst_pos + i,
          /*<<bigstring.js 52 69>>*/ caml_string_get(v_str,v_src_pos + i));
       /*<<bigstring.js 53 2>>*/ return 0 /*<<bigstring.js 54 0>>*/ }
     /*<<bigstring.js 64 0>>*/  /*<<bigstring.js 64 34>>*/ var
     caml_blit_string_to_bigstring=
      bigstring_blit_string_bigstring_stub;
     /*<<stdlib.js 304 0>>*/ function caml_make_vect(len,init)
     { /*<<stdlib.js 305 2>>*/ var
        /*<<stdlib.js 305 10>>*/ len=len + 1 | 0,
        /*<<stdlib.js 306 8>>*/ b=new Array(len);
      b[0] = 0;
       /*<<stdlib.js 308 2>>*/ for
       ( /*<<stdlib.js 308 13>>*/ var i=1;i < len;i++)
       b[i] = init;
       /*<<stdlib.js 309 2>>*/ return b /*<<stdlib.js 310 0>>*/ }
     /*<<jslib.js 104 0>>*/ function js_print_stderr(s)
     { /*<<jslib.js 105 2>>*/  /*<<jslib.js 105 8>>*/ var g=joo_global_object;
       /*<<jslib.js 106 2>>*/ if
       (g.process && g.process.stdout && g.process.stdout.write)
        /*<<jslib.js 106 63>>*/  /*<<jslib.js 107 4>>*/ g.process.stderr.write
        (s);
      else
        /*<<jslib.js 108 9>>*/ { /*<<jslib.js 111 2>>*/ if
         ( /*<<jslib.js 111 5>>*/ s.charCodeAt(s.length - 1) == 10)
         s =  /*<<jslib.js 112 8>>*/ s.substr(0,s.length - 1);
         /*<<jslib.js 113 2>>*/  /*<<jslib.js 113 8>>*/ var v=g.console;
        v && v.error &&  /*<<jslib.js 114 18>>*/ v.error(s)} /*<<jslib.js 116 0>>*/ }
     /*<<mlString.js 80 0>>*/ function caml_utf8_of_utf16(s)
     { /*<<mlString.js 81 2>>*/ for
       (var
          /*<<mlString.js 81 13>>*/ b="",
          /*<<mlString.js 81 21>>*/ t=b,
         c,
         d,
          /*<<mlString.js 81 34>>*/ i=0,
          /*<<mlString.js 81 41>>*/ l=s.length;
        i
        <
        l;
        i++)
        /*<<mlString.js 81 65>>*/ {c
        =
         /*<<mlString.js 82 8>>*/ s.charCodeAt(i);
         /*<<mlString.js 83 4>>*/ if(c < 128)
          /*<<mlString.js 83 18>>*/ { /*<<mlString.js 84 6>>*/ for
           ( /*<<mlString.js 84 17>>*/ var j=i + 1;
            j
            <
            l
            &&
            (c =  /*<<mlString.js 84 42>>*/ s.charCodeAt(j))
            <
            128;
            j++)
            /*<<mlString.js 84 71>>*/ ;
           /*<<mlString.js 85 6>>*/ if(j - i > 512)
            /*<<mlString.js 85 23>>*/ { /*<<mlString.js 85 25>>*/ t.substr
             (0,1);
            b += t;
            t = "";
            b +=  /*<<mlString.js 85 62>>*/ s.slice(i,j)}
          else
           t +=  /*<<mlString.js 86 16>>*/ s.slice(i,j);
           /*<<mlString.js 87 6>>*/ if(j == l)
            /*<<mlString.js 87 18>>*/ break;
          i = j}
         /*<<mlString.js 90 4>>*/ if(c < 2048)
          /*<<mlString.js 90 19>>*/ {t
          +=
           /*<<mlString.js 91 11>>*/ String.fromCharCode(192 | c >> 6);
          t +=  /*<<mlString.js 92 11>>*/ String.fromCharCode(128 | c & 63)}
        else
          /*<<mlString.js 93 11>>*/ if(c < 55296 || c >= 57343)
           /*<<mlString.js 93 42>>*/ t
          +=
           /*<<mlString.js 94 11>>*/ String.fromCharCode
           (224 | c >> 12,128 | c >> 6 & 63,128 | c & 63);
         else
           /*<<mlString.js 97 11>>*/ if
           (c
            >=
            56319
            ||
            i
            +
            1
            ==
            l
            ||
            (d =  /*<<mlString.js 98 20>>*/ s.charCodeAt(i + 1))
            <
            56320
            ||
            d
            >
            57343)
            /*<<mlString.js 98 65>>*/ t += "\xef\xbf\xbd";
          else
            /*<<mlString.js 101 11>>*/ {i++;
            c = (c << 10) + d - 56613888;
            t
            +=
             /*<<mlString.js 104 11>>*/ String.fromCharCode
             (240 | c >> 18,128 | c >> 12 & 63,128 | c >> 6 & 63,128 | c & 63)}
         /*<<mlString.js 109 4>>*/ if(t.length > 1024)
          /*<<mlString.js 109 25>>*/ { /*<<mlString.js 109 26>>*/ t.substr
           (0,1);
          b += t;
          t = ""}}
       /*<<mlString.js 111 2>>*/ return b + t /*<<mlString.js 112 0>>*/ }
     /*<<mlString.js 442 0>>*/ function caml_js_to_string(s)
     { /*<<mlString.js 443 2>>*/  /*<<mlString.js 443 10>>*/ var tag=9;
       /*<<mlString.js 444 2>>*/ if
       (!  /*<<mlString.js 444 7>>*/ caml_is_ascii(s))
       tag = 8,s =  /*<<mlString.js 445 41>>*/ caml_utf8_of_utf16(s);
       /*<<mlString.js 446 2>>*/ return new MlBytes(tag,s,s.length) /*<<mlString.js 447 0>>*/ }
     /*<<stdlib.js 114 0>>*/ function caml_raise_constant(tag)
     { /*<<stdlib.js 114 37>>*/ throw tag /*<<stdlib.js 114 48>>*/ }
     /*<<stdlib.js 203 0>>*/ function caml_raise_not_found()
     { /*<<stdlib.js 204 2>>*/ caml_raise_constant(caml_global_data.Not_found) /*<<stdlib.js 204 51>>*/ }
     /*<<stdlib.js 1066 0>>*/ function caml_sys_getenv(name)
     { /*<<stdlib.js 1067 2>>*/ var
        /*<<stdlib.js 1067 8>>*/ g=joo_global_object,
        /*<<stdlib.js 1068 8>>*/ n= /*<<stdlib.js 1068 10>>*/ name.toString();
       /*<<stdlib.js 1070 2>>*/ if
       (g.process && g.process.env && g.process.env[n] != undefined)
        /*<<stdlib.js 1073 4>>*/ return  /*<<stdlib.js 1073 11>>*/ caml_js_to_string
               (g.process.env[n]);
       /*<<stdlib.js 1074 2>>*/ caml_raise_not_found() /*<<stdlib.js 1075 0>>*/ }
     /*<<ieee_754.js 21 0>>*/  /*<<ieee_754.js 21 12>>*/ var
     log2_ok=
      Math.log2
      &&
       /*<<ieee_754.js 21 27>>*/ Math.log2(1.12355820928894744e+307)
      ==
      1020;
     /*<<ieee_754.js 22 0>>*/ function jsoo_floor_log2(x)
     { /*<<ieee_754.js 23 4>>*/ if(log2_ok)
        /*<<ieee_754.js 23 16>>*/ return  /*<<ieee_754.js 23 23>>*/ Math.floor
               ( /*<<ieee_754.js 23 34>>*/ Math.log2(x));
       /*<<ieee_754.js 24 4>>*/  /*<<ieee_754.js 24 10>>*/ var i=0;
       /*<<ieee_754.js 25 4>>*/ if(x == 0)
        /*<<ieee_754.js 25 16>>*/ return - Infinity;
       /*<<ieee_754.js 26 4>>*/ if(x >= 1)
        /*<<ieee_754.js 26 13>>*/ while(x >= 2)
         /*<<ieee_754.js 26 27>>*/ {x /= 2;i++}
      else
        /*<<ieee_754.js 27 9>>*/ while(x < 1)
         /*<<ieee_754.js 27 24>>*/ {x *= 2;i--}
       /*<<ieee_754.js 28 4>>*/ return i /*<<ieee_754.js 29 0>>*/ }
     /*<<ieee_754.js 33 0>>*/ function caml_int64_bits_of_float(x)
     { /*<<ieee_754.js 34 2>>*/ if(!  /*<<ieee_754.js 34 7>>*/ isFinite(x))
        /*<<ieee_754.js 34 20>>*/ { /*<<ieee_754.js 35 4>>*/ if
         ( /*<<ieee_754.js 35 8>>*/ isNaN(x))
          /*<<ieee_754.js 35 18>>*/ return [255,1,0,32752];
         /*<<ieee_754.js 36 4>>*/ return x > 0?[255,0,0,32752]:[255,0,0,65520]}
       /*<<ieee_754.js 38 2>>*/  /*<<ieee_754.js 38 11>>*/ var
       sign=
        x == 0 && 1 / x == - Infinity?32768:x >= 0?0:32768;
       /*<<ieee_754.js 39 2>>*/ if(sign)x = - x;
       /*<<ieee_754.js 38 2>>*/  /*<<ieee_754.js 42 10>>*/ var
       exp=
         /*<<ieee_754.js 42 12>>*/ jsoo_floor_log2(x) + 1023;
       /*<<ieee_754.js 43 2>>*/ if(exp <= 0)
        /*<<ieee_754.js 43 16>>*/ {exp = 0;
        x /=  /*<<ieee_754.js 45 9>>*/ Math.pow(2,- 1026)}
      else
        /*<<ieee_754.js 46 9>>*/ {x
        /=
         /*<<ieee_754.js 47 9>>*/ Math.pow(2,exp - 1027);
         /*<<ieee_754.js 48 4>>*/ if(x < 16)
          /*<<ieee_754.js 48 16>>*/ {x *= 2;exp -= 1}
         /*<<ieee_754.js 50 4>>*/ if(exp == 0)
          /*<<ieee_754.js 50 18>>*/ x /= 2}
       /*<<ieee_754.js 38 2>>*/ var
        /*<<ieee_754.js 53 8>>*/ k= /*<<ieee_754.js 53 10>>*/ Math.pow(2,24),
        /*<<ieee_754.js 54 9>>*/ r3=x | 0;
      x = (x - r3) * k;
       /*<<ieee_754.js 38 2>>*/  /*<<ieee_754.js 56 9>>*/ var r2=x | 0;
      x = (x - r2) * k;
       /*<<ieee_754.js 38 2>>*/  /*<<ieee_754.js 58 9>>*/ var r1=x | 0;
      r3 = r3 & 15 | sign | exp << 4;
       /*<<ieee_754.js 60 2>>*/ return [255,r1,r2,r3] /*<<ieee_754.js 61 0>>*/ }
     /*<<int64.js 332 0>>*/ function caml_int64_to_bytes(x)
     { /*<<int64.js 333 2>>*/ return [x[3] >> 8,
              x[3] & 255,
              x[2] >> 16,
              x[2] >> 8 & 255,
              x[2] & 255,
              x[1] >> 16,
              x[1] >> 8 & 255,
              x[1] & 255] /*<<int64.js 335 0>>*/ }
     /*<<marshal.js 344 0>>*/  /*<<marshal.js 344 20>>*/ var
     caml_output_val=
       /*<<marshal.js 344 22>>*/ function()
        { /*<<marshal.js 345 2>>*/ function Writer()
          {this.chunk = [] /*<<marshal.js 345 40>>*/ }
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           { /*<<marshal.js 349 6>>*/ for
             ( /*<<marshal.js 349 17>>*/ var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 255 /*<<marshal.js 348 10>>*/ },
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
             /*<<marshal.js 354 6>>*/ for
             ( /*<<marshal.js 354 17>>*/ var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 255 /*<<marshal.js 352 15>>*/ },
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
             /*<<marshal.js 360 6>>*/ this.write(32,2224400062);
             /*<<marshal.js 361 6>>*/ this.write(32,this.block_len);
             /*<<marshal.js 362 6>>*/ this.write(32,this.obj_counter);
             /*<<marshal.js 363 6>>*/ this.write(32,this.size_32);
             /*<<marshal.js 364 6>>*/ this.write(32,this.size_64);
             /*<<marshal.js 365 6>>*/ return this.chunk /*<<marshal.js 357 13>>*/ }};
          /*<<marshal.js 368 2>>*/ return function(v)
          { /*<<marshal.js 369 4>>*/ var
             /*<<marshal.js 369 15>>*/ writer=new Writer(),
             /*<<marshal.js 370 14>>*/ stack=[];
            /*<<marshal.js 371 4>>*/ function extern_rec(v)
            { /*<<marshal.js 372 6>>*/ if
              (v instanceof Array && v[0] === (v[0] | 0))
               /*<<marshal.js 372 51>>*/ { /*<<marshal.js 373 8>>*/ if
                (v[0] == 255)
                 /*<<marshal.js 373 25>>*/ { /*<<marshal.js 375 10>>*/ writer.write
                  (8,18);
                  /*<<marshal.js 376 10>>*/ for
                  ( /*<<marshal.js 376 21>>*/ var i=0;i < 3;i++)
                   /*<<marshal.js 376 38>>*/ writer.write
                   (8, /*<<marshal.js 376 55>>*/ "_j\0".charCodeAt(i));
                  /*<<marshal.js 377 10>>*/  /*<<marshal.js 377 16>>*/ var
                  b=
                    /*<<marshal.js 377 18>>*/ caml_int64_to_bytes(v);
                  /*<<marshal.js 378 10>>*/ for
                  ( /*<<marshal.js 378 21>>*/ var i=0;i < 8;i++)
                   /*<<marshal.js 378 38>>*/ writer.write(8,b[i]);
                 writer.size_32 += 4;
                 writer.size_64 += 3;
                  /*<<marshal.js 381 10>>*/ return}
                /*<<marshal.js 383 8>>*/ if(v[0] == 251)
                 /*<<marshal.js 383 25>>*/  /*<<marshal.js 384 10>>*/ caml_failwith
                 ("output_value: abstract value (Abstract)");
                /*<<marshal.js 386 8>>*/ if(v[0] < 16 && v.length - 1 < 8)
                 /*<<marshal.js 387 10>>*/ writer.write
                 (8,128 + v[0] + (v.length - 1 << 4));
               else
                 /*<<marshal.js 389 10>>*/ writer.write_code
                 (32,8,v.length - 1 << 10 | v[0]);
               writer.size_32 += v.length;
               writer.size_64 += v.length;
                /*<<marshal.js 392 8>>*/ if(v.length > 1)
                 /*<<marshal.js 392 26>>*/ stack.push(v,1)}
             else
               /*<<marshal.js 393 13>>*/ if(v instanceof MlBytes)
                /*<<marshal.js 393 39>>*/ { /*<<marshal.js 394 8>>*/  /*<<marshal.js 394 16>>*/ var
                 len=
                   /*<<marshal.js 394 18>>*/ caml_ml_string_length(v);
                 /*<<marshal.js 395 8>>*/ if(len < 32)
                  /*<<marshal.js 396 10>>*/ writer.write(8,32 + len);
                else
                  /*<<marshal.js 397 13>>*/ if(len < 256)
                   /*<<marshal.js 398 10>>*/ writer.write_code(8,9,len);
                 else
                   /*<<marshal.js 400 10>>*/ writer.write_code(32,10,len);
                 /*<<marshal.js 401 8>>*/ for
                 ( /*<<marshal.js 401 19>>*/ var i=0;i < len;i++)
                  /*<<marshal.js 402 10>>*/ writer.write
                  (8, /*<<marshal.js 402 27>>*/ caml_string_unsafe_get(v,i));
                writer.size_32 += 1 + ((len + 4) / 4 | 0);
                writer.size_64 += 1 + ((len + 8) / 8 | 0)}
              else
                /*<<marshal.js 405 13>>*/ if(v != (v | 0))
                 /*<<marshal.js 406 23>>*/ { /*<<marshal.js 407 10>>*/  /*<<marshal.js 407 24>>*/ var
                  type_of_v=
                   typeof v;
                  /*<<marshal.js 416 10>>*/ caml_failwith
                  ("output_value: abstract value (" + type_of_v + ")")}
               else
                 /*<<marshal.js 421 13>>*/ if(v >= 0 && v < 64)
                  /*<<marshal.js 421 37>>*/  /*<<marshal.js 422 10>>*/ writer.write
                  (8,64 + v);
                else
                  /*<<marshal.js 423 15>>*/ if(v >= - (1 << 7) && v < 1 << 7)
                   /*<<marshal.js 425 12>>*/ writer.write_code(8,0,v);
                 else
                   /*<<marshal.js 426 15>>*/ if
                   (v >= - (1 << 15) && v < 1 << 15)
                    /*<<marshal.js 427 12>>*/ writer.write_code(16,1,v);
                  else
                    /*<<marshal.js 429 12>>*/ writer.write_code(32,2,v) /*<<marshal.js 432 4>>*/ }
            /*<<marshal.js 433 4>>*/ extern_rec(v);
            /*<<marshal.js 434 4>>*/ while(stack.length > 0)
             /*<<marshal.js 434 29>>*/ { /*<<marshal.js 435 6>>*/ var
               /*<<marshal.js 435 12>>*/ i=
                /*<<marshal.js 435 14>>*/ stack.pop(),
               /*<<marshal.js 436 12>>*/ v=
                /*<<marshal.js 436 14>>*/ stack.pop();
              /*<<marshal.js 437 6>>*/ if(i + 1 < v.length)
               /*<<marshal.js 437 28>>*/ stack.push(v,i + 1);
              /*<<marshal.js 438 6>>*/ extern_rec(v[i])}
            /*<<marshal.js 440 4>>*/ writer.finalize();
            /*<<marshal.js 441 4>>*/ return writer.chunk /*<<marshal.js 368 9>>*/ } /*<<marshal.js 344 22>>*/ }
       ();
     /*<<bigarray.js 56 0>>*/ function caml_ba_get_size(dims)
     { /*<<bigarray.js 57 4>>*/ var
        /*<<bigarray.js 57 15>>*/ n_dims=dims.length,
        /*<<bigarray.js 58 13>>*/ size=1;
       /*<<bigarray.js 59 4>>*/ for
       ( /*<<bigarray.js 59 15>>*/ var i=0;i < n_dims;i++)
        /*<<bigarray.js 59 37>>*/ { /*<<bigarray.js 60 8>>*/ if(dims[i] < 0)
          /*<<bigarray.js 61 12>>*/ caml_invalid_argument
          ("Bigarray.create: negative dimension");
        size = size * dims[i]}
       /*<<bigarray.js 64 4>>*/ return size /*<<bigarray.js 65 0>>*/ }
     /*<<bigarray.js 68 0>>*/ var caml_ba_views;
     /*<<bigarray.js 38 0>>*/ function caml_ba_init_views()
     { /*<<bigarray.js 39 4>>*/ if(! caml_ba_views)
        /*<<bigarray.js 39 24>>*/ { /*<<bigarray.js 40 8>>*/  /*<<bigarray.js 40 14>>*/ var
         g=
          joo_global_object;
        caml_ba_views
        =
        [[g.Float32Array,
          g.Float64Array,
          g.Int8Array,
          g.Uint8Array,
          g.Int16Array,
          g.Uint16Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Int32Array,
          g.Float32Array,
          g.Float64Array,
          g.Uint8Array],
         [0,0,0,0,0,0,0,1,0,0,2,2,0]]} /*<<bigarray.js 52 0>>*/ }
     /*<<jslib_js_of_ocaml.js 35 0>>*/ function caml_js_from_array(a)
     { /*<<jslib_js_of_ocaml.js 35 33>>*/ return  /*<<jslib_js_of_ocaml.js 35 40>>*/ raw_array_sub
              (a,1,a.length - 1) /*<<jslib_js_of_ocaml.js 35 71>>*/ }
     /*<<stdlib.js 209 0>>*/ function caml_array_bound_error()
     { /*<<stdlib.js 210 2>>*/ caml_invalid_argument("index out of bounds") /*<<stdlib.js 211 0>>*/ }
     /*<<bigarray.js 74 0>>*/ function caml_ba_create_from
     (data,data2,data_type,kind,layout,dims)
     { /*<<bigarray.js 75 4>>*/ var
        /*<<bigarray.js 75 15>>*/ n_dims=dims.length,
        /*<<bigarray.js 76 13>>*/ size=
         /*<<bigarray.js 76 15>>*/ caml_ba_get_size(dims);
       /*<<bigarray.js 82 4>>*/ function offset_c(index)
       { /*<<bigarray.js 83 8>>*/  /*<<bigarray.js 83 16>>*/ var ofs=0;
         /*<<bigarray.js 84 8>>*/ if(n_dims != index.length)
          /*<<bigarray.js 85 12>>*/ caml_invalid_argument
          ("Bigarray.get/set: bad number of dimensions");
         /*<<bigarray.js 86 8>>*/ for
         ( /*<<bigarray.js 86 19>>*/ var i=0;i < n_dims;i++)
          /*<<bigarray.js 86 41>>*/ { /*<<bigarray.js 87 12>>*/ if
           (index[i] < 0 || index[i] >= dims[i])
            /*<<bigarray.js 88 16>>*/ caml_array_bound_error();
          ofs = ofs * dims[i] + index[i]}
         /*<<bigarray.js 91 8>>*/ return ofs /*<<bigarray.js 92 4>>*/ }
       /*<<bigarray.js 94 4>>*/ function offset_fortran(index)
       { /*<<bigarray.js 95 8>>*/  /*<<bigarray.js 95 16>>*/ var ofs=0;
         /*<<bigarray.js 96 8>>*/ if(n_dims != index.length)
          /*<<bigarray.js 97 12>>*/ caml_invalid_argument
          ("Bigarray.get/set: wrong number of indices");
         /*<<bigarray.js 98 8>>*/ for
         ( /*<<bigarray.js 98 19>>*/ var i=n_dims - 1;i >= 0;i--)
          /*<<bigarray.js 98 46>>*/ { /*<<bigarray.js 99 12>>*/ if
           (index[i] < 1 || index[i] > dims[i])
            /*<<bigarray.js 100 16>>*/ caml_array_bound_error();
          ofs = ofs * dims[i] + (index[i] - 1)}
         /*<<bigarray.js 103 8>>*/ return ofs /*<<bigarray.js 104 4>>*/ }
       /*<<bigarray.js 106 4>>*/ var
        /*<<bigarray.js 106 15>>*/ offset=layout == 0?offset_c:offset_fortran,
        /*<<bigarray.js 108 13>>*/ dim0=dims[0];
       /*<<bigarray.js 113 4>>*/ function get_std(index)
       { /*<<bigarray.js 114 8>>*/ var
          /*<<bigarray.js 114 16>>*/ ofs=
           /*<<bigarray.js 114 18>>*/ offset(index),
          /*<<bigarray.js 115 14>>*/ v=data[ofs];
         /*<<bigarray.js 116 8>>*/ return v /*<<bigarray.js 117 4>>*/ }
       /*<<bigarray.js 119 4>>*/ function get_int64(index)
       { /*<<bigarray.js 120 8>>*/ var
          /*<<bigarray.js 120 16>>*/ off=
           /*<<bigarray.js 120 18>>*/ offset(index),
          /*<<bigarray.js 121 14>>*/ l=data[off],
          /*<<bigarray.js 122 14>>*/ h=data2[off];
         /*<<bigarray.js 123 8>>*/ return [255,
                l & 16777215,
                l >>> 24 & 255 | (h & 65535) << 8,
                h >>> 16 & 65535] /*<<bigarray.js 128 4>>*/ }
       /*<<bigarray.js 130 4>>*/ function get_complex(index)
       { /*<<bigarray.js 131 8>>*/ var
          /*<<bigarray.js 131 16>>*/ off=
           /*<<bigarray.js 131 18>>*/ offset(index),
          /*<<bigarray.js 132 14>>*/ r=data[off],
          /*<<bigarray.js 133 14>>*/ i=data2[off];
         /*<<bigarray.js 134 8>>*/ return [254,r,i] /*<<bigarray.js 135 4>>*/ }
       /*<<bigarray.js 137 4>>*/  /*<<bigarray.js 137 12>>*/ var
       get=
        data_type == 1?get_int64:data_type == 2?get_complex:get_std;
       /*<<bigarray.js 139 4>>*/ function get1_c(i)
       { /*<<bigarray.js 140 8>>*/ if(i < 0 || i >= dim0)
          /*<<bigarray.js 141 12>>*/ caml_array_bound_error();
         /*<<bigarray.js 142 8>>*/ return data[i] /*<<bigarray.js 143 4>>*/ }
       /*<<bigarray.js 144 4>>*/ function get1_fortran(i)
       { /*<<bigarray.js 145 8>>*/ if(i < 1 || i > dim0)
          /*<<bigarray.js 146 12>>*/ caml_array_bound_error();
         /*<<bigarray.js 147 8>>*/ return data[i - 1] /*<<bigarray.js 148 4>>*/ }
       /*<<bigarray.js 149 4>>*/ function get1_any(i)
       { /*<<bigarray.js 150 8>>*/ return  /*<<bigarray.js 150 15>>*/ get([i]) /*<<bigarray.js 151 4>>*/ }
       /*<<bigarray.js 153 4>>*/  /*<<bigarray.js 153 13>>*/ var
       get1=
        data_type == 0?layout == 0?get1_c:get1_fortran:get1_any;
       /*<<bigarray.js 158 4>>*/ function set_std_raw(off,v)
       {data[off] = v /*<<bigarray.js 160 4>>*/ }
       /*<<bigarray.js 162 4>>*/ function set_int64_raw(off,v)
       {data[off] = v[1] | (v[2] & 255) << 24;
        data2[off] = v[2] >>> 8 & 65535 | v[3] << 16 /*<<bigarray.js 165 4>>*/ }
       /*<<bigarray.js 167 4>>*/ function set_complex_raw(off,v)
       {data[off] = v[1];data2[off] = v[2] /*<<bigarray.js 170 4>>*/ }
       /*<<bigarray.js 172 4>>*/ function set_std(index,v)
       { /*<<bigarray.js 173 8>>*/  /*<<bigarray.js 173 16>>*/ var
         ofs=
           /*<<bigarray.js 173 18>>*/ offset(index);
         /*<<bigarray.js 174 8>>*/ return  /*<<bigarray.js 174 15>>*/ set_std_raw
                (ofs,v) /*<<bigarray.js 175 4>>*/ }
       /*<<bigarray.js 176 4>>*/ function set_int64(index,v)
       { /*<<bigarray.js 177 8>>*/ return  /*<<bigarray.js 177 15>>*/ set_int64_raw
                ( /*<<bigarray.js 177 29>>*/ offset(index),v) /*<<bigarray.js 178 4>>*/ }
       /*<<bigarray.js 179 4>>*/ function set_complex(index,v)
       { /*<<bigarray.js 180 8>>*/ return  /*<<bigarray.js 180 15>>*/ set_complex_raw
                ( /*<<bigarray.js 180 31>>*/ offset(index),v) /*<<bigarray.js 181 4>>*/ }
       /*<<bigarray.js 183 4>>*/  /*<<bigarray.js 183 12>>*/ var
       set=
        data_type == 1?set_int64:data_type == 2?set_complex:set_std;
       /*<<bigarray.js 185 4>>*/ function set1_c(i,v)
       { /*<<bigarray.js 186 8>>*/ if(i < 0 || i >= dim0)
          /*<<bigarray.js 187 12>>*/ caml_array_bound_error();
        data[i] = v /*<<bigarray.js 189 4>>*/ }
       /*<<bigarray.js 190 4>>*/ function set1_fortran(i,v)
       { /*<<bigarray.js 191 8>>*/ if(i < 1 || i > dim0)
          /*<<bigarray.js 192 12>>*/ caml_array_bound_error();
        data[i - 1] = v /*<<bigarray.js 194 4>>*/ }
       /*<<bigarray.js 195 4>>*/ function set1_any(i,v)
       { /*<<bigarray.js 196 8>>*/ set([i],v) /*<<bigarray.js 197 4>>*/ }
       /*<<bigarray.js 199 4>>*/  /*<<bigarray.js 199 13>>*/ var
       set1=
        data_type == 0?layout == 0?set1_c:set1_fortran:set1_any;
       /*<<bigarray.js 204 4>>*/ function nth_dim(i)
       { /*<<bigarray.js 205 8>>*/ if(i < 0 || i >= n_dims)
          /*<<bigarray.js 206 12>>*/ caml_invalid_argument("Bigarray.dim");
         /*<<bigarray.js 207 8>>*/ return dims[i] /*<<bigarray.js 208 4>>*/ }
       /*<<bigarray.js 210 4>>*/ function fill(v)
       { /*<<bigarray.js 211 8>>*/ if(data_type == 0)
          /*<<bigarray.js 212 12>>*/ for
          ( /*<<bigarray.js 212 23>>*/ var i=0;i < data.length;i++)
           /*<<bigarray.js 213 16>>*/ set_std_raw(i,v);
         /*<<bigarray.js 214 8>>*/ if(data_type == 1)
          /*<<bigarray.js 215 12>>*/ for
          ( /*<<bigarray.js 215 23>>*/ var i=0;i < data.length;i++)
           /*<<bigarray.js 216 16>>*/ set_int64_raw(i,v);
         /*<<bigarray.js 217 8>>*/ if(data_type == 2)
          /*<<bigarray.js 218 12>>*/ for
          ( /*<<bigarray.js 218 23>>*/ var i=0;i < data.length;i++)
           /*<<bigarray.js 219 16>>*/ set_complex_raw(i,v) /*<<bigarray.js 220 4>>*/ }
       /*<<bigarray.js 221 4>>*/ function blit(from)
       { /*<<bigarray.js 222 8>>*/ if(n_dims != from.num_dims)
          /*<<bigarray.js 223 12>>*/ caml_invalid_argument
          ("Bigarray.blit: dimension mismatch");
         /*<<bigarray.js 224 8>>*/ for
         ( /*<<bigarray.js 224 19>>*/ var i=0;i < n_dims;i++)
          /*<<bigarray.js 225 12>>*/ if
          (dims[i] !=  /*<<bigarray.js 225 27>>*/ from.nth_dim(i))
           /*<<bigarray.js 226 16>>*/ caml_invalid_argument
           ("Bigarray.blit: dimension mismatch");
         /*<<bigarray.js 227 8>>*/ data.set(from.data);
         /*<<bigarray.js 228 8>>*/ if(data_type != 0)
          /*<<bigarray.js 229 12>>*/ data2.set(from.data2) /*<<bigarray.js 230 4>>*/ }
       /*<<bigarray.js 232 4>>*/ function sub(ofs,len)
       { /*<<bigarray.js 233 8>>*/ var
         changed_dim,
          /*<<bigarray.js 234 16>>*/ mul=1;
         /*<<bigarray.js 236 8>>*/ if(layout == 0)
          /*<<bigarray.js 236 25>>*/ { /*<<bigarray.js 237 12>>*/ for
           ( /*<<bigarray.js 237 23>>*/ var i=1;i < n_dims;i++)
           mul = mul * dims[i];
          changed_dim = 0}
        else
          /*<<bigarray.js 240 15>>*/ { /*<<bigarray.js 241 12>>*/ for
           ( /*<<bigarray.js 241 23>>*/ var i=0;i < n_dims - 1;i++)
           mul = mul * dims[i];
          changed_dim = n_dims - 1;
          ofs = ofs - 1}
         /*<<bigarray.js 247 8>>*/ if
         (ofs < 0 || len < 0 || ofs + len > dims[changed_dim])
          /*<<bigarray.js 248 12>>*/ caml_invalid_argument
          ("Bigarray.sub: bad sub-array");
         /*<<bigarray.js 233 8>>*/ var
          /*<<bigarray.js 250 21>>*/ new_data=
           /*<<bigarray.js 250 23>>*/ data.subarray
           (ofs * mul,(ofs + len) * mul),
          /*<<bigarray.js 251 22>>*/ new_data2=
          data_type == 0
           ?null
           : /*<<bigarray.js 251 62>>*/ data2.subarray
             (ofs * mul,(ofs + len) * mul),
          /*<<bigarray.js 253 21>>*/ new_dims=[];
         /*<<bigarray.js 254 8>>*/ for
         ( /*<<bigarray.js 254 19>>*/ var i=0;i < n_dims;i++)
         new_dims[i] = dims[i];
        new_dims[changed_dim] = len;
         /*<<bigarray.js 258 8>>*/ return  /*<<bigarray.js 258 15>>*/ caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,new_dims) /*<<bigarray.js 259 4>>*/ }
       /*<<bigarray.js 261 4>>*/ function slice(vind)
       { /*<<bigarray.js 262 8>>*/ var
          /*<<bigarray.js 262 21>>*/ num_inds=vind.length,
          /*<<bigarray.js 263 18>>*/ index=[],
          /*<<bigarray.js 264 21>>*/ sub_dims=[],
         ofs;
         /*<<bigarray.js 267 8>>*/ if(num_inds >= n_dims)
          /*<<bigarray.js 268 12>>*/ caml_invalid_argument
          ("Bigarray.slice: too many indices");
         /*<<bigarray.js 271 8>>*/ if(layout == 0)
          /*<<bigarray.js 271 25>>*/ { /*<<bigarray.js 272 12>>*/ for
           ( /*<<bigarray.js 272 23>>*/ var i=0;i < num_inds;i++)
           index[i] = vind[i];
           /*<<bigarray.js 274 12>>*/ for(;i < n_dims;i++)index[i] = 0;
          ofs =  /*<<bigarray.js 276 18>>*/ offset(index);
          sub_dims =  /*<<bigarray.js 277 23>>*/ dims.slice(num_inds)}
        else
          /*<<bigarray.js 278 15>>*/ { /*<<bigarray.js 279 12>>*/ for
           ( /*<<bigarray.js 279 23>>*/ var i=0;i < num_inds;i++)
           index[n_dims - num_inds + i] = vind[i];
           /*<<bigarray.js 281 12>>*/ for
           ( /*<<bigarray.js 281 23>>*/ var i=0;i < n_dims - num_inds;i++)
           index[i] = 1;
          ofs =  /*<<bigarray.js 283 18>>*/ offset(index);
          sub_dims =  /*<<bigarray.js 284 23>>*/ dims.slice(0,num_inds)}
         /*<<bigarray.js 262 8>>*/ var
          /*<<bigarray.js 287 17>>*/ size=
           /*<<bigarray.js 287 19>>*/ caml_ba_get_size(sub_dims),
          /*<<bigarray.js 288 21>>*/ new_data=
           /*<<bigarray.js 288 23>>*/ data.subarray(ofs,ofs + size),
          /*<<bigarray.js 289 22>>*/ new_data2=
          data_type == 0
           ?null
           : /*<<bigarray.js 289 62>>*/ data2.subarray(ofs,ofs + size);
         /*<<bigarray.js 291 8>>*/ return  /*<<bigarray.js 291 15>>*/ caml_ba_create_from
                (new_data,new_data2,data_type,kind,layout,sub_dims) /*<<bigarray.js 292 4>>*/ }
       /*<<bigarray.js 294 4>>*/ function reshape(vdim)
       { /*<<bigarray.js 295 8>>*/ var
          /*<<bigarray.js 295 20>>*/ new_dim=[],
          /*<<bigarray.js 296 21>>*/ num_dims=vdim.length;
         /*<<bigarray.js 298 8>>*/ if(num_dims < 1)
          /*<<bigarray.js 299 12>>*/ caml_invalid_argument
          ("Bigarray.reshape: bad number of dimensions");
         /*<<bigarray.js 295 8>>*/  /*<<bigarray.js 300 21>>*/ var num_elts=1;
         /*<<bigarray.js 301 8>>*/ for
         ( /*<<bigarray.js 301 19>>*/ var i=0;i < num_dims;i++)
          /*<<bigarray.js 301 43>>*/ {new_dim[i] = vdim[i];
           /*<<bigarray.js 303 12>>*/ if(new_dim[i] < 0)
            /*<<bigarray.js 304 16>>*/ caml_invalid_argument
            ("Bigarray.reshape: negative dimension");
          num_elts = num_elts * new_dim[i]}
         /*<<bigarray.js 309 8>>*/ if(num_elts != size)
          /*<<bigarray.js 310 12>>*/ caml_invalid_argument
          ("Bigarray.reshape: size mismatch");
         /*<<bigarray.js 312 8>>*/ return  /*<<bigarray.js 312 15>>*/ caml_ba_create_from
                (data,data2,data_type,kind,layout,new_dim) /*<<bigarray.js 313 4>>*/ }
       /*<<bigarray.js 315 4>>*/ function compare(b,total)
       { /*<<bigarray.js 316 8>>*/ if(layout != b.layout)
          /*<<bigarray.js 317 12>>*/ return b.layout - layout;
         /*<<bigarray.js 318 8>>*/ if(n_dims != b.num_dims)
          /*<<bigarray.js 319 12>>*/ return b.num_dims - n_dims;
         /*<<bigarray.js 320 8>>*/ for
         ( /*<<bigarray.js 320 19>>*/ var i=0;i < n_dims;i++)
          /*<<bigarray.js 321 12>>*/ if
          ( /*<<bigarray.js 321 16>>*/ nth_dim(i)
           !=
            /*<<bigarray.js 321 30>>*/ b.nth_dim(i))
           /*<<bigarray.js 322 16>>*/ return  /*<<bigarray.js 322 24>>*/ nth_dim
                   (i)
                  <
                   /*<<bigarray.js 322 37>>*/ b.nth_dim(i)
                  ?- 1
                  :1;
         /*<<bigarray.js 323 8>>*/ switch(kind)
         {case 0:
          case 1:
          case 10:
          case 11:
            /*<<bigarray.js 328 16>>*/ var x,y;
            /*<<bigarray.js 329 16>>*/ for
            ( /*<<bigarray.js 329 27>>*/ var i=0;i < data.length;i++)
             /*<<bigarray.js 329 54>>*/ {x = data[i];
             y = b.data[i];
              /*<<bigarray.js 334 20>>*/ if(x < y)
               /*<<bigarray.js 335 24>>*/ return - 1;
              /*<<bigarray.js 336 20>>*/ if(x > y)
               /*<<bigarray.js 337 24>>*/ return 1;
              /*<<bigarray.js 338 20>>*/ if(x != y)
               /*<<bigarray.js 338 32>>*/ if(x != y)
                /*<<bigarray.js 339 36>>*/ { /*<<bigarray.js 340 28>>*/ if
                 (! total)
                  /*<<bigarray.js 341 32>>*/ return NaN;
                 /*<<bigarray.js 342 28>>*/ if(x == x)
                  /*<<bigarray.js 343 32>>*/ return 1;
                 /*<<bigarray.js 344 28>>*/ if(y == y)
                  /*<<bigarray.js 345 32>>*/ return - 1}
              /*<<bigarray.js 348 20>>*/ if(data2)
               /*<<bigarray.js 348 31>>*/ {x = data2[i];
               y = b.data2[i];
                /*<<bigarray.js 352 24>>*/ if(x < y)
                 /*<<bigarray.js 353 28>>*/ return - 1;
                /*<<bigarray.js 354 24>>*/ if(x > y)
                 /*<<bigarray.js 355 28>>*/ return 1;
                /*<<bigarray.js 356 24>>*/ if(x != y)
                 /*<<bigarray.js 356 36>>*/ if(x != y)
                  /*<<bigarray.js 357 40>>*/ { /*<<bigarray.js 358 32>>*/ if
                   (! total)
                    /*<<bigarray.js 359 36>>*/ return NaN;
                   /*<<bigarray.js 360 32>>*/ if(x == x)
                    /*<<bigarray.js 361 36>>*/ return 1;
                   /*<<bigarray.js 362 32>>*/ if(y == y)
                    /*<<bigarray.js 363 36>>*/ return - 1}}}
            /*<<bigarray.js 369 16>>*/ break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 12:
            /*<<bigarray.js 379 16>>*/ for
            ( /*<<bigarray.js 379 27>>*/ var i=0;i < data.length;i++)
             /*<<bigarray.js 379 54>>*/ { /*<<bigarray.js 380 20>>*/ if
              (data[i] < b.data[i])
               /*<<bigarray.js 381 24>>*/ return - 1;
              /*<<bigarray.js 382 20>>*/ if(data[i] > b.data[i])
               /*<<bigarray.js 383 24>>*/ return 1}
            /*<<bigarray.js 386 16>>*/ break;
          case 7:
            /*<<bigarray.js 389 16>>*/ for
            ( /*<<bigarray.js 389 27>>*/ var i=0;i < data.length;i++)
             /*<<bigarray.js 389 54>>*/ { /*<<bigarray.js 390 20>>*/ if
              (data2[i] < b.data2[i])
               /*<<bigarray.js 391 24>>*/ return - 1;
              /*<<bigarray.js 392 20>>*/ if(data2[i] > b.data2[i])
               /*<<bigarray.js 393 24>>*/ return 1;
              /*<<bigarray.js 394 20>>*/ if(data[i] < b.data[i])
               /*<<bigarray.js 395 24>>*/ return - 1;
              /*<<bigarray.js 396 20>>*/ if(data[i] > b.data[i])
               /*<<bigarray.js 397 24>>*/ return 1}
            /*<<bigarray.js 400 16>>*/ break
          }
         /*<<bigarray.js 402 8>>*/ return 0 /*<<bigarray.js 403 4>>*/ }
       /*<<bigarray.js 405 4>>*/ return {data:data,
              data2:data2,
              data_type:data_type,
              num_dims:n_dims,
              nth_dim:nth_dim,
              kind:kind,
              layout:layout,
              size:size,
              sub:sub,
              slice:slice,
              blit:blit,
              fill:fill,
              reshape:reshape,
              get:get,
              get1:get1,
              set:set,
              set1:set1,
              compare:compare} /*<<bigarray.js 425 0>>*/ }
     /*<<bigarray.js 434 0>>*/ function caml_ba_create(kind,layout,dims_ml)
     { /*<<bigarray.js 436 4>>*/ caml_ba_init_views();
       /*<<bigarray.js 439 4>>*/ var
        /*<<bigarray.js 439 13>>*/ dims=
         /*<<bigarray.js 439 15>>*/ caml_js_from_array(dims_ml),
        /*<<bigarray.js 442 13>>*/ size=
         /*<<bigarray.js 442 15>>*/ caml_ba_get_size(dims),
        /*<<bigarray.js 445 13>>*/ view=caml_ba_views[0][kind];
       /*<<bigarray.js 446 4>>*/ if(! view)
        /*<<bigarray.js 447 8>>*/ caml_invalid_argument
        ("Bigarray.create: unsupported kind");
       /*<<bigarray.js 439 4>>*/ var
        /*<<bigarray.js 448 13>>*/ data=new view(size),
        /*<<bigarray.js 451 18>>*/ data_type=caml_ba_views[1][kind],
        /*<<bigarray.js 452 14>>*/ data2=null;
       /*<<bigarray.js 453 4>>*/ if(data_type != 0)
        /*<<bigarray.js 453 38>>*/ data2 = new view(size);
       /*<<bigarray.js 457 4>>*/ return  /*<<bigarray.js 457 11>>*/ caml_ba_create_from
              (data,data2,data_type,kind,layout,dims) /*<<bigarray.js 458 0>>*/ }
     /*<<bigstring.js 4 0>>*/ function bigstring_alloc(_,size)
     { /*<<bigstring.js 5 2>>*/ return  /*<<bigstring.js 5 9>>*/ caml_ba_create
              (12,0,[0,size]) /*<<bigstring.js 6 0>>*/ }
     /*<<bigstring.js 126 0>>*/ function bigstring_marshal_stub(v,_fl)
     { /*<<bigstring.js 128 2>>*/ var
        /*<<bigstring.js 128 10>>*/ arr=
         /*<<bigstring.js 128 12>>*/ caml_output_val(v),
        /*<<bigstring.js 129 10>>*/ bs=
         /*<<bigstring.js 129 12>>*/ bigstring_alloc(0,arr.length);
       /*<<bigstring.js 130 2>>*/ for
       ( /*<<bigstring.js 130 12>>*/ var i=0;i < arr.length;i++)
        /*<<bigstring.js 130 37>>*/  /*<<bigstring.js 131 4>>*/ caml_ba_set_1
        (bs,i,arr[i]);
       /*<<bigstring.js 133 2>>*/ return bs /*<<bigstring.js 134 0>>*/ }
     /*<<fs.js 188 0>>*/ function caml_sys_rename(o,n)
     { /*<<fs.js 189 2>>*/ var
        /*<<fs.js 189 13>>*/ o_root= /*<<fs.js 189 15>>*/ resolve_fs_device(o),
        /*<<fs.js 190 13>>*/ n_root= /*<<fs.js 190 15>>*/ resolve_fs_device(n);
       /*<<fs.js 191 2>>*/ if(o_root.device != n_root.device)
        /*<<fs.js 192 4>>*/ caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
       /*<<fs.js 193 2>>*/ if(! o_root.device.rename)
        /*<<fs.js 194 4>>*/ caml_failwith("caml_sys_rename: no implemented");
       /*<<fs.js 195 2>>*/ o_root.device.rename(o_root.rest,n_root.rest) /*<<fs.js 196 0>>*/ }
     /*<<fs.js 144 0>>*/ function caml_raise_not_a_dir(name)
     {name
      =
      name instanceof MlBytes? /*<<fs.js 145 35>>*/ name.toString():name;
       /*<<fs.js 146 2>>*/ caml_raise_sys_error(name + ": Not a directory") /*<<fs.js 147 0>>*/ }
     /*<<fs.js 159 0>>*/ function caml_sys_read_directory(name)
     { /*<<fs.js 160 2>>*/ var
        /*<<fs.js 160 11>>*/ root=
         /*<<fs.js 160 13>>*/ resolve_fs_device(name),
        /*<<fs.js 161 8>>*/ a=
         /*<<fs.js 161 10>>*/ root.device.readdir(root.rest),
        /*<<fs.js 162 8>>*/ l=new Array(a.length + 1);
      l[0] = 0;
       /*<<fs.js 164 2>>*/ for( /*<<fs.js 164 11>>*/ var i=0;i < a.length;i++)
       l[i + 1] =  /*<<fs.js 165 13>>*/ caml_new_string(a[i]);
       /*<<fs.js 166 2>>*/ return l /*<<fs.js 167 0>>*/ }
     /*<<io.js 97 0>>*/  /*<<io.js 97 21>>*/ var caml_ml_channels=new Array();
     /*<<io.js 286 0>>*/ function caml_ml_seek_in(chanid,pos)
     { /*<<io.js 287 2>>*/  /*<<io.js 287 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 288 2>>*/ if(chan.refill != null)
        /*<<io.js 288 27>>*/ caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
       /*<<io.js 290 2>>*/ return 0 /*<<io.js 291 0>>*/ }
     /*<<io.js 328 0>>*/ function caml_ml_flush(chanid)
     { /*<<io.js 329 4>>*/  /*<<io.js 329 13>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 330 4>>*/ if(! chan.opened)
        /*<<io.js 330 22>>*/ caml_raise_sys_error
        ("Cannot flush a closed channel");
       /*<<io.js 331 4>>*/ if(! chan.buffer || chan.buffer == "")
        /*<<io.js 331 42>>*/ return 0;
       /*<<io.js 332 4>>*/ if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
        /*<<io.js 334 48>>*/ { /*<<io.js 335 6>>*/  /*<<io.js 335 17>>*/ var
         output=
          caml_global_data.fds[chan.fd].output;
         /*<<io.js 336 6>>*/ switch(output.length)
         {case 2:
            /*<<io.js 337 14>>*/ output(chanid,chan.buffer);
            /*<<io.js 337 41>>*/ break;
          default: /*<<io.js 338 15>>*/ output(chan.buffer)}}
      chan.buffer = "";
       /*<<io.js 342 4>>*/ return 0 /*<<io.js 343 0>>*/ }
     /*<<io.js 350 0>>*/ function caml_ml_output_bytes
     (chanid,buffer,offset,len)
     { /*<<io.js 351 4>>*/  /*<<io.js 351 13>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 352 4>>*/ if(! chan.opened)
        /*<<io.js 352 22>>*/ caml_raise_sys_error
        ("Cannot output to a closed channel");
       /*<<io.js 351 4>>*/ var string;
       /*<<io.js 354 4>>*/ if
       (offset
        ==
        0
        &&
         /*<<io.js 354 22>>*/ caml_ml_bytes_length(buffer)
        ==
        len)
       string = buffer;
      else
        /*<<io.js 356 9>>*/ {string
        =
         /*<<io.js 357 17>>*/ caml_create_bytes(len);
         /*<<io.js 358 8>>*/ caml_blit_bytes(buffer,offset,string,0,len)}
       /*<<io.js 351 4>>*/ var
        /*<<io.js 360 17>>*/ jsstring=
         /*<<io.js 360 19>>*/ caml_jsbytes_of_string(string),
        /*<<io.js 361 11>>*/ id=
         /*<<io.js 361 13>>*/ jsstring.lastIndexOf("\n");
       /*<<io.js 362 4>>*/ if(id < 0)
       chan.buffer += jsstring;
      else
        /*<<io.js 364 9>>*/ {chan.buffer
        +=
         /*<<io.js 365 21>>*/ jsstring.substr(0,id + 1);
         /*<<io.js 366 8>>*/ caml_ml_flush(chanid);
        chan.buffer +=  /*<<io.js 367 23>>*/ jsstring.substr(id + 1)}
       /*<<io.js 369 4>>*/ return 0 /*<<io.js 370 0>>*/ }
     /*<<io.js 374 0>>*/ function caml_ml_output(chanid,buffer,offset,len)
     { /*<<io.js 375 4>>*/ return  /*<<io.js 375 11>>*/ caml_ml_output_bytes
              (chanid,buffer,offset,len) /*<<io.js 376 0>>*/ }
     /*<<io.js 381 0>>*/ function caml_ml_output_char(chanid,c)
     { /*<<io.js 382 4>>*/  /*<<io.js 382 10>>*/ var
       s=
         /*<<io.js 382 12>>*/ caml_new_string
         ( /*<<io.js 382 28>>*/ String.fromCharCode(c));
       /*<<io.js 383 4>>*/ caml_ml_output(chanid,s,0,1);
       /*<<io.js 384 4>>*/ return 0 /*<<io.js 385 0>>*/ }
     /*<<io.js 203 0>>*/ function caml_ml_refill_input(chan)
     { /*<<io.js 204 2>>*/ var
        /*<<io.js 204 10>>*/ str= /*<<io.js 204 12>>*/ chan.refill(),
        /*<<io.js 205 14>>*/ str_len=
         /*<<io.js 205 16>>*/ caml_ml_bytes_length(str);
       /*<<io.js 206 2>>*/ if(str_len == 0)chan.refill = null;
       /*<<io.js 207 2>>*/ chan.file.write
       ( /*<<io.js 207 18>>*/ chan.file.length(),str,0,str_len);
       /*<<io.js 208 2>>*/ return str_len /*<<io.js 209 0>>*/ }
     /*<<io.js 213 0>>*/ function caml_ml_may_refill_input(chanid)
     { /*<<io.js 214 2>>*/  /*<<io.js 214 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 215 2>>*/ if(chan.refill == null)
        /*<<io.js 215 27>>*/ return;
       /*<<io.js 216 2>>*/ if
       ( /*<<io.js 216 6>>*/ chan.file.length() != chan.offset)
        /*<<io.js 216 41>>*/ return;
       /*<<io.js 217 2>>*/ caml_ml_refill_input(chan) /*<<io.js 218 0>>*/ }
     /*<<stdlib.js 191 0>>*/ function caml_raise_end_of_file()
     { /*<<stdlib.js 192 2>>*/ caml_raise_constant
       (caml_global_data.End_of_file) /*<<stdlib.js 193 0>>*/ }
     /*<<io.js 255 0>>*/ function caml_ml_input_char(chanid)
     { /*<<io.js 256 2>>*/  /*<<io.js 256 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 257 2>>*/ caml_ml_may_refill_input(chanid);
       /*<<io.js 258 2>>*/ if
       (chan.offset >=  /*<<io.js 258 21>>*/ chan.file.length())
        /*<<io.js 259 4>>*/ caml_raise_end_of_file();
       /*<<io.js 256 2>>*/  /*<<io.js 260 10>>*/ var
       res=
         /*<<io.js 260 12>>*/ chan.file.read_one(chan.offset);
      chan.offset++;
       /*<<io.js 262 2>>*/ return res /*<<io.js 263 0>>*/ }
     /*<<stdlib.js 953 0>>*/ function caml_sys_const_ostype_win32()
     { /*<<stdlib.js 953 42>>*/ return 0 /*<<stdlib.js 953 52>>*/ }
     /*<<stdlib.js 221 0>>*/ function caml_obj_is_block(x)
     { /*<<stdlib.js 221 33>>*/ return + (x instanceof Array) /*<<stdlib.js 221 63>>*/ }
     /*<<ieee_754.js 124 0>>*/ function caml_int64_float_of_bits(x)
     { /*<<ieee_754.js 125 2>>*/  /*<<ieee_754.js 125 10>>*/ var
       exp=
        (x[3] & 32767) >> 4;
       /*<<ieee_754.js 126 2>>*/ if(exp == 2047)
        /*<<ieee_754.js 126 19>>*/ return (x[1] | x[2] | x[3] & 15) == 0
               ?x[3] & 32768?- Infinity:Infinity
               :NaN;
       /*<<ieee_754.js 125 2>>*/ var
        /*<<ieee_754.js 132 8>>*/ k=
         /*<<ieee_754.js 132 10>>*/ Math.pow(2,- 24),
        /*<<ieee_754.js 133 10>>*/ res=(x[1] * k + x[2]) * k + (x[3] & 15);
       /*<<ieee_754.js 134 2>>*/ if(exp > 0)
        /*<<ieee_754.js 134 15>>*/ {res += 16;
        res *=  /*<<ieee_754.js 136 11>>*/ Math.pow(2,exp - 1027)}
      else
       res *=  /*<<ieee_754.js 138 11>>*/ Math.pow(2,- 1026);
       /*<<ieee_754.js 139 2>>*/ if(x[3] & 32768)res = - res;
       /*<<ieee_754.js 140 2>>*/ return res /*<<ieee_754.js 141 0>>*/ }
     /*<<int64.js 327 0>>*/ function caml_int64_of_bytes(a)
     { /*<<int64.js 328 2>>*/ return [255,
              a[7] | a[6] << 8 | a[5] << 16,
              a[4] | a[3] << 8 | a[2] << 16,
              a[1] | a[0] << 8] /*<<int64.js 330 0>>*/ }
     /*<<marshal.js 126 0>>*/ function caml_float_of_bytes(a)
     { /*<<marshal.js 127 2>>*/ return  /*<<marshal.js 127 9>>*/ caml_int64_float_of_bits
              ( /*<<marshal.js 127 35>>*/ caml_int64_of_bytes(a)) /*<<marshal.js 128 0>>*/ }
     /*<<ieee_754.js 242 0>>*/ function caml_log10_float(x)
     { /*<<ieee_754.js 242 32>>*/ return Math.LOG10E
             *
              /*<<ieee_754.js 242 53>>*/ Math.log(x) /*<<ieee_754.js 242 66>>*/ }
     /*<<stdlib.js 1177 0>>*/  /*<<stdlib.js 1177 26>>*/ var
     caml_runtime_warnings=
      0;
     /*<<stdlib.js 1181 0>>*/ function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;
       /*<<stdlib.js 1183 2>>*/ return 0 /*<<stdlib.js 1184 0>>*/ }
     /*<<ieee_754.js 152 0>>*/ function caml_classify_float(x)
     { /*<<ieee_754.js 153 2>>*/ if( /*<<ieee_754.js 153 6>>*/ isFinite(x))
        /*<<ieee_754.js 153 20>>*/ { /*<<ieee_754.js 154 4>>*/ if
         ( /*<<ieee_754.js 154 8>>*/ Math.abs(x) >= 2.22507385850720138e-308)
          /*<<ieee_754.js 154 48>>*/ return 0;
         /*<<ieee_754.js 155 4>>*/ if(x != 0)
          /*<<ieee_754.js 155 16>>*/ return 1;
         /*<<ieee_754.js 156 4>>*/ return 2}
       /*<<ieee_754.js 158 2>>*/ return  /*<<ieee_754.js 158 9>>*/ isNaN(x)
              ?4
              :3 /*<<ieee_754.js 159 0>>*/ }
     /*<<jslib_js_of_ocaml.js 43 0>>*/ function caml_js_var(x)
     { /*<<jslib_js_of_ocaml.js 44 2>>*/  /*<<jslib_js_of_ocaml.js 44 8>>*/ var
       x=
         /*<<jslib_js_of_ocaml.js 44 10>>*/ x.toString();
       /*<<jslib_js_of_ocaml.js 46 2>>*/ if
       (!
         /*<<jslib_js_of_ocaml.js 46 6>>*/ x.match
         (/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
        /*<<jslib_js_of_ocaml.js 46 73>>*/  /*<<jslib_js_of_ocaml.js 47 4>>*/ js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
       /*<<jslib_js_of_ocaml.js 50 2>>*/ return  /*<<jslib_js_of_ocaml.js 50 9>>*/ eval
              (x) /*<<jslib_js_of_ocaml.js 51 0>>*/ }
     /*<<io.js 313 0>>*/ function caml_ml_input_scan_line(chanid)
     { /*<<io.js 314 2>>*/  /*<<io.js 314 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 315 2>>*/ caml_ml_may_refill_input(chanid);
       /*<<io.js 314 2>>*/ var
        /*<<io.js 316 8>>*/ p=chan.offset,
        /*<<io.js 317 10>>*/ len= /*<<io.js 317 12>>*/ chan.file.length();
       /*<<io.js 318 2>>*/ if(p >= len) /*<<io.js 318 15>>*/ return 0;
       /*<<io.js 319 2>>*/ while(true)
        /*<<io.js 319 14>>*/ { /*<<io.js 320 4>>*/ if(p >= len)
          /*<<io.js 320 17>>*/ return - (p - chan.offset);
         /*<<io.js 321 4>>*/ if
         ( /*<<io.js 321 7>>*/ chan.file.read_one(p) == 10)
          /*<<io.js 321 36>>*/ return p - chan.offset + 1;
        p++} /*<<io.js 324 0>>*/ }
     /*<<io.js 31 0>>*/ function caml_std_output(chanid,s)
     { /*<<io.js 32 2>>*/ var
        /*<<io.js 32 11>>*/ chan=caml_ml_channels[chanid],
        /*<<io.js 33 10>>*/ str= /*<<io.js 33 12>>*/ caml_new_string(s),
        /*<<io.js 34 11>>*/ slen=
         /*<<io.js 34 13>>*/ caml_ml_string_length(str);
       /*<<io.js 35 2>>*/ chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
       /*<<io.js 37 2>>*/ return 0 /*<<io.js 38 0>>*/ }
     /*<<gc.js 4 0>>*/ function caml_gc_minor()
     { /*<<gc.js 4 26>>*/ return 0 /*<<gc.js 4 34>>*/ }
     /*<<weak.js 32 0>>*/  /*<<weak.js 32 26>>*/ var caml_ephe_data_offset=2;
     /*<<weak.js 124 0>>*/ function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];
       /*<<weak.js 126 2>>*/ return 0 /*<<weak.js 127 0>>*/ }
     /*<<stdlib.js 523 0>>*/ function caml_is_printable(c)
     { /*<<stdlib.js 523 32>>*/ return + (c > 31 && c < 127) /*<<stdlib.js 523 61>>*/ }
     /*<<mlString.js 523 0>>*/ function caml_bytes_lessequal(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 524 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 525 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 526 2>>*/ return s1.c <= s2.c?1:0 /*<<mlString.js 527 0>>*/ }
     /*<<bigarray.js 528 0>>*/ function caml_ba_uint8_get64(ba,i0)
     { /*<<bigarray.js 529 4>>*/ var
        /*<<bigarray.js 529 11>>*/ b1= /*<<bigarray.js 529 13>>*/ ba.get1(i0),
        /*<<bigarray.js 530 11>>*/ b2=
         /*<<bigarray.js 530 13>>*/ ba.get1(i0 + 1)
        <<
        8,
        /*<<bigarray.js 531 11>>*/ b3=
         /*<<bigarray.js 531 13>>*/ ba.get1(i0 + 2)
        <<
        16,
        /*<<bigarray.js 532 11>>*/ b4=
         /*<<bigarray.js 532 13>>*/ ba.get1(i0 + 3),
        /*<<bigarray.js 533 11>>*/ b5=
         /*<<bigarray.js 533 13>>*/ ba.get1(i0 + 4)
        <<
        8,
        /*<<bigarray.js 534 11>>*/ b6=
         /*<<bigarray.js 534 13>>*/ ba.get1(i0 + 5)
        <<
        16,
        /*<<bigarray.js 535 11>>*/ b7=
         /*<<bigarray.js 535 13>>*/ ba.get1(i0 + 6),
        /*<<bigarray.js 536 11>>*/ b8=
         /*<<bigarray.js 536 13>>*/ ba.get1(i0 + 7)
        <<
        8;
       /*<<bigarray.js 537 4>>*/ return [255,
              b1 | b2 | b3,
              b4 | b5 | b6,
              b7 | b8] /*<<bigarray.js 538 0>>*/ }
     /*<<int64.js 39 0>>*/ function caml_int64_compare(x,y)
     { /*<<int64.js 40 2>>*/ var
        /*<<int64.js 40 9>>*/ x3=x[3] << 16,
        /*<<int64.js 41 9>>*/ y3=y[3] << 16;
       /*<<int64.js 42 2>>*/ if(x3 > y3) /*<<int64.js 42 15>>*/ return 1;
       /*<<int64.js 43 2>>*/ if(x3 < y3) /*<<int64.js 43 15>>*/ return - 1;
       /*<<int64.js 44 2>>*/ if(x[2] > y[2]) /*<<int64.js 44 19>>*/ return 1;
       /*<<int64.js 45 2>>*/ if(x[2] < y[2])
        /*<<int64.js 45 19>>*/ return - 1;
       /*<<int64.js 46 2>>*/ if(x[1] > y[1]) /*<<int64.js 46 19>>*/ return 1;
       /*<<int64.js 47 2>>*/ if(x[1] < y[1])
        /*<<int64.js 47 19>>*/ return - 1;
       /*<<int64.js 48 2>>*/ return 0 /*<<int64.js 49 0>>*/ }
     /*<<stdlib.js 418 0>>*/ function caml_int_compare(a,b)
     { /*<<stdlib.js 419 2>>*/ if(a < b) /*<<stdlib.js 419 13>>*/ return - 1;
       /*<<stdlib.js 419 26>>*/ if(a == b) /*<<stdlib.js 419 38>>*/ return 0;
       /*<<stdlib.js 419 48>>*/ return 1 /*<<stdlib.js 420 0>>*/ }
     /*<<mlString.js 472 0>>*/ function caml_string_compare(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 473 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 474 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 475 2>>*/ return s1.c < s2.c?- 1:s1.c > s2.c?1:0 /*<<mlString.js 476 0>>*/ }
     /*<<stdlib.js 332 0>>*/ function caml_compare_val(a,b,total)
     { /*<<stdlib.js 333 2>>*/  /*<<stdlib.js 333 12>>*/ var stack=[];
       /*<<stdlib.js 334 2>>*/ for(;;)
        /*<<stdlib.js 334 10>>*/ { /*<<stdlib.js 335 4>>*/ if
         (! (total && a === b))
          /*<<stdlib.js 335 29>>*/ if(a instanceof MlBytes)
           /*<<stdlib.js 336 32>>*/ if(b instanceof MlBytes)
           { /*<<stdlib.js 337 34>>*/ if(a !== b)
              /*<<stdlib.js 338 25>>*/ { /*<<stdlib.js 339 2>>*/  /*<<stdlib.js 339 8>>*/ var
               x=
                 /*<<stdlib.js 339 10>>*/ caml_string_compare(a,b);
               /*<<stdlib.js 340 2>>*/ if(x != 0)
                /*<<stdlib.js 340 14>>*/ return x}}
          else
            /*<<stdlib.js 344 10>>*/ return 1;
         else
           /*<<stdlib.js 345 13>>*/ if
           (a instanceof Array && a[0] === (a[0] | 0))
            /*<<stdlib.js 345 58>>*/ { /*<<stdlib.js 346 8>>*/  /*<<stdlib.js 346 15>>*/ var
             ta=
              a[0];
             /*<<stdlib.js 348 8>>*/ if(ta === 254)ta = 0;
             /*<<stdlib.js 350 8>>*/ if(ta === 250)
              /*<<stdlib.js 350 24>>*/ {a = a[1];
               /*<<stdlib.js 352 10>>*/ continue}
            else
              /*<<stdlib.js 353 15>>*/ if
              (b instanceof Array && b[0] === (b[0] | 0))
               /*<<stdlib.js 353 60>>*/ { /*<<stdlib.js 354 10>>*/  /*<<stdlib.js 354 17>>*/ var
                tb=
                 b[0];
                /*<<stdlib.js 356 10>>*/ if(tb === 254)tb = 0;
                /*<<stdlib.js 358 10>>*/ if(tb === 250)
                 /*<<stdlib.js 358 26>>*/ {b = b[1];
                  /*<<stdlib.js 360 12>>*/ continue}
               else
                 /*<<stdlib.js 361 17>>*/ if(ta != tb)
                  /*<<stdlib.js 361 31>>*/ return ta < tb?- 1:1;
                else
                  /*<<stdlib.js 363 17>>*/ switch(ta)
                  {case 248:
                     /*<<stdlib.js 367 2>>*/  /*<<stdlib.js 367 8>>*/ var
                     x=
                       /*<<stdlib.js 367 10>>*/ caml_int_compare(a[2],b[2]);
                     /*<<stdlib.js 368 2>>*/ if(x != 0)
                      /*<<stdlib.js 368 14>>*/ return x;
                     /*<<stdlib.js 369 2>>*/ break;
                   case 251:
                     /*<<stdlib.js 371 22>>*/  /*<<stdlib.js 372 16>>*/ caml_invalid_argument
                     ("equal: abstract value");
                   case 255:
                     /*<<stdlib.js 376 2>>*/  /*<<stdlib.js 376 8>>*/ var
                     x=
                       /*<<stdlib.js 376 10>>*/ caml_int64_compare(a,b);
                     /*<<stdlib.js 377 2>>*/ if(x != 0)
                      /*<<stdlib.js 377 14>>*/ return x;
                     /*<<stdlib.js 378 2>>*/ break;
                   default:
                     /*<<stdlib.js 381 14>>*/ if(a.length != b.length)
                      /*<<stdlib.js 381 40>>*/ return a.length < b.length?- 1:1;
                     /*<<stdlib.js 382 14>>*/ if(a.length > 1)
                      /*<<stdlib.js 382 32>>*/ stack.push(a,b,1)}}
             else
               /*<<stdlib.js 386 10>>*/ return 1}
          else
            /*<<stdlib.js 387 13>>*/ if
            (b instanceof MlBytes
             ||
             b instanceof Array
             &&
             b[0]
             ===
             (b[0] | 0))
             /*<<stdlib.js 388 60>>*/ return - 1;
           else
             /*<<stdlib.js 390 13>>*/ if
             (typeof a != "number" && a && a.compare)
              /*<<stdlib.js 390 57>>*/ { /*<<stdlib.js 391 8>>*/  /*<<stdlib.js 391 16>>*/ var
               cmp=
                 /*<<stdlib.js 391 18>>*/ a.compare(b,total);
               /*<<stdlib.js 392 8>>*/ if(cmp != 0)
                /*<<stdlib.js 392 22>>*/ return cmp}
            else
              /*<<stdlib.js 393 13>>*/ if(typeof a == "function")
               /*<<stdlib.js 393 41>>*/  /*<<stdlib.js 394 8>>*/ caml_invalid_argument
               ("compare: functional value");
             else
               /*<<stdlib.js 395 13>>*/ { /*<<stdlib.js 396 8>>*/ if(a < b)
                 /*<<stdlib.js 396 19>>*/ return - 1;
                /*<<stdlib.js 397 8>>*/ if(a > b)
                 /*<<stdlib.js 397 19>>*/ return 1;
                /*<<stdlib.js 398 8>>*/ if(a != b)
                 /*<<stdlib.js 398 20>>*/ { /*<<stdlib.js 399 10>>*/ if
                  (! total)
                   /*<<stdlib.js 399 22>>*/ return NaN;
                  /*<<stdlib.js 400 10>>*/ if(a == a)
                   /*<<stdlib.js 400 22>>*/ return 1;
                  /*<<stdlib.js 401 10>>*/ if(b == b)
                   /*<<stdlib.js 401 22>>*/ return - 1}}
         /*<<stdlib.js 405 4>>*/ if(stack.length == 0)
          /*<<stdlib.js 405 27>>*/ return 0;
         /*<<stdlib.js 406 4>>*/  /*<<stdlib.js 406 10>>*/ var
         i=
           /*<<stdlib.js 406 12>>*/ stack.pop();
        b =  /*<<stdlib.js 407 8>>*/ stack.pop();
        a =  /*<<stdlib.js 408 8>>*/ stack.pop();
         /*<<stdlib.js 409 4>>*/ if(i + 1 < a.length)
          /*<<stdlib.js 409 26>>*/ stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]} /*<<stdlib.js 413 0>>*/ }
     /*<<stdlib.js 423 0>>*/ function caml_equal(x,y)
     { /*<<stdlib.js 423 29>>*/ return +
             ( /*<<stdlib.js 423 38>>*/ caml_compare_val(x,y,false) == 0) /*<<stdlib.js 423 73>>*/ }
     /*<<bigarray.js 481 0>>*/ function caml_ba_num_dims(ba,_dim)
     { /*<<bigarray.js 482 4>>*/ return ba.num_dims /*<<bigarray.js 483 0>>*/ }
     /*<<bigarray.js 541 0>>*/ function caml_ba_get_1(ba,i0)
     { /*<<bigarray.js 542 4>>*/ return  /*<<bigarray.js 542 11>>*/ ba.get1
              (i0) /*<<bigarray.js 543 0>>*/ }
     /*<<bigstring.js 33 0>>*/ function bigstring_blit_bigstring_bytes_stub
     (v_bstr,v_src_pos,v_str,v_dst_pos,v_len)
     { /*<<bigstring.js 34 2>>*/ for
       ( /*<<bigstring.js 34 12>>*/ var i=0;i < v_len;i++)
        /*<<bigstring.js 34 32>>*/ { /*<<bigstring.js 35 4>>*/  /*<<bigstring.js 35 10>>*/ var
         c=
           /*<<bigstring.js 35 12>>*/ caml_ba_get_1(v_bstr,v_src_pos + i);
         /*<<bigstring.js 36 4>>*/ caml_bytes_set(v_str,v_dst_pos + i,c)}
       /*<<bigstring.js 38 2>>*/ return 0 /*<<bigstring.js 39 0>>*/ }
     /*<<fs.js 238 0>>*/ function caml_create_file(name,content)
     { /*<<fs.js 239 2>>*/  /*<<fs.js 239 11>>*/ var
       root=
         /*<<fs.js 239 13>>*/ resolve_fs_device(name);
       /*<<fs.js 240 2>>*/ if(! root.device.register)
        /*<<fs.js 240 29>>*/ caml_failwith("cannot register file");
       /*<<fs.js 241 2>>*/ root.device.register(root.rest,content);
       /*<<fs.js 242 2>>*/ return 0 /*<<fs.js 243 0>>*/ }
     /*<<fs.js 225 0>>*/ function caml_fs_init()
     { /*<<fs.js 226 2>>*/  /*<<fs.js 226 9>>*/ var
       tmp=
        joo_global_object.caml_fs_tmp;
       /*<<fs.js 227 2>>*/ if(tmp)
        /*<<fs.js 227 9>>*/ for
        ( /*<<fs.js 228 14>>*/ var i=0;i < tmp.length;i++)
         /*<<fs.js 228 39>>*/  /*<<fs.js 229 6>>*/ caml_create_file
         (tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
       /*<<fs.js 233 2>>*/ return 0 /*<<fs.js 234 0>>*/ }
     /*<<stdlib.js 254 0>>*/ if(! Math.imul)
     Math.imul
     =
     function(x,y)
      {y |= 0;
        /*<<stdlib.js 257 14>>*/ return ((x >> 16) * y << 16)
              +
              (x & 65535)
              *
              y
              |
              0 /*<<stdlib.js 256 4>>*/ };
     /*<<stdlib.js 258 0>>*/  /*<<stdlib.js 258 13>>*/ var caml_mul=Math.imul;
     /*<<stdlib.js 739 0>>*/ function caml_hash_mix_int(h,d)
     {d =  /*<<stdlib.js 740 6>>*/ caml_mul(d,3432918353 | 0);
      d = d << 15 | d >>> 32 - 15;
      d =  /*<<stdlib.js 742 6>>*/ caml_mul(d,461845907);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
       /*<<stdlib.js 745 2>>*/ return (h + (h << 2) | 0)
             +
             (3864292196 | 0)
             |
             0 /*<<stdlib.js 746 0>>*/ }
     /*<<stdlib.js 803 0>>*/ function caml_hash_mix_string_arr(h,s)
     { /*<<stdlib.js 804 2>>*/ var  /*<<stdlib.js 804 10>>*/ len=s.length,i,w;
       /*<<stdlib.js 805 2>>*/ for(i = 0;i + 4 <= len;i += 4)
        /*<<stdlib.js 805 36>>*/ {w
        =
        s[i]
        |
        s[i + 1]
        <<
        8
        |
        s[i + 2]
        <<
        16
        |
        s[i + 3]
        <<
        24;
        h =  /*<<stdlib.js 810 8>>*/ caml_hash_mix_int(h,w)}
      w = 0;
       /*<<stdlib.js 813 2>>*/ switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h =  /*<<stdlib.js 817 8>>*/ caml_hash_mix_int(h,w)
        }
      h ^= len;
       /*<<stdlib.js 821 2>>*/ return h /*<<stdlib.js 822 0>>*/ }
     /*<<stdlib.js 122 0>>*/ function caml_return_exn_constant(tag)
     { /*<<stdlib.js 122 42>>*/ return tag /*<<stdlib.js 122 54>>*/ }
     /*<<stdlib.js 76 0>>*/  /*<<stdlib.js 76 22>>*/ var caml_named_values={};
     /*<<stdlib.js 87 0>>*/ function caml_named_value(nm)
     { /*<<stdlib.js 88 2>>*/ return caml_named_values[nm] /*<<stdlib.js 89 0>>*/ }
     /*<<stdlib.js 148 0>>*/ function caml_wrap_exception(e)
     { /*<<stdlib.js 149 2>>*/ if(e instanceof Array)
        /*<<stdlib.js 149 25>>*/ return e;
       /*<<stdlib.js 151 2>>*/ if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
         /*<<stdlib.js 154 8>>*/ e.message.match(/maximum call stack/i))
        /*<<stdlib.js 155 4>>*/ return  /*<<stdlib.js 155 11>>*/ caml_return_exn_constant
               (caml_global_data.Stack_overflow);
       /*<<stdlib.js 157 2>>*/ if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
         /*<<stdlib.js 160 8>>*/ e.message.match(/too much recursion/i))
        /*<<stdlib.js 161 4>>*/ return  /*<<stdlib.js 161 11>>*/ caml_return_exn_constant
               (caml_global_data.Stack_overflow);
       /*<<stdlib.js 163 2>>*/ if
       (e instanceof joo_global_object.Error
        &&
         /*<<stdlib.js 163 45>>*/ caml_named_value("jsError"))
        /*<<stdlib.js 164 4>>*/ return [0,
                /*<<stdlib.js 164 14>>*/ caml_named_value("jsError"),
               e];
       /*<<stdlib.js 166 2>>*/ return [0,
              caml_global_data.Failure,
               /*<<stdlib.js 166 37>>*/ caml_js_to_string
               ( /*<<stdlib.js 166 56>>*/ String(e))] /*<<stdlib.js 167 0>>*/ }
     /*<<stdlib.js 1039 0>>*/ function
     caml_final_register_called_without_value
     ()
     { /*<<stdlib.js 1039 55>>*/ return 0 /*<<stdlib.js 1039 65>>*/ }
     /*<<stdlib.js 929 0>>*/ function caml_sys_random_seed()
     { /*<<stdlib.js 930 2>>*/  /*<<stdlib.js 930 8>>*/ var
       x=
        new Date() ^ 4294967295 *  /*<<stdlib.js 930 32>>*/ Math.random();
       /*<<stdlib.js 931 2>>*/ return [0,x] /*<<stdlib.js 932 0>>*/ }
     /*<<stdlib.js 1167 0>>*/ function caml_list_of_js_array(a)
     { /*<<stdlib.js 1168 2>>*/  /*<<stdlib.js 1168 8>>*/ var l=0;
       /*<<stdlib.js 1169 2>>*/ for
       ( /*<<stdlib.js 1169 11>>*/ var i=a.length - 1;i >= 0;i--)
        /*<<stdlib.js 1169 36>>*/ { /*<<stdlib.js 1170 4>>*/  /*<<stdlib.js 1170 10>>*/ var
         e=
          a[i];
        l = [0,e,l]}
       /*<<stdlib.js 1173 2>>*/ return l /*<<stdlib.js 1174 0>>*/ }
     /*<<bigarray.js 546 0>>*/ function caml_ba_get_2(ba,i0,i1)
     { /*<<bigarray.js 547 4>>*/ return  /*<<bigarray.js 547 11>>*/ ba.get
              ([i0,i1]) /*<<bigarray.js 548 0>>*/ }
     /*<<parsing.js 236 0>>*/ function caml_set_parser_trace()
     { /*<<parsing.js 236 35>>*/ return 0 /*<<parsing.js 236 45>>*/ }
     /*<<unix.js 53 0>>*/ function win_handle_fd(x)
     { /*<<unix.js 53 27>>*/ return x /*<<unix.js 53 36>>*/ }
     /*<<unix.js 2 0>>*/ function unix_gettimeofday()
     { /*<<unix.js 3 2>>*/ return  /*<<unix.js 3 9>>*/ new Date().getTime()
             /
             1e3 /*<<unix.js 4 0>>*/ }
     /*<<bigarray.js 562 0>>*/ function caml_ba_uint8_set16(ba,i0,v)
     { /*<<bigarray.js 563 4>>*/ ba.set1(i0,v & 255);
       /*<<bigarray.js 564 4>>*/ ba.set1(i0 + 1,v >>> 8 & 255);
       /*<<bigarray.js 565 4>>*/ return 0 /*<<bigarray.js 566 0>>*/ }
     /*<<stdlib.js 47 0>>*/ function raw_array_append_one(a,x)
     { /*<<stdlib.js 48 2>>*/ var
        /*<<stdlib.js 48 8>>*/ l=a.length,
        /*<<stdlib.js 49 8>>*/ b=new Array(l + 1),
        /*<<stdlib.js 50 8>>*/ i=0;
       /*<<stdlib.js 51 2>>*/ for(;i < l;i++)b[i] = a[i];
      b[i] = x;
       /*<<stdlib.js 53 2>>*/ return b /*<<stdlib.js 54 0>>*/ }
     /*<<stdlib.js 59 0>>*/ function caml_call_gen(f,args)
     { /*<<stdlib.js 60 2>>*/ if(f.fun)
        /*<<stdlib.js 61 4>>*/ return  /*<<stdlib.js 61 11>>*/ caml_call_gen
               (f.fun,args);
       /*<<stdlib.js 62 2>>*/ var
        /*<<stdlib.js 62 8>>*/ n=f.length,
        /*<<stdlib.js 63 14>>*/ argsLen=args.length,
        /*<<stdlib.js 64 8>>*/ d=n - argsLen;
       /*<<stdlib.js 65 2>>*/ if(d == 0)
        /*<<stdlib.js 66 4>>*/ return  /*<<stdlib.js 66 11>>*/ f.apply
               (null,args);
      else
        /*<<stdlib.js 67 7>>*/ if(d < 0)
         /*<<stdlib.js 68 4>>*/ return  /*<<stdlib.js 68 11>>*/ caml_call_gen
                ( /*<<stdlib.js 68 25>>*/ f.apply
                  (null, /*<<stdlib.js 69 33>>*/ raw_array_sub(args,0,n)),
                  /*<<stdlib.js 70 25>>*/ raw_array_sub(args,n,argsLen - n));
       else
         /*<<stdlib.js 72 4>>*/ return function(x)
         { /*<<stdlib.js 72 25>>*/ return  /*<<stdlib.js 72 32>>*/ caml_call_gen
                  (f, /*<<stdlib.js 72 49>>*/ raw_array_append_one(args,x)) /*<<stdlib.js 72 11>>*/ } /*<<stdlib.js 73 0>>*/ }
     /*<<jslib_js_of_ocaml.js 112 0>>*/ function caml_js_wrap_callback(f)
     { /*<<jslib_js_of_ocaml.js 113 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 114 4>>*/ return arguments.length > 0
                ? /*<<jslib_js_of_ocaml.js 115 13>>*/ caml_call_gen
                  (f,arguments)
                : /*<<jslib_js_of_ocaml.js 117 13>>*/ caml_call_gen
                  (f,[undefined]) /*<<jslib_js_of_ocaml.js 113 9>>*/ } /*<<jslib_js_of_ocaml.js 120 0>>*/ }
     /*<<jslib_js_of_ocaml.js 124 0>>*/ function
     caml_js_wrap_callback_arguments
     (f)
     { /*<<jslib_js_of_ocaml.js 125 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 126 4>>*/ return  /*<<jslib_js_of_ocaml.js 126 11>>*/  /*<<jslib_js_of_ocaml.js 126 11>>*/ caml_js_wrap_callback
                 (f)
                (arguments) /*<<jslib_js_of_ocaml.js 125 9>>*/ } /*<<jslib_js_of_ocaml.js 128 0>>*/ }
     /*<<fs.js 123 0>>*/ function caml_sys_chdir(dir)
     { /*<<fs.js 124 2>>*/  /*<<fs.js 124 11>>*/ var
       root=
         /*<<fs.js 124 13>>*/ resolve_fs_device(dir);
       /*<<fs.js 125 2>>*/ if
       ( /*<<fs.js 125 5>>*/ root.device.exists(root.rest))
        /*<<fs.js 125 36>>*/ { /*<<fs.js 126 4>>*/ caml_current_dir
        =
        root.rest?root.path + root.rest + "/":root.path;
         /*<<fs.js 128 4>>*/ return 0}
      else
        /*<<fs.js 130 7>>*/  /*<<fs.js 131 4>>*/ caml_raise_no_such_file(dir) /*<<fs.js 133 0>>*/ }
     /*<<gc.js 12 0>>*/ function caml_gc_counters()
     { /*<<gc.js 12 30>>*/ return [254,0,0,0] /*<<gc.js 12 49>>*/ }
     /*<<jslib.js 30 0>>*/ function caml_js_delete(o,f)
     {delete o[f]; /*<<jslib.js 30 44>>*/ return 0 /*<<jslib.js 30 52>>*/ }
     /*<<fs.js 69 0>>*/ function caml_list_mount_point()
     { /*<<fs.js 70 4>>*/  /*<<fs.js 70 13>>*/ var prev=0;
       /*<<fs.js 71 4>>*/ for
       ( /*<<fs.js 71 14>>*/ var i=0;i < jsoo_mount_point.length;i++)
        /*<<fs.js 71 52>>*/ { /*<<fs.js 72 8>>*/  /*<<fs.js 72 16>>*/ var
         old=
          prev;
        prev
        =
        [0, /*<<fs.js 73 19>>*/ caml_new_string(jsoo_mount_point[i].path),old]}
       /*<<fs.js 75 4>>*/ return prev /*<<fs.js 76 0>>*/ }
     /*<<stdlib.js 470 0>>*/ function caml_int_of_string(s)
     { /*<<stdlib.js 471 2>>*/ var
        /*<<stdlib.js 471 8>>*/ r=
         /*<<stdlib.js 471 10>>*/ caml_parse_sign_and_base(s),
        /*<<stdlib.js 472 8>>*/ i=r[0],
        /*<<stdlib.js 472 21>>*/ sign=r[1],
        /*<<stdlib.js 472 34>>*/ base=r[2],
        /*<<stdlib.js 473 10>>*/ len=
         /*<<stdlib.js 473 12>>*/ caml_ml_string_length(s),
        /*<<stdlib.js 474 16>>*/ threshold=- 1 >>> 0,
        /*<<stdlib.js 475 8>>*/ c=
        i < len? /*<<stdlib.js 475 20>>*/ caml_string_unsafe_get(s,i):0,
        /*<<stdlib.js 476 8>>*/ d=
         /*<<stdlib.js 476 10>>*/ caml_parse_digit(c);
       /*<<stdlib.js 477 2>>*/ if(d < 0 || d >= base)
        /*<<stdlib.js 477 26>>*/ caml_failwith("int_of_string");
       /*<<stdlib.js 471 2>>*/  /*<<stdlib.js 478 10>>*/ var res=d;
       /*<<stdlib.js 479 2>>*/ for(i++;i < len;i++)
        /*<<stdlib.js 479 22>>*/ {c
        =
         /*<<stdlib.js 480 8>>*/ caml_string_unsafe_get(s,i);
         /*<<stdlib.js 481 4>>*/ if(c == 95)
          /*<<stdlib.js 481 17>>*/ continue;
        d =  /*<<stdlib.js 482 8>>*/ caml_parse_digit(c);
         /*<<stdlib.js 483 4>>*/ if(d < 0 || d >= base)
          /*<<stdlib.js 483 28>>*/ break;
        res = base * res + d;
         /*<<stdlib.js 485 4>>*/ if(res > threshold)
          /*<<stdlib.js 485 25>>*/ caml_failwith("int_of_string")}
       /*<<stdlib.js 487 2>>*/ if(i != len)
        /*<<stdlib.js 487 16>>*/ caml_failwith("int_of_string");
      res = sign * res;
       /*<<stdlib.js 492 2>>*/ if(base == 10 && (res | 0) != res)
        /*<<stdlib.js 494 4>>*/ caml_failwith("int_of_string");
       /*<<stdlib.js 495 2>>*/ return res | 0 /*<<stdlib.js 496 0>>*/ }
     /*<<marshal.js 21 0>>*/  /*<<marshal.js 21 27>>*/ var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:128,
       PREFIX_SMALL_INT:64,
       PREFIX_SMALL_STRING:32,
       CODE_INT8:0,
       CODE_INT16:1,
       CODE_INT32:2,
       CODE_INT64:3,
       CODE_SHARED8:4,
       CODE_SHARED16:5,
       CODE_SHARED32:6,
       CODE_BLOCK32:8,
       CODE_BLOCK64:19,
       CODE_STRING8:9,
       CODE_STRING32:10,
       CODE_DOUBLE_BIG:11,
       CODE_DOUBLE_LITTLE:12,
       CODE_DOUBLE_ARRAY8_BIG:13,
       CODE_DOUBLE_ARRAY8_LITTLE:14,
       CODE_DOUBLE_ARRAY32_BIG:15,
       CODE_DOUBLE_ARRAY32_LITTLE:7,
       CODE_CODEPOINTER:16,
       CODE_INFIXPOINTER:17,
       CODE_CUSTOM:18};
     /*<<jslib_js_of_ocaml.js 172 0>>*/ function caml_js_equals(x,y)
     { /*<<jslib_js_of_ocaml.js 172 33>>*/ return + (x == y) /*<<jslib_js_of_ocaml.js 172 51>>*/ }
     /*<<stdlib.js 780 0>>*/ function caml_hash_mix_string_str(h,s)
     { /*<<stdlib.js 781 2>>*/ var  /*<<stdlib.js 781 10>>*/ len=s.length,i,w;
       /*<<stdlib.js 782 2>>*/ for(i = 0;i + 4 <= len;i += 4)
        /*<<stdlib.js 782 36>>*/ {w
        =
         /*<<stdlib.js 783 8>>*/ s.charCodeAt(i)
        |
         /*<<stdlib.js 784 11>>*/ s.charCodeAt(i + 1)
        <<
        8
        |
         /*<<stdlib.js 785 11>>*/ s.charCodeAt(i + 2)
        <<
        16
        |
         /*<<stdlib.js 786 11>>*/ s.charCodeAt(i + 3)
        <<
        24;
        h =  /*<<stdlib.js 787 8>>*/ caml_hash_mix_int(h,w)}
      w = 0;
       /*<<stdlib.js 790 2>>*/ switch(len & 3)
       {case 3:w =  /*<<stdlib.js 791 15>>*/ s.charCodeAt(i + 2) << 16;
        case 2:w |=  /*<<stdlib.js 792 15>>*/ s.charCodeAt(i + 1) << 8;
        case 1:
         w |=  /*<<stdlib.js 793 15>>*/ s.charCodeAt(i);
         h =  /*<<stdlib.js 794 14>>*/ caml_hash_mix_int(h,w)
        }
      h ^= len;
       /*<<stdlib.js 798 2>>*/ return h /*<<stdlib.js 799 0>>*/ }
     /*<<stdlib.js 432 0>>*/ function caml_greaterthan(x,y)
     { /*<<stdlib.js 432 35>>*/ return +
             ( /*<<stdlib.js 432 44>>*/ caml_compare_val(x,y,false) > 0) /*<<stdlib.js 432 78>>*/ }
     /*<<bigarray.js 606 0>>*/ function caml_ba_blit(src,dst)
     { /*<<bigarray.js 607 4>>*/ dst.blit(src);
       /*<<bigarray.js 608 4>>*/ return 0 /*<<bigarray.js 609 0>>*/ }
     /*<<marshal.js 148 0>>*/ function caml_input_value_from_reader
     (reader,ofs)
     { /*<<marshal.js 149 2>>*/ var
        /*<<marshal.js 149 13>>*/ _magic=
         /*<<marshal.js 149 15>>*/ reader.read32u(),
        /*<<marshal.js 150 17>>*/ _block_len=
         /*<<marshal.js 150 19>>*/ reader.read32u(),
        /*<<marshal.js 151 18>>*/ num_objects=
         /*<<marshal.js 151 20>>*/ reader.read32u(),
        /*<<marshal.js 152 15>>*/ _size_32=
         /*<<marshal.js 152 17>>*/ reader.read32u(),
        /*<<marshal.js 153 15>>*/ _size_64=
         /*<<marshal.js 153 17>>*/ reader.read32u(),
        /*<<marshal.js 154 12>>*/ stack=[],
        /*<<marshal.js 155 23>>*/ intern_obj_table=num_objects > 0?[]:null,
        /*<<marshal.js 156 18>>*/ obj_counter=0;
       /*<<marshal.js 157 2>>*/ function intern_rec()
       { /*<<marshal.js 158 4>>*/  /*<<marshal.js 158 13>>*/ var
         code=
           /*<<marshal.js 158 15>>*/ reader.read8u();
         /*<<marshal.js 159 4>>*/ if(code >= 64)
          /*<<marshal.js 159 47>>*/ if(code >= 128)
           /*<<marshal.js 160 51>>*/ { /*<<marshal.js 161 8>>*/ var
             /*<<marshal.js 161 16>>*/ tag=code & 15,
             /*<<marshal.js 162 17>>*/ size=code >> 4 & 7,
             /*<<marshal.js 163 14>>*/ v=[tag];
            /*<<marshal.js 164 8>>*/ if(size == 0)
             /*<<marshal.js 164 23>>*/ return v;
            /*<<marshal.js 165 8>>*/ if(intern_obj_table)
            intern_obj_table[obj_counter++] = v;
            /*<<marshal.js 166 8>>*/ stack.push(v,size);
            /*<<marshal.js 167 8>>*/ return v}
         else
           /*<<marshal.js 169 8>>*/ return code & 63;
        else
          /*<<marshal.js 170 11>>*/ if(code >= 32)
           /*<<marshal.js 171 52>>*/ { /*<<marshal.js 172 8>>*/ var
             /*<<marshal.js 172 16>>*/ len=code & 31,
             /*<<marshal.js 173 14>>*/ v=
              /*<<marshal.js 173 16>>*/ reader.readstr(len);
            /*<<marshal.js 174 8>>*/ if(intern_obj_table)
            intern_obj_table[obj_counter++] = v;
            /*<<marshal.js 175 8>>*/ return v}
         else
           /*<<marshal.js 176 13>>*/ switch(code)
           {case 0:
              /*<<marshal.js 179 10>>*/ return  /*<<marshal.js 179 17>>*/ reader.read8s
                     ();
            case 1:
              /*<<marshal.js 181 10>>*/ return  /*<<marshal.js 181 17>>*/ reader.read16s
                     ();
            case 2:
              /*<<marshal.js 183 10>>*/ return  /*<<marshal.js 183 17>>*/ reader.read32s
                     ();
            case 3:
              /*<<marshal.js 185 10>>*/ caml_failwith
              ("input_value: integer too large");
              /*<<marshal.js 186 10>>*/ break;
            case 4:
              /*<<marshal.js 188 10>>*/  /*<<marshal.js 188 21>>*/ var
              offset=
                /*<<marshal.js 188 23>>*/ reader.read8u();
              /*<<marshal.js 189 10>>*/ return intern_obj_table
                     [obj_counter - offset];
            case 5:
              /*<<marshal.js 191 10>>*/  /*<<marshal.js 191 21>>*/ var
              offset=
                /*<<marshal.js 191 23>>*/ reader.read16u();
              /*<<marshal.js 192 10>>*/ return intern_obj_table
                     [obj_counter - offset];
            case 6:
              /*<<marshal.js 194 10>>*/  /*<<marshal.js 194 21>>*/ var
              offset=
                /*<<marshal.js 194 23>>*/ reader.read32u();
              /*<<marshal.js 195 10>>*/ return intern_obj_table
                     [obj_counter - offset];
            case 8:
              /*<<marshal.js 197 10>>*/ var
               /*<<marshal.js 197 21>>*/ header=
                /*<<marshal.js 197 23>>*/ reader.read32u(),
               /*<<marshal.js 198 18>>*/ tag=header & 255,
               /*<<marshal.js 199 19>>*/ size=header >> 10,
               /*<<marshal.js 200 16>>*/ v=[tag];
              /*<<marshal.js 201 10>>*/ if(size == 0)
               /*<<marshal.js 201 25>>*/ return v;
              /*<<marshal.js 202 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 203 10>>*/ stack.push(v,size);
              /*<<marshal.js 204 10>>*/ return v;
            case 19:
              /*<<marshal.js 206 10>>*/ caml_failwith
              ("input_value: data block too large");
              /*<<marshal.js 207 10>>*/ break;
            case 9:
              /*<<marshal.js 209 10>>*/ var
               /*<<marshal.js 209 18>>*/ len=
                /*<<marshal.js 209 20>>*/ reader.read8u(),
               /*<<marshal.js 210 16>>*/ v=
                /*<<marshal.js 210 18>>*/ reader.readstr(len);
              /*<<marshal.js 211 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 212 10>>*/ return v;
            case 10:
              /*<<marshal.js 214 10>>*/ var
               /*<<marshal.js 214 18>>*/ len=
                /*<<marshal.js 214 20>>*/ reader.read32u(),
               /*<<marshal.js 215 16>>*/ v=
                /*<<marshal.js 215 18>>*/ reader.readstr(len);
              /*<<marshal.js 216 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 217 10>>*/ return v;
            case 12:
              /*<<marshal.js 219 10>>*/  /*<<marshal.js 219 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 220 10>>*/ for
              ( /*<<marshal.js 220 21>>*/ var i=0;i < 8;i++)
              t[7 - i] =  /*<<marshal.js 220 47>>*/ reader.read8u();
              /*<<marshal.js 219 10>>*/  /*<<marshal.js 221 16>>*/ var
              v=
                /*<<marshal.js 221 18>>*/ caml_float_of_bytes(t);
              /*<<marshal.js 222 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 223 10>>*/ return v;
            case 11:
              /*<<marshal.js 225 10>>*/  /*<<marshal.js 225 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 226 10>>*/ for
              ( /*<<marshal.js 226 21>>*/ var i=0;i < 8;i++)
              t[i] =  /*<<marshal.js 226 43>>*/ reader.read8u();
              /*<<marshal.js 225 10>>*/  /*<<marshal.js 227 16>>*/ var
              v=
                /*<<marshal.js 227 18>>*/ caml_float_of_bytes(t);
              /*<<marshal.js 228 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 229 10>>*/ return v;
            case 14:
              /*<<marshal.js 231 10>>*/ var
               /*<<marshal.js 231 18>>*/ len=
                /*<<marshal.js 231 20>>*/ reader.read8u(),
               /*<<marshal.js 232 16>>*/ v=new Array(len + 1);
             v[0] = 254;
              /*<<marshal.js 231 10>>*/  /*<<marshal.js 234 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 235 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 236 10>>*/ for
              ( /*<<marshal.js 236 21>>*/ var i=1;i <= len;i++)
               /*<<marshal.js 236 39>>*/ { /*<<marshal.js 237 12>>*/ for
                ( /*<<marshal.js 237 23>>*/ var j=0;j < 8;j++)
                t[7 - j] =  /*<<marshal.js 237 49>>*/ reader.read8u();
               v[i] =  /*<<marshal.js 238 19>>*/ caml_float_of_bytes(t)}
              /*<<marshal.js 240 10>>*/ return v;
            case 13:
              /*<<marshal.js 242 10>>*/ var
               /*<<marshal.js 242 18>>*/ len=
                /*<<marshal.js 242 20>>*/ reader.read8u(),
               /*<<marshal.js 243 16>>*/ v=new Array(len + 1);
             v[0] = 254;
              /*<<marshal.js 242 10>>*/  /*<<marshal.js 245 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 246 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 247 10>>*/ for
              ( /*<<marshal.js 247 21>>*/ var i=1;i <= len;i++)
               /*<<marshal.js 247 39>>*/ { /*<<marshal.js 248 12>>*/ for
                ( /*<<marshal.js 248 23>>*/ var j=0;j < 8;j++)
                t[j] =  /*<<marshal.js 248 45>>*/ reader.read8u();
               v[i] =  /*<<marshal.js 249 20>>*/ caml_float_of_bytes(t)}
              /*<<marshal.js 251 10>>*/ return v;
            case 7:
              /*<<marshal.js 253 10>>*/ var
               /*<<marshal.js 253 18>>*/ len=
                /*<<marshal.js 253 20>>*/ reader.read32u(),
               /*<<marshal.js 254 16>>*/ v=new Array(len + 1);
             v[0] = 254;
              /*<<marshal.js 256 10>>*/ if(intern_obj_table)
              intern_obj_table[obj_counter++] = v;
              /*<<marshal.js 253 10>>*/  /*<<marshal.js 257 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 258 10>>*/ for
              ( /*<<marshal.js 258 21>>*/ var i=1;i <= len;i++)
               /*<<marshal.js 258 39>>*/ { /*<<marshal.js 259 12>>*/ for
                ( /*<<marshal.js 259 23>>*/ var j=0;j < 8;j++)
                t[7 - j] =  /*<<marshal.js 259 49>>*/ reader.read8u();
               v[i] =  /*<<marshal.js 260 19>>*/ caml_float_of_bytes(t)}
              /*<<marshal.js 262 10>>*/ return v;
            case 15:
              /*<<marshal.js 264 10>>*/ var
               /*<<marshal.js 264 18>>*/ len=
                /*<<marshal.js 264 20>>*/ reader.read32u(),
               /*<<marshal.js 265 16>>*/ v=new Array(len + 1);
             v[0] = 254;
              /*<<marshal.js 264 10>>*/  /*<<marshal.js 267 16>>*/ var
              t=
               new Array(8);
              /*<<marshal.js 268 10>>*/ for
              ( /*<<marshal.js 268 21>>*/ var i=1;i <= len;i++)
               /*<<marshal.js 268 39>>*/ { /*<<marshal.js 269 12>>*/ for
                ( /*<<marshal.js 269 23>>*/ var j=0;j < 8;j++)
                t[j] =  /*<<marshal.js 269 45>>*/ reader.read8u();
               v[i] =  /*<<marshal.js 270 20>>*/ caml_float_of_bytes(t)}
              /*<<marshal.js 272 10>>*/ return v;
            case 16:
            case 17:
              /*<<marshal.js 275 10>>*/ caml_failwith
              ("input_value: code pointer");
              /*<<marshal.js 276 10>>*/ break;
            case 18:
              /*<<marshal.js 278 10>>*/ var c, /*<<marshal.js 278 19>>*/ s="";
              /*<<marshal.js 279 10>>*/ while
              ((c =  /*<<marshal.js 279 22>>*/ reader.read8u()) != 0)
              s +=  /*<<marshal.js 279 51>>*/ String.fromCharCode(c);
              /*<<marshal.js 280 10>>*/ switch(s)
              {case "_j":
                 /*<<marshal.js 283 12>>*/  /*<<marshal.js 283 18>>*/ var
                 t=
                  new Array(8);
                 /*<<marshal.js 284 12>>*/ for
                 ( /*<<marshal.js 284 23>>*/ var j=0;j < 8;j++)
                 t[j] =  /*<<marshal.js 284 45>>*/ reader.read8u();
                 /*<<marshal.js 283 12>>*/  /*<<marshal.js 285 18>>*/ var
                 v=
                   /*<<marshal.js 285 20>>*/ caml_int64_of_bytes(t);
                 /*<<marshal.js 286 12>>*/ if(intern_obj_table)
                 intern_obj_table[obj_counter++] = v;
                 /*<<marshal.js 287 12>>*/ return v;
               case "_i":
                 /*<<marshal.js 290 12>>*/  /*<<marshal.js 290 18>>*/ var
                 v=
                   /*<<marshal.js 290 20>>*/ reader.read32s();
                 /*<<marshal.js 291 12>>*/ if(intern_obj_table)
                 intern_obj_table[obj_counter++] = v;
                 /*<<marshal.js 292 12>>*/ return v;
               case "_n":
                 /*<<marshal.js 295 12>>*/ switch
                 ( /*<<marshal.js 295 20>>*/ reader.read8u())
                 {case 1:
                    /*<<marshal.js 297 14>>*/  /*<<marshal.js 297 20>>*/ var
                    v=
                      /*<<marshal.js 297 22>>*/ reader.read32s();
                    /*<<marshal.js 298 14>>*/ if(intern_obj_table)
                    intern_obj_table[obj_counter++] = v;
                    /*<<marshal.js 299 14>>*/ return v;
                  case 2:
                    /*<<marshal.js 301 14>>*/ caml_failwith
                    ("input_value: native integer value too large");
                  default:
                    /*<<marshal.js 303 14>>*/ caml_failwith
                    ("input_value: ill-formed native integer")}
               default:
                 /*<<marshal.js 306 12>>*/ caml_failwith
                 ("input_value: unknown custom block identifier")}
            default:
              /*<<marshal.js 309 10>>*/ caml_failwith
              ("input_value: ill-formed message")} /*<<marshal.js 313 2>>*/ }
       /*<<marshal.js 314 2>>*/  /*<<marshal.js 314 10>>*/ var
       res=
         /*<<marshal.js 314 12>>*/ intern_rec();
       /*<<marshal.js 315 2>>*/ while(stack.length > 0)
        /*<<marshal.js 315 27>>*/ { /*<<marshal.js 316 4>>*/ var
          /*<<marshal.js 316 13>>*/ size=
           /*<<marshal.js 316 15>>*/ stack.pop(),
          /*<<marshal.js 317 10>>*/ v= /*<<marshal.js 317 12>>*/ stack.pop(),
          /*<<marshal.js 318 10>>*/ d=v.length;
         /*<<marshal.js 319 4>>*/ if(d < size)
          /*<<marshal.js 319 18>>*/ stack.push(v,size);
        v[d] =  /*<<marshal.js 320 11>>*/ intern_rec()}
       /*<<marshal.js 322 2>>*/ if(typeof ofs != "number")ofs[0] = reader.i;
       /*<<marshal.js 323 2>>*/ return res /*<<marshal.js 324 0>>*/ }
     /*<<bigarray.js 624 0>>*/ function caml_ba_slice(ba,vind)
     { /*<<bigarray.js 625 4>>*/ return  /*<<bigarray.js 625 11>>*/ ba.slice
              ( /*<<bigarray.js 625 20>>*/ caml_js_from_array(vind)) /*<<bigarray.js 626 0>>*/ }
     /*<<stdlib.js 197 0>>*/ function caml_raise_zero_divide()
     { /*<<stdlib.js 198 2>>*/ caml_raise_constant
       (caml_global_data.Division_by_zero) /*<<stdlib.js 199 0>>*/ }
     /*<<int64.js 215 0>>*/ function caml_int64_div(x,y)
     { /*<<int64.js 217 2>>*/ if
       ( /*<<int64.js 217 6>>*/ caml_int64_is_zero(y))
        /*<<int64.js 217 30>>*/ caml_raise_zero_divide();
       /*<<int64.js 218 2>>*/  /*<<int64.js 218 11>>*/ var sign=x[3] ^ y[3];
       /*<<int64.js 219 2>>*/ if(x[3] & 32768)
       x =  /*<<int64.js 219 25>>*/ caml_int64_neg(x);
       /*<<int64.js 220 2>>*/ if(y[3] & 32768)
       y =  /*<<int64.js 220 25>>*/ caml_int64_neg(y);
       /*<<int64.js 218 2>>*/  /*<<int64.js 221 8>>*/ var
       q=
         /*<<int64.js 221 10>>*/ caml_int64_udivmod(x,y)[1];
       /*<<int64.js 222 2>>*/ if(sign & 32768)
       q =  /*<<int64.js 222 25>>*/ caml_int64_neg(q);
       /*<<int64.js 223 2>>*/ return q /*<<int64.js 224 0>>*/ }
     /*<<bigstring.js 87 0>>*/ function bigstring_find(bs,chr,pos,len)
     { /*<<bigstring.js 88 2>>*/ while(len > 0)
        /*<<bigstring.js 88 16>>*/ { /*<<bigstring.js 89 4>>*/ if
         ( /*<<bigstring.js 89 7>>*/ caml_ba_get_1(bs,pos) == chr)
          /*<<bigstring.js 89 37>>*/ return pos;
        pos++;
        len--}
       /*<<bigstring.js 93 2>>*/ return - 1 /*<<bigstring.js 94 0>>*/ }
     /*<<jslib.js 55 0>>*/ function caml_js_html_entities(s)
     { /*<<jslib.js 56 4>>*/ var
       str,
        /*<<jslib.js 56 18>>*/ temp=
         /*<<jslib.js 56 20>>*/ document.createElement("p");
      temp.innerHTML = s;
      str = temp.textContent || temp.innerText;
      temp = null;
       /*<<jslib.js 60 4>>*/ return str /*<<jslib.js 61 0>>*/ }
     /*<<int64.js 257 0>>*/ function caml_int64_of_float(x)
     { /*<<int64.js 258 2>>*/ if(x < 0)
       x =  /*<<int64.js 258 17>>*/ Math.ceil(x);
       /*<<int64.js 259 2>>*/ return [255,
              x & 16777215,
               /*<<int64.js 261 10>>*/ Math.floor(x * caml_int64_offset)
              &
              16777215,
               /*<<int64.js 262 10>>*/ Math.floor
               (x * caml_int64_offset * caml_int64_offset)
              &
              65535] /*<<int64.js 263 0>>*/ }
     /*<<io.js 181 0>>*/ function caml_ml_channel_size_64(chanid)
     { /*<<io.js 182 2>>*/  /*<<io.js 182 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 183 2>>*/ return  /*<<io.js 183 9>>*/ caml_int64_of_float
              ( /*<<io.js 183 29>>*/ chan.file.length()) /*<<io.js 184 0>>*/ }
     /*<<bigarray.js 596 0>>*/ function caml_ba_set_2(ba,i0,i1,v)
     { /*<<bigarray.js 597 4>>*/ return  /*<<bigarray.js 597 11>>*/ ba.set
              ([i0,i1],v) /*<<bigarray.js 598 0>>*/ }
     /*<<mlString.js 234 0>>*/ function caml_string_unsafe_set(s,i,c)
     { /*<<mlString.js 235 4>>*/ return  /*<<mlString.js 235 11>>*/ caml_bytes_unsafe_set
              (s,i,c) /*<<mlString.js 236 0>>*/ }
     /*<<internalMod.js 22 0>>*/ function caml_CamlinternalMod_init_mod
     (loc,shape)
     { /*<<internalMod.js 23 2>>*/ function undef_module(_x)
       { /*<<internalMod.js 24 4>>*/ caml_raise_with_arg
         (caml_global_data.Undefined_recursive_module,loc) /*<<internalMod.js 25 2>>*/ }
       /*<<internalMod.js 26 2>>*/ function loop(shape,struct,idx)
       { /*<<internalMod.js 27 4>>*/ if(typeof shape === "number")
          /*<<internalMod.js 28 6>>*/ switch(shape)
          {case 0:
            struct[idx] = {fun:undef_module};
             /*<<internalMod.js 31 8>>*/ break;
           case 1:
            struct[idx] = [246,undef_module];
             /*<<internalMod.js 34 8>>*/ break;
           default:struct[idx] = []}
        else
          /*<<internalMod.js 39 6>>*/ switch(shape[0])
          {case 0:
            struct[idx] = [0];
             /*<<internalMod.js 42 8>>*/ for
             ( /*<<internalMod.js 42 17>>*/ var i=1;i < shape[1].length;i++)
              /*<<internalMod.js 43 10>>*/ loop(shape[1][i],struct[idx],i);
             /*<<internalMod.js 44 8>>*/ break;
           default:struct[idx] = shape[1]} /*<<internalMod.js 48 2>>*/ }
       /*<<internalMod.js 49 2>>*/  /*<<internalMod.js 49 10>>*/ var res=[];
       /*<<internalMod.js 50 2>>*/ loop(shape,res,0);
       /*<<internalMod.js 51 2>>*/ return res[0] /*<<internalMod.js 52 0>>*/ }
     /*<<jslib_js_of_ocaml.js 179 0>>*/ function caml_js_eval_string(s)
     { /*<<jslib_js_of_ocaml.js 179 34>>*/ return  /*<<jslib_js_of_ocaml.js 179 41>>*/ eval
              ( /*<<jslib_js_of_ocaml.js 179 46>>*/ s.toString()) /*<<jslib_js_of_ocaml.js 179 60>>*/ }
     /*<<mlString.js 481 0>>*/ function caml_bytes_compare(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 482 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 483 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 484 2>>*/ return s1.c < s2.c?- 1:s1.c > s2.c?1:0 /*<<mlString.js 485 0>>*/ }
     /*<<marshal.js 328 0>>*/ function caml_marshal_data_size(s,ofs)
     { /*<<marshal.js 329 2>>*/ function get32(s,i)
       { /*<<marshal.js 330 4>>*/ return  /*<<marshal.js 330 12>>*/ caml_bytes_unsafe_get
                (s,i)
               <<
               24
               |
                /*<<marshal.js 331 12>>*/ caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
                /*<<marshal.js 332 12>>*/ caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
                /*<<marshal.js 333 12>>*/ caml_bytes_unsafe_get(s,i + 3) /*<<marshal.js 334 2>>*/ }
       /*<<marshal.js 335 2>>*/ if
       ( /*<<marshal.js 335 6>>*/ get32(s,ofs) != (2224400062 | 0))
        /*<<marshal.js 336 4>>*/ caml_failwith
        ("Marshal.data_size: bad object");
       /*<<marshal.js 337 2>>*/ return  /*<<marshal.js 337 10>>*/ get32
              (s,ofs + 4) /*<<marshal.js 338 0>>*/ }
     /*<<marshal.js 50 0>>*/ function MlBytesReader(s,i)
     {this.s =  /*<<marshal.js 50 41>>*/ caml_jsbytes_of_string(s);
      this.i = i /*<<marshal.js 50 80>>*/ }
    MlBytesReader.prototype
    =
    {read8u:
     function()
      { /*<<marshal.js 52 23>>*/ return  /*<<marshal.js 52 30>>*/ this.s.charCodeAt
               (this.i++) /*<<marshal.js 52 9>>*/ },
     read8s:
     function()
      { /*<<marshal.js 53 23>>*/ return  /*<<marshal.js 53 30>>*/ this.s.charCodeAt
               (this.i++)
              <<
              24
              >>
              24 /*<<marshal.js 53 9>>*/ },
     read16u:
     function()
      { /*<<marshal.js 55 4>>*/ var
         /*<<marshal.js 55 10>>*/ s=this.s,
         /*<<marshal.js 55 22>>*/ i=this.i;
       this.i = i + 2;
        /*<<marshal.js 57 4>>*/ return  /*<<marshal.js 57 12>>*/ s.charCodeAt
               (i)
              <<
              8
              |
               /*<<marshal.js 57 36>>*/ s.charCodeAt(i + 1) /*<<marshal.js 54 10>>*/ },
     read16s:
     function()
      { /*<<marshal.js 60 4>>*/ var
         /*<<marshal.js 60 10>>*/ s=this.s,
         /*<<marshal.js 60 22>>*/ i=this.i;
       this.i = i + 2;
        /*<<marshal.js 62 4>>*/ return  /*<<marshal.js 62 12>>*/ s.charCodeAt
               (i)
              <<
              24
              >>
              16
              |
               /*<<marshal.js 62 43>>*/ s.charCodeAt(i + 1) /*<<marshal.js 59 10>>*/ },
     read32u:
     function()
      { /*<<marshal.js 65 4>>*/ var
         /*<<marshal.js 65 10>>*/ s=this.s,
         /*<<marshal.js 65 22>>*/ i=this.i;
       this.i = i + 4;
        /*<<marshal.js 67 4>>*/ return ( /*<<marshal.js 67 13>>*/ s.charCodeAt
                (i)
               <<
               24
               |
                /*<<marshal.js 67 39>>*/ s.charCodeAt(i + 1)
               <<
               16
               |
                /*<<marshal.js 68 13>>*/ s.charCodeAt(i + 2)
               <<
               8
               |
                /*<<marshal.js 68 39>>*/ s.charCodeAt(i + 3))
              >>>
              0 /*<<marshal.js 64 10>>*/ },
     read32s:
     function()
      { /*<<marshal.js 71 4>>*/ var
         /*<<marshal.js 71 10>>*/ s=this.s,
         /*<<marshal.js 71 22>>*/ i=this.i;
       this.i = i + 4;
        /*<<marshal.js 73 4>>*/ return  /*<<marshal.js 73 12>>*/ s.charCodeAt
               (i)
              <<
              24
              |
               /*<<marshal.js 73 38>>*/ s.charCodeAt(i + 1)
              <<
              16
              |
               /*<<marshal.js 74 7>>*/ s.charCodeAt(i + 2)
              <<
              8
              |
               /*<<marshal.js 74 33>>*/ s.charCodeAt(i + 3) /*<<marshal.js 70 10>>*/ },
     readstr:
     function(len)
      { /*<<marshal.js 77 4>>*/  /*<<marshal.js 77 10>>*/ var i=this.i;
       this.i = i + len;
        /*<<marshal.js 79 4>>*/ return  /*<<marshal.js 79 11>>*/ caml_new_string
               ( /*<<marshal.js 79 27>>*/ this.s.substring(i,i + len)) /*<<marshal.js 76 10>>*/ }};
     /*<<marshal.js 132 0>>*/ function caml_input_value_from_string(s,ofs)
     { /*<<marshal.js 133 2>>*/  /*<<marshal.js 133 13>>*/ var
       reader=
        new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
       /*<<marshal.js 134 2>>*/ return  /*<<marshal.js 134 9>>*/ caml_input_value_from_reader
              (reader,ofs) /*<<marshal.js 135 0>>*/ }
     /*<<io.js 234 0>>*/ function caml_input_value(chanid)
     { /*<<io.js 235 2>>*/ var
        /*<<io.js 235 11>>*/ chan=caml_ml_channels[chanid],
        /*<<io.js 237 10>>*/ buf= /*<<io.js 237 12>>*/ caml_create_bytes(8);
       /*<<io.js 238 2>>*/ chan.file.read(chan.offset,buf,0,8);
       /*<<io.js 235 2>>*/ var
        /*<<io.js 241 10>>*/ len=
         /*<<io.js 241 12>>*/ caml_marshal_data_size(buf,0)
        +
        20,
        /*<<io.js 243 10>>*/ buf= /*<<io.js 243 12>>*/ caml_create_bytes(len);
       /*<<io.js 244 2>>*/ chan.file.read(chan.offset,buf,0,len);
       /*<<io.js 235 2>>*/ var
        /*<<io.js 246 13>>*/ offset=[0],
        /*<<io.js 247 10>>*/ res=
         /*<<io.js 247 12>>*/ caml_input_value_from_string(buf,offset);
      chan.offset = chan.offset + offset[0];
       /*<<io.js 249 2>>*/ return res /*<<io.js 250 0>>*/ }
     /*<<bigarray.js 471 0>>*/ function caml_ba_kind(ba)
     { /*<<bigarray.js 472 4>>*/ return ba.kind /*<<bigarray.js 473 0>>*/ }
     /*<<jslib_js_of_ocaml.js 57 0>>*/ function caml_js_fun_call(f,a)
     { /*<<jslib_js_of_ocaml.js 58 2>>*/ switch(a.length)
       {case 1:
          /*<<jslib_js_of_ocaml.js 59 10>>*/ return  /*<<jslib_js_of_ocaml.js 59 17>>*/ f
                 ();
        case 2:
          /*<<jslib_js_of_ocaml.js 60 10>>*/ return  /*<<jslib_js_of_ocaml.js 60 17>>*/ f
                 (a[1]);
        case 3:
          /*<<jslib_js_of_ocaml.js 61 10>>*/ return  /*<<jslib_js_of_ocaml.js 61 17>>*/ f
                 (a[1],a[2]);
        case 4:
          /*<<jslib_js_of_ocaml.js 62 10>>*/ return  /*<<jslib_js_of_ocaml.js 62 17>>*/ f
                 (a[1],a[2],a[3]);
        case 5:
          /*<<jslib_js_of_ocaml.js 63 10>>*/ return  /*<<jslib_js_of_ocaml.js 63 17>>*/ f
                 (a[1],a[2],a[3],a[4]);
        case 6:
          /*<<jslib_js_of_ocaml.js 64 10>>*/ return  /*<<jslib_js_of_ocaml.js 64 17>>*/ f
                 (a[1],a[2],a[3],a[4],a[5]);
        case 7:
          /*<<jslib_js_of_ocaml.js 65 10>>*/ return  /*<<jslib_js_of_ocaml.js 65 17>>*/ f
                 (a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:
          /*<<jslib_js_of_ocaml.js 66 10>>*/ return  /*<<jslib_js_of_ocaml.js 66 17>>*/ f
                 (a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
       /*<<jslib_js_of_ocaml.js 68 2>>*/ return  /*<<jslib_js_of_ocaml.js 68 9>>*/ f.apply
              (null, /*<<jslib_js_of_ocaml.js 68 23>>*/ caml_js_from_array(a)) /*<<jslib_js_of_ocaml.js 69 0>>*/ }
     /*<<bigstring.js 138 0>>*/ function bigstring_marshal_blit_stub
     (s,ofs,len,v,_fl)
     { /*<<bigstring.js 140 2>>*/  /*<<bigstring.js 140 8>>*/ var
       t=
         /*<<bigstring.js 140 10>>*/ caml_output_val(v);
       /*<<bigstring.js 141 2>>*/ if(t.length > len)
        /*<<bigstring.js 141 22>>*/ caml_failwith
        ("Marshal.to_buffer: buffer overflow");
       /*<<bigstring.js 142 2>>*/ for
       ( /*<<bigstring.js 142 12>>*/ var i=0;i < t.length;i++)
        /*<<bigstring.js 142 35>>*/  /*<<bigstring.js 143 4>>*/ caml_ba_set_1
        (s,i + ofs,t[i]);
       /*<<bigstring.js 145 2>>*/ return t.length /*<<bigstring.js 146 0>>*/ }
     /*<<jslib.js 23 0>>*/ function caml_js_pure_expr(f)
     { /*<<jslib.js 23 33>>*/ return  /*<<jslib.js 23 40>>*/ f() /*<<jslib.js 23 45>>*/ }
     /*<<stdlib.js 1078 0>>*/ function caml_sys_exit(code)
     { /*<<stdlib.js 1079 2>>*/  /*<<stdlib.js 1079 8>>*/ var
       g=
        joo_global_object;
       /*<<stdlib.js 1080 2>>*/ if(g.quit)
        /*<<stdlib.js 1080 13>>*/ g.quit(code);
       /*<<stdlib.js 1082 2>>*/ if(g.process && g.process.exit)
        /*<<stdlib.js 1083 4>>*/ g.process.exit(code);
       /*<<stdlib.js 1084 2>>*/ caml_invalid_argument
       ("Function 'exit' not implemented") /*<<stdlib.js 1085 0>>*/ }
     /*<<io.js 222 0>>*/ function caml_ml_input(chanid,s,i,l)
     { /*<<io.js 223 2>>*/ var
        /*<<io.js 223 11>>*/ chan=caml_ml_channels[chanid],
        /*<<io.js 224 9>>*/ l2=
         /*<<io.js 224 11>>*/ chan.file.length()
        -
        chan.offset;
       /*<<io.js 225 2>>*/ if(l2 == 0 && chan.refill != null)
       l2 =  /*<<io.js 225 43>>*/ caml_ml_refill_input(chan);
       /*<<io.js 226 2>>*/ if(l2 < l)l = l2;
       /*<<io.js 227 2>>*/ chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
       /*<<io.js 229 2>>*/ return l /*<<io.js 230 0>>*/ }
     /*<<bigarray.js 630 0>>*/ function caml_ba_reshape(ba,vind)
     { /*<<bigarray.js 631 4>>*/ return  /*<<bigarray.js 631 11>>*/ ba.reshape
              ( /*<<bigarray.js 631 22>>*/ caml_js_from_array(vind)) /*<<bigarray.js 632 0>>*/ }
     /*<<ieee_754.js 65 0>>*/ function caml_int32_bits_of_float(x)
     { /*<<ieee_754.js 66 2>>*/  /*<<ieee_754.js 66 15>>*/ var
       float32a=
        new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
       /*<<ieee_754.js 66 2>>*/  /*<<ieee_754.js 68 13>>*/ var
       int32a=
        new (joo_global_object.Int32Array)(float32a.buffer);
       /*<<ieee_754.js 69 2>>*/ return int32a[0] | 0 /*<<ieee_754.js 70 0>>*/ }
     /*<<bigstring.js 150 0>>*/ function caml_hash_mix_bigstring(h,bs)
     { /*<<bigstring.js 151 4>>*/ return  /*<<bigstring.js 151 11>>*/ caml_hash_mix_string_arr
              (h,bs.data) /*<<bigstring.js 152 0>>*/ }
     /*<<stdlib.js 1119 0>>*/ function caml_set_oo_id(b)
     {b[2] = caml_oo_last_id++;
       /*<<stdlib.js 1121 2>>*/ return b /*<<stdlib.js 1122 0>>*/ }
     /*<<stdlib.js 1049 0>>*/ function caml_record_backtrace()
     { /*<<stdlib.js 1049 36>>*/ return 0 /*<<stdlib.js 1049 46>>*/ }
     /*<<stdlib.js 103 0>>*/ function caml_get_global_data()
     { /*<<stdlib.js 103 35>>*/ return caml_global_data /*<<stdlib.js 103 60>>*/ }
     /*<<unix.js 13 0>>*/ function unix_gmtime(t)
     { /*<<unix.js 14 2>>*/ var
        /*<<unix.js 14 8>>*/ d=new Date(t * 1e3),
        /*<<unix.js 15 19>>*/ januaryfirst=
        new
         Date
         ( /*<<unix.js 15 30>>*/ Date.UTC
           ( /*<<unix.js 15 39>>*/ d.getUTCFullYear(),0,1)),
        /*<<unix.js 16 10>>*/ doy=
         /*<<unix.js 16 12>>*/ Math.floor((d - januaryfirst) / 864e5);
       /*<<unix.js 17 2>>*/ return [0,
               /*<<unix.js 17 13>>*/ d.getUTCSeconds(),
               /*<<unix.js 17 32>>*/ d.getUTCMinutes(),
               /*<<unix.js 17 51>>*/ d.getUTCHours(),
               /*<<unix.js 18 10>>*/ d.getUTCDate(),
               /*<<unix.js 18 26>>*/ d.getUTCMonth(),
               /*<<unix.js 18 43>>*/ d.getUTCFullYear() - 1900,
               /*<<unix.js 19 10>>*/ d.getUTCDay(),
              doy,
              false | 0] /*<<unix.js 21 0>>*/ }
     /*<<bigarray.js 512 0>>*/ function caml_ba_uint8_get16(ba,i0)
     { /*<<bigarray.js 513 4>>*/ var
        /*<<bigarray.js 513 11>>*/ b1= /*<<bigarray.js 513 13>>*/ ba.get1(i0),
        /*<<bigarray.js 514 11>>*/ b2=
         /*<<bigarray.js 514 13>>*/ ba.get1(i0 + 1)
        <<
        8;
       /*<<bigarray.js 515 4>>*/ return b1 | b2 /*<<bigarray.js 516 0>>*/ }
     /*<<int64.js 136 0>>*/ function caml_int64_shift_right_unsigned(x,s)
     {s = s & 63;
       /*<<int64.js 138 2>>*/ if(s == 0) /*<<int64.js 138 14>>*/ return x;
       /*<<int64.js 139 2>>*/ if(s < 24)
        /*<<int64.js 140 4>>*/ return [255,
               (x[1] >> s | x[2] << 24 - s) & 16777215,
               (x[2] >> s | x[3] << 24 - s) & 16777215,
               x[3] >> s];
       /*<<int64.js 144 2>>*/ if(s < 48)
        /*<<int64.js 145 4>>*/ return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 16777215,
               x[3] >> s - 24,
               0];
       /*<<int64.js 149 2>>*/ return [255,x[3] >> s - 48,0,0] /*<<int64.js 150 0>>*/ }
     /*<<stdlib.js 913 0>>*/ function caml_sys_const_backend_type()
     { /*<<stdlib.js 914 2>>*/ return [0,
               /*<<stdlib.js 914 13>>*/ caml_new_string("js_of_ocaml")] /*<<stdlib.js 915 0>>*/ }
     /*<<stdlib.js 907 0>>*/ function caml_sys_get_config()
     { /*<<stdlib.js 908 2>>*/ return [0,
               /*<<stdlib.js 908 13>>*/ caml_new_string("Unix"),
              32,
              0] /*<<stdlib.js 909 0>>*/ }
     /*<<stdlib.js 416 0>>*/ function caml_compare(a,b)
     { /*<<stdlib.js 416 31>>*/ return  /*<<stdlib.js 416 38>>*/ caml_compare_val
              (a,b,true) /*<<stdlib.js 416 69>>*/ }
     /*<<unix.js 8 0>>*/ function unix_time()
     { /*<<unix.js 9 2>>*/ return  /*<<unix.js 9 9>>*/ Math.floor
              ( /*<<unix.js 9 20>>*/ unix_gettimeofday()) /*<<unix.js 10 0>>*/ }
     /*<<io.js 101 0>>*/ function caml_ml_out_channels_list()
     { /*<<io.js 102 2>>*/  /*<<io.js 102 8>>*/ var l=0;
       /*<<io.js 103 2>>*/ for
       ( /*<<io.js 103 12>>*/ var c=0;c < caml_ml_channels.length;c++)
        /*<<io.js 103 50>>*/ if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
       /*<<io.js 107 2>>*/ return l /*<<io.js 108 0>>*/ }
     /*<<bigstring.js 43 0>>*/  /*<<bigstring.js 43 41>>*/ var
     bigstring_blit_bigstring_string_stub=
      bigstring_blit_bigstring_bytes_stub;
     /*<<stdlib.js 1126 0>>*/ function caml_fresh_oo_id()
     { /*<<stdlib.js 1127 2>>*/ return caml_oo_last_id++ /*<<stdlib.js 1128 0>>*/ }
     /*<<int64.js 251 0>>*/ function caml_int64_to_float(x)
     { /*<<int64.js 252 2>>*/ return (x[3] << 16)
             *
              /*<<int64.js 252 25>>*/ Math.pow(2,32)
             +
             x[2]
             *
              /*<<int64.js 252 50>>*/ Math.pow(2,24)
             +
             x[1] /*<<int64.js 253 0>>*/ }
     /*<<bigstring.js 103 0>>*/ function bigstring_of_array_buffer(ab)
     { /*<<bigstring.js 104 2>>*/  /*<<bigstring.js 104 9>>*/ var
       ta=
        new (joo_global_object.Uint8Array)(ab);
       /*<<bigstring.js 105 2>>*/ return  /*<<bigstring.js 105 9>>*/ caml_ba_create_from
              (ta,null,0,12,0,[ta.length]) /*<<bigstring.js 106 0>>*/ }
     /*<<bigstring.js 10 0>>*/ function bigstring_destroy_stub(v_bstr)
     { /*<<bigstring.js 11 2>>*/ if(v_bstr.data2 != null)
        /*<<bigstring.js 11 28>>*/  /*<<bigstring.js 12 6>>*/ caml_invalid_argument
        ("bigstring_destroy: unsupported kind");
       /*<<bigstring.js 15 2>>*/ if
       ( /*<<bigstring.js 15 6>>*/ v_bstr.hasOwnProperty("__is_deallocated"))
        /*<<bigstring.js 15 49>>*/  /*<<bigstring.js 16 4>>*/ caml_invalid_argument
        ("bigstring_destroy: bigstring is already deallocated");
       /*<<bigstring.js 19 2>>*/ var
        /*<<bigstring.js 19 21>>*/ destroyed_data=
        new (v_bstr.data.__proto__.constructor)(0),
        /*<<bigstring.js 20 26>>*/ destroyed_bigstring=
         /*<<bigstring.js 21 6>>*/ caml_ba_create_from
         (destroyed_data,null,v_bstr.data_type,v_bstr.kind,v_bstr.layout,[0]);
      destroyed_bigstring.__is_deallocated = true;
       /*<<bigstring.js 26 2>>*/ Object.assign(v_bstr,destroyed_bigstring);
       /*<<bigstring.js 28 2>>*/ return 0 /*<<bigstring.js 29 0>>*/ }
     /*<<stdlib.js 1053 0>>*/ function caml_raw_backtrace_length()
     { /*<<stdlib.js 1053 39>>*/ return 0 /*<<stdlib.js 1053 49>>*/ }
     /*<<bigarray.js 519 0>>*/ function caml_ba_uint8_get32(ba,i0)
     { /*<<bigarray.js 520 4>>*/ var
        /*<<bigarray.js 520 11>>*/ b1= /*<<bigarray.js 520 13>>*/ ba.get1(i0),
        /*<<bigarray.js 521 11>>*/ b2=
         /*<<bigarray.js 521 13>>*/ ba.get1(i0 + 1)
        <<
        8,
        /*<<bigarray.js 522 11>>*/ b3=
         /*<<bigarray.js 522 13>>*/ ba.get1(i0 + 2)
        <<
        16,
        /*<<bigarray.js 523 11>>*/ b4=
         /*<<bigarray.js 523 13>>*/ ba.get1(i0 + 3)
        <<
        24;
       /*<<bigarray.js 524 4>>*/ return b1 | b2 | b3 | b4 /*<<bigarray.js 525 0>>*/ }
     /*<<bigstring.js 97 0>>*/ function bigstring_to_array_buffer(bs)
     { /*<<bigstring.js 98 2>>*/ return bs.data.buffer /*<<bigstring.js 99 0>>*/ }
     /*<<stdlib.js 276 0>>*/ function caml_mod(x,y)
     { /*<<stdlib.js 277 2>>*/ if(y == 0)
        /*<<stdlib.js 277 14>>*/ caml_raise_zero_divide();
       /*<<stdlib.js 278 2>>*/ return x % y /*<<stdlib.js 279 0>>*/ }
     /*<<stdlib.js 228 0>>*/ function caml_obj_block(tag,size)
     { /*<<stdlib.js 229 2>>*/  /*<<stdlib.js 229 8>>*/ var
       o=
        new Array(size + 1);
      o[0] = tag;
       /*<<stdlib.js 231 2>>*/ for
       ( /*<<stdlib.js 231 13>>*/ var i=1;i <= size;i++)
       o[i] = 0;
       /*<<stdlib.js 232 2>>*/ return o /*<<stdlib.js 233 0>>*/ }
     /*<<bigarray.js 32 0>>*/ function caml_ba_init()
     { /*<<bigarray.js 33 4>>*/ return 0 /*<<bigarray.js 34 0>>*/ }
     /*<<stdlib.js 1041 0>>*/ function caml_final_release()
     { /*<<stdlib.js 1041 33>>*/ return 0 /*<<stdlib.js 1041 43>>*/ }
     /*<<bigarray.js 507 0>>*/ function caml_ba_get_generic(ba,index)
     { /*<<bigarray.js 508 4>>*/ return  /*<<bigarray.js 508 11>>*/ ba.get
              ( /*<<bigarray.js 508 18>>*/ caml_js_from_array(index)) /*<<bigarray.js 509 0>>*/ }
     /*<<marshal.js 85 0>>*/ function BigStringReader(bs,i)
     {this.s = bs;this.i = i /*<<marshal.js 85 60>>*/ }
    BigStringReader.prototype
    =
    {read8u:
     function()
      { /*<<marshal.js 87 23>>*/ return  /*<<marshal.js 87 30>>*/ caml_ba_get_1
               (this.s,this.i++) /*<<marshal.js 87 9>>*/ },
     read8s:
     function()
      { /*<<marshal.js 88 23>>*/ return  /*<<marshal.js 88 30>>*/ caml_ba_get_1
               (this.s,this.i++)
              <<
              24
              >>
              24 /*<<marshal.js 88 9>>*/ },
     read16u:
     function()
      { /*<<marshal.js 90 4>>*/ var
         /*<<marshal.js 90 10>>*/ s=this.s,
         /*<<marshal.js 90 22>>*/ i=this.i;
       this.i = i + 2;
        /*<<marshal.js 92 4>>*/ return  /*<<marshal.js 92 12>>*/ caml_ba_get_1
               (s,i)
              <<
              8
              |
               /*<<marshal.js 92 39>>*/ caml_ba_get_1(s,i + 1) /*<<marshal.js 89 10>>*/ },
     read16s:
     function()
      { /*<<marshal.js 95 4>>*/ var
         /*<<marshal.js 95 10>>*/ s=this.s,
         /*<<marshal.js 95 22>>*/ i=this.i;
       this.i = i + 2;
        /*<<marshal.js 97 4>>*/ return  /*<<marshal.js 97 12>>*/ caml_ba_get_1
               (s,i)
              <<
              24
              >>
              16
              |
               /*<<marshal.js 97 46>>*/ caml_ba_get_1(s,i + 1) /*<<marshal.js 94 10>>*/ },
     read32u:
     function()
      { /*<<marshal.js 100 4>>*/ var
         /*<<marshal.js 100 10>>*/ s=this.s,
         /*<<marshal.js 100 22>>*/ i=this.i;
       this.i = i + 4;
        /*<<marshal.js 102 4>>*/ return ( /*<<marshal.js 102 13>>*/ caml_ba_get_1
                (s,i)
               <<
               24
               |
                /*<<marshal.js 102 44>>*/ caml_ba_get_1(s,i + 1)
               <<
               16
               |
                /*<<marshal.js 103 13>>*/ caml_ba_get_1(s,i + 2)
               <<
               8
               |
                /*<<marshal.js 103 43>>*/ caml_ba_get_1(s,i + 3))
              >>>
              0 /*<<marshal.js 99 10>>*/ },
     read32s:
     function()
      { /*<<marshal.js 106 4>>*/ var
         /*<<marshal.js 106 10>>*/ s=this.s,
         /*<<marshal.js 106 22>>*/ i=this.i;
       this.i = i + 4;
        /*<<marshal.js 108 4>>*/ return  /*<<marshal.js 108 12>>*/ caml_ba_get_1
               (s,i)
              <<
              24
              |
               /*<<marshal.js 108 43>>*/ caml_ba_get_1(s,i + 1)
              <<
              16
              |
               /*<<marshal.js 109 5>>*/ caml_ba_get_1(s,i + 2)
              <<
              8
              |
               /*<<marshal.js 109 35>>*/ caml_ba_get_1(s,i + 3) /*<<marshal.js 105 10>>*/ },
     readstr:
     function(len)
      { /*<<marshal.js 112 4>>*/ var
         /*<<marshal.js 112 10>>*/ i=this.i,
         /*<<marshal.js 113 12>>*/ arr=new Array(len);
        /*<<marshal.js 114 4>>*/ for
        ( /*<<marshal.js 114 14>>*/ var j=0;j < len;j++)
         /*<<marshal.js 114 32>>*/ arr[j]
        =
         /*<<marshal.js 115 15>>*/ caml_ba_get_1(this.s,i + j);
       this.i = i + len;
        /*<<marshal.js 118 4>>*/ return  /*<<marshal.js 118 11>>*/ caml_string_of_array
               (arr) /*<<marshal.js 111 10>>*/ }};
     /*<<stdlib.js 1045 0>>*/ function caml_get_exception_backtrace()
     { /*<<stdlib.js 1045 43>>*/ return 0 /*<<stdlib.js 1045 53>>*/ }
     /*<<stdlib.js 38 0>>*/ function raw_array_cons(a,x)
     { /*<<stdlib.js 39 2>>*/ var
        /*<<stdlib.js 39 8>>*/ l=a.length,
        /*<<stdlib.js 40 8>>*/ b=new Array(l + 1);
      b[0] = x;
       /*<<stdlib.js 42 2>>*/ for( /*<<stdlib.js 42 12>>*/ var i=1;i <= l;i++)
       b[i] = a[i - 1];
       /*<<stdlib.js 43 2>>*/ return b /*<<stdlib.js 44 0>>*/ }
     /*<<jslib_js_of_ocaml.js 38 0>>*/ function caml_js_to_array(a)
     { /*<<jslib_js_of_ocaml.js 38 31>>*/ return  /*<<jslib_js_of_ocaml.js 38 38>>*/ raw_array_cons
              (a,0) /*<<jslib_js_of_ocaml.js 38 59>>*/ }
     /*<<fs.js 96 0>>*/ function caml_mount_autoload(name,f)
     { /*<<fs.js 97 2>>*/ var
        /*<<fs.js 97 11>>*/ path= /*<<fs.js 97 13>>*/ caml_make_path(name),
        /*<<fs.js 98 11>>*/ name= /*<<fs.js 98 13>>*/ path.join("/") + "/";
       /*<<fs.js 99 2>>*/ jsoo_mount_point.push
       ({path:name,device:new MlFakeDevice(name,f)});
       /*<<fs.js 100 2>>*/ return 0 /*<<fs.js 101 0>>*/ }
     /*<<io.js 24 0>>*/ function caml_sys_close(fd)
     {delete caml_global_data.fds[fd];
       /*<<io.js 26 2>>*/ return 0 /*<<io.js 27 0>>*/ }
     /*<<stdlib.js 629 0>>*/ function caml_format_float(fmt,x)
     { /*<<stdlib.js 630 2>>*/ var
       s,
        /*<<stdlib.js 630 11>>*/ f=
         /*<<stdlib.js 630 13>>*/ caml_parse_format(fmt),
        /*<<stdlib.js 631 11>>*/ prec=f.prec < 0?6:f.prec;
       /*<<stdlib.js 632 2>>*/ if(x < 0 || x == 0 && 1 / x == - Infinity)
        /*<<stdlib.js 632 45>>*/ {f.sign = - 1;x = - x}
       /*<<stdlib.js 633 2>>*/ if( /*<<stdlib.js 633 6>>*/ isNaN(x))
        /*<<stdlib.js 633 16>>*/ {s = "nan";f.filler = " "}
      else
        /*<<stdlib.js 634 7>>*/ if(!  /*<<stdlib.js 634 12>>*/ isFinite(x))
         /*<<stdlib.js 634 25>>*/ {s = "inf";f.filler = " "}
       else
         /*<<stdlib.js 636 4>>*/ switch(f.conv)
         {case "e":
            /*<<stdlib.js 638 6>>*/ var
             /*<<stdlib.js 638 12>>*/ s=
              /*<<stdlib.js 638 14>>*/ x.toExponential(prec),
             /*<<stdlib.js 640 12>>*/ i=s.length;
            /*<<stdlib.js 641 6>>*/ if
            ( /*<<stdlib.js 641 10>>*/ s.charAt(i - 3) == "e")
            s
            =
             /*<<stdlib.js 642 12>>*/ s.slice(0,i - 1)
            +
            "0"
            +
             /*<<stdlib.js 642 39>>*/ s.slice(i - 1);
            /*<<stdlib.js 643 6>>*/ break;
          case "f":
           s =  /*<<stdlib.js 645 10>>*/ x.toFixed(prec);
            /*<<stdlib.js 645 27>>*/ break;
          case "g":
           prec = prec?prec:1;
           s =  /*<<stdlib.js 648 10>>*/ x.toExponential(prec - 1);
            /*<<stdlib.js 649 6>>*/ var
             /*<<stdlib.js 649 12>>*/ j=
              /*<<stdlib.js 649 14>>*/ s.indexOf("e"),
             /*<<stdlib.js 650 14>>*/ exp=
             +
              /*<<stdlib.js 650 17>>*/ s.slice(j + 1);
            /*<<stdlib.js 651 6>>*/ if
            (exp
             <
             -
             4
             ||
             x
             >=
             1e+21
             ||
              /*<<stdlib.js 651 35>>*/ x.toFixed(0).length
             >
             prec)
             /*<<stdlib.js 651 63>>*/ { /*<<stdlib.js 653 8>>*/  /*<<stdlib.js 653 14>>*/ var
              i=
               j - 1;
              /*<<stdlib.js 653 23>>*/ while
              ( /*<<stdlib.js 653 30>>*/ s.charAt(i) == "0")
              i--;
              /*<<stdlib.js 654 8>>*/ if
              ( /*<<stdlib.js 654 12>>*/ s.charAt(i) == ".")
              i--;
             s
             =
              /*<<stdlib.js 655 12>>*/ s.slice(0,i + 1)
             +
              /*<<stdlib.js 655 32>>*/ s.slice(j);
             i = s.length;
              /*<<stdlib.js 657 8>>*/ if
              ( /*<<stdlib.js 657 12>>*/ s.charAt(i - 3) == "e")
              s
              =
               /*<<stdlib.js 658 14>>*/ s.slice(0,i - 1)
              +
              "0"
              +
               /*<<stdlib.js 658 41>>*/ s.slice(i - 1);
              /*<<stdlib.js 659 8>>*/ break}
           else
             /*<<stdlib.js 660 13>>*/ { /*<<stdlib.js 661 8>>*/  /*<<stdlib.js 661 14>>*/ var
              p=
               prec;
              /*<<stdlib.js 662 8>>*/ if(exp < 0)
               /*<<stdlib.js 662 21>>*/ {p -= exp + 1;
               s =  /*<<stdlib.js 662 41>>*/ x.toFixed(p)}
             else
               /*<<stdlib.js 663 13>>*/ while
               (s
                =
                 /*<<stdlib.js 663 24>>*/ x.toFixed(p),
                s.length
                >
                prec
                +
                1)
               p--;
              /*<<stdlib.js 664 8>>*/ if(p)
               /*<<stdlib.js 664 15>>*/ { /*<<stdlib.js 666 10>>*/  /*<<stdlib.js 666 16>>*/ var
                i=
                 s.length - 1;
                /*<<stdlib.js 666 32>>*/ while
                ( /*<<stdlib.js 666 39>>*/ s.charAt(i) == "0")
                i--;
                /*<<stdlib.js 667 10>>*/ if
                ( /*<<stdlib.js 667 14>>*/ s.charAt(i) == ".")
                i--;
               s =  /*<<stdlib.js 668 14>>*/ s.slice(0,i + 1)}}
            /*<<stdlib.js 671 6>>*/ break
          }
       /*<<stdlib.js 673 2>>*/ return  /*<<stdlib.js 673 9>>*/ caml_finish_formatting
              (f,s) /*<<stdlib.js 674 0>>*/ }
     /*<<mlString.js 370 0>>*/ function caml_bytes_set64(s,i,i64)
     { /*<<mlString.js 371 2>>*/ if(i >>> 0 >= s.l + 7)
        /*<<mlString.js 371 26>>*/ caml_string_bound_error();
       /*<<mlString.js 372 2>>*/  /*<<mlString.js 372 8>>*/ var
       a=
         /*<<mlString.js 372 10>>*/ caml_int64_to_bytes(i64);
       /*<<mlString.js 373 2>>*/ for
       ( /*<<mlString.js 373 12>>*/ var j=0;j < 8;j++)
        /*<<mlString.js 373 29>>*/  /*<<mlString.js 374 4>>*/ caml_string_unsafe_set
        (s,i + 7 - j,a[j]);
       /*<<mlString.js 376 2>>*/ return 0 /*<<mlString.js 377 0>>*/ }
     /*<<mlString.js 331 0>>*/ function caml_bytes_set16(s,i,i16)
     { /*<<mlString.js 332 2>>*/ if(i >>> 0 >= s.l + 1)
        /*<<mlString.js 332 26>>*/ caml_string_bound_error();
       /*<<mlString.js 333 2>>*/ var
        /*<<mlString.js 333 9>>*/ b2=255 & i16 >> 8,
        /*<<mlString.js 334 9>>*/ b1=255 & i16;
       /*<<mlString.js 335 2>>*/ caml_string_unsafe_set(s,i + 0,b1);
       /*<<mlString.js 336 2>>*/ caml_string_unsafe_set(s,i + 1,b2);
       /*<<mlString.js 337 2>>*/ return 0 /*<<mlString.js 338 0>>*/ }
     /*<<mlString.js 342 0>>*/ function caml_string_set16(s,i,i16)
     { /*<<mlString.js 343 4>>*/ return  /*<<mlString.js 343 11>>*/ caml_bytes_set16
              (s,i,i16) /*<<mlString.js 344 0>>*/ }
     /*<<stdlib.js 1153 0>>*/ function caml_int64_bswap(x)
     { /*<<stdlib.js 1154 2>>*/ return [255,
              (x[3] & 65280) >> 8 | (x[3] & 255) << 8 | x[2] & 16711680,
              (x[2] & 65280) >> 8 | (x[2] & 255) << 8 | x[1] & 16711680,
              (x[1] & 65280) >> 8 | (x[1] & 255) << 8] /*<<stdlib.js 1164 0>>*/ }
     /*<<stdlib.js 269 0>>*/ function caml_div(x,y)
     { /*<<stdlib.js 270 2>>*/ if(y == 0)
        /*<<stdlib.js 270 14>>*/ caml_raise_zero_divide();
       /*<<stdlib.js 271 2>>*/ return x / y | 0 /*<<stdlib.js 272 0>>*/ }
     /*<<mlString.js 570 0>>*/ function caml_fill_bytes(s,i,l,c)
     { /*<<mlString.js 571 2>>*/ if(l > 0)
        /*<<mlString.js 571 13>>*/ if
        (i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
         /*<<mlString.js 572 77>>*/ if(c == 0)
          /*<<mlString.js 573 18>>*/ {s.c = "";s.t = 2}
        else
          /*<<mlString.js 576 13>>*/ {s.c
          =
           /*<<mlString.js 577 14>>*/ caml_str_repeat
           (l, /*<<mlString.js 577 34>>*/ String.fromCharCode(c));
          s.t = l == s.l?0:2}
       else
         /*<<mlString.js 580 11>>*/ { /*<<mlString.js 581 6>>*/ if(s.t != 4)
           /*<<mlString.js 581 32>>*/ caml_convert_string_to_array(s);
          /*<<mlString.js 582 6>>*/ for(l += i;i < l;i++)s.c[i] = c}
       /*<<mlString.js 585 2>>*/ return 0 /*<<mlString.js 586 0>>*/ }
     /*<<mlString.js 590 0>>*/  /*<<mlString.js 590 21>>*/ var
     caml_fill_string=
      caml_fill_bytes;
     /*<<mlString.js 531 0>>*/ function caml_string_lessthan(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 532 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 533 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 534 2>>*/ return s1.c < s2.c?1:0 /*<<mlString.js 535 0>>*/ }
     /*<<mlString.js 558 0>>*/ function caml_string_greaterthan(s1,s2)
     { /*<<mlString.js 559 2>>*/ return  /*<<mlString.js 559 9>>*/ caml_string_lessthan
              (s2,s1) /*<<mlString.js 560 0>>*/ }
     /*<<gc.js 6 0>>*/ function caml_gc_major()
     { /*<<gc.js 6 26>>*/ return 0 /*<<gc.js 6 34>>*/ }
     /*<<weak.js 143 0>>*/ function caml_ephe_get_data_copy(x)
     { /*<<weak.js 144 2>>*/ return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,
                 /*<<weak.js 147 15>>*/ caml_obj_dup(x[caml_ephe_data_offset])] /*<<weak.js 148 0>>*/ }
     /*<<lexing.js 20 0>>*/ function caml_lex_array(s)
     {s =  /*<<lexing.js 21 6>>*/ caml_jsbytes_of_string(s);
       /*<<lexing.js 22 2>>*/ var
        /*<<lexing.js 22 8>>*/ l=s.length / 2,
        /*<<lexing.js 23 8>>*/ a=new Array(l);
       /*<<lexing.js 24 2>>*/ for( /*<<lexing.js 24 13>>*/ var i=0;i < l;i++)
       a[i]
       =
       ( /*<<lexing.js 25 12>>*/ s.charCodeAt(2 * i)
        |
         /*<<lexing.js 25 35>>*/ s.charCodeAt(2 * i + 1)
        <<
        8)
       <<
       16
       >>
       16;
       /*<<lexing.js 26 2>>*/ return a /*<<lexing.js 27 0>>*/ }
     /*<<lexing.js 31 0>>*/ function caml_lex_engine(tbl,start_state,lexbuf)
     { /*<<lexing.js 32 2>>*/ var
        /*<<lexing.js 32 17>>*/ lex_buffer=2,
        /*<<lexing.js 33 21>>*/ lex_buffer_len=3,
        /*<<lexing.js 34 20>>*/ lex_start_pos=5,
        /*<<lexing.js 35 19>>*/ lex_curr_pos=6,
        /*<<lexing.js 36 19>>*/ lex_last_pos=7,
        /*<<lexing.js 37 22>>*/ lex_last_action=8,
        /*<<lexing.js 38 22>>*/ lex_eof_reached=9,
        /*<<lexing.js 39 15>>*/ lex_base=1,
        /*<<lexing.js 40 18>>*/ lex_backtrk=2,
        /*<<lexing.js 41 18>>*/ lex_default=3,
        /*<<lexing.js 42 16>>*/ lex_trans=4,
        /*<<lexing.js 43 16>>*/ lex_check=5;
       /*<<lexing.js 45 2>>*/ if(! tbl.lex_default)
        /*<<lexing.js 45 24>>*/ {tbl.lex_base
        =
         /*<<lexing.js 46 22>>*/ caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk
        =
         /*<<lexing.js 47 22>>*/ caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check
        =
         /*<<lexing.js 48 22>>*/ caml_lex_array(tbl[lex_check]);
        tbl.lex_trans
        =
         /*<<lexing.js 49 22>>*/ caml_lex_array(tbl[lex_trans]);
        tbl.lex_default
        =
         /*<<lexing.js 50 22>>*/ caml_lex_array(tbl[lex_default])}
       /*<<lexing.js 32 2>>*/ var
       c,
        /*<<lexing.js 53 15>>*/ state=start_state,
        /*<<lexing.js 55 13>>*/ buffer=
         /*<<lexing.js 55 15>>*/ caml_array_of_string(lexbuf[lex_buffer]);
       /*<<lexing.js 57 2>>*/ if(state >= 0)
        /*<<lexing.js 57 18>>*/ {lexbuf[lex_last_pos]
        =
        lexbuf[lex_start_pos]
        =
        lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
        /*<<lexing.js 61 9>>*/ state = - state - 1;
       /*<<lexing.js 65 2>>*/ for(;;)
        /*<<lexing.js 65 10>>*/ { /*<<lexing.js 67 4>>*/  /*<<lexing.js 67 13>>*/ var
         base=
          tbl.lex_base[state];
         /*<<lexing.js 68 4>>*/ if(base < 0)
          /*<<lexing.js 68 18>>*/ return - base - 1;
         /*<<lexing.js 67 4>>*/  /*<<lexing.js 70 16>>*/ var
         backtrk=
          tbl.lex_backtrk[state];
         /*<<lexing.js 71 4>>*/ if(backtrk >= 0)
          /*<<lexing.js 71 22>>*/ {lexbuf[lex_last_pos]
          =
          lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
         /*<<lexing.js 76 4>>*/ if
         (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
          /*<<lexing.js 76 55>>*/ if(lexbuf[lex_eof_reached] == 0)
           /*<<lexing.js 78 8>>*/ return - state - 1;
         else
          c = 256;
        else
          /*<<lexing.js 81 9>>*/ {c = buffer[lexbuf[lex_curr_pos]];
          lexbuf[lex_curr_pos]++}
         /*<<lexing.js 87 4>>*/ state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
         /*<<lexing.js 92 4>>*/ if(state < 0)
          /*<<lexing.js 92 19>>*/ {lexbuf[lex_curr_pos]
          =
          lexbuf[lex_last_pos];
           /*<<lexing.js 94 6>>*/ if(lexbuf[lex_last_action] == - 1)
            /*<<lexing.js 95 8>>*/ caml_failwith("lexing: empty token");
          else
            /*<<lexing.js 97 8>>*/ return lexbuf[lex_last_action]}
        else
          /*<<lexing.js 98 9>>*/ if(c == 256)lexbuf[lex_eof_reached] = 0} /*<<lexing.js 105 0>>*/ }
     /*<<stdlib.js 1090 0>>*/ function caml_sys_get_argv()
     { /*<<stdlib.js 1091 2>>*/ var
        /*<<stdlib.js 1091 8>>*/ g=joo_global_object,
        /*<<stdlib.js 1092 11>>*/ main="a.out",
        /*<<stdlib.js 1093 11>>*/ args=[];
       /*<<stdlib.js 1095 2>>*/ if
       (g.process && g.process.argv && g.process.argv.length > 1)
        /*<<stdlib.js 1097 35>>*/ { /*<<stdlib.js 1098 4>>*/  /*<<stdlib.js 1098 13>>*/ var
         argv=
          g.process.argv;
        main = argv[1];
        args
        =
         /*<<stdlib.js 1101 11>>*/ raw_array_sub(argv,2,argv.length - 2)}
       /*<<stdlib.js 1091 2>>*/ var
        /*<<stdlib.js 1104 8>>*/ p=
         /*<<stdlib.js 1104 10>>*/ caml_js_to_string(main),
        /*<<stdlib.js 1105 12>>*/ args2=[0,p];
       /*<<stdlib.js 1106 2>>*/ for
       ( /*<<stdlib.js 1106 12>>*/ var i=0;i < args.length;i++)
        /*<<stdlib.js 1107 4>>*/ args2.push
        ( /*<<stdlib.js 1107 15>>*/ caml_js_to_string(args[i]));
       /*<<stdlib.js 1108 2>>*/ return [0,p,args2] /*<<stdlib.js 1109 0>>*/ }
     /*<<jslib_js_of_ocaml.js 25 0>>*/ function caml_js_to_bool(x)
     { /*<<jslib_js_of_ocaml.js 25 30>>*/ return + x /*<<jslib_js_of_ocaml.js 25 41>>*/ }
     /*<<fs.js 151 0>>*/ function caml_sys_file_exists(name)
     { /*<<fs.js 152 2>>*/  /*<<fs.js 152 11>>*/ var
       root=
         /*<<fs.js 152 13>>*/ resolve_fs_device(name);
       /*<<fs.js 153 2>>*/ return  /*<<fs.js 153 9>>*/ root.device.exists
              (root.rest) /*<<fs.js 154 0>>*/ }
     /*<<weak.js 28 0>>*/  /*<<weak.js 28 25>>*/ var caml_ephe_key_offset=3;
     /*<<weak.js 52 0>>*/ function caml_weak_get(x,i)
     { /*<<weak.js 53 4>>*/ if(i < 0 || caml_ephe_key_offset + i >= x.length)
        /*<<weak.js 54 6>>*/ caml_invalid_argument("Weak.get_key");
       /*<<weak.js 55 4>>*/ return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i] /*<<weak.js 56 0>>*/ }
     /*<<weak.js 60 0>>*/ function caml_weak_get_copy(x,i)
     { /*<<weak.js 61 2>>*/ if(i < 0 || caml_ephe_key_offset + i >= x.length)
        /*<<weak.js 62 4>>*/ caml_invalid_argument("Weak.get_copy");
       /*<<weak.js 63 2>>*/  /*<<weak.js 63 8>>*/ var
       y=
         /*<<weak.js 63 10>>*/ caml_weak_get(x,i);
       /*<<weak.js 64 2>>*/ if(y === 0) /*<<weak.js 64 15>>*/ return y;
       /*<<weak.js 63 2>>*/  /*<<weak.js 65 8>>*/ var z=y[1];
       /*<<weak.js 66 2>>*/ if(z instanceof Array)
        /*<<weak.js 66 26>>*/ return [0,
                /*<<weak.js 66 37>>*/ caml_obj_dup(z)];
       /*<<weak.js 67 2>>*/ return y /*<<weak.js 68 0>>*/ }
     /*<<weak.js 103 0>>*/  /*<<weak.js 103 27>>*/ var
     caml_ephe_get_key_copy=
      caml_weak_get_copy;
     /*<<stdlib.js 1136 0>>*/ function caml_convert_raw_backtrace_slot()
     { /*<<stdlib.js 1137 2>>*/ caml_failwith
       ("caml_convert_raw_backtrace_slot") /*<<stdlib.js 1138 0>>*/ }
     /*<<stdlib.js 1055 0>>*/ function caml_raw_backtrace_next_slot()
     { /*<<stdlib.js 1055 42>>*/ return 0 /*<<stdlib.js 1055 51>>*/ }
     /*<<stdlib.js 970 0>>*/ function caml_array_sub(a,i,len)
     { /*<<stdlib.js 971 2>>*/  /*<<stdlib.js 971 9>>*/ var
       a2=
        new Array(len + 1);
      a2[0] = 0;
       /*<<stdlib.js 973 2>>*/ for
       (var  /*<<stdlib.js 973 13>>*/ i2=1, /*<<stdlib.js 973 20>>*/ i1=i + 1;
        i2
        <=
        len;
        i2++,
        i1++)
        /*<<stdlib.js 973 49>>*/ a2[i2] = a[i1];
       /*<<stdlib.js 976 2>>*/ return a2 /*<<stdlib.js 977 0>>*/ }
     /*<<stdlib.js 438 0>>*/ function caml_lessthan(x,y)
     { /*<<stdlib.js 438 32>>*/ return +
             ( /*<<stdlib.js 438 41>>*/ caml_compare_val(x,y,false) < 0) /*<<stdlib.js 438 75>>*/ }
     /*<<mlString.js 498 0>>*/ function caml_bytes_equal(s1,s2)
     { /*<<mlString.js 499 2>>*/ if(s1 === s2)
        /*<<mlString.js 499 16>>*/ return 1;
      s1.t
      &
      6
      &&
       /*<<mlString.js 500 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 501 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 502 2>>*/ return s1.c == s2.c?1:0 /*<<mlString.js 503 0>>*/ }
     /*<<stdlib.js 949 0>>*/ function caml_sys_const_ostype_cygwin()
     { /*<<stdlib.js 949 43>>*/ return 0 /*<<stdlib.js 949 53>>*/ }
     /*<<stdlib.js 96 0>>*/ function caml_register_global(n,v,name_opt)
     {caml_global_data[n + 1] = v;
       /*<<stdlib.js 98 2>>*/ if(name_opt)caml_global_data[name_opt] = v /*<<stdlib.js 99 0>>*/ }
     /*<<ieee_754.js 244 0>>*/ function caml_cosh_float(x)
     { /*<<ieee_754.js 244 31>>*/ return ( /*<<ieee_754.js 244 39>>*/ Math.exp
               (x)
              +
               /*<<ieee_754.js 244 53>>*/ Math.exp(- x))
             /
             2 /*<<ieee_754.js 244 72>>*/ }
     /*<<weak.js 71 0>>*/ function caml_weak_check(x,i)
     { /*<<weak.js 72 2>>*/ return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0 /*<<weak.js 76 0>>*/ }
     /*<<weak.js 107 0>>*/  /*<<weak.js 107 24>>*/ var
     caml_ephe_check_key=
      caml_weak_check;
     /*<<stdlib.js 750 0>>*/ function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h =  /*<<stdlib.js 752 6>>*/ caml_mul(h,2246822507 | 0);
      h ^= h >>> 13;
      h =  /*<<stdlib.js 754 6>>*/ caml_mul(h,3266489909 | 0);
      h ^= h >>> 16;
       /*<<stdlib.js 756 2>>*/ return h /*<<stdlib.js 757 0>>*/ }
     /*<<bigarray.js 578 0>>*/ function caml_ba_uint8_set64(ba,i0,v)
     { /*<<bigarray.js 579 4>>*/ ba.set1(i0,v[1] & 255);
       /*<<bigarray.js 580 4>>*/ ba.set1(i0 + 1,v[1] >> 8 & 255);
       /*<<bigarray.js 581 4>>*/ ba.set1(i0 + 2,v[1] >> 16);
       /*<<bigarray.js 582 4>>*/ ba.set1(i0 + 3,v[2] & 255);
       /*<<bigarray.js 583 4>>*/ ba.set1(i0 + 4,v[2] >> 8 & 255);
       /*<<bigarray.js 584 4>>*/ ba.set1(i0 + 5,v[2] >> 16);
       /*<<bigarray.js 585 4>>*/ ba.set1(i0 + 6,v[3] & 255);
       /*<<bigarray.js 586 4>>*/ ba.set1(i0 + 7,v[3] >> 8);
       /*<<bigarray.js 587 4>>*/ return 0 /*<<bigarray.js 588 0>>*/ }
     /*<<lexing.js 114 0>>*/ function caml_lex_run_mem(s,i,mem,curr_pos)
     { /*<<lexing.js 115 2>>*/ for(;;)
        /*<<lexing.js 115 11>>*/ { /*<<lexing.js 116 4>>*/  /*<<lexing.js 116 12>>*/ var
         dst=
           /*<<lexing.js 116 14>>*/ s.charCodeAt(i);
        i++;
         /*<<lexing.js 117 4>>*/ if(dst == 255)
          /*<<lexing.js 117 21>>*/ return;
         /*<<lexing.js 116 4>>*/  /*<<lexing.js 118 12>>*/ var
         src=
           /*<<lexing.js 118 14>>*/ s.charCodeAt(i);
        i++;
         /*<<lexing.js 119 4>>*/ mem[dst + 1]
        =
        src == 255?curr_pos:mem[src + 1]} /*<<lexing.js 124 0>>*/ }
     /*<<lexing.js 126 0>>*/ function caml_lex_run_tag(s,i,mem)
     { /*<<lexing.js 127 2>>*/ for(;;)
        /*<<lexing.js 127 11>>*/ { /*<<lexing.js 128 4>>*/  /*<<lexing.js 128 12>>*/ var
         dst=
           /*<<lexing.js 128 14>>*/ s.charCodeAt(i);
        i++;
         /*<<lexing.js 129 4>>*/ if(dst == 255)
          /*<<lexing.js 129 21>>*/ return;
         /*<<lexing.js 128 4>>*/  /*<<lexing.js 130 12>>*/ var
         src=
           /*<<lexing.js 130 14>>*/ s.charCodeAt(i);
        i++;
         /*<<lexing.js 131 4>>*/ mem[dst + 1] = src == 255?- 1:mem[src + 1]} /*<<lexing.js 136 0>>*/ }
     /*<<lexing.js 138 0>>*/ function caml_new_lex_engine
     (tbl,start_state,lexbuf)
     { /*<<lexing.js 139 2>>*/ var
        /*<<lexing.js 139 17>>*/ lex_buffer=2,
        /*<<lexing.js 140 21>>*/ lex_buffer_len=3,
        /*<<lexing.js 141 20>>*/ lex_start_pos=5,
        /*<<lexing.js 142 19>>*/ lex_curr_pos=6,
        /*<<lexing.js 143 19>>*/ lex_last_pos=7,
        /*<<lexing.js 144 22>>*/ lex_last_action=8,
        /*<<lexing.js 145 22>>*/ lex_eof_reached=9,
        /*<<lexing.js 146 14>>*/ lex_mem=10,
        /*<<lexing.js 147 15>>*/ lex_base=1,
        /*<<lexing.js 148 18>>*/ lex_backtrk=2,
        /*<<lexing.js 149 18>>*/ lex_default=3,
        /*<<lexing.js 150 16>>*/ lex_trans=4,
        /*<<lexing.js 151 16>>*/ lex_check=5,
        /*<<lexing.js 152 20>>*/ lex_base_code=6,
        /*<<lexing.js 153 23>>*/ lex_backtrk_code=7,
        /*<<lexing.js 154 23>>*/ lex_default_code=8,
        /*<<lexing.js 155 21>>*/ lex_trans_code=9,
        /*<<lexing.js 156 21>>*/ lex_check_code=10,
        /*<<lexing.js 157 15>>*/ lex_code=11;
       /*<<lexing.js 159 2>>*/ if(! tbl.lex_default)
        /*<<lexing.js 159 24>>*/ {tbl.lex_base
        =
         /*<<lexing.js 160 22>>*/ caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk
        =
         /*<<lexing.js 161 22>>*/ caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check
        =
         /*<<lexing.js 162 22>>*/ caml_lex_array(tbl[lex_check]);
        tbl.lex_trans
        =
         /*<<lexing.js 163 22>>*/ caml_lex_array(tbl[lex_trans]);
        tbl.lex_default
        =
         /*<<lexing.js 164 22>>*/ caml_lex_array(tbl[lex_default])}
       /*<<lexing.js 166 2>>*/ if(! tbl.lex_default_code)
        /*<<lexing.js 166 29>>*/ {tbl.lex_base_code
        =
         /*<<lexing.js 167 27>>*/ caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code
        =
         /*<<lexing.js 168 27>>*/ caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code
        =
         /*<<lexing.js 169 27>>*/ caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code
        =
         /*<<lexing.js 170 27>>*/ caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code
        =
         /*<<lexing.js 171 27>>*/ caml_lex_array(tbl[lex_default_code])}
       /*<<lexing.js 173 2>>*/ if(tbl.lex_code == null)
       tbl.lex_code
       =
        /*<<lexing.js 173 43>>*/ caml_jsbytes_of_string(tbl[lex_code]);
       /*<<lexing.js 139 2>>*/ var
       c,
        /*<<lexing.js 175 15>>*/ state=start_state,
        /*<<lexing.js 177 13>>*/ buffer=
         /*<<lexing.js 177 15>>*/ caml_array_of_string(lexbuf[lex_buffer]);
       /*<<lexing.js 179 2>>*/ if(state >= 0)
        /*<<lexing.js 179 18>>*/ {lexbuf[lex_last_pos]
        =
        lexbuf[lex_start_pos]
        =
        lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
        /*<<lexing.js 183 9>>*/ state = - state - 1;
       /*<<lexing.js 187 2>>*/ for(;;)
        /*<<lexing.js 187 10>>*/ { /*<<lexing.js 189 4>>*/  /*<<lexing.js 189 13>>*/ var
         base=
          tbl.lex_base[state];
         /*<<lexing.js 190 4>>*/ if(base < 0)
          /*<<lexing.js 190 18>>*/ { /*<<lexing.js 191 6>>*/  /*<<lexing.js 191 17>>*/ var
           pc_off=
            tbl.lex_base_code[state];
           /*<<lexing.js 192 6>>*/ caml_lex_run_tag
           (tbl.lex_code,pc_off,lexbuf[lex_mem]);
           /*<<lexing.js 193 6>>*/ return - base - 1}
         /*<<lexing.js 189 4>>*/  /*<<lexing.js 196 16>>*/ var
         backtrk=
          tbl.lex_backtrk[state];
         /*<<lexing.js 197 4>>*/ if(backtrk >= 0)
          /*<<lexing.js 197 22>>*/ { /*<<lexing.js 198 6>>*/  /*<<lexing.js 198 17>>*/ var
           pc_off=
            tbl.lex_backtrk_code[state];
           /*<<lexing.js 199 6>>*/ caml_lex_run_tag
           (tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
         /*<<lexing.js 204 4>>*/ if
         (lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
          /*<<lexing.js 204 55>>*/ if(lexbuf[lex_eof_reached] == 0)
           /*<<lexing.js 206 8>>*/ return - state - 1;
         else
          c = 256;
        else
          /*<<lexing.js 209 9>>*/ {c = buffer[lexbuf[lex_curr_pos]];
          lexbuf[lex_curr_pos]++}
         /*<<lexing.js 189 4>>*/  /*<<lexing.js 215 15>>*/ var pstate=state;
         /*<<lexing.js 216 4>>*/ state
        =
        tbl.lex_check[base + c] == state
         ?tbl.lex_trans[base + c]
         :tbl.lex_default[state];
         /*<<lexing.js 221 4>>*/ if(state < 0)
          /*<<lexing.js 221 19>>*/ {lexbuf[lex_curr_pos]
          =
          lexbuf[lex_last_pos];
           /*<<lexing.js 223 6>>*/ if(lexbuf[lex_last_action] == - 1)
            /*<<lexing.js 224 8>>*/ caml_failwith("lexing: empty token");
          else
            /*<<lexing.js 226 8>>*/ return lexbuf[lex_last_action]}
        else
          /*<<lexing.js 227 9>>*/ { /*<<lexing.js 229 6>>*/ var
            /*<<lexing.js 229 20>>*/ base_code=tbl.lex_base_code[pstate],
           pc_off;
           /*<<lexing.js 230 6>>*/ pc_off
          =
          tbl.lex_check_code[base_code + c] == pstate
           ?tbl.lex_trans_code[base_code + c]
           :tbl.lex_default_code[pstate];
           /*<<lexing.js 234 6>>*/ if(pc_off > 0)
            /*<<lexing.js 235 8>>*/ caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
           /*<<lexing.js 240 6>>*/ if(c == 256)lexbuf[lex_eof_reached] = 0}} /*<<lexing.js 243 0>>*/ }
     /*<<jslib_js_of_ocaml.js 27 0>>*/ function caml_js_from_float(x)
     { /*<<jslib_js_of_ocaml.js 27 33>>*/ return x /*<<jslib_js_of_ocaml.js 27 43>>*/ }
     /*<<stdlib.js 321 0>>*/ function caml_floatarray_create(len)
     { /*<<stdlib.js 322 2>>*/ var
        /*<<stdlib.js 322 10>>*/ len=len + 1 | 0,
        /*<<stdlib.js 323 8>>*/ b=new Array(len);
      b[0] = 254;
       /*<<stdlib.js 325 2>>*/ for
       ( /*<<stdlib.js 325 13>>*/ var i=1;i < len;i++)
       b[i] = 0;
       /*<<stdlib.js 326 2>>*/ return b /*<<stdlib.js 327 0>>*/ }
     /*<<gc.js 18 0>>*/ function caml_gc_stat()
     { /*<<gc.js 19 2>>*/ return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] /*<<gc.js 20 0>>*/ }
     /*<<stdlib.js 435 0>>*/ function caml_lessequal(x,y)
     { /*<<stdlib.js 435 33>>*/ return +
             ( /*<<stdlib.js 435 42>>*/ caml_compare_val(x,y,false) <= 0) /*<<stdlib.js 435 77>>*/ }
     /*<<io.js 405 0>>*/ function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_channels[chanid].offset
      =
       /*<<io.js 406 36>>*/ caml_int64_to_float(pos);
       /*<<io.js 407 2>>*/ return 0 /*<<io.js 408 0>>*/ }
     /*<<gc.js 23 0>>*/ function caml_gc_set(_control)
     { /*<<gc.js 24 2>>*/ return 0 /*<<gc.js 25 0>>*/ }
     /*<<jslib.js 28 0>>*/ function caml_js_get(o,f)
     { /*<<jslib.js 28 28>>*/ return o[f] /*<<jslib.js 28 41>>*/ }
     /*<<stdlib.js 1014 0>>*/  /*<<stdlib.js 1014 22>>*/ var
     caml_method_cache=
      [];
     /*<<stdlib.js 1015 0>>*/ function caml_get_public_method(obj,tag,cacheid)
     { /*<<stdlib.js 1016 2>>*/ var
        /*<<stdlib.js 1016 12>>*/ meths=obj[1],
        /*<<stdlib.js 1017 10>>*/ ofs=caml_method_cache[cacheid];
       /*<<stdlib.js 1018 2>>*/ if(ofs === null)
        /*<<stdlib.js 1018 20>>*/ for
        ( /*<<stdlib.js 1020 15>>*/ var i=caml_method_cache.length;
         i
         <
         cacheid;
         i++)
        caml_method_cache[i] = 0;
      else
        /*<<stdlib.js 1022 9>>*/ if(meths[ofs] === tag)
         /*<<stdlib.js 1022 33>>*/ return meths[ofs - 1];
       /*<<stdlib.js 1016 2>>*/ var
        /*<<stdlib.js 1025 9>>*/ li=3,
        /*<<stdlib.js 1025 17>>*/ hi=meths[1] * 2 + 1,
       mi;
       /*<<stdlib.js 1026 2>>*/ while(li < hi)
        /*<<stdlib.js 1026 18>>*/ {mi = li + hi >> 1 | 1;
         /*<<stdlib.js 1028 4>>*/ if(tag < meths[mi + 1])
         hi = mi - 2;
        else
         li = mi}
      caml_method_cache[cacheid] = li + 1;
       /*<<stdlib.js 1033 2>>*/ return tag == meths[li + 1]?meths[li]:0 /*<<stdlib.js 1034 0>>*/ }
     /*<<jslib.js 65 0>>*/ function caml_js_get_console()
     { /*<<jslib.js 66 2>>*/ var
        /*<<jslib.js 66 8>>*/ c=
        joo_global_object.console?joo_global_object.console:{},
        /*<<jslib.js 67 8>>*/ m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
       /*<<jslib.js 69 2>>*/ function f(){ /*<<jslib.js 69 17>>*/ }
       /*<<jslib.js 70 2>>*/ for
       ( /*<<jslib.js 70 13>>*/ var i=0;i < m.length;i++)
        /*<<jslib.js 70 37>>*/ if(! c[m[i]])c[m[i]] = f;
       /*<<jslib.js 71 2>>*/ return c /*<<jslib.js 72 0>>*/ }
     /*<<jslib.js 90 0>>*/ function js_print_stdout(s)
     { /*<<jslib.js 91 2>>*/  /*<<jslib.js 91 8>>*/ var g=joo_global_object;
       /*<<jslib.js 92 2>>*/ if
       (g.process && g.process.stdout && g.process.stdout.write)
        /*<<jslib.js 92 63>>*/  /*<<jslib.js 93 4>>*/ g.process.stdout.write
        (s);
      else
        /*<<jslib.js 94 9>>*/ { /*<<jslib.js 97 2>>*/ if
         ( /*<<jslib.js 97 5>>*/ s.charCodeAt(s.length - 1) == 10)
         s =  /*<<jslib.js 98 8>>*/ s.substr(0,s.length - 1);
         /*<<jslib.js 99 2>>*/  /*<<jslib.js 99 8>>*/ var v=g.console;
        v && v.log &&  /*<<jslib.js 100 17>>*/ v.log(s)} /*<<jslib.js 102 0>>*/ }
     /*<<io.js 46 0>>*/ function caml_sys_open_internal(idx,output,file,flags)
     { /*<<io.js 47 2>>*/ if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
       /*<<io.js 49 2>>*/  /*<<io.js 49 11>>*/ var info={};
      info.file = file;
      info.offset = flags.append? /*<<io.js 51 29>>*/ file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
       /*<<io.js 55 2>>*/ if
       (! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
       /*<<io.js 57 2>>*/ return idx /*<<io.js 58 0>>*/ }
     /*<<io.js 59 0>>*/ function caml_sys_open(name,flags,_perms)
     { /*<<io.js 60 2>>*/  /*<<io.js 60 8>>*/ var f={};
       /*<<io.js 61 2>>*/ while(flags)
        /*<<io.js 61 14>>*/ { /*<<io.js 62 4>>*/ switch(flags[1])
         {case 0:f.rdonly = 1; /*<<io.js 63 25>>*/ break;
          case 1:f.wronly = 1; /*<<io.js 64 25>>*/ break;
          case 2:f.append = 1; /*<<io.js 65 25>>*/ break;
          case 3:f.create = 1; /*<<io.js 66 25>>*/ break;
          case 4:f.truncate = 1; /*<<io.js 67 27>>*/ break;
          case 5:f.excl = 1; /*<<io.js 68 24>>*/ break;
          case 6:f.binary = 1; /*<<io.js 69 25>>*/ break;
          case 7:f.text = 1; /*<<io.js 70 23>>*/ break;
          case 8:f.nonblock = 1; /*<<io.js 71 27>>*/ break
          }
        flags = flags[2]}
       /*<<io.js 75 2>>*/ if(f.rdonly && f.wronly)
        /*<<io.js 76 4>>*/ caml_raise_sys_error
        ( /*<<io.js 76 25>>*/ name.toString()
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
       /*<<io.js 77 2>>*/ if(f.text && f.binary)
        /*<<io.js 78 4>>*/ caml_raise_sys_error
        ( /*<<io.js 78 25>>*/ name.toString()
         +
         " : flags Open_text and Open_binary are not compatible");
       /*<<io.js 60 2>>*/ var
        /*<<io.js 79 11>>*/ root= /*<<io.js 79 13>>*/ resolve_fs_device(name),
        /*<<io.js 80 11>>*/ file=
         /*<<io.js 80 13>>*/ root.device.open(root.rest,f),
        /*<<io.js 81 10>>*/ idx=
        caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
       /*<<io.js 82 2>>*/ return  /*<<io.js 82 9>>*/ caml_sys_open_internal
              (idx + 1,caml_std_output,file,f) /*<<io.js 83 0>>*/ }
     /*<<io.js 84 0>>*/ caml_sys_open_internal
     (0,
      caml_std_output,
      new MlFakeFile( /*<<io.js 84 57>>*/ caml_create_bytes(0)));
     /*<<io.js 85 0>>*/ caml_sys_open_internal
     (1,
      js_print_stdout,
      new MlFakeFile( /*<<io.js 85 57>>*/ caml_create_bytes(0)));
     /*<<io.js 86 0>>*/ caml_sys_open_internal
     (2,
      js_print_stderr,
      new MlFakeFile( /*<<io.js 86 57>>*/ caml_create_bytes(0)));
     /*<<io.js 131 0>>*/ function caml_ml_open_descriptor_in(fd)
     { /*<<io.js 132 2>>*/  /*<<io.js 132 11>>*/ var
       data=
        caml_global_data.fds[fd];
       /*<<io.js 133 2>>*/ if(data.flags.wronly)
        /*<<io.js 133 24>>*/ caml_raise_sys_error
        ("fd " + fd + " is writeonly");
       /*<<io.js 132 2>>*/  /*<<io.js 135 14>>*/ var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
       /*<<io.js 144 2>>*/ return channel.fd /*<<io.js 145 0>>*/ }
     /*<<gc.js 10 0>>*/ function caml_gc_compaction()
     { /*<<gc.js 10 31>>*/ return 0 /*<<gc.js 10 39>>*/ }
     /*<<jslib_js_of_ocaml.js 95 0>>*/ function caml_ojs_new_arr(c,a)
     { /*<<jslib_js_of_ocaml.js 96 2>>*/ switch(a.length)
       {case 0: /*<<jslib_js_of_ocaml.js 97 10>>*/ return new c();
        case 1: /*<<jslib_js_of_ocaml.js 98 10>>*/ return new c(a[0]);
        case 2: /*<<jslib_js_of_ocaml.js 99 10>>*/ return new c(a[0],a[1]);
        case 3:
          /*<<jslib_js_of_ocaml.js 100 10>>*/ return new c(a[0],a[1],a[2]);
        case 4:
          /*<<jslib_js_of_ocaml.js 101 10>>*/ return new
                 c
                 (a[0],a[1],a[2],a[3]);
        case 5:
          /*<<jslib_js_of_ocaml.js 102 10>>*/ return new
                 c
                 (a[0],a[1],a[2],a[3],a[4]);
        case 6:
          /*<<jslib_js_of_ocaml.js 103 10>>*/ return new
                 c
                 (a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:
          /*<<jslib_js_of_ocaml.js 104 10>>*/ return new
                 c
                 (a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
       /*<<jslib_js_of_ocaml.js 106 2>>*/ function F()
       { /*<<jslib_js_of_ocaml.js 106 17>>*/ return  /*<<jslib_js_of_ocaml.js 106 24>>*/ c.apply
                (this,a) /*<<jslib_js_of_ocaml.js 106 42>>*/ }
      F.prototype = c.prototype;
       /*<<jslib_js_of_ocaml.js 108 2>>*/ return new F() /*<<jslib_js_of_ocaml.js 109 0>>*/ }
     /*<<weak.js 99 0>>*/ var
      /*<<weak.js 99 22>>*/ caml_ephe_get_key=caml_weak_get,
      /*<<jslib.js 46 20>>*/ caml_js_regexps=
      {amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
     /*<<jslib.js 47 0>>*/ function caml_js_html_escape(s)
     { /*<<jslib.js 48 2>>*/ if
       (!  /*<<jslib.js 48 7>>*/ caml_js_regexps.all.test(s))
        /*<<jslib.js 48 36>>*/ return s;
       /*<<jslib.js 49 2>>*/ return  /*<<jslib.js 49 9>>*/  /*<<jslib.js 49 9>>*/  /*<<jslib.js 49 9>>*/ s.replace
                (caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;") /*<<jslib.js 52 0>>*/ }
     /*<<io.js 163 0>>*/ function caml_ml_close_channel(chanid)
     { /*<<io.js 164 2>>*/  /*<<io.js 164 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 165 2>>*/ caml_ml_flush(chanid);
      chan.opened = false;
       /*<<io.js 167 2>>*/ chan.file.close();
       /*<<io.js 168 2>>*/ caml_sys_close(chan.fd);
       /*<<io.js 169 2>>*/ return 0 /*<<io.js 170 0>>*/ }
     /*<<unix.js 50 0>>*/ function win_cleanup(){ /*<<unix.js 50 24>>*/ }
     /*<<stdlib.js 172 0>>*/ function caml_exn_with_js_backtrace(exn,force)
     { /*<<stdlib.js 174 4>>*/ if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
       /*<<stdlib.js 175 2>>*/ return exn /*<<stdlib.js 176 0>>*/ }
     /*<<stdlib.js 1205 0>>*/ function caml_sys_isatty(_chan)
     { /*<<stdlib.js 1206 2>>*/ return 0 /*<<stdlib.js 1207 0>>*/ }
     /*<<bigarray.js 496 0>>*/ function caml_ba_dim_2(ba)
     { /*<<bigarray.js 497 4>>*/ return  /*<<bigarray.js 497 11>>*/ ba.nth_dim
              (1) /*<<bigarray.js 498 0>>*/ }
     /*<<jslib_js_of_ocaml.js 149 0>>*/ function
     caml_js_wrap_meth_callback_arguments
     (f)
     { /*<<jslib_js_of_ocaml.js 150 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 151 4>>*/ return  /*<<jslib_js_of_ocaml.js 151 11>>*/ caml_call_gen
                (f,[this,arguments]) /*<<jslib_js_of_ocaml.js 150 9>>*/ } /*<<jslib_js_of_ocaml.js 153 0>>*/ }
     /*<<stdlib.js 1112 0>>*/ function unix_inet_addr_of_string()
     { /*<<stdlib.js 1112 38>>*/ return 0 /*<<stdlib.js 1112 47>>*/ }
     /*<<ieee_754.js 246 0>>*/ function caml_sinh_float(x)
     { /*<<ieee_754.js 246 31>>*/ return ( /*<<ieee_754.js 246 39>>*/ Math.exp
               (x)
              -
               /*<<ieee_754.js 246 53>>*/ Math.exp(- x))
             /
             2 /*<<ieee_754.js 246 72>>*/ }
     /*<<jslib.js 26 0>>*/ function caml_js_set(o,f,v)
     {o[f] = v; /*<<jslib.js 26 37>>*/ return 0 /*<<jslib.js 26 45>>*/ }
     /*<<ieee_754.js 174 0>>*/ function caml_ldexp_float(x,exp)
     {exp |= 0;
       /*<<ieee_754.js 176 2>>*/ if(exp > 1023)
        /*<<ieee_754.js 176 18>>*/ {exp -= 1023;
        x *=  /*<<ieee_754.js 178 9>>*/ Math.pow(2,1023);
         /*<<ieee_754.js 179 4>>*/ if(exp > 1023)
          /*<<ieee_754.js 179 20>>*/ {exp -= 1023;
          x *=  /*<<ieee_754.js 181 11>>*/ Math.pow(2,1023)}}
       /*<<ieee_754.js 184 2>>*/ if(exp < - 1023)
        /*<<ieee_754.js 184 19>>*/ {exp += 1023;
        x *=  /*<<ieee_754.js 186 9>>*/ Math.pow(2,- 1023)}
      x *=  /*<<ieee_754.js 188 7>>*/ Math.pow(2,exp);
       /*<<ieee_754.js 189 2>>*/ return x /*<<ieee_754.js 190 0>>*/ }
     /*<<jslib_js_of_ocaml.js 131 0>>*/ function caml_js_wrap_callback_strict
     (arity,f)
     { /*<<jslib_js_of_ocaml.js 132 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 133 4>>*/  /*<<jslib_js_of_ocaml.js 133 10>>*/ var
         n=
          arguments.length;
         /*<<jslib_js_of_ocaml.js 134 4>>*/ if(n == arity)
          /*<<jslib_js_of_ocaml.js 134 19>>*/ return  /*<<jslib_js_of_ocaml.js 134 26>>*/ caml_call_gen
                 (f,arguments);
         /*<<jslib_js_of_ocaml.js 133 4>>*/  /*<<jslib_js_of_ocaml.js 135 13>>*/ var
         args=
          new Array(arity);
         /*<<jslib_js_of_ocaml.js 136 4>>*/ for
         ( /*<<jslib_js_of_ocaml.js 136 15>>*/ var i=0;i < n && i < arity;i++)
         args[i] = arguments[i];
         /*<<jslib_js_of_ocaml.js 137 4>>*/ return  /*<<jslib_js_of_ocaml.js 137 11>>*/ caml_call_gen
                (f,args) /*<<jslib_js_of_ocaml.js 132 9>>*/ } /*<<jslib_js_of_ocaml.js 139 0>>*/ }
     /*<<stdlib.js 291 0>>*/ function caml_array_get(array,index)
     { /*<<stdlib.js 292 2>>*/ if(index < 0 || index >= array.length - 1)
        /*<<stdlib.js 292 50>>*/ caml_array_bound_error();
       /*<<stdlib.js 293 2>>*/ return array[index + 1] /*<<stdlib.js 294 0>>*/ }
     /*<<stdlib.js 1062 0>>*/ function caml_get_current_callstack()
     { /*<<stdlib.js 1062 41>>*/ return [0] /*<<stdlib.js 1062 53>>*/ }
     /*<<int64.js 229 0>>*/ function caml_int64_mod(x,y)
     { /*<<int64.js 231 2>>*/ if
       ( /*<<int64.js 231 6>>*/ caml_int64_is_zero(y))
        /*<<int64.js 231 30>>*/ caml_raise_zero_divide();
       /*<<int64.js 232 2>>*/  /*<<int64.js 232 11>>*/ var sign=x[3];
       /*<<int64.js 233 2>>*/ if(x[3] & 32768)
       x =  /*<<int64.js 233 25>>*/ caml_int64_neg(x);
       /*<<int64.js 234 2>>*/ if(y[3] & 32768)
       y =  /*<<int64.js 234 25>>*/ caml_int64_neg(y);
       /*<<int64.js 232 2>>*/  /*<<int64.js 235 8>>*/ var
       r=
         /*<<int64.js 235 10>>*/ caml_int64_udivmod(x,y)[2];
       /*<<int64.js 236 2>>*/ if(sign & 32768)
       r =  /*<<int64.js 236 25>>*/ caml_int64_neg(r);
       /*<<int64.js 237 2>>*/ return r /*<<int64.js 238 0>>*/ }
     /*<<fs.js 213 0>>*/ function caml_create_file_extern(name,content)
     { /*<<fs.js 214 2>>*/ if(joo_global_object.caml_create_file)
        /*<<fs.js 215 4>>*/ joo_global_object.caml_create_file(name,content);
      else
        /*<<fs.js 216 7>>*/ { /*<<fs.js 217 4>>*/ if
         (! joo_global_object.caml_fs_tmp)
         joo_global_object.caml_fs_tmp = [];
         /*<<fs.js 218 4>>*/ joo_global_object.caml_fs_tmp.push
         ({name:name,content:content})}
       /*<<fs.js 220 2>>*/ return 0 /*<<fs.js 221 0>>*/ }
     /*<<stdlib.js 226 0>>*/ function caml_obj_set_tag(x,tag)
     {x[0] = tag; /*<<stdlib.js 226 49>>*/ return 0 /*<<stdlib.js 226 59>>*/ }
     /*<<bigstring.js 118 0>>*/ function bigstring_unmarshal_stub(s,ofs)
     { /*<<bigstring.js 119 2>>*/  /*<<bigstring.js 119 13>>*/ var
       reader=
        new BigStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
       /*<<bigstring.js 120 2>>*/ return  /*<<bigstring.js 120 9>>*/ caml_input_value_from_reader
              (reader,ofs) /*<<bigstring.js 121 0>>*/ }
     /*<<stdlib.js 1146 0>>*/ function caml_int32_bswap(x)
     { /*<<stdlib.js 1147 2>>*/ return (x & 255)
             <<
             24
             |
             (x & 65280)
             <<
             8
             |
             (x & 16711680)
             >>>
             8
             |
             (x & 4278190080)
             >>>
             24 /*<<stdlib.js 1151 0>>*/ }
     /*<<stdlib.js 1221 0>>*/ function
     caml_spacetime_only_works_for_native_code
     ()
     { /*<<stdlib.js 1222 2>>*/ caml_failwith
       ("Spacetime profiling only works for native code") /*<<stdlib.js 1223 0>>*/ }
     /*<<unix.js 47 0>>*/ function win_startup(){ /*<<unix.js 47 24>>*/ }
     /*<<io.js 295 0>>*/ function caml_ml_seek_in_64(chanid,pos)
     { /*<<io.js 296 2>>*/  /*<<io.js 296 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 297 2>>*/ if(chan.refill != null)
        /*<<io.js 297 27>>*/ caml_raise_sys_error("Illegal seek");
      chan.offset =  /*<<io.js 298 16>>*/ caml_int64_to_float(pos);
       /*<<io.js 299 2>>*/ return 0 /*<<io.js 300 0>>*/ }
     /*<<bigarray.js 601 0>>*/ function caml_ba_set_3(ba,i0,i1,i2,v)
     { /*<<bigarray.js 602 4>>*/ return  /*<<bigarray.js 602 11>>*/ ba.set
              ([i0,i1,i2],v) /*<<bigarray.js 603 0>>*/ }
     /*<<jslib.js 33 0>>*/ function caml_js_instanceof(o,c)
     { /*<<jslib.js 33 35>>*/ return o instanceof c /*<<jslib.js 33 58>>*/ }
     /*<<stdlib.js 761 0>>*/ function caml_hash_mix_float(h,v0)
     { /*<<stdlib.js 762 2>>*/ var
        /*<<stdlib.js 762 8>>*/ v=
         /*<<stdlib.js 762 10>>*/ caml_int64_bits_of_float(v0),
        /*<<stdlib.js 763 9>>*/ lo=v[1] | v[2] << 24,
        /*<<stdlib.js 764 9>>*/ hi=v[2] >>> 8 | v[3] << 16;
      h =  /*<<stdlib.js 765 6>>*/ caml_hash_mix_int(h,lo);
      h =  /*<<stdlib.js 766 6>>*/ caml_hash_mix_int(h,hi);
       /*<<stdlib.js 767 2>>*/ return h /*<<stdlib.js 768 0>>*/ }
     /*<<stdlib.js 426 0>>*/ function caml_notequal(x,y)
     { /*<<stdlib.js 426 32>>*/ return +
             ( /*<<stdlib.js 426 41>>*/ caml_compare_val(x,y,false) != 0) /*<<stdlib.js 426 76>>*/ }
     /*<<int64.js 120 0>>*/ function caml_int64_shift_left(x,s)
     {s = s & 63;
       /*<<int64.js 122 2>>*/ if(s == 0) /*<<int64.js 122 14>>*/ return x;
       /*<<int64.js 123 2>>*/ if(s < 24)
        /*<<int64.js 124 4>>*/ return [255,
               x[1] << s & 16777215,
               (x[2] << s | x[1] >> 24 - s) & 16777215,
               (x[3] << s | x[2] >> 24 - s) & 65535];
       /*<<int64.js 128 2>>*/ if(s < 48)
        /*<<int64.js 129 4>>*/ return [255,
               0,
               x[1] << s - 24 & 16777215,
               (x[2] << s - 24 | x[1] >> 48 - s) & 65535];
       /*<<int64.js 132 2>>*/ return [255,0,0,x[1] << s - 48 & 65535] /*<<int64.js 133 0>>*/ }
     /*<<jslib_js_of_ocaml.js 142 0>>*/ function caml_js_wrap_meth_callback(f)
     { /*<<jslib_js_of_ocaml.js 143 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 144 4>>*/ return  /*<<jslib_js_of_ocaml.js 144 11>>*/ caml_call_gen
                (f,
                  /*<<jslib_js_of_ocaml.js 144 27>>*/ raw_array_cons
                  (arguments,this)) /*<<jslib_js_of_ocaml.js 143 9>>*/ } /*<<jslib_js_of_ocaml.js 146 0>>*/ }
     /*<<stdlib.js 941 0>>*/ function caml_sys_const_int_size()
     { /*<<stdlib.js 941 38>>*/ return 32 /*<<stdlib.js 941 49>>*/ }
     /*<<bigstring.js 47 0>>*/  /*<<bigstring.js 47 34>>*/ var
     caml_blit_bigstring_to_string=
      bigstring_blit_bigstring_bytes_stub;
     /*<<stdlib.js 1227 0>>*/ function caml_is_js()
     { /*<<stdlib.js 1228 2>>*/ return 1 /*<<stdlib.js 1229 0>>*/ }
     /*<<mlString.js 381 0>>*/ function caml_string_set64(s,i,i64)
     { /*<<mlString.js 382 4>>*/ return  /*<<mlString.js 382 11>>*/ caml_bytes_set64
              (s,i,i64) /*<<mlString.js 383 0>>*/ }
     /*<<bigarray.js 491 0>>*/ function caml_ba_dim_1(ba)
     { /*<<bigarray.js 492 4>>*/ return  /*<<bigarray.js 492 11>>*/ ba.nth_dim
              (0) /*<<bigarray.js 493 0>>*/ }
     /*<<jslib_js_of_ocaml.js 73 0>>*/ function caml_js_meth_call(o,f,args)
     { /*<<jslib_js_of_ocaml.js 74 2>>*/ return  /*<<jslib_js_of_ocaml.js 74 9>>*/ o
               [ /*<<jslib_js_of_ocaml.js 74 11>>*/ f.toString()].apply
              (o, /*<<jslib_js_of_ocaml.js 74 34>>*/ caml_js_from_array(args)) /*<<jslib_js_of_ocaml.js 75 0>>*/ }
     /*<<fs.js 201 0>>*/ function caml_ba_map_file
     (vfd,kind,layout,shared,dims,pos)
     { /*<<fs.js 203 2>>*/ caml_failwith("caml_ba_map_file not implemented") /*<<fs.js 204 0>>*/ }
     /*<<fs.js 208 0>>*/ function caml_ba_map_file_bytecode(argv,argn)
     { /*<<fs.js 209 2>>*/ return  /*<<fs.js 209 9>>*/ caml_ba_map_file
              (argv[0],argv[1],argv[2],argv[3],argv[4],argv[5]) /*<<fs.js 210 0>>*/ }
     /*<<unix.js 24 0>>*/ function unix_localtime(t)
     { /*<<unix.js 25 2>>*/ var
        /*<<unix.js 25 8>>*/ d=new Date(t * 1e3),
        /*<<unix.js 26 19>>*/ januaryfirst=
        new Date( /*<<unix.js 26 30>>*/ d.getFullYear(),0,1),
        /*<<unix.js 27 10>>*/ doy=
         /*<<unix.js 27 12>>*/ Math.floor((d - januaryfirst) / 864e5),
        /*<<unix.js 28 10>>*/ jan=
        new Date( /*<<unix.js 28 21>>*/ d.getFullYear(),0,1),
        /*<<unix.js 29 10>>*/ jul=
        new Date( /*<<unix.js 29 21>>*/ d.getFullYear(),6,1),
        /*<<unix.js 30 24>>*/ stdTimezoneOffset=
         /*<<unix.js 30 26>>*/ Math.max
         ( /*<<unix.js 30 35>>*/ jan.getTimezoneOffset(),
           /*<<unix.js 30 60>>*/ jul.getTimezoneOffset());
       /*<<unix.js 31 2>>*/ return [0,
               /*<<unix.js 31 13>>*/ d.getSeconds(),
               /*<<unix.js 31 29>>*/ d.getMinutes(),
               /*<<unix.js 31 45>>*/ d.getHours(),
               /*<<unix.js 32 2>>*/ d.getDate(),
               /*<<unix.js 32 15>>*/ d.getMonth(),
               /*<<unix.js 32 29>>*/ d.getFullYear() - 1900,
               /*<<unix.js 33 2>>*/ d.getDay(),
              doy,
               /*<<unix.js 34 3>>*/ d.getTimezoneOffset()
              <
              stdTimezoneOffset
              |
              0] /*<<unix.js 35 0>>*/ }
     /*<<weak.js 36 0>>*/ function caml_weak_create(n)
     { /*<<weak.js 37 2>>*/ if(n < 0)
        /*<<weak.js 37 13>>*/ caml_invalid_argument("Weak.create");
       /*<<weak.js 38 2>>*/  /*<<weak.js 38 8>>*/ var
       x=
        [251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
       /*<<weak.js 40 2>>*/ return x /*<<weak.js 41 0>>*/ }
     /*<<weak.js 91 0>>*/  /*<<weak.js 91 21>>*/ var
     caml_ephe_create=
      caml_weak_create;
     /*<<jslib_js_of_ocaml.js 175 0>>*/ function caml_js_to_byte_string(s)
     { /*<<jslib_js_of_ocaml.js 175 37>>*/ return  /*<<jslib_js_of_ocaml.js 175 44>>*/ caml_new_string
              (s) /*<<jslib_js_of_ocaml.js 175 64>>*/ }
     /*<<ieee_754.js 248 0>>*/ function caml_tanh_float(x)
     { /*<<ieee_754.js 249 2>>*/ var
        /*<<ieee_754.js 249 8>>*/ y= /*<<ieee_754.js 249 10>>*/ Math.exp(x),
        /*<<ieee_754.js 249 25>>*/ z= /*<<ieee_754.js 249 27>>*/ Math.exp(- x);
       /*<<ieee_754.js 250 2>>*/ return (y - z) / (y + z) /*<<ieee_754.js 251 0>>*/ }
     /*<<polyfill/json2.js 170 0>>*/  /*<<polyfill/json2.js 170 9>>*/ var
     JSON=
      joo_global_object.JSON;
     /*<<polyfill/json2.js 171 0>>*/ if(typeof JSON !== "object")
      /*<<polyfill/json2.js 171 30>>*/ JSON = {};
    ( /*<<polyfill/json2.js 175 1>>*/ function()
       {"use strict";
         /*<<polyfill/json2.js 178 4>>*/ var
          /*<<polyfill/json2.js 178 15>>*/ rx_one=/^[\],:{}\s]*$/,
          /*<<polyfill/json2.js 179 15>>*/ rx_two=
          /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
          /*<<polyfill/json2.js 180 17>>*/ rx_three=
          /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
          /*<<polyfill/json2.js 181 16>>*/ rx_four=/(?:^|:|,)(?:\s*\[)+/g,
          /*<<polyfill/json2.js 182 21>>*/ rx_escapable=
          /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          /*<<polyfill/json2.js 183 21>>*/ rx_dangerous=
          /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
         /*<<polyfill/json2.js 185 4>>*/ function f(n)
         { /*<<polyfill/json2.js 187 8>>*/ return n < 10?"0" + n:n /*<<polyfill/json2.js 190 4>>*/ }
         /*<<polyfill/json2.js 192 4>>*/ function this_value()
         { /*<<polyfill/json2.js 193 8>>*/ return  /*<<polyfill/json2.js 193 15>>*/ this.valueOf
                  () /*<<polyfill/json2.js 194 4>>*/ }
         /*<<polyfill/json2.js 196 4>>*/ if
         (typeof Date.prototype.toJSON !== "function")
          /*<<polyfill/json2.js 196 53>>*/ {Date.prototype.toJSON
          =
          function()
           { /*<<polyfill/json2.js 200 12>>*/ return  /*<<polyfill/json2.js 200 19>>*/ isFinite
                     ( /*<<polyfill/json2.js 200 28>>*/ this.valueOf())
                    ? /*<<polyfill/json2.js 201 18>>*/ this.getUTCFullYear()
                     +
                     "-"
                     +
                      /*<<polyfill/json2.js 202 24>>*/ f
                      ( /*<<polyfill/json2.js 202 26>>*/ this.getUTCMonth() + 1)
                     +
                     "-"
                     +
                      /*<<polyfill/json2.js 203 24>>*/ f
                      ( /*<<polyfill/json2.js 203 26>>*/ this.getUTCDate())
                     +
                     "T"
                     +
                      /*<<polyfill/json2.js 204 24>>*/ f
                      ( /*<<polyfill/json2.js 204 26>>*/ this.getUTCHours())
                     +
                     ":"
                     +
                      /*<<polyfill/json2.js 205 24>>*/ f
                      ( /*<<polyfill/json2.js 205 26>>*/ this.getUTCMinutes())
                     +
                     ":"
                     +
                      /*<<polyfill/json2.js 206 24>>*/ f
                      ( /*<<polyfill/json2.js 206 26>>*/ this.getUTCSeconds())
                     +
                     "Z"
                    :null /*<<polyfill/json2.js 198 32>>*/ };
          Boolean.prototype.toJSON = this_value;
          Number.prototype.toJSON = this_value;
          String.prototype.toJSON = this_value}
         /*<<polyfill/json2.js 215 4>>*/ var gap,indent,meta,rep;
         /*<<polyfill/json2.js 221 4>>*/ function quote(string)
         {rx_escapable.lastIndex = 0;
           /*<<polyfill/json2.js 229 8>>*/ return  /*<<polyfill/json2.js 229 15>>*/ rx_escapable.test
                   (string)
                  ?'"'
                   +
                    /*<<polyfill/json2.js 230 20>>*/ string.replace
                    (rx_escapable,
                     function(a)
                      { /*<<polyfill/json2.js 231 16>>*/  /*<<polyfill/json2.js 231 22>>*/ var
                        c=
                         meta[a];
                        /*<<polyfill/json2.js 232 16>>*/ return typeof c
                               ===
                               "string"
                               ?c
                               :"\\u"
                                +
                                 /*<<polyfill/json2.js 234 30>>*/ ("0000"
                                  +
                                   /*<<polyfill/json2.js 234 40>>*/  /*<<polyfill/json2.js 234 40>>*/ a.charCodeAt
                                    (0).toString
                                   (16)).slice
                                 (- 4) /*<<polyfill/json2.js 230 49>>*/ })
                   +
                   '"'
                  :'"' + string + '"' /*<<polyfill/json2.js 237 4>>*/ }
         /*<<polyfill/json2.js 240 4>>*/ function str(key,holder)
         { /*<<polyfill/json2.js 244 8>>*/ var
           i,
           k,
           v,
           length,
            /*<<polyfill/json2.js 248 17>>*/ mind=gap,
           partial,
            /*<<polyfill/json2.js 250 18>>*/ value=holder[key];
           /*<<polyfill/json2.js 254 8>>*/ if
           (value
            &&
            typeof value
            ===
            "object"
            &&
            typeof value.toJSON
            ===
            "function")
            /*<<polyfill/json2.js 255 52>>*/ value
           =
            /*<<polyfill/json2.js 256 20>>*/ value.toJSON(key);
           /*<<polyfill/json2.js 262 8>>*/ if(typeof rep === "function")
            /*<<polyfill/json2.js 262 39>>*/ value
           =
            /*<<polyfill/json2.js 263 20>>*/ rep.call(holder,key,value);
           /*<<polyfill/json2.js 268 8>>*/ switch(typeof value)
           {case "string":
              /*<<polyfill/json2.js 270 12>>*/ return  /*<<polyfill/json2.js 270 19>>*/ quote
                     (value);
            case "number":
              /*<<polyfill/json2.js 276 12>>*/ return  /*<<polyfill/json2.js 276 19>>*/ isFinite
                      (value)
                     ? /*<<polyfill/json2.js 277 18>>*/ String(value)
                     :"null";
            case "boolean":
            case "null":
              /*<<polyfill/json2.js 287 12>>*/ return  /*<<polyfill/json2.js 287 19>>*/ String
                     (value);
            case "object":
              /*<<polyfill/json2.js 297 12>>*/ if(! value)
               /*<<polyfill/json2.js 297 24>>*/ return "null";
             gap += indent;
             partial = [];
              /*<<polyfill/json2.js 308 12>>*/ if
              ( /*<<polyfill/json2.js 308 16>>*/ Object.prototype.toString.apply
                (value)
               ===
               "[object Array]")
               /*<<polyfill/json2.js 308 77>>*/ {length = value.length;
                /*<<polyfill/json2.js 314 16>>*/ for(i = 0;i < length;i += 1)
                 /*<<polyfill/json2.js 314 48>>*/ partial[i]
                =
                 /*<<polyfill/json2.js 315 33>>*/ str(i,value)
                ||
                "null";
               v
               =
               partial.length === 0
                ?"[]"
                :gap
                  ?"[\n"
                   +
                   gap
                   +
                    /*<<polyfill/json2.js 324 40>>*/ partial.join(",\n" + gap)
                   +
                   "\n"
                   +
                   mind
                   +
                   "]"
                  :"["
                   +
                    /*<<polyfill/json2.js 325 32>>*/ partial.join(",")
                   +
                   "]";
               gap = mind;
                /*<<polyfill/json2.js 327 16>>*/ return v}
              /*<<polyfill/json2.js 332 12>>*/ if
              (rep && typeof rep === "object")
               /*<<polyfill/json2.js 332 48>>*/ {length = rep.length;
                /*<<polyfill/json2.js 334 16>>*/ for(i = 0;i < length;i += 1)
                 /*<<polyfill/json2.js 334 48>>*/ if
                 (typeof rep[i] === "string")
                  /*<<polyfill/json2.js 335 52>>*/ {k = rep[i];
                  v =  /*<<polyfill/json2.js 337 28>>*/ str(k,value);
                   /*<<polyfill/json2.js 338 24>>*/ if(v)
                    /*<<polyfill/json2.js 338 31>>*/  /*<<polyfill/json2.js 339 28>>*/ partial.push
                    ( /*<<polyfill/json2.js 339 41>>*/ quote(k)
                     +
                     (gap?": ":":")
                     +
                     v)}}
             else
               /*<<polyfill/json2.js 347 19>>*/ for(k in value)
                /*<<polyfill/json2.js 351 33>>*/ if
                ( /*<<polyfill/json2.js 352 24>>*/ Object.prototype.hasOwnProperty.call
                  (value,k))
                 /*<<polyfill/json2.js 352 72>>*/ {v
                 =
                  /*<<polyfill/json2.js 353 28>>*/ str(k,value);
                  /*<<polyfill/json2.js 354 24>>*/ if(v)
                   /*<<polyfill/json2.js 354 31>>*/  /*<<polyfill/json2.js 355 28>>*/ partial.push
                   ( /*<<polyfill/json2.js 355 41>>*/ quote(k)
                    +
                    (gap?": ":":")
                    +
                    v)}
             v
             =
             partial.length === 0
              ?"{}"
              :gap
                ?"{\n"
                 +
                 gap
                 +
                  /*<<polyfill/json2.js 371 36>>*/ partial.join(",\n" + gap)
                 +
                 "\n"
                 +
                 mind
                 +
                 "}"
                :"{"
                 +
                  /*<<polyfill/json2.js 372 28>>*/ partial.join(",")
                 +
                 "}";
             gap = mind;
              /*<<polyfill/json2.js 374 12>>*/ return v
            } /*<<polyfill/json2.js 376 4>>*/ }
         /*<<polyfill/json2.js 380 4>>*/ if
         (typeof JSON.stringify !== "function")
          /*<<polyfill/json2.js 380 46>>*/ {meta
          =
          {"\b":"\\b",
           "\t":"\\t",
           "\n":"\\n",
           "\f":"\\f",
           "\r":"\\r",
           '"':'\\"',
           "\\":"\\\\"};
          JSON.stringify
          =
          function(value,replacer,space)
           { /*<<polyfill/json2.js 398 12>>*/ var i;
            gap = "";
            indent = "";
             /*<<polyfill/json2.js 405 12>>*/ if(typeof space === "number")
              /*<<polyfill/json2.js 405 43>>*/ for(i = 0;i < space;i += 1)
               /*<<polyfill/json2.js 406 47>>*/ indent += " ";
            else
              /*<<polyfill/json2.js 412 19>>*/ if(typeof space === "string")
               /*<<polyfill/json2.js 412 50>>*/ indent = space;
            rep = replacer;
             /*<<polyfill/json2.js 420 12>>*/ if
             (replacer
              &&
              typeof replacer
              !==
              "function"
              &&
              (typeof replacer
               !==
               "object"
               ||
               typeof replacer.length
               !==
               "number"))
              /*<<polyfill/json2.js 422 58>>*/ throw new
                    Error
                    ("JSON.stringify");
             /*<<polyfill/json2.js 429 12>>*/ return  /*<<polyfill/json2.js 429 19>>*/ str
                    ("",{"":value}) /*<<polyfill/json2.js 390 25>>*/ }}
         /*<<polyfill/json2.js 436 4>>*/ if(typeof JSON.parse !== "function")
          /*<<polyfill/json2.js 436 42>>*/ JSON.parse
         =
         function(text,reviver)
          { /*<<polyfill/json2.js 442 12>>*/ var j;
            /*<<polyfill/json2.js 444 12>>*/ function walk(holder,key)
            { /*<<polyfill/json2.js 449 16>>*/ var
              k,
              v,
               /*<<polyfill/json2.js 449 32>>*/ value=holder[key];
              /*<<polyfill/json2.js 450 16>>*/ if
              (value && typeof value === "object")
               /*<<polyfill/json2.js 450 56>>*/ for(k in value)
                /*<<polyfill/json2.js 451 37>>*/ if
                ( /*<<polyfill/json2.js 452 28>>*/ Object.prototype.hasOwnProperty.call
                  (value,k))
                 /*<<polyfill/json2.js 452 76>>*/ {v
                 =
                  /*<<polyfill/json2.js 453 32>>*/ walk(value,k);
                  /*<<polyfill/json2.js 454 28>>*/ if(v !== undefined)
                   /*<<polyfill/json2.js 454 49>>*/ value[k] = v;
                 else
                   /*<<polyfill/json2.js 456 35>>*/ delete value[k]}
              /*<<polyfill/json2.js 462 16>>*/ return  /*<<polyfill/json2.js 462 23>>*/ reviver.call
                     (holder,key,value) /*<<polyfill/json2.js 463 12>>*/ }
           text =  /*<<polyfill/json2.js 470 19>>*/ String(text);
           rx_dangerous.lastIndex = 0;
            /*<<polyfill/json2.js 472 12>>*/ if
            ( /*<<polyfill/json2.js 472 16>>*/ rx_dangerous.test(text))
             /*<<polyfill/json2.js 472 41>>*/ text
            =
             /*<<polyfill/json2.js 473 23>>*/ text.replace
             (rx_dangerous,
              function(a)
               { /*<<polyfill/json2.js 474 20>>*/ return "\\u"
                       +
                        /*<<polyfill/json2.js 475 28>>*/ ("0000"
                         +
                          /*<<polyfill/json2.js 475 38>>*/  /*<<polyfill/json2.js 475 38>>*/ a.charCodeAt
                           (0).toString
                          (16)).slice
                        (- 4) /*<<polyfill/json2.js 473 50>>*/ });
            /*<<polyfill/json2.js 492 12>>*/ if
            ( /*<<polyfill/json2.js 493 16>>*/ rx_one.test
              ( /*<<polyfill/json2.js 494 20>>*/  /*<<polyfill/json2.js 494 20>>*/  /*<<polyfill/json2.js 494 20>>*/ text.replace
                  (rx_two,"@").replace
                 (rx_three,"]").replace
                (rx_four,"")))
             /*<<polyfill/json2.js 499 14>>*/ {j
             =
              /*<<polyfill/json2.js 506 20>>*/ eval("(" + text + ")");
              /*<<polyfill/json2.js 511 16>>*/ return typeof reviver
                     ===
                     "function"
                     ? /*<<polyfill/json2.js 512 22>>*/ walk({"":j},"")
                     :j}
            /*<<polyfill/json2.js 518 12>>*/ throw new
                  SyntaxError
                  ("JSON.parse") /*<<polyfill/json2.js 437 21>>*/ } /*<<polyfill/json2.js 175 1>>*/ }
      ());
     /*<<polyfill/json2.js 525 0>>*/ function caml_json()
     { /*<<polyfill/json2.js 525 23>>*/ return JSON /*<<polyfill/json2.js 525 36>>*/ }
     /*<<jslib.js 75 0>>*/ function caml_trampoline(res)
     { /*<<jslib.js 76 2>>*/  /*<<jslib.js 76 8>>*/ var c=1;
       /*<<jslib.js 77 2>>*/ while(res && res.joo_tramp)
        /*<<jslib.js 77 29>>*/ {res
        =
         /*<<jslib.js 78 10>>*/ res.joo_tramp.apply(null,res.joo_args);
        c++}
       /*<<jslib.js 81 2>>*/ return res /*<<jslib.js 82 0>>*/ }
     /*<<unix.js 39 0>>*/ function unix_mktime(tm)
     { /*<<unix.js 40 4>>*/ var
        /*<<unix.js 40 10>>*/ d=
        new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]),
        /*<<unix.js 41 10>>*/ t=
         /*<<unix.js 41 12>>*/ Math.floor
         ( /*<<unix.js 41 23>>*/ d.getTime() / 1e3),
        /*<<unix.js 42 12>>*/ tm2= /*<<unix.js 42 14>>*/ unix_localtime(t);
       /*<<unix.js 43 4>>*/ return [0,t,tm2] /*<<unix.js 44 0>>*/ }
     /*<<mlString.js 306 0>>*/ function caml_bytes_get64(s,i)
     { /*<<mlString.js 307 2>>*/ if(i >>> 0 >= s.l + 7)
        /*<<mlString.js 307 26>>*/ caml_string_bound_error();
       /*<<mlString.js 308 2>>*/  /*<<mlString.js 308 8>>*/ var
       a=
        new Array(8);
       /*<<mlString.js 309 2>>*/ for
       ( /*<<mlString.js 309 12>>*/ var j=0;j < 8;j++)
        /*<<mlString.js 309 28>>*/ a[7 - j]
       =
        /*<<mlString.js 310 15>>*/ caml_string_unsafe_get(s,i + j);
       /*<<mlString.js 312 2>>*/ return  /*<<mlString.js 312 9>>*/ caml_int64_of_bytes
              (a) /*<<mlString.js 313 0>>*/ }
     /*<<weak.js 44 0>>*/ function caml_weak_set(x,i,v)
     { /*<<weak.js 45 4>>*/ if(i < 0 || caml_ephe_key_offset + i >= x.length)
        /*<<weak.js 46 6>>*/ caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
       /*<<weak.js 48 4>>*/ return 0 /*<<weak.js 49 0>>*/ }
     /*<<fs.js 171 0>>*/ function caml_sys_remove(name)
     { /*<<fs.js 172 2>>*/ var
        /*<<fs.js 172 11>>*/ root=
         /*<<fs.js 172 13>>*/ resolve_fs_device(name),
        /*<<fs.js 173 9>>*/ ok=
         /*<<fs.js 173 11>>*/ root.device.unlink(root.rest);
       /*<<fs.js 174 2>>*/ if(ok == 0)
        /*<<fs.js 174 14>>*/ caml_raise_no_such_file(name);
       /*<<fs.js 175 2>>*/ return 0 /*<<fs.js 176 0>>*/ }
     /*<<fs.js 105 0>>*/ function caml_unmount(name)
     { /*<<fs.js 106 2>>*/ var
        /*<<fs.js 106 11>>*/ path= /*<<fs.js 106 13>>*/ caml_make_path(name),
        /*<<fs.js 107 11>>*/ name= /*<<fs.js 107 13>>*/ path.join("/") + "/",
        /*<<fs.js 108 10>>*/ idx=- 1;
       /*<<fs.js 109 2>>*/ for
       ( /*<<fs.js 109 12>>*/ var i=0;i < jsoo_mount_point.length;i++)
        /*<<fs.js 110 4>>*/ if(jsoo_mount_point[i].path == name)idx = i;
       /*<<fs.js 111 2>>*/ if(idx > - 1)
        /*<<fs.js 111 15>>*/ jsoo_mount_point.splice(idx,1);
       /*<<fs.js 112 2>>*/ return 0 /*<<fs.js 113 0>>*/ }
     /*<<mlString.js 271 0>>*/ function caml_string_get32(s,i)
     { /*<<mlString.js 272 2>>*/ if(i >>> 0 >= s.l + 3)
        /*<<mlString.js 272 26>>*/ caml_string_bound_error();
       /*<<mlString.js 273 2>>*/ var
        /*<<mlString.js 273 9>>*/ b1=
         /*<<mlString.js 273 11>>*/ caml_string_unsafe_get(s,i),
        /*<<mlString.js 274 9>>*/ b2=
         /*<<mlString.js 274 11>>*/ caml_string_unsafe_get(s,i + 1),
        /*<<mlString.js 275 9>>*/ b3=
         /*<<mlString.js 275 11>>*/ caml_string_unsafe_get(s,i + 2),
        /*<<mlString.js 276 9>>*/ b4=
         /*<<mlString.js 276 11>>*/ caml_string_unsafe_get(s,i + 3);
       /*<<mlString.js 277 2>>*/ return b4 << 24 | b3 << 16 | b2 << 8 | b1 /*<<mlString.js 278 0>>*/ }
     /*<<ieee_754.js 234 0>>*/ function caml_hypot_float(x,y)
     { /*<<ieee_754.js 235 2>>*/ var
        /*<<ieee_754.js 235 8>>*/ x= /*<<ieee_754.js 235 10>>*/ Math.abs(x),
        /*<<ieee_754.js 235 25>>*/ y= /*<<ieee_754.js 235 27>>*/ Math.abs(y),
        /*<<ieee_754.js 236 8>>*/ a= /*<<ieee_754.js 236 10>>*/ Math.max(x,y),
        /*<<ieee_754.js 236 28>>*/ b=
         /*<<ieee_754.js 236 30>>*/ Math.min(x,y)
        /
        (a?a:1);
       /*<<ieee_754.js 237 2>>*/ return a
             *
              /*<<ieee_754.js 237 14>>*/ Math.sqrt(1 + b * b) /*<<ieee_754.js 238 0>>*/ }
     /*<<ieee_754.js 144 0>>*/ function caml_int32_float_of_bits(x)
     { /*<<ieee_754.js 145 2>>*/  /*<<ieee_754.js 145 13>>*/ var
       int32a=
        new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
       /*<<ieee_754.js 145 2>>*/  /*<<ieee_754.js 147 15>>*/ var
       float32a=
        new (joo_global_object.Float32Array)(int32a.buffer);
       /*<<ieee_754.js 148 2>>*/ return float32a[0] /*<<ieee_754.js 149 0>>*/ }
     /*<<io.js 308 0>>*/ function caml_ml_pos_in_64(chanid)
     { /*<<io.js 308 36>>*/ return  /*<<io.js 308 43>>*/ caml_int64_of_float
              (caml_ml_channels[chanid].offset) /*<<io.js 308 95>>*/ }
     /*<<jslib_js_of_ocaml.js 54 0>>*/ function caml_js_call(f,o,args)
     { /*<<jslib_js_of_ocaml.js 54 36>>*/ return  /*<<jslib_js_of_ocaml.js 54 43>>*/ f.apply
              (o, /*<<jslib_js_of_ocaml.js 54 54>>*/ caml_js_from_array(args)) /*<<jslib_js_of_ocaml.js 54 81>>*/ }
     /*<<stdlib.js 1215 0>>*/ function caml_register_channel_for_spacetime
     (_channel)
     { /*<<stdlib.js 1216 2>>*/ return 0 /*<<stdlib.js 1217 0>>*/ }
     /*<<mlString.js 324 0>>*/ function caml_string_set(s,i,c)
     { /*<<mlString.js 325 2>>*/ if(i >>> 0 >= s.l)
        /*<<mlString.js 325 22>>*/ caml_string_bound_error();
       /*<<mlString.js 326 2>>*/ return  /*<<mlString.js 326 9>>*/ caml_string_unsafe_set
              (s,i,c) /*<<mlString.js 327 0>>*/ }
     /*<<stdlib.js 946 0>>*/ function caml_sys_const_max_wosize()
     { /*<<stdlib.js 946 40>>*/ return 2147483647 / 4 | 0 /*<<stdlib.js 946 66>>*/ }
     /*<<weak.js 117 0>>*/ function caml_ephe_unset_key(x,i)
     { /*<<weak.js 118 2>>*/ return  /*<<weak.js 118 9>>*/ caml_weak_set
              (x,i,0) /*<<weak.js 119 0>>*/ }
     /*<<io.js 412 0>>*/ function caml_ml_pos_out(chanid)
     { /*<<io.js 412 34>>*/ return caml_ml_channels[chanid].offset /*<<io.js 412 72>>*/ }
     /*<<stdlib.js 1210 0>>*/ function caml_spacetime_enabled(_unit)
     { /*<<stdlib.js 1211 2>>*/ return 0 /*<<stdlib.js 1212 0>>*/ }
     /*<<mlString.js 489 0>>*/ function caml_string_equal(s1,s2)
     { /*<<mlString.js 490 2>>*/ if(s1 === s2)
        /*<<mlString.js 490 16>>*/ return 1;
      s1.t
      &
      6
      &&
       /*<<mlString.js 491 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 492 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 493 2>>*/ return s1.c == s2.c?1:0 /*<<mlString.js 494 0>>*/ }
     /*<<mlString.js 511 0>>*/ function caml_bytes_notequal(s1,s2)
     { /*<<mlString.js 511 39>>*/ return 1
             -
              /*<<mlString.js 511 48>>*/ caml_string_equal(s1,s2) /*<<mlString.js 511 75>>*/ }
     /*<<jslib_js_of_ocaml.js 197 0>>*/ function caml_js_object(a)
     { /*<<jslib_js_of_ocaml.js 198 2>>*/  /*<<jslib_js_of_ocaml.js 198 8>>*/ var
       o=
        {};
       /*<<jslib_js_of_ocaml.js 199 2>>*/ for
       ( /*<<jslib_js_of_ocaml.js 199 13>>*/ var i=1;i < a.length;i++)
        /*<<jslib_js_of_ocaml.js 199 37>>*/ { /*<<jslib_js_of_ocaml.js 200 4>>*/  /*<<jslib_js_of_ocaml.js 200 10>>*/ var
         p=
          a[i];
        o[ /*<<jslib_js_of_ocaml.js 201 6>>*/ p[1].toString()] = p[2]}
       /*<<jslib_js_of_ocaml.js 203 2>>*/ return o /*<<jslib_js_of_ocaml.js 204 0>>*/ }
     /*<<stdlib.js 1199 0>>*/ function caml_runtime_parameters(_unit)
     { /*<<stdlib.js 1200 2>>*/ return  /*<<stdlib.js 1200 9>>*/ caml_new_string
              ("") /*<<stdlib.js 1201 0>>*/ }
     /*<<stdlib.js 1003 0>>*/ function caml_array_blit(a1,i1,a2,i2,len)
     { /*<<stdlib.js 1004 2>>*/ if(i2 <= i1)
        /*<<stdlib.js 1004 16>>*/ for
        ( /*<<stdlib.js 1005 15>>*/ var j=1;j <= len;j++)
        a2[i2 + j] = a1[i1 + j];
      else
        /*<<stdlib.js 1006 9>>*/ for
        ( /*<<stdlib.js 1007 15>>*/ var j=len;j >= 1;j--)
        a2[i2 + j] = a1[i1 + j];
       /*<<stdlib.js 1009 2>>*/ return 0 /*<<stdlib.js 1010 0>>*/ }
     /*<<weak.js 81 0>>*/ function caml_weak_blit(a1,i1,a2,i2,len)
     { /*<<weak.js 83 2>>*/ caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
       /*<<weak.js 86 2>>*/ return 0 /*<<weak.js 87 0>>*/ }
     /*<<mlString.js 539 0>>*/ function caml_bytes_lessthan(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 540 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 541 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 542 2>>*/ return s1.c < s2.c?1:0 /*<<mlString.js 543 0>>*/ }
     /*<<gc.js 14 0>>*/ function caml_gc_quick_stat()
     { /*<<gc.js 15 2>>*/ return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] /*<<gc.js 16 0>>*/ }
     /*<<io.js 268 0>>*/ function caml_ml_input_int(chanid)
     { /*<<io.js 269 2>>*/ var
        /*<<io.js 269 11>>*/ chan=caml_ml_channels[chanid],
        /*<<io.js 270 11>>*/ file=chan.file;
       /*<<io.js 271 2>>*/ while
       (chan.offset + 3 >=  /*<<io.js 271 30>>*/ file.length())
        /*<<io.js 271 45>>*/ { /*<<io.js 272 4>>*/  /*<<io.js 272 10>>*/ var
         l=
           /*<<io.js 272 12>>*/ caml_ml_refill_input(chan);
         /*<<io.js 273 4>>*/ if(l == 0)
          /*<<io.js 273 16>>*/ caml_raise_end_of_file()}
       /*<<io.js 269 2>>*/ var
        /*<<io.js 275 8>>*/ o=chan.offset,
        /*<<io.js 276 8>>*/ r=
         /*<<io.js 276 10>>*/ file.read_one(o)
        <<
        24
        |
         /*<<io.js 277 10>>*/ file.read_one(o + 1)
        <<
        16
        |
         /*<<io.js 278 10>>*/ file.read_one(o + 2)
        <<
        8
        |
         /*<<io.js 279 10>>*/ file.read_one(o + 3);
      chan.offset += 4;
       /*<<io.js 281 2>>*/ return r /*<<io.js 282 0>>*/ }
     /*<<stdlib.js 1141 0>>*/ function caml_bswap16(x)
     { /*<<stdlib.js 1142 2>>*/ return (x & 255) << 8 | (x & 65280) >> 8 /*<<stdlib.js 1144 0>>*/ }
     /*<<io.js 150 0>>*/ function caml_ml_set_binary_mode(chanid,mode)
     { /*<<io.js 151 2>>*/ var
        /*<<io.js 151 11>>*/ chan=caml_ml_channels[chanid],
        /*<<io.js 152 11>>*/ data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
       /*<<io.js 155 2>>*/ return 0 /*<<io.js 156 0>>*/ }
     /*<<stdlib.js 1037 0>>*/ function caml_final_register()
     { /*<<stdlib.js 1037 34>>*/ return 0 /*<<stdlib.js 1037 44>>*/ }
     /*<<fs.js 117 0>>*/ function caml_sys_getcwd()
     { /*<<fs.js 118 2>>*/ return  /*<<fs.js 118 9>>*/ caml_new_string
              (caml_current_dir) /*<<fs.js 119 0>>*/ }
     /*<<stdlib.js 500 0>>*/ function caml_float_of_string(s)
     { /*<<stdlib.js 501 2>>*/ var res;
      s =  /*<<stdlib.js 502 6>>*/ caml_jsbytes_of_string(s);
      res = + s;
       /*<<stdlib.js 504 2>>*/ if(s.length > 0 && res === res)
        /*<<stdlib.js 504 39>>*/ return res;
      s =  /*<<stdlib.js 505 6>>*/ s.replace(/_/g,"");
      res = + s;
       /*<<stdlib.js 507 2>>*/ if
       (s.length
        >
        0
        &&
        res
        ===
        res
        ||
         /*<<stdlib.js 507 43>>*/ /^[+-]?nan$/i.test(s))
        /*<<stdlib.js 507 66>>*/ return res;
       /*<<stdlib.js 501 2>>*/  /*<<stdlib.js 508 8>>*/ var
       m=
         /*<<stdlib.js 508 10>>*/ /^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec
         (s);
       /*<<stdlib.js 510 2>>*/ if(m)
        /*<<stdlib.js 510 7>>*/ { /*<<stdlib.js 511 4>>*/ var
          /*<<stdlib.js 511 11>>*/ m3=
           /*<<stdlib.js 511 13>>*/ m[3].replace(/0+$/,""),
          /*<<stdlib.js 512 17>>*/ mantissa=
           /*<<stdlib.js 512 19>>*/ parseInt(m[1] + m[2] + m3,16),
          /*<<stdlib.js 513 17>>*/ exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa *  /*<<stdlib.js 514 21>>*/ Math.pow(2,exponent);
         /*<<stdlib.js 515 4>>*/ return res}
       /*<<stdlib.js 517 2>>*/ if
       ( /*<<stdlib.js 517 5>>*/ /^\+?inf(inity)?$/i.test(s))
        /*<<stdlib.js 517 34>>*/ return Infinity;
       /*<<stdlib.js 518 2>>*/ if
       ( /*<<stdlib.js 518 5>>*/ /^-inf(inity)?$/i.test(s))
        /*<<stdlib.js 518 32>>*/ return - Infinity;
       /*<<stdlib.js 519 2>>*/ caml_failwith("float_of_string") /*<<stdlib.js 520 0>>*/ }
     /*<<mlString.js 253 0>>*/ function caml_string_get16(s,i)
     { /*<<mlString.js 254 2>>*/ if(i >>> 0 >= s.l + 1)
        /*<<mlString.js 254 26>>*/ caml_string_bound_error();
       /*<<mlString.js 255 2>>*/ var
        /*<<mlString.js 255 9>>*/ b1=
         /*<<mlString.js 255 11>>*/ caml_string_unsafe_get(s,i),
        /*<<mlString.js 256 9>>*/ b2=
         /*<<mlString.js 256 11>>*/ caml_string_unsafe_get(s,i + 1);
       /*<<mlString.js 257 2>>*/ return b2 << 8 | b1 /*<<mlString.js 258 0>>*/ }
     /*<<stdlib.js 937 0>>*/ function caml_sys_const_big_endian()
     { /*<<stdlib.js 937 40>>*/ return 0 /*<<stdlib.js 937 50>>*/ }
     /*<<weak.js 161 0>>*/ function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;
       /*<<weak.js 163 2>>*/ return 0 /*<<weak.js 164 0>>*/ }
     /*<<marshal.js 447 0>>*/ function caml_output_value_to_string(v,_fl)
     { /*<<marshal.js 449 2>>*/ return  /*<<marshal.js 449 9>>*/ caml_string_of_array
              ( /*<<marshal.js 449 31>>*/ caml_output_val(v)) /*<<marshal.js 450 0>>*/ }
     /*<<io.js 389 0>>*/ function caml_output_value(chanid,v,_flags)
     { /*<<io.js 390 2>>*/  /*<<io.js 390 8>>*/ var
       s=
         /*<<io.js 390 10>>*/ caml_output_value_to_string(v);
       /*<<io.js 391 2>>*/ caml_ml_output
       (chanid,s,0, /*<<io.js 391 28>>*/ caml_ml_string_length(s));
       /*<<io.js 392 2>>*/ return 0 /*<<io.js 393 0>>*/ }
     /*<<stdlib.js 956 0>>*/ function caml_sys_system_command(cmd)
     { /*<<stdlib.js 957 2>>*/  /*<<stdlib.js 957 10>>*/ var
       cmd=
         /*<<stdlib.js 957 12>>*/ cmd.toString();
       /*<<stdlib.js 958 2>>*/ joo_global_object.console.log(cmd);
       /*<<stdlib.js 959 2>>*/ if
       (typeof require
        !=
        "undefined"
        &&
         /*<<stdlib.js 960 9>>*/ require("child_process")
        &&
         /*<<stdlib.js 961 9>>*/ require("child_process").execSync)
        /*<<stdlib.js 961 44>>*/ try
        { /*<<stdlib.js 962 9>>*/  /*<<stdlib.js 962 9>>*/ require
           ("child_process").execSync
          (cmd);
          /*<<stdlib.js 962 49>>*/ return 0}
       catch(e){ /*<<stdlib.js 963 15>>*/ return 1}
      else
        /*<<stdlib.js 965 7>>*/ return 127 /*<<stdlib.js 966 0>>*/ }
     /*<<bigarray.js 551 0>>*/ function caml_ba_get_3(ba,i0,i1,i2)
     { /*<<bigarray.js 552 4>>*/ return  /*<<bigarray.js 552 11>>*/ ba.get
              ([i0,i1,i2]) /*<<bigarray.js 553 0>>*/ }
     /*<<weak.js 95 0>>*/  /*<<weak.js 95 23>>*/ var
     caml_ephe_blit_key=
      caml_weak_blit;
     /*<<stdlib.js 178 0>>*/ function caml_js_error_of_exception(exn)
     { /*<<stdlib.js 179 2>>*/ if(exn.js_error)
        /*<<stdlib.js 179 19>>*/ return exn.js_error;
       /*<<stdlib.js 180 2>>*/ return null /*<<stdlib.js 181 0>>*/ }
     /*<<stdlib.js 298 0>>*/ function caml_check_bound(array,index)
     { /*<<stdlib.js 299 2>>*/ if(index >>> 0 >= array.length - 1)
        /*<<stdlib.js 299 39>>*/ caml_array_bound_error();
       /*<<stdlib.js 300 2>>*/ return array /*<<stdlib.js 301 0>>*/ }
     /*<<mlString.js 642 0>>*/ function caml_bytes_of_string(s)
     { /*<<mlString.js 642 35>>*/ return s /*<<mlString.js 642 43>>*/ }
     /*<<stdlib.js 771 0>>*/ function caml_hash_mix_int64(h,v)
     { /*<<stdlib.js 772 2>>*/ var
        /*<<stdlib.js 772 9>>*/ lo=v[1] | v[2] << 24,
        /*<<stdlib.js 773 9>>*/ hi=v[2] >>> 8 | v[3] << 16;
      h =  /*<<stdlib.js 774 6>>*/ caml_hash_mix_int(h,hi ^ lo);
       /*<<stdlib.js 775 2>>*/ return h /*<<stdlib.js 776 0>>*/ }
     /*<<stdlib.js 828 0>>*/ function caml_hash_mix_string(h,v)
     { /*<<stdlib.js 829 4>>*/ switch(v.t & 6)
       {default: /*<<stdlib.js 831 8>>*/ caml_convert_string_to_bytes(v);case 0:
         h =  /*<<stdlib.js 833 12>>*/ caml_hash_mix_string_str(h,v.c);
          /*<<stdlib.js 834 8>>*/ break;
        case 2:h =  /*<<stdlib.js 836 12>>*/ caml_hash_mix_string_arr(h,v.c)
        }
       /*<<stdlib.js 838 4>>*/ return h /*<<stdlib.js 839 0>>*/ }
     /*<<stdlib.js 846 0>>*/  /*<<stdlib.js 846 20>>*/ var
     HASH_QUEUE_SIZE=
      256;
     /*<<stdlib.js 847 0>>*/ function caml_hash(count,limit,seed,obj)
     { /*<<stdlib.js 848 4>>*/ var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
       /*<<stdlib.js 850 4>>*/ if(sz < 0 || sz > HASH_QUEUE_SIZE)
       sz = HASH_QUEUE_SIZE;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
       /*<<stdlib.js 854 4>>*/ while(rd < wr && num > 0)
        /*<<stdlib.js 854 31>>*/ {v = queue[rd++];
         /*<<stdlib.js 856 8>>*/ if(v instanceof Array && v[0] === (v[0] | 0))
          /*<<stdlib.js 856 53>>*/ switch(v[0])
          {case 248:
            h =  /*<<stdlib.js 860 20>>*/ caml_hash_mix_int(h,v[2]);
            num--;
             /*<<stdlib.js 862 16>>*/ break;
           case 250:queue[--rd] = v[1]; /*<<stdlib.js 866 16>>*/ break;
           case 255:
            h =  /*<<stdlib.js 869 20>>*/ caml_hash_mix_int64(h,v);
            num--;
             /*<<stdlib.js 871 16>>*/ break;
           default:
             /*<<stdlib.js 873 16>>*/  /*<<stdlib.js 873 24>>*/ var
             tag=
              v.length - 1 << 10 | v[0];
            h =  /*<<stdlib.js 874 20>>*/ caml_hash_mix_int(h,tag);
             /*<<stdlib.js 875 16>>*/ for(i = 1,len = v.length;i < len;i++)
              /*<<stdlib.js 875 58>>*/ { /*<<stdlib.js 876 20>>*/ if(wr >= sz)
                /*<<stdlib.js 876 34>>*/ break;
              queue[wr++] = v[i]}
             /*<<stdlib.js 879 16>>*/ break}
        else
          /*<<stdlib.js 881 15>>*/ if(v instanceof MlBytes)
           /*<<stdlib.js 881 41>>*/ {h
           =
            /*<<stdlib.js 882 16>>*/ caml_hash_mix_string(h,v);
           num--}
         else
           /*<<stdlib.js 884 15>>*/ if(v === (v | 0))
            /*<<stdlib.js 884 32>>*/ {h
            =
             /*<<stdlib.js 886 16>>*/ caml_hash_mix_int(h,v + v + 1);
            num--}
          else
            /*<<stdlib.js 888 15>>*/ if(v === + v)
             /*<<stdlib.js 888 29>>*/ {h
             =
              /*<<stdlib.js 890 16>>*/ caml_hash_mix_float(h,v);
             num--}
           else
             /*<<stdlib.js 892 15>>*/ if
             (v && v.hash && typeof v.hash === "function")
              /*<<stdlib.js 892 63>>*/ h
             =
              /*<<stdlib.js 894 9>>*/ caml_hash_mix_int
              (h, /*<<stdlib.js 894 30>>*/ v.hash())}
      h =  /*<<stdlib.js 897 8>>*/ caml_hash_mix_final(h);
       /*<<stdlib.js 898 4>>*/ return h & 1073741823 /*<<stdlib.js 899 0>>*/ }
     /*<<bigstring.js 75 0>>*/ function bigstring_memcmp_stub
     (v_s1,v_s1_pos,v_s2,v_s2_pos,v_len)
     { /*<<bigstring.js 76 2>>*/ for
       ( /*<<bigstring.js 76 13>>*/ var i=0;i < v_len;i++)
        /*<<bigstring.js 76 34>>*/ { /*<<bigstring.js 77 4>>*/ var
          /*<<bigstring.js 77 10>>*/ a=
           /*<<bigstring.js 77 12>>*/ caml_ba_get_1(v_s1,v_s1_pos + i),
          /*<<bigstring.js 78 10>>*/ b=
           /*<<bigstring.js 78 12>>*/ caml_ba_get_1(v_s2,v_s2_pos + i);
         /*<<bigstring.js 79 4>>*/ if(a < b)
          /*<<bigstring.js 79 15>>*/ return - 1;
         /*<<bigstring.js 80 4>>*/ if(a > b)
          /*<<bigstring.js 80 15>>*/ return 1}
       /*<<bigstring.js 82 2>>*/ return 0 /*<<bigstring.js 83 0>>*/ }
     /*<<stdlib.js 224 0>>*/ function caml_obj_tag(x)
     { /*<<stdlib.js 224 28>>*/ return x instanceof Array
              ?x[0]
              :x instanceof MlBytes?252:1e3 /*<<stdlib.js 224 94>>*/ }
     /*<<jslib_js_of_ocaml.js 208 0>>*/ function caml_js_export_var()
     { /*<<jslib_js_of_ocaml.js 209 2>>*/ return typeof module
              !==
              "undefined"
              &&
              module
              &&
              module.exports
              ?module.exports
              :joo_global_object /*<<jslib_js_of_ocaml.js 213 0>>*/ }
     /*<<ieee_754.js 193 0>>*/ function caml_frexp_float(x)
     { /*<<ieee_754.js 194 2>>*/ if
       (x == 0 || !  /*<<ieee_754.js 194 19>>*/ isFinite(x))
        /*<<ieee_754.js 194 32>>*/ return [0,x,0];
       /*<<ieee_754.js 195 2>>*/  /*<<ieee_754.js 195 10>>*/ var neg=x < 0;
       /*<<ieee_754.js 196 2>>*/ if(neg)x = - x;
       /*<<ieee_754.js 195 2>>*/  /*<<ieee_754.js 197 10>>*/ var
       exp=
         /*<<ieee_754.js 197 12>>*/ jsoo_floor_log2(x) + 1;
      x *=  /*<<ieee_754.js 198 7>>*/ Math.pow(2,- exp);
       /*<<ieee_754.js 199 2>>*/ if(x < 0.5)
        /*<<ieee_754.js 199 15>>*/ {x *= 2;exp -= 1}
       /*<<ieee_754.js 200 2>>*/ if(neg)x = - x;
       /*<<ieee_754.js 201 2>>*/ return [0,x,exp] /*<<ieee_754.js 202 0>>*/ }
     /*<<mlString.js 282 0>>*/ function caml_bytes_get32(s,i)
     { /*<<mlString.js 283 2>>*/ if(i >>> 0 >= s.l + 3)
        /*<<mlString.js 283 26>>*/ caml_string_bound_error();
       /*<<mlString.js 284 2>>*/ var
        /*<<mlString.js 284 9>>*/ b1=
         /*<<mlString.js 284 11>>*/ caml_string_unsafe_get(s,i),
        /*<<mlString.js 285 9>>*/ b2=
         /*<<mlString.js 285 11>>*/ caml_string_unsafe_get(s,i + 1),
        /*<<mlString.js 286 9>>*/ b3=
         /*<<mlString.js 286 11>>*/ caml_string_unsafe_get(s,i + 2),
        /*<<mlString.js 287 9>>*/ b4=
         /*<<mlString.js 287 11>>*/ caml_string_unsafe_get(s,i + 3);
       /*<<mlString.js 288 2>>*/ return b4 << 24 | b3 << 16 | b2 << 8 | b1 /*<<mlString.js 289 0>>*/ }
     /*<<bigstring.js 58 0>>*/ function bigstring_blit_bytes_bigstring_stub
     (v_str,v_src_pos,v_bstr,v_dst_pos,v_len)
     { /*<<bigstring.js 59 2>>*/ for
       ( /*<<bigstring.js 59 13>>*/ var i=0;i < v_len;i++)
        /*<<bigstring.js 59 34>>*/ caml_ba_set_1
        (v_bstr,
         v_dst_pos + i,
          /*<<bigstring.js 59 69>>*/ caml_bytes_get(v_str,v_src_pos + i));
       /*<<bigstring.js 60 2>>*/ return 0 /*<<bigstring.js 61 0>>*/ }
     /*<<ieee_754.js 215 0>>*/ function caml_copysign_float(x,y)
     { /*<<ieee_754.js 216 2>>*/ if(y == 0)y = 1 / y;
      x =  /*<<ieee_754.js 217 6>>*/ Math.abs(x);
       /*<<ieee_754.js 218 2>>*/ return y < 0?- x:x /*<<ieee_754.js 219 0>>*/ }
     /*<<bigarray.js 557 0>>*/ function caml_ba_set_generic(ba,index,v)
     { /*<<bigarray.js 558 4>>*/ return  /*<<bigarray.js 558 11>>*/ ba.set
              ( /*<<bigarray.js 558 18>>*/ caml_js_from_array(index),v) /*<<bigarray.js 559 0>>*/ }
     /*<<weak.js 111 0>>*/ function caml_ephe_set_key(x,i,v)
     { /*<<weak.js 112 2>>*/ return  /*<<weak.js 112 9>>*/ caml_weak_set
              (x,i,[0,v]) /*<<weak.js 113 0>>*/ }
     /*<<io.js 416 0>>*/ function caml_ml_pos_out_64(chanid)
     { /*<<io.js 417 2>>*/ return  /*<<io.js 417 9>>*/ caml_int64_of_float
              (caml_ml_channels[chanid].offset) /*<<io.js 418 0>>*/ }
     /*<<mlString.js 294 0>>*/ function caml_string_get64(s,i)
     { /*<<mlString.js 295 2>>*/ if(i >>> 0 >= s.l + 7)
        /*<<mlString.js 295 26>>*/ caml_string_bound_error();
       /*<<mlString.js 296 2>>*/  /*<<mlString.js 296 8>>*/ var
       a=
        new Array(8);
       /*<<mlString.js 297 2>>*/ for
       ( /*<<mlString.js 297 12>>*/ var j=0;j < 8;j++)
        /*<<mlString.js 297 28>>*/ a[7 - j]
       =
        /*<<mlString.js 298 15>>*/ caml_string_unsafe_get(s,i + j);
       /*<<mlString.js 300 2>>*/ return  /*<<mlString.js 300 9>>*/ caml_int64_of_bytes
              (a) /*<<mlString.js 301 0>>*/ }
     /*<<mlString.js 515 0>>*/ function caml_string_lessequal(s1,s2)
     {s1.t
      &
      6
      &&
       /*<<mlString.js 516 16>>*/ caml_convert_string_to_bytes(s1);
      s2.t
      &
      6
      &&
       /*<<mlString.js 517 16>>*/ caml_convert_string_to_bytes(s2);
       /*<<mlString.js 518 2>>*/ return s1.c <= s2.c?1:0 /*<<mlString.js 519 0>>*/ }
     /*<<mlString.js 547 0>>*/ function caml_string_greaterequal(s1,s2)
     { /*<<mlString.js 548 2>>*/ return  /*<<mlString.js 548 9>>*/ caml_string_lessequal
              (s2,s1) /*<<mlString.js 549 0>>*/ }
     /*<<io.js 304 0>>*/ function caml_ml_pos_in(chanid)
     { /*<<io.js 304 33>>*/ return caml_ml_channels[chanid].offset /*<<io.js 304 71>>*/ }
     /*<<int64.js 105 0>>*/ function caml_int64_and(x,y)
     { /*<<int64.js 106 2>>*/ return [255,x[1] & y[1],x[2] & y[2],x[3] & y[3]] /*<<int64.js 107 0>>*/ }
     /*<<stdlib.js 939 0>>*/ function caml_sys_const_word_size()
     { /*<<stdlib.js 939 39>>*/ return 32 /*<<stdlib.js 939 50>>*/ }
     /*<<bigarray.js 462 0>>*/ function caml_ba_change_layout(ba,layout)
     { /*<<bigarray.js 463 2>>*/ if(ba.layout == layout)
        /*<<bigarray.js 463 26>>*/ return ba;
       /*<<bigarray.js 464 2>>*/  /*<<bigarray.js 464 11>>*/ var dims=[];
       /*<<bigarray.js 465 2>>*/ for
       ( /*<<bigarray.js 465 12>>*/ var i=0;i < ba.num_dims;i++)
       dims[i] =  /*<<bigarray.js 466 14>>*/ ba.nth_dim(i);
       /*<<bigarray.js 467 2>>*/ return  /*<<bigarray.js 467 9>>*/ caml_ba_create_from
              (ba.data,ba.data2,ba.data_type,ba.kind,layout,dims) /*<<bigarray.js 468 0>>*/ }
     /*<<marshal.js 139 0>>*/ function caml_input_value_from_bytes(s,ofs)
     { /*<<marshal.js 140 2>>*/  /*<<marshal.js 140 13>>*/ var
       reader=
        new MlBytesReader(s,typeof ofs == "number"?ofs:ofs[0]);
       /*<<marshal.js 141 2>>*/ return  /*<<marshal.js 141 9>>*/ caml_input_value_from_reader
              (reader,ofs) /*<<marshal.js 142 0>>*/ }
     /*<<jslib_js_of_ocaml.js 78 0>>*/ function caml_js_new(c,a)
     { /*<<jslib_js_of_ocaml.js 79 2>>*/ switch(a.length)
       {case 1: /*<<jslib_js_of_ocaml.js 80 10>>*/ return new c();
        case 2: /*<<jslib_js_of_ocaml.js 81 10>>*/ return new c(a[1]);
        case 3: /*<<jslib_js_of_ocaml.js 82 10>>*/ return new c(a[1],a[2]);
        case 4:
          /*<<jslib_js_of_ocaml.js 83 10>>*/ return new c(a[1],a[2],a[3]);
        case 5:
          /*<<jslib_js_of_ocaml.js 84 10>>*/ return new c(a[1],a[2],a[3],a[4]);
        case 6:
          /*<<jslib_js_of_ocaml.js 85 10>>*/ return new
                 c
                 (a[1],a[2],a[3],a[4],a[5]);
        case 7:
          /*<<jslib_js_of_ocaml.js 86 10>>*/ return new
                 c
                 (a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:
          /*<<jslib_js_of_ocaml.js 87 10>>*/ return new
                 c
                 (a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
       /*<<jslib_js_of_ocaml.js 89 2>>*/ function F()
       { /*<<jslib_js_of_ocaml.js 89 17>>*/ return  /*<<jslib_js_of_ocaml.js 89 24>>*/ c.apply
                (this,
                  /*<<jslib_js_of_ocaml.js 89 38>>*/ caml_js_from_array(a)) /*<<jslib_js_of_ocaml.js 89 62>>*/ }
      F.prototype = c.prototype;
       /*<<jslib_js_of_ocaml.js 91 2>>*/ return new F() /*<<jslib_js_of_ocaml.js 92 0>>*/ }
     /*<<stdlib.js 614 0>>*/ function caml_format_int(fmt,i)
     { /*<<stdlib.js 615 2>>*/ if
       ( /*<<stdlib.js 615 6>>*/ caml_jsbytes_of_string(fmt) == "%d")
        /*<<stdlib.js 615 43>>*/ return  /*<<stdlib.js 615 50>>*/ caml_new_string
               ("" + i);
       /*<<stdlib.js 616 2>>*/  /*<<stdlib.js 616 8>>*/ var
       f=
         /*<<stdlib.js 616 10>>*/ caml_parse_format(fmt);
       /*<<stdlib.js 617 2>>*/ if(i < 0)
        /*<<stdlib.js 617 13>>*/ if(f.signedconv)
         /*<<stdlib.js 617 33>>*/ {f.sign = - 1;i = - i}
       else
        i >>>= 0;
       /*<<stdlib.js 616 2>>*/  /*<<stdlib.js 618 8>>*/ var
       s=
         /*<<stdlib.js 618 10>>*/ i.toString(f.base);
       /*<<stdlib.js 619 2>>*/ if(f.prec >= 0)
        /*<<stdlib.js 619 19>>*/ {f.filler = " ";
         /*<<stdlib.js 621 4>>*/  /*<<stdlib.js 621 10>>*/ var
         n=
          f.prec - s.length;
         /*<<stdlib.js 622 4>>*/ if(n > 0)
         s =  /*<<stdlib.js 622 19>>*/ caml_str_repeat(n,"0") + s}
       /*<<stdlib.js 624 2>>*/ return  /*<<stdlib.js 624 9>>*/ caml_finish_formatting
              (f,s) /*<<stdlib.js 625 0>>*/ }
     /*<<jslib_js_of_ocaml.js 32 0>>*/ function caml_js_from_string(s)
     { /*<<jslib_js_of_ocaml.js 32 34>>*/ return  /*<<jslib_js_of_ocaml.js 32 41>>*/ s.toString
              () /*<<jslib_js_of_ocaml.js 32 55>>*/ }
     /*<<stdlib.js 243 0>>*/ function caml_obj_truncate(x,s)
     { /*<<stdlib.js 244 2>>*/ if(s <= 0 || s + 1 > x.length)
        /*<<stdlib.js 245 4>>*/ caml_invalid_argument("Obj.truncate");
       /*<<stdlib.js 246 2>>*/ if(x.length != s + 1)x.length = s + 1;
       /*<<stdlib.js 247 2>>*/ return 0 /*<<stdlib.js 248 0>>*/ }
     /*<<bigarray.js 618 0>>*/ function caml_ba_sub(ba,ofs,len)
     { /*<<bigarray.js 619 4>>*/ return  /*<<bigarray.js 619 11>>*/ ba.sub
              (ofs,len) /*<<bigarray.js 620 0>>*/ }
     /*<<gc.js 8 0>>*/ function caml_gc_full_major()
     { /*<<gc.js 8 31>>*/ return 0 /*<<gc.js 8 39>>*/ }
     /*<<int64.js 100 0>>*/ function caml_int64_is_minus_one(x)
     { /*<<int64.js 101 2>>*/ return x[3]
             ==
             65535
             &&
             (x[1] & x[2])
             ==
             16777215 /*<<int64.js 102 0>>*/ }
     /*<<mlString.js 348 0>>*/ function caml_bytes_set32(s,i,i32)
     { /*<<mlString.js 349 2>>*/ if(i >>> 0 >= s.l + 3)
        /*<<mlString.js 349 26>>*/ caml_string_bound_error();
       /*<<mlString.js 350 2>>*/ var
        /*<<mlString.js 350 9>>*/ b4=255 & i32 >> 24,
        /*<<mlString.js 351 9>>*/ b3=255 & i32 >> 16,
        /*<<mlString.js 352 9>>*/ b2=255 & i32 >> 8,
        /*<<mlString.js 353 9>>*/ b1=255 & i32;
       /*<<mlString.js 354 2>>*/ caml_string_unsafe_set(s,i + 0,b1);
       /*<<mlString.js 355 2>>*/ caml_string_unsafe_set(s,i + 1,b2);
       /*<<mlString.js 356 2>>*/ caml_string_unsafe_set(s,i + 2,b3);
       /*<<mlString.js 357 2>>*/ caml_string_unsafe_set(s,i + 3,b4);
       /*<<mlString.js 358 2>>*/ return 0 /*<<mlString.js 359 0>>*/ }
     /*<<io.js 114 0>>*/ function caml_ml_open_descriptor_out(fd)
     { /*<<io.js 115 2>>*/  /*<<io.js 115 11>>*/ var
       data=
        caml_global_data.fds[fd];
       /*<<io.js 116 2>>*/ if(data.flags.rdonly)
        /*<<io.js 116 24>>*/ caml_raise_sys_error("fd " + fd + " is readonly");
       /*<<io.js 115 2>>*/  /*<<io.js 117 14>>*/ var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
       /*<<io.js 126 2>>*/ return channel.fd /*<<io.js 127 0>>*/ }
     /*<<stdlib.js 1194 0>>*/ function caml_runtime_variant(_unit)
     { /*<<stdlib.js 1195 2>>*/ return  /*<<stdlib.js 1195 9>>*/ caml_new_string
              ("") /*<<stdlib.js 1196 0>>*/ }
     /*<<stdlib.js 992 0>>*/ function caml_array_concat(l)
     { /*<<stdlib.js 993 2>>*/  /*<<stdlib.js 993 8>>*/ var a=[0];
       /*<<stdlib.js 994 2>>*/ while(l !== 0)
        /*<<stdlib.js 994 18>>*/ { /*<<stdlib.js 995 4>>*/  /*<<stdlib.js 995 10>>*/ var
         b=
          l[1];
         /*<<stdlib.js 996 4>>*/ for
         ( /*<<stdlib.js 996 15>>*/ var i=1;i < b.length;i++)
          /*<<stdlib.js 996 39>>*/ a.push(b[i]);
        l = l[2]}
       /*<<stdlib.js 999 2>>*/ return a /*<<stdlib.js 1000 0>>*/ }
     /*<<bigarray.js 569 0>>*/ function caml_ba_uint8_set32(ba,i0,v)
     { /*<<bigarray.js 570 4>>*/ ba.set1(i0,v & 255);
       /*<<bigarray.js 571 4>>*/ ba.set1(i0 + 1,v >>> 8 & 255);
       /*<<bigarray.js 572 4>>*/ ba.set1(i0 + 2,v >>> 16 & 255);
       /*<<bigarray.js 573 4>>*/ ba.set1(i0 + 3,v >>> 24 & 255);
       /*<<bigarray.js 574 4>>*/ return 0 /*<<bigarray.js 575 0>>*/ }
     /*<<stdlib.js 951 0>>*/ function caml_sys_const_ostype_unix()
     { /*<<stdlib.js 951 41>>*/ return 1 /*<<stdlib.js 951 51>>*/ }
     /*<<weak.js 153 0>>*/ function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;
       /*<<weak.js 155 2>>*/ return 0 /*<<weak.js 156 0>>*/ }
     /*<<bigstring.js 110 0>>*/ function bigstring_marshal_data_size_stub
     (s,ofs)
     { /*<<bigstring.js 111 2>>*/ if
       ( /*<<bigstring.js 111 6>>*/ caml_ba_uint8_get32(s,ofs)
        !=
        (2224400062 | 0))
        /*<<bigstring.js 112 4>>*/ caml_failwith
        ("Marshal.data_size: bad object");
       /*<<bigstring.js 113 2>>*/ return  /*<<bigstring.js 113 10>>*/ caml_ba_uint8_get32
              (s,ofs + 4) /*<<bigstring.js 114 0>>*/ }
     /*<<stdlib.js 313 0>>*/ function caml_make_float_vect(len)
     { /*<<stdlib.js 314 2>>*/ var
        /*<<stdlib.js 314 10>>*/ len=len + 1 | 0,
        /*<<stdlib.js 315 8>>*/ b=new Array(len);
      b[0] = 254;
       /*<<stdlib.js 317 2>>*/ for
       ( /*<<stdlib.js 317 13>>*/ var i=1;i < len;i++)
       b[i] = 0;
       /*<<stdlib.js 318 2>>*/ return b /*<<stdlib.js 319 0>>*/ }
     /*<<io.js 398 0>>*/ function caml_ml_seek_out(chanid,pos)
     {caml_ml_channels[chanid].offset = pos;
       /*<<io.js 400 2>>*/ return 0 /*<<io.js 401 0>>*/ }
     /*<<stdlib.js 429 0>>*/ function caml_greaterequal(x,y)
     { /*<<stdlib.js 429 36>>*/ return +
             ( /*<<stdlib.js 429 45>>*/ caml_compare_val(x,y,false) >= 0) /*<<stdlib.js 429 80>>*/ }
     /*<<jslib.js 36 0>>*/ function caml_js_typeof(o)
     { /*<<jslib.js 36 29>>*/ return typeof o /*<<jslib.js 36 46>>*/ }
     /*<<jslib_js_of_ocaml.js 168 0>>*/ function
     caml_js_wrap_meth_callback_unsafe
     (f)
     { /*<<jslib_js_of_ocaml.js 169 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 169 23>>*/ f.apply
         (null,
           /*<<jslib_js_of_ocaml.js 169 37>>*/ raw_array_cons(arguments,this)) /*<<jslib_js_of_ocaml.js 169 9>>*/ } /*<<jslib_js_of_ocaml.js 170 0>>*/ }
     /*<<bigarray.js 501 0>>*/ function caml_ba_dim_3(ba)
     { /*<<bigarray.js 502 4>>*/ return  /*<<bigarray.js 502 11>>*/ ba.nth_dim
              (2) /*<<bigarray.js 503 0>>*/ }
     /*<<stdlib.js 1047 0>>*/ function caml_get_exception_raw_backtrace()
     { /*<<stdlib.js 1047 47>>*/ return [0] /*<<stdlib.js 1047 59>>*/ }
     /*<<weak.js 169 0>>*/ function caml_ephe_check_data(x)
     { /*<<weak.js 170 2>>*/ return x[caml_ephe_data_offset] === undefined?0:1 /*<<weak.js 174 0>>*/ }
     /*<<ieee_754.js 228 0>>*/ function caml_log1p_float(x)
     { /*<<ieee_754.js 229 2>>*/ var
        /*<<ieee_754.js 229 8>>*/ y=1 + x,
        /*<<ieee_754.js 229 19>>*/ z=y - 1;
       /*<<ieee_754.js 230 2>>*/ return z == 0
              ?x
              :x *  /*<<ieee_754.js 230 19>>*/ Math.log(y) / z /*<<ieee_754.js 231 0>>*/ }
     /*<<mlString.js 262 0>>*/ function caml_bytes_get16(s,i)
     { /*<<mlString.js 263 2>>*/ if(i >>> 0 >= s.l + 1)
        /*<<mlString.js 263 26>>*/ caml_string_bound_error();
       /*<<mlString.js 264 2>>*/ var
        /*<<mlString.js 264 9>>*/ b1=
         /*<<mlString.js 264 11>>*/ caml_string_unsafe_get(s,i),
        /*<<mlString.js 265 9>>*/ b2=
         /*<<mlString.js 265 11>>*/ caml_string_unsafe_get(s,i + 1);
       /*<<mlString.js 266 2>>*/ return b2 << 8 | b1 /*<<mlString.js 267 0>>*/ }
     /*<<int64.js 110 0>>*/ function caml_int64_or(x,y)
     { /*<<int64.js 111 2>>*/ return [255,x[1] | y[1],x[2] | y[2],x[3] | y[3]] /*<<int64.js 112 0>>*/ }
     /*<<jslib_js_of_ocaml.js 23 0>>*/ function caml_js_from_bool(x)
     { /*<<jslib_js_of_ocaml.js 23 32>>*/ return ! ! x /*<<jslib_js_of_ocaml.js 23 44>>*/ }
     /*<<io.js 92 0>>*/ function caml_ml_set_channel_name()
     { /*<<io.js 93 2>>*/ return 0 /*<<io.js 94 0>>*/ }
     /*<<stdlib.js 251 0>>*/ function caml_lazy_make_forward(v)
     { /*<<stdlib.js 251 38>>*/ return [250,v] /*<<stdlib.js 251 55>>*/ }
     /*<<mlString.js 451 0>>*/ function caml_create_string(len)
     { /*<<mlString.js 452 2>>*/ if(len < 0)
        /*<<mlString.js 452 15>>*/ caml_invalid_argument("String.create");
       /*<<mlString.js 453 2>>*/ return new MlBytes(len?2:9,"",len) /*<<mlString.js 454 0>>*/ }
     /*<<jslib.js 39 0>>*/ function caml_js_on_ie()
     { /*<<jslib.js 40 2>>*/  /*<<jslib.js 40 9>>*/ var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
       /*<<jslib.js 42 2>>*/ return  /*<<jslib.js 42 9>>*/ ua.indexOf("MSIE")
             !=
             -
             1
             &&
              /*<<jslib.js 42 37>>*/ ua.indexOf("Opera")
             !=
             0 /*<<jslib.js 43 0>>*/ }
     /*<<bigarray.js 476 0>>*/ function caml_ba_layout(ba)
     { /*<<bigarray.js 477 4>>*/ return ba.layout /*<<bigarray.js 478 0>>*/ }
     /*<<md5.js 36 0>>*/  /*<<md5.js 36 20>>*/ var
     caml_md5_string=
       /*<<md5.js 37 0>>*/ function()
        { /*<<md5.js 38 2>>*/ function add(x,y)
          { /*<<md5.js 38 24>>*/ return x + y | 0 /*<<md5.js 38 44>>*/ }
          /*<<md5.js 39 2>>*/ function xx(q,a,b,x,s,t)
          {a
           =
            /*<<md5.js 40 8>>*/ add
            ( /*<<md5.js 40 12>>*/ add(a,q), /*<<md5.js 40 23>>*/ add(x,t));
            /*<<md5.js 41 4>>*/ return  /*<<md5.js 41 11>>*/ add
                   (a << s | a >>> 32 - s,b) /*<<md5.js 42 2>>*/ }
          /*<<md5.js 43 2>>*/ function ff(a,b,c,d,x,s,t)
          { /*<<md5.js 44 4>>*/ return  /*<<md5.js 44 11>>*/ xx
                   (b & c | ~ b & d,a,b,x,s,t) /*<<md5.js 45 2>>*/ }
          /*<<md5.js 46 2>>*/ function gg(a,b,c,d,x,s,t)
          { /*<<md5.js 47 4>>*/ return  /*<<md5.js 47 11>>*/ xx
                   (b & d | c & ~ d,a,b,x,s,t) /*<<md5.js 48 2>>*/ }
          /*<<md5.js 49 2>>*/ function hh(a,b,c,d,x,s,t)
          { /*<<md5.js 49 31>>*/ return  /*<<md5.js 49 38>>*/ xx
                   (b ^ c ^ d,a,b,x,s,t) /*<<md5.js 49 68>>*/ }
          /*<<md5.js 50 2>>*/ function ii(a,b,c,d,x,s,t)
          { /*<<md5.js 50 31>>*/ return  /*<<md5.js 50 38>>*/ xx
                   (c ^ (b | ~ d),a,b,x,s,t) /*<<md5.js 50 73>>*/ }
          /*<<md5.js 52 2>>*/ function md5(buffer,length)
          { /*<<md5.js 53 4>>*/  /*<<md5.js 53 10>>*/ var i=length;
           buffer[i >> 2] |= 128 << 8 * (i & 3);
            /*<<md5.js 55 4>>*/ for(i = (i & ~ 3) + 8;(i & 63) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 536870911;
            /*<<md5.js 53 4>>*/  /*<<md5.js 60 10>>*/ var
            w=
             [1732584193,4023233417,2562383102,271733878];
            /*<<md5.js 62 4>>*/ for(i = 0;i < buffer.length;i += 16)
             /*<<md5.js 62 43>>*/ { /*<<md5.js 63 6>>*/ var
               /*<<md5.js 63 12>>*/ a=w[0],
               /*<<md5.js 63 22>>*/ b=w[1],
               /*<<md5.js 63 32>>*/ c=w[2],
               /*<<md5.js 63 42>>*/ d=w[3];
             a =  /*<<md5.js 65 10>>*/ ff(a,b,c,d,buffer[i + 0],7,3614090360);
             d
             =
              /*<<md5.js 66 10>>*/ ff(d,a,b,c,buffer[i + 1],12,3905402710);
             c =  /*<<md5.js 67 10>>*/ ff(c,d,a,b,buffer[i + 2],17,606105819);
             b
             =
              /*<<md5.js 68 10>>*/ ff(b,c,d,a,buffer[i + 3],22,3250441966);
             a =  /*<<md5.js 69 10>>*/ ff(a,b,c,d,buffer[i + 4],7,4118548399);
             d
             =
              /*<<md5.js 70 10>>*/ ff(d,a,b,c,buffer[i + 5],12,1200080426);
             c
             =
              /*<<md5.js 71 10>>*/ ff(c,d,a,b,buffer[i + 6],17,2821735955);
             b
             =
              /*<<md5.js 72 10>>*/ ff(b,c,d,a,buffer[i + 7],22,4249261313);
             a =  /*<<md5.js 73 10>>*/ ff(a,b,c,d,buffer[i + 8],7,1770035416);
             d
             =
              /*<<md5.js 74 10>>*/ ff(d,a,b,c,buffer[i + 9],12,2336552879);
             c
             =
              /*<<md5.js 75 10>>*/ ff(c,d,a,b,buffer[i + 10],17,4294925233);
             b
             =
              /*<<md5.js 76 10>>*/ ff(b,c,d,a,buffer[i + 11],22,2304563134);
             a
             =
              /*<<md5.js 77 10>>*/ ff(a,b,c,d,buffer[i + 12],7,1804603682);
             d
             =
              /*<<md5.js 78 10>>*/ ff(d,a,b,c,buffer[i + 13],12,4254626195);
             c
             =
              /*<<md5.js 79 10>>*/ ff(c,d,a,b,buffer[i + 14],17,2792965006);
             b
             =
              /*<<md5.js 80 10>>*/ ff(b,c,d,a,buffer[i + 15],22,1236535329);
             a =  /*<<md5.js 82 10>>*/ gg(a,b,c,d,buffer[i + 1],5,4129170786);
             d =  /*<<md5.js 83 10>>*/ gg(d,a,b,c,buffer[i + 6],9,3225465664);
             c
             =
              /*<<md5.js 84 10>>*/ gg(c,d,a,b,buffer[i + 11],14,643717713);
             b
             =
              /*<<md5.js 85 10>>*/ gg(b,c,d,a,buffer[i + 0],20,3921069994);
             a =  /*<<md5.js 86 10>>*/ gg(a,b,c,d,buffer[i + 5],5,3593408605);
             d =  /*<<md5.js 87 10>>*/ gg(d,a,b,c,buffer[i + 10],9,38016083);
             c
             =
              /*<<md5.js 88 10>>*/ gg(c,d,a,b,buffer[i + 15],14,3634488961);
             b
             =
              /*<<md5.js 89 10>>*/ gg(b,c,d,a,buffer[i + 4],20,3889429448);
             a =  /*<<md5.js 90 10>>*/ gg(a,b,c,d,buffer[i + 9],5,568446438);
             d
             =
              /*<<md5.js 91 10>>*/ gg(d,a,b,c,buffer[i + 14],9,3275163606);
             c
             =
              /*<<md5.js 92 10>>*/ gg(c,d,a,b,buffer[i + 3],14,4107603335);
             b
             =
              /*<<md5.js 93 10>>*/ gg(b,c,d,a,buffer[i + 8],20,1163531501);
             a
             =
              /*<<md5.js 94 10>>*/ gg(a,b,c,d,buffer[i + 13],5,2850285829);
             d =  /*<<md5.js 95 10>>*/ gg(d,a,b,c,buffer[i + 2],9,4243563512);
             c
             =
              /*<<md5.js 96 10>>*/ gg(c,d,a,b,buffer[i + 7],14,1735328473);
             b
             =
              /*<<md5.js 97 10>>*/ gg(b,c,d,a,buffer[i + 12],20,2368359562);
             a =  /*<<md5.js 99 10>>*/ hh(a,b,c,d,buffer[i + 5],4,4294588738);
             d
             =
              /*<<md5.js 100 10>>*/ hh(d,a,b,c,buffer[i + 8],11,2272392833);
             c
             =
              /*<<md5.js 101 10>>*/ hh(c,d,a,b,buffer[i + 11],16,1839030562);
             b
             =
              /*<<md5.js 102 10>>*/ hh(b,c,d,a,buffer[i + 14],23,4259657740);
             a
             =
              /*<<md5.js 103 10>>*/ hh(a,b,c,d,buffer[i + 1],4,2763975236);
             d
             =
              /*<<md5.js 104 10>>*/ hh(d,a,b,c,buffer[i + 4],11,1272893353);
             c
             =
              /*<<md5.js 105 10>>*/ hh(c,d,a,b,buffer[i + 7],16,4139469664);
             b
             =
              /*<<md5.js 106 10>>*/ hh(b,c,d,a,buffer[i + 10],23,3200236656);
             a
             =
              /*<<md5.js 107 10>>*/ hh(a,b,c,d,buffer[i + 13],4,681279174);
             d
             =
              /*<<md5.js 108 10>>*/ hh(d,a,b,c,buffer[i + 0],11,3936430074);
             c
             =
              /*<<md5.js 109 10>>*/ hh(c,d,a,b,buffer[i + 3],16,3572445317);
             b =  /*<<md5.js 110 10>>*/ hh(b,c,d,a,buffer[i + 6],23,76029189);
             a
             =
              /*<<md5.js 111 10>>*/ hh(a,b,c,d,buffer[i + 9],4,3654602809);
             d
             =
              /*<<md5.js 112 10>>*/ hh(d,a,b,c,buffer[i + 12],11,3873151461);
             c
             =
              /*<<md5.js 113 10>>*/ hh(c,d,a,b,buffer[i + 15],16,530742520);
             b
             =
              /*<<md5.js 114 10>>*/ hh(b,c,d,a,buffer[i + 2],23,3299628645);
             a
             =
              /*<<md5.js 116 10>>*/ ii(a,b,c,d,buffer[i + 0],6,4096336452);
             d
             =
              /*<<md5.js 117 10>>*/ ii(d,a,b,c,buffer[i + 7],10,1126891415);
             c
             =
              /*<<md5.js 118 10>>*/ ii(c,d,a,b,buffer[i + 14],15,2878612391);
             b
             =
              /*<<md5.js 119 10>>*/ ii(b,c,d,a,buffer[i + 5],21,4237533241);
             a
             =
              /*<<md5.js 120 10>>*/ ii(a,b,c,d,buffer[i + 12],6,1700485571);
             d
             =
              /*<<md5.js 121 10>>*/ ii(d,a,b,c,buffer[i + 3],10,2399980690);
             c
             =
              /*<<md5.js 122 10>>*/ ii(c,d,a,b,buffer[i + 10],15,4293915773);
             b
             =
              /*<<md5.js 123 10>>*/ ii(b,c,d,a,buffer[i + 1],21,2240044497);
             a
             =
              /*<<md5.js 124 10>>*/ ii(a,b,c,d,buffer[i + 8],6,1873313359);
             d
             =
              /*<<md5.js 125 10>>*/ ii(d,a,b,c,buffer[i + 15],10,4264355552);
             c
             =
              /*<<md5.js 126 10>>*/ ii(c,d,a,b,buffer[i + 6],15,2734768916);
             b
             =
              /*<<md5.js 127 10>>*/ ii(b,c,d,a,buffer[i + 13],21,1309151649);
             a
             =
              /*<<md5.js 128 10>>*/ ii(a,b,c,d,buffer[i + 4],6,4149444226);
             d
             =
              /*<<md5.js 129 10>>*/ ii(d,a,b,c,buffer[i + 11],10,3174756917);
             c
             =
              /*<<md5.js 130 10>>*/ ii(c,d,a,b,buffer[i + 2],15,718787259);
             b
             =
              /*<<md5.js 131 10>>*/ ii(b,c,d,a,buffer[i + 9],21,3951481745);
             w[0] =  /*<<md5.js 133 13>>*/ add(a,w[0]);
             w[1] =  /*<<md5.js 134 13>>*/ add(b,w[1]);
             w[2] =  /*<<md5.js 135 13>>*/ add(c,w[2]);
             w[3] =  /*<<md5.js 136 13>>*/ add(d,w[3])}
            /*<<md5.js 53 4>>*/  /*<<md5.js 139 10>>*/ var t=new Array(16);
            /*<<md5.js 140 4>>*/ for( /*<<md5.js 140 15>>*/ var i=0;i < 4;i++)
             /*<<md5.js 141 6>>*/ for
             ( /*<<md5.js 141 17>>*/ var j=0;j < 4;j++)
             t[i * 4 + j] = w[i] >> 8 * j & 255;
            /*<<md5.js 143 4>>*/ return t /*<<md5.js 144 2>>*/ }
          /*<<md5.js 146 2>>*/ return function(s,ofs,len)
          { /*<<md5.js 149 4>>*/  /*<<md5.js 149 12>>*/ var buf=[];
            /*<<md5.js 150 4>>*/ switch(s.t & 6)
            {default: /*<<md5.js 152 6>>*/ caml_convert_string_to_bytes(s);case 0:
               /*<<md5.js 154 6>>*/  /*<<md5.js 154 12>>*/ var b=s.c;
               /*<<md5.js 155 6>>*/ for
               ( /*<<md5.js 155 17>>*/ var i=0;i < len;i += 4)
                /*<<md5.js 155 37>>*/ { /*<<md5.js 156 8>>*/  /*<<md5.js 156 14>>*/ var
                 j=
                  i + ofs;
                buf[i >> 2]
                =
                 /*<<md5.js 158 10>>*/ b.charCodeAt(j)
                |
                 /*<<md5.js 158 29>>*/ b.charCodeAt(j + 1)
                <<
                8
                |
                 /*<<md5.js 159 11>>*/ b.charCodeAt(j + 2)
                <<
                16
                |
                 /*<<md5.js 159 39>>*/ b.charCodeAt(j + 3)
                <<
                24}
               /*<<md5.js 161 6>>*/ for(;i < len;i++)
               buf[i >> 2]
               |=
                /*<<md5.js 161 40>>*/ b.charCodeAt(i + ofs)
               <<
               8
               *
               (i & 3);
               /*<<md5.js 162 6>>*/ break;
             case 4:
               /*<<md5.js 164 6>>*/  /*<<md5.js 164 12>>*/ var a=s.c;
               /*<<md5.js 165 6>>*/ for
               ( /*<<md5.js 165 17>>*/ var i=0;i < len;i += 4)
                /*<<md5.js 165 37>>*/ { /*<<md5.js 166 8>>*/  /*<<md5.js 166 14>>*/ var
                 j=
                  i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
               /*<<md5.js 169 6>>*/ for(;i < len;i++)
               buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
            /*<<md5.js 171 4>>*/ return  /*<<md5.js 171 11>>*/ caml_string_of_array
                   ( /*<<md5.js 171 32>>*/ md5(buf,len)) /*<<md5.js 146 9>>*/ } /*<<md5.js 37 0>>*/ }
       ();
     /*<<md5.js 24 0>>*/ function caml_md5_chan(chanid,len)
     { /*<<md5.js 25 2>>*/ var
        /*<<md5.js 25 11>>*/ chan=caml_ml_channels[chanid],
        /*<<md5.js 26 15>>*/ chan_len= /*<<md5.js 26 17>>*/ chan.file.length();
       /*<<md5.js 27 2>>*/ if(len < 0)len = chan_len - chan.offset;
       /*<<md5.js 28 2>>*/ if(chan.offset + len > chan_len)
        /*<<md5.js 28 35>>*/ caml_raise_end_of_file();
       /*<<md5.js 25 2>>*/  /*<<md5.js 29 10>>*/ var
       buf=
         /*<<md5.js 29 12>>*/ caml_create_bytes(len);
       /*<<md5.js 30 2>>*/ chan.file.read(chan.offset,buf,0,len);
       /*<<md5.js 31 2>>*/ return  /*<<md5.js 31 9>>*/ caml_md5_string
              (buf,0,len) /*<<md5.js 32 0>>*/ }
     /*<<int64.js 153 0>>*/ function caml_int64_shift_right(x,s)
     {s = s & 63;
       /*<<int64.js 155 2>>*/ if(s == 0) /*<<int64.js 155 14>>*/ return x;
       /*<<int64.js 156 2>>*/  /*<<int64.js 156 8>>*/ var h=x[3] << 16 >> 16;
       /*<<int64.js 157 2>>*/ if(s < 24)
        /*<<int64.js 158 4>>*/ return [255,
               (x[1] >> s | x[2] << 24 - s) & 16777215,
               (x[2] >> s | h << 24 - s) & 16777215,
               x[3] << 16 >> s >>> 16];
       /*<<int64.js 156 2>>*/  /*<<int64.js 162 11>>*/ var
       sign=
        x[3] << 16 >> 31;
       /*<<int64.js 163 2>>*/ if(s < 48)
        /*<<int64.js 164 4>>*/ return [255,
               (x[2] >> s - 24 | x[3] << 48 - s) & 16777215,
               x[3] << 16 >> s - 24 >> 16 & 16777215,
               sign & 65535];
       /*<<int64.js 168 2>>*/ return [255,
              x[3] << 16 >> s - 32 & 16777215,
              sign & 16777215,
              sign & 65535] /*<<int64.js 171 0>>*/ }
     /*<<stdlib.js 1051 0>>*/ function caml_convert_raw_backtrace()
     { /*<<stdlib.js 1051 41>>*/ return [0] /*<<stdlib.js 1051 53>>*/ }
     /*<<stdlib.js 284 0>>*/ function caml_array_set(array,index,newval)
     { /*<<stdlib.js 285 2>>*/ if(index < 0 || index >= array.length - 1)
        /*<<stdlib.js 285 50>>*/ caml_array_bound_error();
      array[index + 1] = newval;
       /*<<stdlib.js 286 25>>*/ return 0 /*<<stdlib.js 287 0>>*/ }
     /*<<mlString.js 552 0>>*/ function caml_bytes_greaterequal(s1,s2)
     { /*<<mlString.js 553 2>>*/ return  /*<<mlString.js 553 9>>*/ caml_bytes_lessequal
              (s2,s1) /*<<mlString.js 554 0>>*/ }
     /*<<stdlib.js 214 0>>*/ function caml_update_dummy(x,y)
     { /*<<stdlib.js 215 2>>*/ if(typeof y === "function")
        /*<<stdlib.js 215 30>>*/ {x.fun = y;
         /*<<stdlib.js 215 43>>*/ return 0}
       /*<<stdlib.js 216 2>>*/ if(y.fun)
        /*<<stdlib.js 216 14>>*/ {x.fun = y.fun;
         /*<<stdlib.js 216 31>>*/ return 0}
       /*<<stdlib.js 217 2>>*/  /*<<stdlib.js 217 8>>*/ var i=y.length;
       /*<<stdlib.js 217 20>>*/ while(i--)x[i] = y[i];
       /*<<stdlib.js 217 45>>*/ return 0 /*<<stdlib.js 218 0>>*/ }
     /*<<internalMod.js 55 0>>*/ function caml_CamlinternalMod_update_mod
     (shape,real,x)
     { /*<<internalMod.js 56 2>>*/ if(typeof shape === "number")
        /*<<internalMod.js 57 4>>*/ switch(shape)
        {case 0:real.fun = x; /*<<internalMod.js 60 6>>*/ break;
         case 1:
         default: /*<<internalMod.js 63 6>>*/ caml_update_dummy(real,x)}
      else
        /*<<internalMod.js 66 4>>*/ switch(shape[0])
        {case 0:
           /*<<internalMod.js 68 6>>*/ for
           ( /*<<internalMod.js 68 15>>*/ var i=1;i < shape[1].length;i++)
            /*<<internalMod.js 69 8>>*/ caml_CamlinternalMod_update_mod
            (shape[1][i],real[i],x[i]);
           /*<<internalMod.js 70 6>>*/ break
         }
       /*<<internalMod.js 74 2>>*/ return 0 /*<<internalMod.js 75 0>>*/ }
     /*<<weak.js 132 0>>*/ function caml_ephe_get_data(x)
     { /*<<weak.js 133 2>>*/ return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]] /*<<weak.js 137 0>>*/ }
     /*<<jslib.js 85 0>>*/ function caml_trampoline_return(f,args)
     { /*<<jslib.js 86 2>>*/ return {joo_tramp:f,joo_args:args} /*<<jslib.js 87 0>>*/ }
     /*<<io.js 423 0>>*/ function caml_ml_output_int(chanid,i)
     { /*<<io.js 424 2>>*/ var
        /*<<io.js 424 10>>*/ arr=
        [i >> 24 & 255,i >> 16 & 255,i >> 8 & 255,i & 255],
        /*<<io.js 425 8>>*/ s= /*<<io.js 425 10>>*/ caml_string_of_array(arr);
       /*<<io.js 426 2>>*/ caml_ml_output(chanid,s,0,4);
       /*<<io.js 427 2>>*/ return 0 /*<<io.js 428 0>>*/ }
     /*<<stdlib.js 903 0>>*/  /*<<stdlib.js 903 22>>*/ var
     caml_initial_time=
      new Date() * 0.001;
     /*<<stdlib.js 904 0>>*/ function caml_sys_time()
     { /*<<stdlib.js 904 28>>*/ return new Date() * 0.001 - caml_initial_time /*<<stdlib.js 904 75>>*/ }
     /*<<io.js 174 0>>*/ function caml_ml_channel_size(chanid)
     { /*<<io.js 175 2>>*/  /*<<io.js 175 11>>*/ var
       chan=
        caml_ml_channels[chanid];
       /*<<io.js 176 2>>*/ return  /*<<io.js 176 9>>*/ chan.file.length() /*<<io.js 177 0>>*/ }
     /*<<stdlib.js 980 0>>*/ function caml_array_append(a1,a2)
     { /*<<stdlib.js 981 2>>*/ var
        /*<<stdlib.js 981 9>>*/ l1=a1.length,
        /*<<stdlib.js 981 25>>*/ l2=a2.length,
        /*<<stdlib.js 982 8>>*/ l=l1 + l2 - 1,
        /*<<stdlib.js 983 8>>*/ a=new Array(l);
      a[0] = 0;
       /*<<stdlib.js 981 2>>*/ var
        /*<<stdlib.js 985 8>>*/ i=1,
        /*<<stdlib.js 985 14>>*/ j=1;
       /*<<stdlib.js 986 2>>*/ for(;i < l1;i++)a[i] = a1[i];
       /*<<stdlib.js 987 2>>*/ for(;i < l;i++,j++)a[i] = a2[j];
       /*<<stdlib.js 988 2>>*/ return a /*<<stdlib.js 989 0>>*/ }
     /*<<stdlib.js 1058 0>>*/ function caml_raw_backtrace_slot()
     { /*<<stdlib.js 1059 2>>*/ caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds") /*<<stdlib.js 1060 0>>*/ }
     /*<<mlString.js 639 0>>*/ function caml_string_of_bytes(s)
     { /*<<mlString.js 639 35>>*/ return s /*<<mlString.js 639 43>>*/ }
     /*<<io.js 196 0>>*/ function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;
       /*<<io.js 198 2>>*/ return 0 /*<<io.js 199 0>>*/ }
     /*<<int64.js 95 0>>*/ function caml_int64_is_min_int(x)
     { /*<<int64.js 96 2>>*/ return x[3] == 32768 && (x[1] | x[2]) == 0 /*<<int64.js 97 0>>*/ }
     /*<<ieee_754.js 77 0>>*/ function caml_hexstring_of_float(x,prec,style)
     { /*<<ieee_754.js 78 2>>*/ if(!  /*<<ieee_754.js 78 7>>*/ isFinite(x))
        /*<<ieee_754.js 78 20>>*/ { /*<<ieee_754.js 79 4>>*/ if
         ( /*<<ieee_754.js 79 8>>*/ isNaN(x))
          /*<<ieee_754.js 79 18>>*/ return  /*<<ieee_754.js 79 25>>*/ caml_js_to_string
                 ("nan");
         /*<<ieee_754.js 80 4>>*/ return  /*<<ieee_754.js 80 11>>*/ caml_js_to_string
                (x > 0?"infinity":"-infinity")}
       /*<<ieee_754.js 82 2>>*/  /*<<ieee_754.js 82 11>>*/ var
       sign=
        x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
       /*<<ieee_754.js 83 2>>*/ if(sign)x = - x;
       /*<<ieee_754.js 82 2>>*/  /*<<ieee_754.js 84 10>>*/ var exp=0;
       /*<<ieee_754.js 85 2>>*/ if(x == 0)
        /*<<ieee_754.js 85 14>>*/ ;
      else
        /*<<ieee_754.js 86 7>>*/ if(x < 1)
         /*<<ieee_754.js 86 18>>*/ while(x < 1 && exp > - 1022)
          /*<<ieee_754.js 87 34>>*/ {x *= 2;exp--}
       else
         /*<<ieee_754.js 88 9>>*/ while(x >= 2)
          /*<<ieee_754.js 89 19>>*/ {x /= 2;exp++}
       /*<<ieee_754.js 82 2>>*/ var
        /*<<ieee_754.js 91 15>>*/ exp_sign=exp < 0?"":"+",
        /*<<ieee_754.js 92 15>>*/ sign_str="";
       /*<<ieee_754.js 93 2>>*/ if(sign)
       sign_str = "-";
      else
        /*<<ieee_754.js 94 7>>*/ switch(style)
        {case 43:sign_str = "+"; /*<<ieee_754.js 96 39>>*/ break;
         case 32:sign_str = " "; /*<<ieee_754.js 97 39>>*/ break;
         default: /*<<ieee_754.js 98 13>>*/ break}
       /*<<ieee_754.js 101 2>>*/ if(prec >= 0 && prec < 13)
        /*<<ieee_754.js 101 30>>*/ { /*<<ieee_754.js 103 6>>*/  /*<<ieee_754.js 103 14>>*/ var
         cst=
           /*<<ieee_754.js 103 16>>*/ Math.pow(2,prec * 4);
        x =  /*<<ieee_754.js 104 10>>*/ Math.round(x * cst) / cst}
       /*<<ieee_754.js 82 2>>*/  /*<<ieee_754.js 106 12>>*/ var
       x_str=
         /*<<ieee_754.js 106 14>>*/ x.toString(16);
       /*<<ieee_754.js 107 2>>*/ if(prec >= 0)
        /*<<ieee_754.js 107 15>>*/ { /*<<ieee_754.js 108 6>>*/  /*<<ieee_754.js 108 14>>*/ var
         idx=
           /*<<ieee_754.js 108 16>>*/ x_str.indexOf(".");
         /*<<ieee_754.js 109 4>>*/ if(idx < 0)
          /*<<ieee_754.js 109 14>>*/ x_str
         +=
         "."
         +
          /*<<ieee_754.js 110 21>>*/ caml_str_repeat(prec,"0");
        else
          /*<<ieee_754.js 112 9>>*/ { /*<<ieee_754.js 113 6>>*/  /*<<ieee_754.js 113 15>>*/ var
           size=
            idx + 1 + prec;
           /*<<ieee_754.js 114 6>>*/ if(x_str.length < size)
           x_str
           +=
            /*<<ieee_754.js 115 17>>*/ caml_str_repeat
            (size - x_str.length,"0");
          else
           x_str =  /*<<ieee_754.js 117 16>>*/ x_str.substr(0,size)}}
       /*<<ieee_754.js 120 2>>*/ return  /*<<ieee_754.js 120 9>>*/ caml_js_to_string
              (sign_str
               +
               "0x"
               +
               x_str
               +
               "p"
               +
               exp_sign
               +
                /*<<ieee_754.js 120 71>>*/ exp.toString(10)) /*<<ieee_754.js 121 0>>*/ }
     /*<<jslib_js_of_ocaml.js 184 0>>*/ function caml_js_expr(s)
     { /*<<jslib_js_of_ocaml.js 185 2>>*/ js_print_stderr
       ("caml_js_expr: fallback to runtime evaluation");
       /*<<jslib_js_of_ocaml.js 186 2>>*/ return  /*<<jslib_js_of_ocaml.js 186 9>>*/ eval
              ( /*<<jslib_js_of_ocaml.js 186 14>>*/ s.toString()) /*<<jslib_js_of_ocaml.js 186 28>>*/ }
     /*<<jslib_js_of_ocaml.js 156 0>>*/ function
     caml_js_wrap_meth_callback_strict
     (arity,f)
     { /*<<jslib_js_of_ocaml.js 157 2>>*/ return function()
       { /*<<jslib_js_of_ocaml.js 158 4>>*/  /*<<jslib_js_of_ocaml.js 158 10>>*/ var
         n=
          arguments.length;
         /*<<jslib_js_of_ocaml.js 159 4>>*/ if(n == arity)
          /*<<jslib_js_of_ocaml.js 159 19>>*/ return  /*<<jslib_js_of_ocaml.js 159 26>>*/ caml_call_gen
                 (f,
                   /*<<jslib_js_of_ocaml.js 159 43>>*/ raw_array_cons
                   (arguments,this));
         /*<<jslib_js_of_ocaml.js 158 4>>*/  /*<<jslib_js_of_ocaml.js 160 13>>*/ var
         args=
          new Array(arity + 1);
        args[0] = this;
         /*<<jslib_js_of_ocaml.js 162 4>>*/ for
         ( /*<<jslib_js_of_ocaml.js 162 15>>*/ var i=1;
          i
          <
          n
          &&
          i
          <=
          arity;
          i++)
         args[i] = arguments[i];
         /*<<jslib_js_of_ocaml.js 163 4>>*/ return  /*<<jslib_js_of_ocaml.js 163 11>>*/ caml_call_gen
                (f,args) /*<<jslib_js_of_ocaml.js 157 9>>*/ } /*<<jslib_js_of_ocaml.js 165 0>>*/ }
     /*<<stdlib.js 1188 0>>*/ function caml_ml_runtime_warnings_enabled(_unit)
     { /*<<stdlib.js 1189 2>>*/ return caml_runtime_warnings /*<<stdlib.js 1190 0>>*/ }
     /*<<stdlib.js 1043 0>>*/ function caml_backtrace_status()
     { /*<<stdlib.js 1043 36>>*/ return 0 /*<<stdlib.js 1043 46>>*/ }
     /*<<stdlib.js 1131 0>>*/ function caml_install_signal_handler()
     { /*<<stdlib.js 1131 39>>*/ return 0 /*<<stdlib.js 1131 47>>*/ }
     /*<<bigarray.js 612 0>>*/ function caml_ba_fill(ba,init)
     { /*<<bigarray.js 613 4>>*/ ba.fill(init);
       /*<<bigarray.js 614 4>>*/ return 0 /*<<bigarray.js 615 0>>*/ }
     /*<<gc.js 28 0>>*/ function caml_gc_get()
     { /*<<gc.js 29 2>>*/ return [0,0,0,0,0,0,0,0,0] /*<<gc.js 30 0>>*/ }
     /*<<marshal.js 454 0>>*/ function caml_output_value_to_bytes(v,_fl)
     { /*<<marshal.js 456 2>>*/ return  /*<<marshal.js 456 9>>*/ caml_string_of_array
              ( /*<<marshal.js 456 31>>*/ caml_output_val(v)) /*<<marshal.js 457 0>>*/ }
     /*<<ieee_754.js 161 0>>*/ function caml_modf_float(x)
     { /*<<ieee_754.js 162 2>>*/ if( /*<<ieee_754.js 162 6>>*/ isFinite(x))
        /*<<ieee_754.js 162 20>>*/ { /*<<ieee_754.js 163 4>>*/  /*<<ieee_754.js 163 12>>*/ var
         neg=
          1 / x < 0;
        x =  /*<<ieee_754.js 164 8>>*/ Math.abs(x);
         /*<<ieee_754.js 163 4>>*/ var
          /*<<ieee_754.js 165 10>>*/ i=
           /*<<ieee_754.js 165 12>>*/ Math.floor(x),
          /*<<ieee_754.js 166 10>>*/ f=x - i;
         /*<<ieee_754.js 167 4>>*/ if(neg)
          /*<<ieee_754.js 167 13>>*/ {i = - i;f = - f}
         /*<<ieee_754.js 168 4>>*/ return [0,f,i]}
       /*<<ieee_754.js 170 2>>*/ if( /*<<ieee_754.js 170 6>>*/ isNaN(x))
        /*<<ieee_754.js 170 17>>*/ return [0,NaN,NaN];
       /*<<ieee_754.js 171 2>>*/ return [0,1 / x,x] /*<<ieee_754.js 172 0>>*/ }
     /*<<stdlib.js 680 0>>*/ function caml_hash_univ_param(count,limit,obj)
     { /*<<stdlib.js 681 2>>*/  /*<<stdlib.js 681 16>>*/ var hash_accu=0;
       /*<<stdlib.js 682 2>>*/ function hash_aux(obj)
       {limit--;
         /*<<stdlib.js 684 4>>*/ if(count < 0 || limit < 0)
          /*<<stdlib.js 684 32>>*/ return;
         /*<<stdlib.js 685 4>>*/ if
         (obj instanceof Array && obj[0] === (obj[0] | 0))
          /*<<stdlib.js 685 55>>*/ switch(obj[0])
          {case 248:
            count--;
            hash_accu = hash_accu * 65599 + obj[2] | 0;
             /*<<stdlib.js 691 8>>*/ break;
           case 250:
            limit++;
             /*<<stdlib.js 694 17>>*/ hash_aux(obj);
             /*<<stdlib.js 694 32>>*/ break;
           case 255:
            count--;
            hash_accu = hash_accu * 65599 + obj[1] + (obj[2] << 24) | 0;
             /*<<stdlib.js 699 8>>*/ break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
             /*<<stdlib.js 703 8>>*/ for
             ( /*<<stdlib.js 703 19>>*/ var i=obj.length - 1;i > 0;i--)
              /*<<stdlib.js 703 49>>*/ hash_aux(obj[i])}
        else
          /*<<stdlib.js 705 11>>*/ if(obj instanceof MlBytes)
           /*<<stdlib.js 705 39>>*/ {count--;
            /*<<stdlib.js 707 6>>*/ switch(obj.t & 6)
            {default:
               /*<<stdlib.js 709 8>>*/ caml_convert_string_to_bytes(obj);case 0:
               /*<<stdlib.js 711 8>>*/ for
               (var
                  /*<<stdlib.js 711 19>>*/ b=obj.c,
                  /*<<stdlib.js 711 30>>*/ l=obj.l,
                  /*<<stdlib.js 711 41>>*/ i=0;
                i
                <
                l;
                i++)
               hash_accu
               =
               hash_accu
               *
               19
               +
                /*<<stdlib.js 712 40>>*/ b.charCodeAt(i)
               |
               0;
               /*<<stdlib.js 713 8>>*/ break;
             case 2:
               /*<<stdlib.js 715 8>>*/ for
               (var
                  /*<<stdlib.js 715 19>>*/ a=obj.c,
                  /*<<stdlib.js 715 30>>*/ l=obj.l,
                  /*<<stdlib.js 715 41>>*/ i=0;
                i
                <
                l;
                i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
           /*<<stdlib.js 718 11>>*/ if(obj === (obj | 0))
            /*<<stdlib.js 718 32>>*/ {count--;
            hash_accu = hash_accu * 65599 + obj | 0}
          else
            /*<<stdlib.js 722 11>>*/ if(obj === + obj)
             /*<<stdlib.js 722 29>>*/ {count--;
              /*<<stdlib.js 725 6>>*/  /*<<stdlib.js 725 12>>*/ var
              p=
                /*<<stdlib.js 725 14>>*/ caml_int64_to_bytes
                ( /*<<stdlib.js 725 35>>*/ caml_int64_bits_of_float(obj));
              /*<<stdlib.js 726 6>>*/ for
              ( /*<<stdlib.js 726 17>>*/ var i=7;i >= 0;i--)
              hash_accu = hash_accu * 19 + p[i] | 0}
           else
             /*<<stdlib.js 727 11>>*/ if
             (obj && obj.hash && typeof obj.hash === "function")
              /*<<stdlib.js 727 65>>*/ hash_accu
             =
             hash_accu
             *
             65599
             +
              /*<<stdlib.js 729 34>>*/ obj.hash()
             |
             0 /*<<stdlib.js 731 2>>*/ }
       /*<<stdlib.js 732 2>>*/ hash_aux(obj);
       /*<<stdlib.js 733 2>>*/ return hash_accu & 1073741823 /*<<stdlib.js 734 0>>*/ }
     /*<<ieee_754.js 205 0>>*/ function caml_float_compare(x,y)
     { /*<<ieee_754.js 206 2>>*/ if(x === y)
        /*<<ieee_754.js 206 15>>*/ return 0;
       /*<<ieee_754.js 207 2>>*/ if(x < y)
        /*<<ieee_754.js 207 13>>*/ return - 1;
       /*<<ieee_754.js 208 2>>*/ if(x > y)
        /*<<ieee_754.js 208 13>>*/ return 1;
       /*<<ieee_754.js 209 2>>*/ if(x === x)
        /*<<ieee_754.js 209 15>>*/ return 1;
       /*<<ieee_754.js 210 2>>*/ if(y === y)
        /*<<ieee_754.js 210 15>>*/ return - 1;
       /*<<ieee_754.js 211 2>>*/ return 0 /*<<ieee_754.js 212 0>>*/ }
     /*<<mlString.js 363 0>>*/ function caml_string_set32(s,i,i32)
     { /*<<mlString.js 364 4>>*/ return  /*<<mlString.js 364 11>>*/ caml_bytes_set32
              (s,i,i32) /*<<mlString.js 365 0>>*/ }
     /*<<parsing.js 22 0>>*/ function caml_parse_engine(tables,env,cmd,arg)
     { /*<<parsing.js 24 2>>*/ var
        /*<<parsing.js 24 14>>*/ ERRCODE=256,
        /*<<parsing.js 32 11>>*/ loop=6,
        /*<<parsing.js 33 16>>*/ testshift=7,
        /*<<parsing.js 34 12>>*/ shift=8,
        /*<<parsing.js 35 20>>*/ shift_recover=9,
        /*<<parsing.js 36 13>>*/ reduce=10,
        /*<<parsing.js 38 17>>*/ READ_TOKEN=0,
        /*<<parsing.js 39 24>>*/ RAISE_PARSE_ERROR=1,
        /*<<parsing.js 40 20>>*/ GROW_STACKS_1=2,
        /*<<parsing.js 41 20>>*/ GROW_STACKS_2=3,
        /*<<parsing.js 42 30>>*/ COMPUTE_SEMANTIC_ACTION=4,
        /*<<parsing.js 43 26>>*/ CALL_ERROR_FUNCTION=5,
        /*<<parsing.js 45 18>>*/ env_s_stack=1,
        /*<<parsing.js 46 18>>*/ env_v_stack=2,
        /*<<parsing.js 47 27>>*/ env_symb_start_stack=3,
        /*<<parsing.js 48 25>>*/ env_symb_end_stack=4,
        /*<<parsing.js 49 20>>*/ env_stacksize=5,
        /*<<parsing.js 50 20>>*/ env_stackbase=6,
        /*<<parsing.js 51 20>>*/ env_curr_char=7,
        /*<<parsing.js 52 15>>*/ env_lval=8,
        /*<<parsing.js 53 21>>*/ env_symb_start=9,
        /*<<parsing.js 54 19>>*/ env_symb_end=10,
        /*<<parsing.js 55 14>>*/ env_asp=11,
        /*<<parsing.js 56 19>>*/ env_rule_len=12,
        /*<<parsing.js 57 22>>*/ env_rule_number=13,
        /*<<parsing.js 58 13>>*/ env_sp=14,
        /*<<parsing.js 59 16>>*/ env_state=15,
        /*<<parsing.js 60 18>>*/ env_errflag=16,
        /*<<parsing.js 63 23>>*/ tbl_transl_const=2,
        /*<<parsing.js 64 23>>*/ tbl_transl_block=3,
        /*<<parsing.js 65 14>>*/ tbl_lhs=4,
        /*<<parsing.js 66 14>>*/ tbl_len=5,
        /*<<parsing.js 67 17>>*/ tbl_defred=6,
        /*<<parsing.js 68 16>>*/ tbl_dgoto=7,
        /*<<parsing.js 69 17>>*/ tbl_sindex=8,
        /*<<parsing.js 70 17>>*/ tbl_rindex=9,
        /*<<parsing.js 71 17>>*/ tbl_gindex=10,
        /*<<parsing.js 72 20>>*/ tbl_tablesize=11,
        /*<<parsing.js 73 16>>*/ tbl_table=12,
        /*<<parsing.js 74 16>>*/ tbl_check=13;
       /*<<parsing.js 79 2>>*/ if(! tables.dgoto)
        /*<<parsing.js 79 21>>*/ {tables.defred
        =
         /*<<parsing.js 80 20>>*/ caml_lex_array(tables[tbl_defred]);
        tables.sindex
        =
         /*<<parsing.js 81 20>>*/ caml_lex_array(tables[tbl_sindex]);
        tables.check
        =
         /*<<parsing.js 82 20>>*/ caml_lex_array(tables[tbl_check]);
        tables.rindex
        =
         /*<<parsing.js 83 20>>*/ caml_lex_array(tables[tbl_rindex]);
        tables.table
        =
         /*<<parsing.js 84 20>>*/ caml_lex_array(tables[tbl_table]);
        tables.len
        =
         /*<<parsing.js 85 20>>*/ caml_lex_array(tables[tbl_len]);
        tables.lhs
        =
         /*<<parsing.js 86 20>>*/ caml_lex_array(tables[tbl_lhs]);
        tables.gindex
        =
         /*<<parsing.js 87 20>>*/ caml_lex_array(tables[tbl_gindex]);
        tables.dgoto
        =
         /*<<parsing.js 88 20>>*/ caml_lex_array(tables[tbl_dgoto])}
       /*<<parsing.js 24 2>>*/ var
        /*<<parsing.js 91 10>>*/ res=0,
       n,
       n1,
       n2,
       state1,
        /*<<parsing.js 94 9>>*/ sp=env[env_sp],
        /*<<parsing.js 95 12>>*/ state=env[env_state],
        /*<<parsing.js 96 14>>*/ errflag=env[env_errflag];
      exit:
       /*<<parsing.js 98 7>>*/ for(;;)
        /*<<parsing.js 98 16>>*/ switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
           /*<<parsing.js 107 6>>*/ if(n != 0)
            /*<<parsing.js 107 18>>*/ {cmd = reduce;
             /*<<parsing.js 107 34>>*/ break}
           /*<<parsing.js 108 6>>*/ if(env[env_curr_char] >= 0)
            /*<<parsing.js 108 35>>*/ {cmd = testshift;
             /*<<parsing.js 108 54>>*/ break}
          res = READ_TOKEN;
           /*<<parsing.js 110 6>>*/ break exit;
         case 1:
           /*<<parsing.js 114 6>>*/ if(arg instanceof Array)
            /*<<parsing.js 114 32>>*/ {env[env_curr_char]
            =
            tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
            /*<<parsing.js 117 13>>*/ {env[env_curr_char]
            =
            tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
           /*<<parsing.js 126 6>>*/ if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
            /*<<parsing.js 127 50>>*/ {cmd = shift;
             /*<<parsing.js 128 21>>*/ break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
           /*<<parsing.js 132 6>>*/ if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
            /*<<parsing.js 133 50>>*/ {n = tables.table[n2];
            cmd = reduce;
             /*<<parsing.js 135 22>>*/ break}
           /*<<parsing.js 137 6>>*/ if(errflag <= 0)
            /*<<parsing.js 137 24>>*/ {res = CALL_ERROR_FUNCTION;
             /*<<parsing.js 139 8>>*/ break exit}
         case 5:
           /*<<parsing.js 144 6>>*/ if(errflag < 3)
            /*<<parsing.js 144 23>>*/ {errflag = 3;
             /*<<parsing.js 146 8>>*/ for(;;)
              /*<<parsing.js 146 17>>*/ {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
               /*<<parsing.js 150 10>>*/ if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
                /*<<parsing.js 151 43>>*/ {cmd = shift_recover;
                 /*<<parsing.js 152 33>>*/ break}
              else
                /*<<parsing.js 153 17>>*/ { /*<<parsing.js 154 12>>*/ if
                 (sp <= env[env_stackbase])
                  /*<<parsing.js 154 42>>*/ return RAISE_PARSE_ERROR;
                sp--}}}
          else
            /*<<parsing.js 159 13>>*/ { /*<<parsing.js 160 8>>*/ if
             (env[env_curr_char] == 0)
              /*<<parsing.js 160 37>>*/ return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
             /*<<parsing.js 163 20>>*/ break}
         case 8:
          env[env_curr_char] = - 1;
           /*<<parsing.js 168 6>>*/ if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
           /*<<parsing.js 173 6>>*/ if(sp >= env[env_stacksize])
            /*<<parsing.js 173 36>>*/ {res = GROW_STACKS_1;
             /*<<parsing.js 175 8>>*/ break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
           /*<<parsing.js 185 6>>*/ break;
         case 10:
           /*<<parsing.js 188 6>>*/  /*<<parsing.js 188 12>>*/ var
           m=
            tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
           /*<<parsing.js 197 6>>*/ state
          =
          n1
           !=
           0
           &&
           n2
           >=
           0
           &&
           n2
           <=
           tables[tbl_tablesize]
           &&
           tables.check[n2]
           ==
           state1
           ?tables.table[n2]
           :tables.dgoto[m];
           /*<<parsing.js 202 6>>*/ if(sp >= env[env_stacksize])
            /*<<parsing.js 202 36>>*/ {res = GROW_STACKS_2;
             /*<<parsing.js 204 8>>*/ break exit}
         case 3:
          res = COMPUTE_SEMANTIC_ACTION; /*<<parsing.js 210 6>>*/ break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
           /*<<parsing.js 215 6>>*/  /*<<parsing.js 215 14>>*/ var
           asp=
            env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
           /*<<parsing.js 217 6>>*/ if(sp > asp)
            /*<<parsing.js 217 20>>*/ env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
           /*<<parsing.js 221 18>>*/ break;
         default: /*<<parsing.js 224 6>>*/ return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
       /*<<parsing.js 231 2>>*/ return res /*<<parsing.js 232 0>>*/ }
     /*<<stdlib.js 30 0>>*/ function raw_array_copy(a)
     { /*<<stdlib.js 31 2>>*/ var
        /*<<stdlib.js 31 8>>*/ l=a.length,
        /*<<stdlib.js 32 8>>*/ b=new Array(l);
       /*<<stdlib.js 33 2>>*/ for( /*<<stdlib.js 33 12>>*/ var i=0;i < l;i++)
       b[i] = a[i];
       /*<<stdlib.js 34 2>>*/ return b /*<<stdlib.js 35 0>>*/ }
     /*<<marshal.js 461 0>>*/ function caml_output_value_to_buffer
     (s,ofs,len,v,_fl)
     { /*<<marshal.js 463 2>>*/  /*<<marshal.js 463 8>>*/ var
       t=
         /*<<marshal.js 463 10>>*/ caml_output_val(v);
       /*<<marshal.js 464 2>>*/ if(t.length > len)
        /*<<marshal.js 464 22>>*/ caml_failwith
        ("Marshal.to_buffer: buffer overflow");
       /*<<marshal.js 465 2>>*/ caml_blit_bytes(t,0,s,ofs,t.length);
       /*<<marshal.js 466 2>>*/ return 0 /*<<marshal.js 467 0>>*/ }
     /*<<jslib_js_of_ocaml.js 191 0>>*/ function caml_pure_js_expr(s)
     { /*<<jslib_js_of_ocaml.js 192 2>>*/ js_print_stderr
       ("caml_pure_js_expr: fallback to runtime evaluation");
       /*<<jslib_js_of_ocaml.js 193 2>>*/ return  /*<<jslib_js_of_ocaml.js 193 9>>*/ eval
              ( /*<<jslib_js_of_ocaml.js 193 14>>*/ s.toString()) /*<<jslib_js_of_ocaml.js 193 28>>*/ }
     /*<<mlString.js 627 0>>*/ function caml_blit_string(s1,i1,s2,i2,len)
     { /*<<mlString.js 629 2>>*/ return  /*<<mlString.js 629 9>>*/ caml_blit_bytes
              (s1,i1,s2,i2,len) /*<<mlString.js 630 0>>*/ }
     /*<<bigstring.js 68 0>>*/ function bigstring_blit_stub(s1,i1,s2,i2,len)
     { /*<<bigstring.js 69 2>>*/ for
       ( /*<<bigstring.js 69 13>>*/ var i=0;i < len;i++)
        /*<<bigstring.js 69 32>>*/ caml_ba_set_1
        (s2,i2 + i, /*<<bigstring.js 69 56>>*/ caml_ba_get_1(s1,i1 + i));
       /*<<bigstring.js 70 2>>*/ return 0 /*<<bigstring.js 71 0>>*/ }
     /*<<mlString.js 507 0>>*/ function caml_string_notequal(s1,s2)
     { /*<<mlString.js 507 40>>*/ return 1
             -
              /*<<mlString.js 507 49>>*/ caml_string_equal(s1,s2) /*<<mlString.js 507 76>>*/ }
     /*<<int64.js 115 0>>*/ function caml_int64_xor(x,y)
     { /*<<int64.js 116 2>>*/ return [255,x[1] ^ y[1],x[2] ^ y[2],x[3] ^ y[3]] /*<<int64.js 117 0>>*/ }
     /*<<mlString.js 564 0>>*/ function caml_bytes_greaterthan(s1,s2)
     { /*<<mlString.js 565 2>>*/ return  /*<<mlString.js 565 9>>*/ caml_bytes_lessthan
              (s2,s1) /*<<mlString.js 566 0>>*/ }
     /*<<fs.js 247 0>>*/ function caml_read_file_content(name)
     { /*<<fs.js 248 2>>*/  /*<<fs.js 248 11>>*/ var
       root=
         /*<<fs.js 248 13>>*/ resolve_fs_device(name);
       /*<<fs.js 249 2>>*/ if
       ( /*<<fs.js 249 5>>*/ root.device.exists(root.rest))
        /*<<fs.js 249 36>>*/ { /*<<fs.js 250 4>>*/ var
          /*<<fs.js 250 13>>*/ file=
           /*<<fs.js 250 15>>*/ root.device.open(root.rest,{rdonly:1}),
          /*<<fs.js 251 13>>*/ len= /*<<fs.js 251 15>>*/ file.length(),
          /*<<fs.js 252 13>>*/ buf=
           /*<<fs.js 252 15>>*/ caml_create_bytes(len);
         /*<<fs.js 253 4>>*/ file.read(0,buf,0,len);
         /*<<fs.js 254 4>>*/ return buf}
       /*<<fs.js 256 2>>*/ caml_raise_no_such_file(name) /*<<fs.js 257 0>>*/ }
     /*<<io.js 188 0>>*/ function caml_ml_set_channel_output(chanid,f)
     { /*<<io.js 189 2>>*/  /*<<io.js 189 11>>*/ var
       chan=
        caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
       /*<<io.js 191 2>>*/ return 0 /*<<io.js 192 0>>*/ }
     /*<<jslib_js_of_ocaml.js 29 0>>*/ function caml_js_to_float(x)
     { /*<<jslib_js_of_ocaml.js 29 31>>*/ return x /*<<jslib_js_of_ocaml.js 29 41>>*/ }
     /*<<stdlib.js 80 0>>*/ function caml_register_named_value(nm,v)
     {caml_named_values[ /*<<stdlib.js 81 20>>*/ caml_jsbytes_of_string(nm)]
      =
      v;
       /*<<stdlib.js 82 2>>*/ return 0 /*<<stdlib.js 83 0>>*/ }
     /*<<bigarray.js 486 0>>*/ function caml_ba_dim(ba,dim)
     { /*<<bigarray.js 487 4>>*/ return  /*<<bigarray.js 487 11>>*/ ba.nth_dim
              (dim) /*<<bigarray.js 488 0>>*/ }
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     bigstring_marshal_blit_stub:bigstring_marshal_blit_stub,
     bigstring_marshal_stub:bigstring_marshal_stub,
     bigstring_unmarshal_stub:bigstring_unmarshal_stub,
     bigstring_marshal_data_size_stub:bigstring_marshal_data_size_stub,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     bigstring_find:bigstring_find,
     bigstring_memcmp_stub:bigstring_memcmp_stub,
     bigstring_blit_stub:bigstring_blit_stub,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     bigstring_blit_bytes_bigstring_stub:bigstring_blit_bytes_bigstring_stub,
     bigstring_blit_string_bigstring_stub:bigstring_blit_string_bigstring_stub,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     bigstring_blit_bigstring_string_stub:bigstring_blit_bigstring_string_stub,
     bigstring_blit_bigstring_bytes_stub:bigstring_blit_bigstring_bytes_stub,
     bigstring_destroy_stub:bigstring_destroy_stub,
     bigstring_alloc:bigstring_alloc,
     caml_json:caml_json,
     JSON:JSON,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_from_string:caml_js_from_string,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_is_js:caml_is_js,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_sys_isatty:caml_sys_isatty,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_sys_exit:caml_sys_exit,
     caml_sys_getenv:caml_sys_getenv,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_get_public_method:caml_get_public_method,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_time:caml_sys_time,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_string_arr:caml_hash_mix_string_arr,
     caml_hash_mix_string_str:caml_hash_mix_string_str,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_format_float:caml_format_float,
     caml_format_int:caml_format_int,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_is_printable:caml_is_printable,
     caml_float_of_string:caml_float_of_string,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_failwith:caml_failwith,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     raw_array_append_one:raw_array_append_one,
     raw_array_cons:raw_array_cons,
     raw_array_copy:raw_array_copy,
     raw_array_sub:raw_array_sub,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_fill:caml_ba_fill,
     caml_ba_blit:caml_ba_blit,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_views:caml_ba_views,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init_views:caml_ba_init_views,
     caml_ba_init:caml_ba_init,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlBytesReader:MlBytesReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_udivmod:caml_int64_udivmod,
     caml_int64_lsr1:caml_int64_lsr1,
     caml_int64_lsl1:caml_int64_lsl1,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_minus_one:caml_int64_is_minus_one,
     caml_int64_is_min_int:caml_int64_is_min_int,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     caml_int64_ucompare:caml_int64_ucompare,
     caml_int64_offset:caml_int64_offset,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_ml_string_length:caml_ml_string_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_string_lessthan:caml_string_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_string_lessequal:caml_string_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_string_equal:caml_string_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_string_compare:caml_string_compare,
     caml_string_of_array:caml_string_of_array,
     caml_new_string:caml_new_string,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_js_to_string:caml_js_to_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_array_of_string:caml_array_of_string,
     caml_convert_string_to_array:caml_convert_string_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_string_bound_error:caml_string_bound_error,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_to_js_string:caml_to_js_string,
     caml_is_ascii:caml_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_string:caml_subarray_to_string,
     caml_str_repeat:caml_str_repeat};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_new_string("Out_of_memory"),0],"Out_of_memory");
    caml_register_global(1,[248,caml_new_string("Sys_error"),-1],"Sys_error");
    caml_register_global(2,[248,caml_new_string("Failure"),-2],"Failure");
    caml_register_global
     (3,[248,caml_new_string("Invalid_argument"),-3],"Invalid_argument");
    caml_register_global
     (4,[248,caml_new_string("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,[248,caml_new_string("Division_by_zero"),-5],"Division_by_zero");
    caml_register_global(6,[248,caml_new_string("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_new_string("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_new_string("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_new_string("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_new_string("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_new_string("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return /*<<?>>*/ }
  (function(){return this}()));


//# 1 ".js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_sub=runtime.caml_array_sub,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtrace=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_set_tag=runtime.caml_obj_set_tag,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_obj_truncate=runtime.caml_obj_truncate,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_native_code=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_weak_blit=runtime.caml_weak_blit,
     caml_weak_check=runtime.caml_weak_check,
     caml_weak_create=runtime.caml_weak_create,
     caml_weak_get=runtime.caml_weak_get,
     caml_weak_get_copy=runtime.caml_weak_get_copy,
     caml_weak_set=runtime.caml_weak_set,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string("%,"),
     cst_really_input=caml_new_string("really_input"),
     cst_input=caml_new_string("input"),
     cst_output_substring=caml_new_string("output_substring"),
     cst_output=caml_new_string("output"),
     cst_12g=caml_new_string("%.12g"),
     cst=caml_new_string("."),
     cst_false$1=caml_new_string("false"),
     cst_true$1=caml_new_string("true"),
     cst_false$0=caml_new_string("false"),
     cst_true$0=caml_new_string("true"),
     cst_bool_of_string=caml_new_string("bool_of_string"),
     cst_true=caml_new_string("true"),
     cst_false=caml_new_string("false"),
     cst_char_of_int=caml_new_string("char_of_int"),
     cst_Pervasives_Exit=caml_new_string("Pervasives.Exit"),
     cst_List_map2=caml_new_string("List.map2"),
     cst_List_iter2=caml_new_string("List.iter2"),
     cst_List_fold_left2=caml_new_string("List.fold_left2"),
     cst_List_fold_right2=caml_new_string("List.fold_right2"),
     cst_List_for_all2=caml_new_string("List.for_all2"),
     cst_List_exists2=caml_new_string("List.exists2"),
     cst_List_combine=caml_new_string("List.combine"),
     cst_List_rev_map2=caml_new_string("List.rev_map2"),
     cst_List_init=caml_new_string("List.init"),
     cst_List_nth$0=caml_new_string("List.nth"),
     cst_nth=caml_new_string("nth"),
     cst_List_nth=caml_new_string("List.nth"),
     cst_tl=caml_new_string("tl"),
     cst_hd=caml_new_string("hd"),
     cst$1=caml_new_string("\\\\"),
     cst$2=caml_new_string("\\'"),
     cst_b=caml_new_string("\\b"),
     cst_t=caml_new_string("\\t"),
     cst_n=caml_new_string("\\n"),
     cst_r=caml_new_string("\\r"),
     cst_Char_chr=caml_new_string("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_new_string(" is not a latin1 character"),
     cst_04X=caml_new_string("%04X"),
     cst_U=caml_new_string("U+"),
     cst_is_not_an_Unicode_scalar_value=
      caml_new_string(" is not an Unicode scalar value"),
     cst_X=caml_new_string("%X"),
     err_no_pred=caml_new_string("U+0000 has no predecessor"),
     err_no_succ=caml_new_string("U+10FFFF has no successor"),
     cst_String_rcontains_from_Bytes_rcontains_from=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_new_string("Bytes.concat"),
     cst_String_blit_Bytes_blit_string=
      caml_new_string("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_new_string("Bytes.blit"),
     cst_String_fill_Bytes_fill=caml_new_string("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_new_string("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_new_string("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Bytes_rcontains_from$0=
      caml_new_string("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes_contains_from$0=
      caml_new_string("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Bytes_rindex_from_opt$0=
      caml_new_string("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_rindex_from$0=
      caml_new_string("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Bytes_index_from_opt$0=
      caml_new_string("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_index_from$0=
      caml_new_string("String.index_from / Bytes.index_from"),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_String_concat=caml_new_string("String.concat"),
     cst_Sys_Break=caml_new_string("Sys.Break"),
     ocaml_version=caml_new_string("4.06.0"),
     cst_Sort_array=caml_new_string("Sort.array"),
     cst_Marshal_from_bytes=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_new_string("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_new_string("Marshal.data_size"),
     cst_Marshal_to_buffer_substring_out_of_bounds=
      caml_new_string("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_extension_constructor$0=
      caml_new_string("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_new_string("Obj.extension_constructor"),
     cst_Array_map2_arrays_must_have_the_same_length=
      caml_new_string("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_have_the_same_length=
      caml_new_string("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_new_string("Array.blit"),
     cst_Array_fill=caml_new_string("Array.fill"),
     cst_Array_sub=caml_new_string("Array.sub"),
     cst_Array_init=caml_new_string("Array.init"),
     cst_Array_Bottom=caml_new_string("Array.Bottom"),
     cst_d=caml_new_string("%d"),
     cst_d$0=caml_new_string("%d"),
     zero$0=[255,0,0,0],
     one$0=[255,1,0,0],
     minus_one$0=[255,16777215,16777215,65535],
     min_int$1=[255,0,0,32768],
     max_int$1=[255,16777215,16777215,32767],
     cst_d$1=caml_new_string("%d"),
     cst_Lexing_lex_refill_cannot_grow_buffer=
      caml_new_string("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_new_string(""),0,0,-1],
     zero_pos=[0,caml_new_string(""),1,0,0],
     cst_syntax_error=caml_new_string("syntax error"),
     cst_Parsing_YYexit=caml_new_string("Parsing.YYexit"),
     cst_Parsing_Parse_error=caml_new_string("Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_new_string("Set.remove_min_elt"),
     cst_Set_bal=caml_new_string("Set.bal"),
     cst_Set_bal$0=caml_new_string("Set.bal"),
     cst_Set_bal$1=caml_new_string("Set.bal"),
     cst_Set_bal$2=caml_new_string("Set.bal"),
     cst_Map_remove_min_elt=caml_new_string("Map.remove_min_elt"),
     cst_Map_bal=caml_new_string("Map.bal"),
     cst_Map_bal$0=caml_new_string("Map.bal"),
     cst_Map_bal$1=caml_new_string("Map.bal"),
     cst_Map_bal$2=caml_new_string("Map.bal"),
     cst_Stack_Empty=caml_new_string("Stack.Empty"),
     cst_Queue_Empty=caml_new_string("Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_new_string("CamlinternalLazy.Undefined"),
     cst_count=caml_new_string("{count = "),
     cst_data=caml_new_string("; data = "),
     cst$5=caml_new_string("}"),
     cst_Sempty=caml_new_string("Sempty"),
     cst_Scons=caml_new_string("Scons ("),
     cst$6=caml_new_string(", "),
     cst$7=caml_new_string(")"),
     cst_Sapp=caml_new_string("Sapp ("),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(")"),
     cst_Slazy=caml_new_string("Slazy"),
     cst_Sgen=caml_new_string("Sgen"),
     cst_Sbuffio=caml_new_string("Sbuffio"),
     cst_Stream_Failure=caml_new_string("Stream.Failure"),
     cst_Stream_Error=caml_new_string("Stream.Error"),
     cst_Buffer_truncate=caml_new_string("Buffer.truncate"),
     cst_Buffer_add_channel=caml_new_string("Buffer.add_channel"),
     cst_Buffer_add_substring_add_subbytes=
      caml_new_string("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buffer=
      caml_new_string("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_new_string("Buffer.nth"),
     cst_Buffer_blit=caml_new_string("Buffer.blit"),
     cst_Buffer_sub=caml_new_string("Buffer.sub"),
     cst_c=caml_new_string("%c"),
     cst_s=caml_new_string("%s"),
     cst_i=caml_new_string("%i"),
     cst_li=caml_new_string("%li"),
     cst_ni=caml_new_string("%ni"),
     cst_Li=caml_new_string("%Li"),
     cst_f=caml_new_string("%f"),
     cst_B=caml_new_string("%B"),
     cst$20=caml_new_string("%{"),
     cst$21=caml_new_string("%}"),
     cst$22=caml_new_string("%("),
     cst$23=caml_new_string("%)"),
     cst_a=caml_new_string("%a"),
     cst_t$0=caml_new_string("%t"),
     cst$24=caml_new_string("%?"),
     cst_r$0=caml_new_string("%r"),
     cst_r$1=caml_new_string("%_r"),
     cst_u$0=caml_new_string("%u"),
     cst_Printf_bad_conversion=caml_new_string("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=caml_new_string("Printf: bad conversion %_"),
     cst$28=caml_new_string("@{"),
     cst$29=caml_new_string("@["),
     cst$30=caml_new_string("@{"),
     cst$31=caml_new_string("@["),
     cst$32=caml_new_string("@{"),
     cst$33=caml_new_string("@["),
     cst_0=caml_new_string("0"),
     cst_padding=caml_new_string("padding"),
     cst_precision=caml_new_string("precision"),
     cst$38=caml_new_string("'*'"),
     cst$36=caml_new_string("'-'"),
     cst_0$2=caml_new_string("'0'"),
     cst$37=caml_new_string("'*'"),
     cst_0$0=caml_new_string("0"),
     cst_0$1=caml_new_string("0"),
     cst_precision$0=caml_new_string("precision"),
     cst_precision$1=caml_new_string("precision"),
     cst$39=caml_new_string("'+'"),
     cst$40=caml_new_string("'#'"),
     cst$41=caml_new_string("' '"),
     cst_padding$0=caml_new_string("`padding'"),
     cst_precision$2=caml_new_string("`precision'"),
     cst$42=caml_new_string("'+'"),
     cst$43=caml_new_string("'_'"),
     sub_format=[0,0,caml_new_string("")],
     formatting_lit=[0,caml_new_string("@;"),1,0],
     cst_digit=caml_new_string("digit"),
     cst_character=caml_new_string("character ')'"),
     cst_character$0=caml_new_string("character '}'"),
     cst$47=caml_new_string("'#'"),
     cst$46=caml_new_string("'+'"),
     cst$45=caml_new_string("'+'"),
     cst$44=caml_new_string("' '"),
     cst$50=caml_new_string("'+'"),
     cst$49=caml_new_string("'+'"),
     cst$48=caml_new_string("' '"),
     cst_non_zero_widths_are_unsupported_for_c_conversions=
      caml_new_string("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=caml_new_string("unexpected end of format"),
     cst$34=caml_new_string(""),
     cst$35=caml_new_string(""),
     cst_b$0=caml_new_string("b"),
     cst_h=caml_new_string("h"),
     cst_hov=caml_new_string("hov"),
     cst_hv=caml_new_string("hv"),
     cst_v=caml_new_string("v"),
     cst_nan=caml_new_string("nan"),
     cst$27=caml_new_string("."),
     cst_neg_infinity=caml_new_string("neg_infinity"),
     cst_infinity=caml_new_string("infinity"),
     cst_12g$0=caml_new_string("%.12g"),
     cst_nd=caml_new_string("%nd"),
     cst_nd$0=caml_new_string("%+nd"),
     cst_nd$1=caml_new_string("% nd"),
     cst_ni$0=caml_new_string("%ni"),
     cst_ni$1=caml_new_string("%+ni"),
     cst_ni$2=caml_new_string("% ni"),
     cst_nx=caml_new_string("%nx"),
     cst_nx$0=caml_new_string("%#nx"),
     cst_nX=caml_new_string("%nX"),
     cst_nX$0=caml_new_string("%#nX"),
     cst_no=caml_new_string("%no"),
     cst_no$0=caml_new_string("%#no"),
     cst_nu=caml_new_string("%nu"),
     cst_ld=caml_new_string("%ld"),
     cst_ld$0=caml_new_string("%+ld"),
     cst_ld$1=caml_new_string("% ld"),
     cst_li$0=caml_new_string("%li"),
     cst_li$1=caml_new_string("%+li"),
     cst_li$2=caml_new_string("% li"),
     cst_lx=caml_new_string("%lx"),
     cst_lx$0=caml_new_string("%#lx"),
     cst_lX=caml_new_string("%lX"),
     cst_lX$0=caml_new_string("%#lX"),
     cst_lo=caml_new_string("%lo"),
     cst_lo$0=caml_new_string("%#lo"),
     cst_lu=caml_new_string("%lu"),
     cst_Ld=caml_new_string("%Ld"),
     cst_Ld$0=caml_new_string("%+Ld"),
     cst_Ld$1=caml_new_string("% Ld"),
     cst_Li$0=caml_new_string("%Li"),
     cst_Li$1=caml_new_string("%+Li"),
     cst_Li$2=caml_new_string("% Li"),
     cst_Lx=caml_new_string("%Lx"),
     cst_Lx$0=caml_new_string("%#Lx"),
     cst_LX=caml_new_string("%LX"),
     cst_LX$0=caml_new_string("%#LX"),
     cst_Lo=caml_new_string("%Lo"),
     cst_Lo$0=caml_new_string("%#Lo"),
     cst_Lu=caml_new_string("%Lu"),
     cst_d$2=caml_new_string("%d"),
     cst_d$3=caml_new_string("%+d"),
     cst_d$4=caml_new_string("% d"),
     cst_i$0=caml_new_string("%i"),
     cst_i$1=caml_new_string("%+i"),
     cst_i$2=caml_new_string("% i"),
     cst_x=caml_new_string("%x"),
     cst_x$0=caml_new_string("%#x"),
     cst_X$0=caml_new_string("%X"),
     cst_X$1=caml_new_string("%#X"),
     cst_o=caml_new_string("%o"),
     cst_o$0=caml_new_string("%#o"),
     cst_u=caml_new_string("%u"),
     cst$25=caml_new_string("%!"),
     cst$26=caml_new_string("@{"),
     cst_0c=caml_new_string("0c"),
     cst$19=caml_new_string("%%"),
     cst$11=caml_new_string("@]"),
     cst$12=caml_new_string("@}"),
     cst$13=caml_new_string("@?"),
     cst$14=caml_new_string("@\n"),
     cst$15=caml_new_string("@."),
     cst$16=caml_new_string("@@"),
     cst$17=caml_new_string("@%"),
     cst$18=caml_new_string("@"),
     cst$10=caml_new_string(".*"),
     cst_CamlinternalFormat_Type_mismatch=
      caml_new_string("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_new_string(""),
     cst$59=caml_new_string("\n"),
     cst_a_boolean=caml_new_string("a boolean"),
     cst_an_integer=caml_new_string("an integer"),
     cst_an_integer$0=caml_new_string("an integer"),
     cst_a_float=caml_new_string("a float"),
     cst_a_float$0=caml_new_string("a float"),
     cst$55=caml_new_string(""),
     cst$56=caml_new_string(" "),
     cst$57=caml_new_string(""),
     cst_one_of=caml_new_string("one of: "),
     cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic=
      caml_new_string
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_new_string("no argument"),
     cst$54=caml_new_string("(?)"),
     cst_help$3=caml_new_string("--help"),
     cst_help$4=caml_new_string("-help"),
     cst_help$2=caml_new_string("-help"),
     cst_Display_this_list_of_options=
      caml_new_string(" Display this list of options"),
     cst_help=caml_new_string("-help"),
     cst_help$1=caml_new_string("--help"),
     cst_Display_this_list_of_options$0=
      caml_new_string(" Display this list of options"),
     cst_help$0=caml_new_string("--help"),
     cst$51=caml_new_string("}"),
     cst$52=caml_new_string("|"),
     cst$53=caml_new_string("{"),
     cst_none=caml_new_string("<none>"),
     cst_Arg_Bad=caml_new_string("Arg.Bad"),
     cst_Arg_Help=caml_new_string("Arg.Help"),
     cst_Arg_Stop=caml_new_string("Arg.Stop"),
     cst$61=caml_new_string(""),
     cst_Program_not_linked_with_g_cannot_print_stack_backtrace=
      caml_new_string
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_new_string("Raised at"),
     cst_Re_raised_at=caml_new_string("Re-raised at"),
     cst_Raised_by_primitive_operation_at=
      caml_new_string("Raised by primitive operation at"),
     cst_Called_from=caml_new_string("Called from"),
     cst_inlined=caml_new_string(" (inlined)"),
     cst$64=caml_new_string(""),
     partial=[4,0,0,0,0],
     cst_Out_of_memory=caml_new_string("Out of memory"),
     cst_Stack_overflow=caml_new_string("Stack overflow"),
     cst_Pattern_matching_failed=caml_new_string("Pattern matching failed"),
     cst_Assertion_failed=caml_new_string("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_new_string("Undefined recursive module"),
     cst$62=caml_new_string(""),
     cst$63=caml_new_string(""),
     cst$60=caml_new_string("_"),
     locfmt=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,0,0,0,[12,45,[4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]]]]]],
       caml_new_string('File "%s", line %d, characters %d-%d: %s')],
     cst_Digest_from_hex$0=caml_new_string("Digest.from_hex"),
     cst_Digest_from_hex=caml_new_string("Digest.from_hex"),
     cst_Digest_to_hex=caml_new_string("Digest.to_hex"),
     cst_Digest_substring=caml_new_string("Digest.substring"),
     cst_Random_int64=caml_new_string("Random.int64"),
     cst_Random_int32=caml_new_string("Random.int32"),
     cst_Random_int=caml_new_string("Random.int"),
     cst_x$1=caml_new_string("x"),
     cst_OCAMLRUNPARAM=caml_new_string("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_new_string("CAMLRUNPARAM"),
     cst$65=caml_new_string(""),
     cst_Weak_Make_hash_bucket_cannot_grow_more=
      caml_new_string("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_new_string("Weak.fill"),
     cst$71=caml_new_string("."),
     cst$69=caml_new_string(">"),
     cst$70=caml_new_string("</"),
     cst$67=caml_new_string(">"),
     cst$68=caml_new_string("<"),
     cst$66=caml_new_string("\n"),
     cst_Format_Empty_queue=caml_new_string("Format.Empty_queue"),
     cst_end_of_input_not_found=caml_new_string("end of input not found"),
     cst_scanf_bad_conversion_a=caml_new_string('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=caml_new_string('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_new_string("scanf: missing reader"),
     cst_scanf_bad_conversion_custom_converter=
      caml_new_string('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=caml_new_string('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=caml_new_string('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=caml_new_string('scanf: bad conversion "%*"'),
     cst$75=caml_new_string('"'),
     cst$76=caml_new_string('"'),
     cst$74=caml_new_string('"'),
     cst_in_format=caml_new_string(' in format "'),
     cst_an=caml_new_string("an"),
     cst_x$2=caml_new_string("x"),
     cst_nfinity=caml_new_string("nfinity"),
     cst_digits=caml_new_string("digits"),
     cst_decimal_digits=caml_new_string("decimal digits"),
     cst_0b=caml_new_string("0b"),
     cst_0o=caml_new_string("0o"),
     cst_0u=caml_new_string("0u"),
     cst_0x=caml_new_string("0x"),
     cst_false$2=caml_new_string("false"),
     cst_true$2=caml_new_string("true"),
     cst_not_a_valid_float_in_hexadecimal_notation=
      caml_new_string("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_found_in_float_token=
      caml_new_string("no dot or exponent part found in float token"),
     cst$73=caml_new_string("-"),
     cst_unnamed_function=caml_new_string("unnamed function"),
     cst_unnamed_character_string=caml_new_string("unnamed character string"),
     cst_unnamed_Pervasives_input_channel=
      caml_new_string("unnamed Pervasives input channel"),
     cst$72=caml_new_string("-"),
     cst_Scanf_Scan_failure=caml_new_string("Scanf.Scan_failure"),
     cst_binary=caml_new_string("binary"),
     cst_octal=caml_new_string("octal"),
     cst_hexadecimal=caml_new_string("hexadecimal"),
     cst_a_Char=caml_new_string("a Char"),
     cst_a_String=caml_new_string("a String"),
     cst$77=caml_new_string(""),
     cst$78=caml_new_string(""),
     cst$79=caml_new_string(""),
     cst$80=caml_new_string(""),
     cst$81=caml_new_string(""),
     cst$83=caml_new_string(""),
     cst$82=caml_new_string(""),
     cst_Illegal_character=caml_new_string("Illegal character "),
     cst_Filename_chop_extension=caml_new_string("Filename.chop_extension"),
     cst$94=caml_new_string(""),
     cst_Filename_chop_suffix=caml_new_string("Filename.chop_suffix"),
     cst$93=caml_new_string(""),
     cst$91=caml_new_string("./"),
     cst$90=caml_new_string(".\\"),
     cst$89=caml_new_string("../"),
     cst$88=caml_new_string("..\\"),
     cst$87=caml_new_string("./"),
     cst$86=caml_new_string("../"),
     cst$85=caml_new_string(""),
     cst$84=caml_new_string(""),
     current_dir_name=caml_new_string("."),
     parent_dir_name=caml_new_string(".."),
     dir_sep=caml_new_string("/"),
     cst_TMPDIR=caml_new_string("TMPDIR"),
     cst_tmp=caml_new_string("/tmp"),
     quotequote=caml_new_string("'\\''"),
     current_dir_name$0=caml_new_string("."),
     parent_dir_name$0=caml_new_string(".."),
     dir_sep$0=caml_new_string("\\"),
     cst_TEMP=caml_new_string("TEMP"),
     cst$92=caml_new_string("."),
     current_dir_name$1=caml_new_string("."),
     parent_dir_name$1=caml_new_string(".."),
     dir_sep$1=caml_new_string("/"),
     cst_Cygwin=caml_new_string("Cygwin"),
     cst_Win32=caml_new_string("Win32"),
     zero$2=[254,0,0],
     one$2=[254,1,0],
     i=[254,0,1],
     cst_Series_is_closed$0=caml_new_string("Series is closed"),
     cst_Series_is_closed=caml_new_string("Series is closed"),
     End_of_file=global_data.End_of_file,
     Sys_error=global_data.Sys_error,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Match_failure=global_data.Match_failure,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _m_=[0,0,[0,6,0]],
     _l_=[0,0,[0,7,0]],
     _k_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _j_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _h_=[0,1],
     _i_=[0,0],
     _a_=[255,0,0,32752],
     _b_=[255,0,0,65520],
     _c_=[255,1,0,32752],
     _d_=[255,16777215,16777215,32751],
     _e_=[255,0,0,16],
     _f_=[255,0,0,15536],
     _p_=[0,0,0],
     _q_=[0,caml_new_string("list.ml"),262,11],
     _I_=[0,caml_new_string("array.ml"),233,4],
     _M_=[255,16777215,16777215,65535],
     _L_=[255,0,0,0],
     _K_=[255,1,0,0],
     _J_=[255,1,0,0],
     _N_=[0,0,0,0],
     _O_=[0,0,0],
     _P_=[0,caml_new_string("set.ml"),510,18],
     _Q_=[0,0,0,0],
     _R_=[0,caml_new_string("map.ml"),393,10],
     _S_=[0,0,0],
     _T_=[0,caml_new_string("stream.ml"),53,12],
     _U_=[0,0],
     _V_=[0,caml_new_string("stream.ml"),82,12],
     _aa_=[0,caml_new_string("buffer.ml"),205,9],
     _$_=[0,caml_new_string("buffer.ml"),141,19],
     ___=[0,caml_new_string("buffer.ml"),159,8],
     _Z_=[0,caml_new_string("buffer.ml"),120,19],
     _Y_=[0,caml_new_string("buffer.ml"),138,8],
     _X_=[0,caml_new_string("buffer.ml"),84,19],
     _W_=[0,caml_new_string("buffer.ml"),117,8],
     _ab_=[0,caml_new_string("camlinternalFormat.ml"),846,23],
     _am_=[0,caml_new_string("camlinternalFormat.ml"),810,21],
     _ae_=[0,caml_new_string("camlinternalFormat.ml"),811,21],
     _an_=[0,caml_new_string("camlinternalFormat.ml"),814,21],
     _af_=[0,caml_new_string("camlinternalFormat.ml"),815,21],
     _ao_=[0,caml_new_string("camlinternalFormat.ml"),818,19],
     _ag_=[0,caml_new_string("camlinternalFormat.ml"),819,19],
     _ap_=[0,caml_new_string("camlinternalFormat.ml"),822,22],
     _ah_=[0,caml_new_string("camlinternalFormat.ml"),823,22],
     _aq_=[0,caml_new_string("camlinternalFormat.ml"),827,30],
     _ai_=[0,caml_new_string("camlinternalFormat.ml"),828,30],
     _ak_=[0,caml_new_string("camlinternalFormat.ml"),832,26],
     _ac_=[0,caml_new_string("camlinternalFormat.ml"),833,26],
     _al_=[0,caml_new_string("camlinternalFormat.ml"),842,28],
     _ad_=[0,caml_new_string("camlinternalFormat.ml"),843,28],
     _aj_=[0,caml_new_string("camlinternalFormat.ml"),847,23],
     _ar_=[0,caml_new_string("camlinternalFormat.ml"),1525,4],
     _as_=[0,caml_new_string("camlinternalFormat.ml"),1593,39],
     _at_=[0,caml_new_string("camlinternalFormat.ml"),1616,31],
     _au_=[0,caml_new_string("camlinternalFormat.ml"),1617,31],
     _av_=[0,caml_new_string("camlinternalFormat.ml"),1797,8],
     _aZ_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aY_=
      [0,
       [11,
        caml_new_string("bad input: format type mismatch between "),
        [3,0,[11,caml_new_string(" and "),[3,0,0]]]],
       caml_new_string("bad input: format type mismatch between %S and %S")],
     _aB_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", duplicate flag "),[1,0]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aC_=[0,1,0],
     _aD_=[0,0],
     _aF_=[1,0],
     _aE_=[1,1],
     _aH_=[1,1],
     _aG_=[1,1],
     _aL_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", flag "),
            [1,
             [11,
              caml_new_string(" is only allowed after the '"),
              [12,
               37,
               [11,caml_new_string("', before padding and precision"),0]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aI_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_new_string
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aJ_=[0,0],
     _aK_=[0,0],
     _aM_=[0,[12,64,0]],
     _aN_=[0,caml_new_string("@ "),1,0],
     _aO_=[0,caml_new_string("@,"),0,0],
     _aP_=[2,60],
     _aQ_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": '"),
          [12,
           37,
           [11,
            caml_new_string("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_new_string(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aR_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": integer "),
          [4,
           0,
           0,
           0,
           [11,caml_new_string(" is greater than the limit "),[4,0,0,0,0]]]]]],
       caml_new_string
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aS_=[0,caml_new_string("camlinternalFormat.ml"),2811,11],
     _aT_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,[11,caml_new_string('" at character number '),[4,0,0,0,0]]]]]]],
       caml_new_string
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aU_=[0,caml_new_string("camlinternalFormat.ml"),2873,34],
     _aV_=[0,caml_new_string("camlinternalFormat.ml"),2906,28],
     _aW_=[0,caml_new_string("camlinternalFormat.ml"),2940,25],
     _aX_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,
             0,
             [11,
              caml_new_string(" is incompatible with '"),
              [0,[11,caml_new_string("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _aA_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", "),
            [2,0,[11,caml_new_string(" expected, read "),[1,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _az_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", '"),
            [0,[11,caml_new_string("' without "),[2,0,0]]]]]]]],
       caml_new_string
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ay_=
      [0,
       [11,
        caml_new_string("invalid format "),
        [3,
         0,
         [11,
          caml_new_string(": at character number "),
          [4,0,0,0,[11,caml_new_string(", "),[2,0,0]]]]]],
       caml_new_string("invalid format %S: at character number %d, %s")],
     _ax_=
      [0,
       [11,caml_new_string("invalid box description "),[3,0,0]],
       caml_new_string("invalid box description %S")],
     _aw_=[0,0,4],
     _bj_=[0,[2,0,[0,0]],caml_new_string("%s%c")],
     _bd_=[0,[2,0,0],caml_new_string("%s")],
     _be_=[0,[2,0,0],caml_new_string("%s")],
     _bb_=[0,[2,0,0],caml_new_string("%s")],
     _bc_=[0,[2,0,0],caml_new_string("%s")],
     _a$_=[0,[2,0,0],caml_new_string("%s")],
     _ba_=[0,[2,0,0],caml_new_string("%s")],
     _a5_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": unknown option '"),
         [2,0,[11,caml_new_string("'.\n"),0]]]],
       caml_new_string("%s: unknown option '%s'.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": wrong argument '"),
         [2,
          0,
          [11,
           caml_new_string("'; option '"),
           [2,
            0,
            [11,
             caml_new_string("' expects "),
             [2,0,[11,caml_new_string(".\n"),0]]]]]]]],
       caml_new_string("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": option '"),
         [2,0,[11,caml_new_string("' needs an argument.\n"),0]]]],
       caml_new_string("%s: option '%s' needs an argument.\n")],
     _a__=
      [0,
       [2,0,[11,caml_new_string(": "),[2,0,[11,caml_new_string(".\n"),0]]]],
       caml_new_string("%s: %s.\n")],
     _a6_=[0,caml_new_string("-help")],
     _a7_=[0,caml_new_string("--help")],
     _a4_=[0,[2,0,0],caml_new_string("%s")],
     _a3_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _a2_=[0,caml_new_string("-help")],
     _a0_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_new_string("  %s %s\n")],
     _a1_=
      [0,
       [11,caml_new_string("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_new_string("  %s %s%s\n")],
     _bo_=
      [0,[11,caml_new_string(", "),[2,0,[2,0,0]]],caml_new_string(", %s%s")],
     _bx_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bv_=[0,[2,0,[12,10,0]],caml_new_string("%s\n")],
     _bw_=
      [0,
       [11,
        caml_new_string
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_new_string
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bt_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(' file "'),
         [2,
          0,
          [12,
           34,
           [2,
            0,
            [11,
             caml_new_string(", line "),
             [4,
              0,
              0,
              0,
              [11,caml_new_string(", characters "),[4,0,0,0,[12,45,partial]]]]]]]]]],
       caml_new_string('%s file "%s"%s, line %d, characters %d-%d')],
     _bu_=
      [0,
       [2,0,[11,caml_new_string(" unknown location"),0]],
       caml_new_string("%s unknown location")],
     _bs_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _br_=
      [0,
       [11,caml_new_string("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_new_string("Uncaught exception: %s\n")],
     _bp_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_new_string("(%s%s)")],
     _bq_=[0,[12,40,[2,0,[12,41,0]]],caml_new_string("(%s)")],
     _bn_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bm_=[0,[3,0,0],caml_new_string("%S")],
     _bG_=
      [0,
       [11,caml_new_string("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("minor_collections: %d\n")],
     _bH_=
      [0,
       [11,caml_new_string("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("major_collections: %d\n")],
     _bI_=
      [0,
       [11,caml_new_string("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_new_string("compactions:       %d\n")],
     _bJ_=[0,[12,10,0],caml_new_string("\n")],
     _bK_=[0,[8,0,0,[0,0],0],caml_new_string("%.0f")],
     _bL_=
      [0,
       [11,caml_new_string("minor_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("minor_words:    %*.0f\n")],
     _bM_=
      [0,
       [11,caml_new_string("promoted_words: "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("promoted_words: %*.0f\n")],
     _bN_=
      [0,
       [11,caml_new_string("major_words:    "),[8,0,[1,1],[0,0],[12,10,0]]],
       caml_new_string("major_words:    %*.0f\n")],
     _bO_=[0,[12,10,0],caml_new_string("\n")],
     _bP_=[0,[4,0,0,0,0],caml_new_string("%d")],
     _bQ_=
      [0,
       [11,caml_new_string("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("top_heap_words: %*d\n")],
     _bR_=
      [0,
       [11,caml_new_string("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("heap_words:     %*d\n")],
     _bS_=
      [0,
       [11,caml_new_string("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("live_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_new_string("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("free_words:     %*d\n")],
     _bU_=
      [0,
       [11,caml_new_string("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("largest_free:   %*d\n")],
     _bV_=
      [0,
       [11,caml_new_string("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_new_string("fragments:      %*d\n")],
     _bW_=[0,[12,10,0],caml_new_string("\n")],
     _bX_=
      [0,
       [11,caml_new_string("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("live_blocks: %d\n")],
     _bY_=
      [0,
       [11,caml_new_string("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("free_blocks: %d\n")],
     _bZ_=
      [0,
       [11,caml_new_string("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_new_string("heap_chunks: %d\n")],
     _b2_=[255,1,0,0],
     _b3_=[255,0,0,0],
     _b4_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _b8_=[0,0],
     _b7_=[0,caml_new_string("hashtbl.ml"),108,23],
     _b__=[3,0,3],
     _b9_=[0,caml_new_string("")],
     _co_=[0,91],
     _cn_=[0,123],
     _cp_=[0,caml_new_string("scanf.ml"),1455,13],
     _cq_=[0,[3,0,[10,0]],caml_new_string("%S%!")],
     _cm_=[0,37,caml_new_string("")],
     _cl_=
      [0,
       [11,
        caml_new_string("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_new_string(": "),[2,0,0]]]],
       caml_new_string("scanf: bad input at char number %i: %s")],
     _ck_=
      [0,
       [11,
        caml_new_string("the character "),
        [1,[11,caml_new_string(" cannot start a boolean"),0]]],
       caml_new_string("the character %C cannot start a boolean")],
     _cj_=
      [0,
       [11,caml_new_string("bad character hexadecimal encoding \\"),[0,[0,0]]],
       caml_new_string("bad character hexadecimal encoding \\%c%c")],
     _ci_=
      [0,
       [11,caml_new_string("bad character decimal encoding \\"),[0,[0,[0,0]]]],
       caml_new_string("bad character decimal encoding \\%c%c%c")],
     _ch_=
      [0,
       [11,
        caml_new_string("character "),
        [1,
         [11,
          caml_new_string(" is not a valid "),
          [2,0,[11,caml_new_string(" digit"),0]]]]],
       caml_new_string("character %C is not a valid %s digit")],
     _cg_=
      [0,
       [11,
        caml_new_string("character "),
        [1,[11,caml_new_string(" is not a decimal digit"),0]]],
       caml_new_string("character %C is not a decimal digit")],
     _cf_=[0,caml_new_string("scanf.ml"),555,9],
     _ce_=
      [0,
       [11,caml_new_string("invalid boolean '"),[2,0,[12,39,0]]],
       caml_new_string("invalid boolean '%s'")],
     _cd_=
      [0,
       [11,
        caml_new_string("looking for "),
        [1,[11,caml_new_string(", found "),[1,0]]]],
       caml_new_string("looking for %C, found %C")],
     _cc_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cb_=
      [0,
       [11,
        caml_new_string("scanning of "),
        [2,
         0,
         [11,
          caml_new_string
           (" failed: the specified length was too short for token"),
          0]]],
       caml_new_string
        ("scanning of %s failed: the specified length was too short for token")],
     _ca_=
      [0,
       [11,caml_new_string("illegal escape character "),[1,0]],
       caml_new_string("illegal escape character %C")],
     _cx_=[0,caml_new_string("camlinternalOO.ml"),438,17],
     _cw_=[0,caml_new_string("camlinternalOO.ml"),420,13],
     _cv_=[0,caml_new_string("camlinternalOO.ml"),417,13],
     _cu_=[0,caml_new_string("camlinternalOO.ml"),414,13],
     _ct_=[0,caml_new_string("camlinternalOO.ml"),411,13],
     _cs_=[0,caml_new_string("camlinternalOO.ml"),408,13],
     _cr_=[0,caml_new_string("camlinternalOO.ml"),281,50],
     _cA_=[0,0],
     _cz_=[0,0],
     _cy_=[0,0],
     _cE_=[0,7,0],
     _cD_=[0,1,[0,3,[0,5,0]]],
     _cC_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _cF_=[254,0,0];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (637,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Pervasives_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon_float=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function _g_(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return s}
    function char_of_int(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_h_
              :_i_}
    function string_of_int(n){return caml_new_string("" + n)}
    function int_of_string_opt(s)
     {try
       {var _xp_=[0,caml_int_of_string(s)];return _xp_}
      catch(_xq_)
       {_xq_ = caml_wrap_exception(_xq_);
        if(_xq_[1] === Failure)return 0;
        throw _xq_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return _g_(s,cst);
        var
         match=caml_string_get(s,i),
         switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function string_of_float(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function float_of_string_opt(s)
     {try
       {var _xn_=[0,caml_float_of_string(s)];return _xn_}
      catch(_xo_)
       {_xo_ = caml_wrap_exception(_xo_);
        if(_xo_[1] === Failure)return 0;
        throw _xo_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_j_,438,name)}
    function open_out_bin(name){return open_out_gen(_k_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_xm_)
             {_xm_ = caml_wrap_exception(_xm_);
              if(_xm_[1] !== Sys_error)throw _xm_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(s) - len | 0) < ofs))
         return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_xl_){}
      try
       {var _xj_=caml_ml_close_channel(oc);return _xj_}
      catch(_xk_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_l_,0,name)}
    function open_in_bin(name){return open_in_gen(_m_,0,name)}
    function input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);really_input(ic,s,0,len);return s}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(accu)return build_result(caml_create_bytes(len),len,accu);
          throw End_of_file}
        if(0 < n)
         {var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           {var len$0=(len + n | 0) - 1 | 0;
            return build_result(caml_create_bytes(len$0),len$0,[0,res,accu])}
          return res}
        var beg=caml_create_bytes(- n | 0);
        caml_ml_input(chan,beg,0,- n | 0);
        var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
        continue}}
    function close_in_noerr(ic)
     {try
       {var _xh_=caml_ml_close_channel(ic);return _xh_}
      catch(_xi_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_new_string("" + i))}
    function print_float(f){return output_string(stdout,string_of_float(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_new_string("" + i))}
    function prerr_float(f){return output_string(stderr,string_of_float(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return float_of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    var exit_function=[0,flush_all];
    function _n_(param,_xf_)
     {var
       str2=_xf_[2],
       fmt2=_xf_[1],
       str1=param[2],
       fmt1=param[1],
       _xg_=_g_(str1,_g_(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_xg_]}
    function at_exit(f)
     {var g=exit_function[1];
      exit_function[1]
      =
      function(param){caml_call1(f,0);return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     Pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       _g_,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       caml_ml_flush,
       flush_all,
       caml_ml_output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       caml_ml_output_char,
       runtime.caml_ml_output_int,
       output_value,
       runtime.caml_ml_seek_out,
       runtime.caml_ml_pos_out,
       caml_ml_channel_size,
       close_out,
       close_out_noerr,
       caml_ml_set_binary_mode,
       open_in,
       open_in_bin,
       open_in_gen,
       caml_ml_input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       caml_ml_input_char,
       runtime.caml_ml_input_int,
       caml_input_value,
       runtime.caml_ml_seek_in,
       runtime.caml_ml_pos_in,
       caml_ml_channel_size,
       caml_ml_close_channel,
       close_in_noerr,
       caml_ml_set_binary_mode,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       _n_,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(642,Pervasives,"Pervasives");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    function init(len,f)
     {if(0 <= len)
       {if(1e4 < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xe_=caml_call1(p,a);
          if(_xe_){var param$0=l;continue}
          return _xe_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xd_=caml_call1(p,a);
          if(_xd_)return _xd_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xc_=caml_call2(p,a1,a2);
            if(_xc_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _xc_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _xb_=caml_call2(p,a1,a2);
            if(_xb_)return _xb_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_xa_=0 === caml_compare(a,x)?1:0;
          if(_xa_)return _xa_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_w$_=a === x?1:0;
          if(_w$_)return _w$_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _w__=0 === caml_compare(a,x)?1:0;
          if(_w__)return _w__;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_w9_=a === x?1:0;
          if(_w9_)return _w9_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _w8_=rev(no);
        return [0,rev(yes),_w8_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function chop(k,l)
     {var k$0=k,l$0=l;
      for(;;)
       {if(0 === k$0)return l$0;
        if(l$0){var l$1=l$0[2],k$1=k$0 - 1 | 0,k$0=k$1,l$0=l$1;continue}
        throw [0,Assert_failure,_q_]}}
    function fast_sort(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w5_=l[2];
            if(_w5_)
             {var x2=_w5_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w6_=l[2];
            if(_w6_)
             {var _w7_=_w6_[2];
              if(_w7_)
               {var x3=_w7_[1],x2$0=_w6_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x1$0,x3)
                          ?0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                            :[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x2$0,[0,x1$0,[0,x3,0]]]
                        :0 < caml_call2(cmp,x2$0,x3)
                          ?0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]
                          :[0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _w2_=l[2];
            if(_w2_)
             {var x2=_w2_[1],x1=l[1];
              return 0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w3_=l[2];
            if(_w3_)
             {var _w4_=_w3_[2];
              if(_w4_)
               {var x3=_w4_[1],x2$0=_w3_[1],x1$0=l[1];
                return 0 < caml_call2(cmp,x1$0,x2$0)
                        ?0 < caml_call2(cmp,x2$0,x3)
                          ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x1$0,x3)
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]
                        :0 < caml_call2(cmp,x1$0,x3)
                          ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                          :0 < caml_call2(cmp,x2$0,x3)
                            ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                            :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function sort_uniq(cmp,l)
     {function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _wZ_=l[2];
            if(_wZ_)
             {var x2=_wZ_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _w0_=l[2];
            if(_w0_)
             {var _w1_=_w0_[2];
              if(_w1_)
               {var
                 x3=_w1_[1],
                 x2$0=_w0_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]]}
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)return [0,x2$0,[0,x1$0,0]];
                  if(0 <= c$3)
                   {var c$4=caml_call2(cmp,x2$0,x3);
                    return 0 === c$4
                            ?[0,x2$0,[0,x1$0,0]]
                            :0 <= c$4
                              ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                              :[0,x2$0,[0,x3,[0,x1$0,0]]]}
                  return [0,x2$0,[0,x1$0,[0,x3,0]]]}
                var c$5=caml_call2(cmp,x2$0,x3);
                if(0 === c$5)return [0,x1$0,[0,x2$0,0]];
                if(0 <= c$5)
                 {var c$6=caml_call2(cmp,x1$0,x3);
                  return 0 === c$6
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 <= c$6
                            ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                            :[0,x1$0,[0,x3,[0,x2$0,0]]]}
                return [0,x1$0,[0,x2$0,[0,x3,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=rev_sort(n1,l),
         l2$1=rev_sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _wW_=l[2];
            if(_wW_)
             {var x2=_wW_[1],x1=l[1],c$0=caml_call2(cmp,x1,x2);
              return 0 === c$0
                      ?[0,x1,0]
                      :0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]]}}}
        else
         if(3 === n)
          if(l)
           {var _wX_=l[2];
            if(_wX_)
             {var _wY_=_wX_[2];
              if(_wY_)
               {var
                 x3=_wY_[1],
                 x2$0=_wX_[1],
                 x1$0=l[1],
                 c$1=caml_call2(cmp,x1$0,x2$0);
                if(0 === c$1)
                 {var c$2=caml_call2(cmp,x2$0,x3);
                  return 0 === c$2
                          ?[0,x2$0,0]
                          :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]]}
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)return [0,x1$0,[0,x2$0,0]];
                  if(0 < c$3)return [0,x1$0,[0,x2$0,[0,x3,0]]];
                  var c$4=caml_call2(cmp,x1$0,x3);
                  return 0 === c$4
                          ?[0,x1$0,[0,x2$0,0]]
                          :0 < c$4
                            ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                            :[0,x3,[0,x1$0,[0,x2$0,0]]]}
                var c$5=caml_call2(cmp,x1$0,x3);
                if(0 === c$5)return [0,x2$0,[0,x1$0,0]];
                if(0 < c$5)return [0,x2$0,[0,x1$0,[0,x3,0]]];
                var c$6=caml_call2(cmp,x2$0,x3);
                return 0 === c$6
                        ?[0,x2$0,[0,x1$0,0]]
                        :0 < c$6
                          ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                          :[0,x3,[0,x2$0,[0,x1$0,0]]]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         l2$0=chop(n1,l),
         l1$0=sort(n1,l),
         l2$1=sort(n2,l2$0),
         l1=l1$0,
         l2=l2$1,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            return rev_append(l1,accu)}
          return rev_append(l2,accu)}}
      var len=length(l);
      return 2 <= len?sort(len,l):l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(645,include,"List");
    function chr(n)
     {if(0 <= n)if(! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {if(40 <= c)
       {if(92 === c)return cst$1;var switch$0=127 <= c?0:1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;var switch$0=1}
       else
        if(14 <= c)
         var switch$0=0;
        else
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r;
           default:var switch$0=0}
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return s$0}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return s}
    function lowercase(c)
     {var switch$0=65 <= c?90 < c?0:1:0;
      if(! switch$0)
       {var switch$1=192 <= c?214 < c?0:1:0;
        if(! switch$1)
         {var switch$2=216 <= c?222 < c?1:0:1;if(switch$2)return c}}
      return c + 32 | 0}
    function uppercase(c)
     {var switch$0=97 <= c?122 < c?0:1:0;
      if(! switch$0)
       {var switch$1=224 <= c?246 < c?0:1:0;
        if(! switch$1)
         {var switch$2=248 <= c?254 < c?1:0:1;if(switch$2)return c}}
      return c - 32 | 0}
    function lowercase_ascii(c)
     {if(65 <= c)if(! (90 < c))return c + 32 | 0;return c}
    function uppercase_ascii(c)
     {if(97 <= c)if(! (122 < c))return c - 32 | 0;return c}
    function compare(c1,c2){return c1 - c2 | 0}
    function equal(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare,
       equal];
    caml_register_global(646,Char,"Char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _wS_=0 <= i?1:0,_wT_=_wS_?i <= 55295?1:0:_wS_;
      if(_wT_)
       var _wU_=_wT_;
      else
       var _wV_=57344 <= i?1:0,_wU_=_wV_?i <= 1114111?1:0:_wV_;
      return _wU_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (_g_
                  (caml_format_int(cst_X,i),
                   cst_is_not_an_Unicode_scalar_value))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (_g_
                  (cst_U,
                   _g_
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_wR_){return _wR_}
    function equal$0(_wQ_,_wP_){return _wQ_ === _wP_?1:0}
    var compare$0=caml_int_compare;
    function hash(_wO_){return _wO_}
    function _r_(_wN_){return _wN_}
    var
     Uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_wM_){return _wM_},
       _r_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$0,
       compare$0,
       hash];
    caml_register_global(647,Uchar,"Uchar");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_wK_=n - 1 | 0,_wJ_=0;
      if(! (_wK_ < 0))
       {var i=_wJ_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _wL_=i + 1 | 0;
          if(_wK_ !== i){var i=_wL_;continue}
          break}}
      return s}
    var empty=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string(b){return copy(b)}
    function of_string(s){return copy(s)}
    function sub(s,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         {var r=caml_create_bytes(len);
          caml_blit_bytes(s,ofs,r,0,len);
          return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len){return sub(b,ofs,len)}
    function _s_(a,b)
     {var
       c=a + b | 0,
       _wI_=b < 0?1:0,
       match=c < 0?1:0,
       switch$0=
        0 === (a < 0?1:0)
         ?0 === _wI_?0 === match?0:1:0
         :0 === _wI_?0:0 === match?1:0;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=_s_(_s_(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var srcoff=0,dstoff=left;
      else
       var srcoff=- left | 0,dstoff=0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(s) - len | 0) < ofs))
         return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_bytes_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((caml_ml_string_length(s1) - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
           return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_string)}
    function iter$0(f,a)
     {var _wG_=caml_ml_bytes_length(a) - 1 | 0,_wF_=0;
      if(! (_wG_ < 0))
       {var i=_wF_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _wH_=i + 1 | 0;
          if(_wG_ !== i){var i=_wH_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _wD_=caml_ml_bytes_length(a) - 1 | 0,_wC_=0;
      if(! (_wD_ < 0))
       {var i=_wC_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _wE_=i + 1 | 0;
          if(_wD_ !== i){var i=_wE_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _wx_=param[2],_wy_=param[1];
            if(_wx_)
             {var
               x=(caml_ml_bytes_length(_wy_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=_wx_;
              continue}
            var _wB_=caml_ml_bytes_length(_wy_) + acc | 0}
          else
           var _wB_=acc;
          var dst=caml_create_bytes(_wB_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _wz_=param$0[2],_wA_=param$0[1];
              if(_wz_)
               {caml_blit_bytes(_wA_,0,dst,pos,caml_ml_bytes_length(_wA_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_wA_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_wA_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_wz_;
                continue}
              caml_blit_bytes(_wA_,0,dst,pos,caml_ml_bytes_length(_wA_));
              return dst}
            return dst}}}
      return empty}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var
       _ww_=param - 9 | 0,
       switch$0=4 < _ww_ >>> 0?23 === _ww_?1:0:2 === _ww_?0:1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len)
         if(is_space(caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1])
           if(is_space(caml_bytes_unsafe_get(s,j[1]))){j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty}}}
    function escaped$0(s)
     {var n=[0,0],_wp_=caml_ml_bytes_length(s) - 1 | 0,_wo_=0;
      if(! (_wp_ < 0))
       {var i$0=_wo_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _wt_=match - 34 | 0;
            if(58 < _wt_ >>> 0)
             if(93 <= _wt_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_wt_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _wu_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _wu_=4;break;case 1:var _wu_=2;break}
          n[1] = n[1] + _wu_ | 0;
          var _wv_=i$0 + 1 | 0;
          if(_wp_ !== i$0){var i$0=_wv_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _wr_=caml_ml_bytes_length(s) - 1 | 0,_wq_=0;
      if(! (_wr_ < 0))
       {var i=_wq_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _ws_=i + 1 | 0;
          if(_wr_ !== i){var i=_ws_;continue}
          break}}
      return s$0}
    function map$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wm_=l - 1 | 0,_wl_=0;
      if(! (_wm_ < 0))
       {var i=_wl_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _wn_=i + 1 | 0;
          if(_wm_ !== i){var i=_wn_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_wj_=l - 1 | 0,_wi_=0;
      if(! (_wj_ < 0))
       {var i=_wi_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _wk_=i + 1 | 0;
          if(_wj_ !== i){var i=_wk_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$0(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$0(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i)if(! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_bytes_length(s) <= i))return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec(s,l,i,c);var _wg_=1;return _wg_}
        catch(_wh_)
         {_wh_ = caml_wrap_exception(_wh_);
          if(_wh_ === Not_found)return 0;
          throw _wh_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_bytes_length(s) <= i))
        try
         {rindex_rec(s,i,c);var _we_=1;return _we_}
        catch(_wf_)
         {_wf_ = caml_wrap_exception(_wf_);
          if(_wf_ === Not_found)return 0;
          throw _wf_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from)}
    var compare$1=runtime.caml_bytes_compare;
    function uppercase$0(s){return map$0(uppercase,s)}
    function lowercase$0(s){return map$0(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function unsafe_of_string(_wd_){return _wd_}
    function unsafe_to_string(_wc_){return _wc_}
    var
     equal$1=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(648,include$0,"Bytes");
    function make$0(n,c){return make(n,c)}
    function init$1(n,f){return init$0(n,f)}
    function copy$0(s){return copy(s)}
    function sub$0(s,ofs,len){return sub(s,ofs,len)}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _v9_=param[2],_v__=param[1];
            if(_v9_)
             {var
               x=(caml_ml_string_length(_v__) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=_v9_;
              continue}
            var _wb_=caml_ml_string_length(_v__) + acc | 0}
          else
           var _wb_=acc;
          var dst=caml_create_bytes(_wb_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _v$_=param$0[2],_wa_=param$0[1];
              if(_v$_)
               {caml_blit_string(_wa_,0,dst,pos,caml_ml_string_length(_wa_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_wa_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_wa_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=_v$_;
                continue}
              caml_blit_string(_wa_,0,dst,pos,caml_ml_string_length(_wa_));
              return dst}
            return dst}}}
      return cst$3}
    function iter$1(f,s)
     {var _v7_=caml_ml_string_length(s) - 1 | 0,_v6_=0;
      if(! (_v7_ < 0))
       {var i=_v6_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(s,i));
          var _v8_=i + 1 | 0;
          if(_v7_ !== i){var i=_v8_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _v4_=caml_ml_string_length(s) - 1 | 0,_v3_=0;
      if(! (_v4_ < 0))
       {var i=_v3_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(s,i));
          var _v5_=i + 1 | 0;
          if(_v4_ !== i){var i=_v5_;continue}
          break}}
      return 0}
    function map$1(f,s){return map$0(f,s)}
    function mapi$1(f,s){return mapi$0(f,s)}
    function is_space$0(param)
     {var
       _v2_=param - 9 | 0,
       switch$0=4 < _v2_ >>> 0?23 === _v2_?1:0:2 === _v2_?0:1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if(! is_space$0(caml_bytes_unsafe_get(s,0)))
       if
        (!
         is_space$0(caml_bytes_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
        return s;
      return trim(s)}
    function escaped$1(s)
     {var i=0;
      for(;;)
       {if(caml_ml_string_length(s) <= i)
         var _v1_=0;
        else
         {var match=caml_bytes_unsafe_get(s,i);
          if(32 <= match)
           {var _v0_=match - 34 | 0;
            if(58 < _v0_ >>> 0)
             if(93 <= _v0_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_v0_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1){var i$0=i + 1 | 0,i=i$0;continue}}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          var _v1_=switch$0?1:1}
        return _v1_?escaped$0(s):s}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_index_from$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)if(! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Bytes_index_from_opt$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_rindex_from$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i)
       if(! (caml_ml_string_length(s) <= i))return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Bytes_rindex_from_opt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i)
       if(! (l < i))
        try
         {index_rec$0(s,l,i,c);var _vY_=1;return _vY_}
        catch(_vZ_)
         {_vZ_ = caml_wrap_exception(_vZ_);
          if(_vZ_ === Not_found)return 0;
          throw _vZ_}
      return invalid_arg(cst_String_contains_from_Bytes_contains_from$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i)
       if(! (caml_ml_string_length(s) <= i))
        try
         {rindex_rec$0(s,i,c);var _vW_=1;return _vW_}
        catch(_vX_)
         {_vX_ = caml_wrap_exception(_vX_);
          if(_vX_ === Not_found)return 0;
          throw _vX_}
      return invalid_arg(cst_String_rcontains_from_Bytes_rcontains_from$0)}
    function uppercase_ascii$1(s){return uppercase_ascii$0(s)}
    function lowercase_ascii$1(s){return lowercase_ascii$0(s)}
    function capitalize_ascii$0(s){return capitalize_ascii(s)}
    function uncapitalize_ascii$0(s){return uncapitalize_ascii(s)}
    var compare$2=caml_string_compare;
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _vS_=caml_ml_string_length(s) - 1 | 0;
      if(! (_vS_ < 0))
       {var i=_vS_;
        for(;;)
         {if(caml_bytes_unsafe_get(s,i) === sep)
           {var _vU_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_vU_];
            j[1] = i}
          var _vV_=i - 1 | 0;
          if(0 !== i){var i=_vV_;continue}
          break}}
      var _vT_=r[1];
      return [0,sub$0(s,0,j[1]),_vT_]}
    function uppercase$1(s){return uppercase$0(s)}
    function lowercase$1(s){return lowercase$0(s)}
    function capitalize$0(s){return capitalize(s)}
    function uncapitalize$0(s){return uncapitalize(s)}
    var
     equal$2=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(649,include$1,"String");
    var
     match=runtime.caml_sys_get_argv(0),
     _t_=match[2],
     match$0=runtime.caml_sys_get_config(0),
     os_type=match$0[1],
     backend_type=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     _u_=match[1],
     big_endian=0,
     size=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _vQ_=[0,caml_sys_getenv(s)];return _vQ_}
      catch(_vR_)
       {_vR_ = caml_wrap_exception(_vR_);
        if(_vR_ === Not_found)return 0;
        throw _vR_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    var
     Sys=
      [0,
       _t_,
       _u_,
       getenv_opt,
       interactive,
       os_type,
       backend_type,
       unix,
       win32,
       cygwin,
       size,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled];
    caml_register_global(650,Sys,"Sys");
    function merge$0(order,l1,l2)
     {if(l1)
       {var t1=l1[2],h1=l1[1];
        if(l2)
         {var t2=l2[2],h2=l2[1];
          return caml_call2(order,h1,h2)
                  ?[0,h1,merge$0(order,t1,l2)]
                  :[0,h2,merge$0(order,l1,t2)]}
        return l1}
      return l2}
    function list(order,l)
     {function initlist(param)
       {if(param)
         {var _vM_=param[2],_vN_=param[1];
          if(_vM_)
           {var
             rest=_vM_[2],
             e2=_vM_[1],
             _vO_=initlist(rest),
             _vP_=
              caml_call2(order,_vN_,e2)?[0,_vN_,[0,e2,0]]:[0,e2,[0,_vN_,0]];
            return [0,_vP_,_vO_]}
          return [0,[0,_vN_,0],0]}
        return 0}
      function merge2(x)
       {if(x)
         {var _vK_=x[2];
          if(_vK_)
           {var rest=_vK_[2],l2=_vK_[1],l1=x[1],_vL_=merge2(rest);
            return [0,merge$0(order,l1,l2),_vL_]}}
        return x}
      var llist$1=initlist(l),llist=llist$1;
      for(;;)
       {if(llist)
         {if(llist[2]){var llist$0=merge2(llist),llist=llist$0;continue}
          var l$0=llist[1];
          return l$0}
        return 0}}
    function swap(arr,i,j)
     {var tmp=arr[i + 1];arr[i + 1] = arr[j + 1];return arr[j + 1] = tmp}
    function array(cmp,arr)
     {function qsort(lo,hi)
       {var lo$0=lo,hi$0=hi;
        a:
        for(;;)
         {var _vH_=6 <= (hi$0 - lo$0 | 0)?1:0;
          if(_vH_)
           {var mid=(lo$0 + hi$0 | 0) >>> 1 | 0;
            if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0);
            if(caml_call2(cmp,arr[hi$0 + 1],arr[mid + 1]))
             {swap(arr,mid,hi$0);
              if(caml_call2(cmp,arr[mid + 1],arr[lo$0 + 1]))swap(arr,mid,lo$0)}
            var
             pivot=arr[mid + 1],
             i=[0,lo$0 + 1 | 0],
             j=[0,hi$0 - 1 | 0],
             _vI_=1 - caml_call2(cmp,pivot,arr[hi$0 + 1]),
             _vJ_=_vI_ || 1 - caml_call2(cmp,arr[lo$0 + 1],pivot);
            if(_vJ_)throw [0,Invalid_argument,cst_Sort_array];
            b:
            for(;;)
             {if(i[1] < j[1])
               for(;;)
                {if(caml_call2(cmp,pivot,arr[i[1] + 1]))
                  for(;;)
                   {if(caml_call2(cmp,arr[j[1] + 1],pivot))
                     {if(i[1] < j[1])swap(arr,i[1],j[1]);
                      i[1]++;
                      j[1] += -1;
                      continue b}
                    j[1] += -1;
                    continue}
                 i[1]++;
                 continue}
              if((j[1] - lo$0 | 0) <= (hi$0 - i[1] | 0))
               {qsort(lo$0,j[1]);var lo$1=i[1],lo$0=lo$1;continue a}
              qsort(i[1],hi$0);
              var hi$1=j[1],hi$0=hi$1;
              continue a}}
          return _vH_}}
      qsort(0,arr.length - 1 - 1 | 0);
      var _vF_=arr.length - 1 - 1 | 0,_vE_=1;
      if(! (_vF_ < 1))
       {var i=_vE_;
        for(;;)
         {var val_i=arr[i + 1];
          if(1 - caml_call2(cmp,arr[(i - 1 | 0) + 1],val_i))
           {arr[i + 1] = arr[(i - 1 | 0) + 1];
            var j=[0,i - 1 | 0];
            for(;;)
             {if(1 <= j[1])
               if(! caml_call2(cmp,arr[(j[1] - 1 | 0) + 1],val_i))
                {arr[j[1] + 1] = arr[(j[1] - 1 | 0) + 1];j[1] += -1;continue}
              arr[j[1] + 1] = val_i;
              break}}
          var _vG_=i + 1 | 0;
          if(_vF_ !== i){var i=_vG_;continue}
          break}}
      return 0}
    var Sort=[0,list,array,merge$0];
    caml_register_global(651,Sort,"Sort");
    function to_buffer(buff,ofs,len,v,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buff) - len | 0) < ofs))
         return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substring_out_of_bounds)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs)
       if(! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
        {var len=caml_marshal_data_size(buff,ofs);
         return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                 ?invalid_arg(cst_Marshal_from_bytes$0)
                 :runtime.caml_input_value_from_string(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs){return from_bytes(buff,ofs)}
    var
     Marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(652,Marshal,"Marshal");
    function is_block(a){return 1 - (typeof a === "number")}
    var
     double_field=runtime.caml_array_get,
     set_double_field=runtime.caml_array_set;
    function marshal(obj){return runtime.caml_output_value_to_string(obj,0)}
    function unmarshal(str,pos)
     {var _vD_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_vD_]}
    var
     first_non_constant_constructor_tag=0,
     last_non_constant_constructor_tag=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1e3,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function extension_constructor(x)
     {if(is_block(x))
       if(caml_obj_tag(x) !== 248)
        if(1 <= x.length - 1)var slot=x[1],switch$0=1;else var switch$0=0;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var slot=x;
      if(is_block(slot))
       if(caml_obj_tag(slot) === 248)
        var name=slot[1],switch$1=1;
       else
        var switch$1=0;
      else
       var switch$1=0;
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function extension_name(slot){return slot[1]}
    function extension_id(slot){return slot[2]}
    function length$0(x){return x.length - 1 - 2 | 0}
    var _v_=runtime.caml_ephe_blit_data,_w_=runtime.caml_ephe_check_data;
    function _x_(_vC_){return runtime.caml_ephe_unset_data(_vC_)}
    var
     _y_=runtime.caml_ephe_set_data,
     _z_=runtime.caml_ephe_get_data_copy,
     _A_=runtime.caml_ephe_get_data;
    function _B_(_vB_,_vA_,_vz_,_vy_,_vx_)
     {return runtime.caml_ephe_blit_key(_vB_,_vA_,_vz_,_vy_,_vx_)}
    function _C_(_vw_,_vv_){return runtime.caml_ephe_check_key(_vw_,_vv_)}
    var _D_=runtime.caml_ephe_unset_key,_E_=runtime.caml_ephe_set_key;
    function _F_(_vu_,_vt_){return runtime.caml_ephe_get_key_copy(_vu_,_vt_)}
    function _G_(_vs_,_vr_){return runtime.caml_ephe_get_key(_vs_,_vr_)}
    var
     _H_=
      [0,
       function(_vq_){return runtime.caml_ephe_create(_vq_)},
       length$0,
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_],
     Obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor_tag,
       last_non_constant_constructor_tag,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _H_];
    caml_register_global(653,Obj,"Obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_vo_=l - 1 | 0,_vn_=1;
        if(! (_vo_ < 1))
         {var i=_vn_;
          for(;;)
           {res[i + 1] = caml_call1(f,i);
            var _vp_=i + 1 | 0;
            if(_vo_ !== i){var i=_vp_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_vl_=sx - 1 | 0,_vk_=0;
      if(! (_vl_ < 0))
       {var x=_vk_;
        for(;;)
         {res[x + 1] = caml_make_vect(sy,init);
          var _vm_=x + 1 | 0;
          if(_vl_ !== x){var x=_vm_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$0(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((a.length - 1 - len | 0) < ofs))
         {var _vi_=(ofs + len | 0) - 1 | 0;
          if(! (_vi_ < ofs))
           {var i=ofs;
            for(;;)
             {a[i + 1] = v;
              var _vj_=i + 1 | 0;
              if(_vi_ !== i){var i=_vj_;continue}
              break}}
          return 0}
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if(0 <= len)
       if(0 <= ofs1)
        if(! ((a1.length - 1 - len | 0) < ofs1))
         if(0 <= ofs2)
          if(! ((a2.length - 1 - len | 0) < ofs2))
           return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$2(f,a)
     {var _vg_=a.length - 1 - 1 | 0,_vf_=0;
      if(! (_vg_ < 0))
       {var i=_vf_;
        for(;;)
         {caml_call1(f,a[i + 1]);
          var _vh_=i + 1 | 0;
          if(_vg_ !== i){var i=_vh_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_have_the_same_length);
      var _vd_=a.length - 1 - 1 | 0,_vc_=0;
      if(! (_vd_ < 0))
       {var i=_vc_;
        for(;;)
         {caml_call2(f,a[i + 1],b[i + 1]);
          var _ve_=i + 1 | 0;
          if(_vd_ !== i){var i=_ve_;continue}
          break}}
      return 0}
    function map$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_va_=l - 1 | 0,_u$_=1;
      if(! (_va_ < 1))
       {var i=_u$_;
        for(;;)
         {r[i + 1] = caml_call1(f,a[i + 1]);
          var _vb_=i + 1 | 0;
          if(_va_ !== i){var i=_vb_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)
       return invalid_arg(cst_Array_map2_arrays_must_have_the_same_length);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_u9_=la - 1 | 0,_u8_=1;
      if(! (_u9_ < 1))
       {var i=_u8_;
        for(;;)
         {r[i + 1] = caml_call2(f,a[i + 1],b[i + 1]);
          var _u__=i + 1 | 0;
          if(_u9_ !== i){var i=_u__;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _u6_=a.length - 1 - 1 | 0,_u5_=0;
      if(! (_u6_ < 0))
       {var i=_u5_;
        for(;;)
         {caml_call2(f,i,a[i + 1]);
          var _u7_=i + 1 | 0;
          if(_u6_ !== i){var i=_u7_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_u3_=l - 1 | 0,_u2_=1;
      if(! (_u3_ < 1))
       {var i=_u2_;
        for(;;)
         {r[i + 1] = caml_call2(f,i,a[i + 1]);
          var _u4_=i + 1 | 0;
          if(_u3_ !== i){var i=_u4_;continue}
          break}}
      return r}
    function to_list(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[i + 1],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function of_list(l)
     {if(l)
       {var tl=l[2],hd=l[1],accu=0,param=l;
        for(;;)
         {if(param)
           {var
             param$0=param[2],
             accu$0=accu + 1 | 0,
             accu=accu$0,
             param=param$0;
            continue}
          var a=caml_make_vect(accu,hd),i=1,param$1=tl;
          for(;;)
           {if(param$1)
             {var tl$0=param$1[2],hd$0=param$1[1];
              a[i + 1] = hd$0;
              var i$0=i + 1 | 0,i=i$0,param$1=tl$0;
              continue}
            return a}}}
      return [0]}
    function fold_left$0(f,x,a)
     {var r=[0,x],_u0_=a.length - 1 - 1 | 0,_uZ_=0;
      if(! (_u0_ < 0))
       {var i=_uZ_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[i + 1]);
          var _u1_=i + 1 | 0;
          if(_u0_ !== i){var i=_u1_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_uX_=a.length - 1 - 1 | 0;
      if(! (_uX_ < 0))
       {var i=_uX_;
        for(;;)
         {r[1] = caml_call2(f,a[i + 1],r[1]);
          var _uY_=i - 1 | 0;
          if(0 !== i){var i=_uY_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[i + 1]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[i + 1])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[i + 1],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[i + 1])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _uQ_=i31 + 1 | 0,_uR_=caml_check_bound(a,_uQ_)[_uQ_ + 1];
          if(caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_uR_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _uS_=i31 + 2 | 0,
           _uT_=caml_check_bound(a,_uS_)[_uS_ + 1],
           _uU_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_uU_)[_uU_ + 1],_uT_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _uV_=i31 + 1 | 0,_uW_=caml_check_bound(a,_uV_)[_uV_ + 1];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[i31 + 1],_uW_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[j + 1],e))
           {var _uP_=caml_check_bound(a,j)[j + 1];
            caml_check_bound(a,i$0)[i$0 + 1] = _uP_;
            var i$0=j;
            continue}
          return caml_check_bound(a,i$0)[i$0 + 1] = e}}
      function trickle(l,i,e)
       {try
         {var _uO_=trickledown(l,i,e);return _uO_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];return caml_check_bound(a,i$0)[i$0 + 1] = e}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_uN_=caml_check_bound(a,i$1)[i$1 + 1];
          caml_check_bound(a,i$0)[i$0 + 1] = _uN_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _uM_=bubbledown(l,i);return _uM_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_uE_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_uE_ < 0))
       {var i$2=_uE_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[i$2 + 1]);
          var _uL_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_uL_;continue}
          break}}
      var _uF_=l - 1 | 0;
      if(! (_uF_ < 2))
       {var i$0=_uF_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[i$0 + 1],
           _uJ_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[i$0 + 1] = _uJ_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_I_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[father + 1],e$0))
             caml_check_bound(a,i)[i + 1] = e$0;
            else
             {var _uD_=caml_check_bound(a,father)[father + 1];
              caml_check_bound(a,i)[i + 1] = _uD_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _uK_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_uK_;continue a}
            break}
          break}}
      var _uG_=1 < l?1:0;
      if(_uG_)
       {var e=caml_check_bound(a,1)[2],_uH_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _uH_;
        var _uI_=caml_check_bound(a,0)[1] = e}
      else
       var _uI_=_uG_;
      return _uI_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[src2ofs + 1],
         s1$1=caml_check_bound(a,src1ofs)[src1ofs + 1],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[d + 1] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[i2$0 + 1],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[d + 1] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[i1$0 + 1],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _uv_=len - 1 | 0,_uu_=0;
        if(! (_uv_ < 0))
         {var i=_uu_;
          a:
          for(;;)
           {var
             _uw_=srcofs + i | 0,
             e=caml_check_bound(a,_uw_)[_uw_ + 1],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _ux_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_ux_)[_ux_ + 1],e))
                 {var
                   _uy_=j[1],
                   _uz_=caml_check_bound(dst,_uy_)[_uy_ + 1],
                   _uA_=j[1] + 1 | 0;
                  caml_check_bound(dst,_uA_)[_uA_ + 1] = _uz_;
                  j[1] += -1;
                  continue}}
              var _uB_=j[1] + 1 | 0;
              caml_check_bound(dst,_uB_)[_uB_ + 1] = e;
              var _uC_=i + 1 | 0;
              if(_uv_ !== i){var i=_uC_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       iteri$2,
       map$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(654,include$2,"Array");
    var zero=0,one=1,minus_one=-1;
    function succ$0(n){return n + 1 | 0}
    function pred$0(n){return n - 1 | 0}
    function abs$0(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$0=-2147483648,max_int$0=2147483647;
    function lognot(n){return n ^ -1}
    function to_string$0(n){return caml_format_int(cst_d,n)}
    function of_string_opt(s)
     {try
       {var _us_=[0,caml_int_of_string(s)];return _us_}
      catch(_ut_)
       {_ut_ = caml_wrap_exception(_ut_);
        if(_ut_[1] === Failure)return 0;
        throw _ut_}}
    var compare$3=caml_int_compare;
    function equal$3(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Int32=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       of_string_opt,
       to_string$0,
       compare$3,
       equal$3];
    caml_register_global(655,Int32,"Int32");
    function succ$1(n){return caml_int64_add(n,_J_)}
    function pred$1(n){return caml_int64_sub(n,_K_)}
    function abs$1(n)
     {return caml_greaterequal(n,_L_)?n:runtime.caml_int64_neg(n)}
    function lognot$0(n){return runtime.caml_int64_xor(n,_M_)}
    function to_string$1(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$0(s)
     {try
       {var _uq_=[0,caml_int64_of_string(s)];return _uq_}
      catch(_ur_)
       {_ur_ = caml_wrap_exception(_ur_);
        if(_ur_[1] === Failure)return 0;
        throw _ur_}}
    var compare$4=caml_int64_compare;
    function equal$4(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    var
     Int64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       of_string_opt$0,
       to_string$1,
       compare$4,
       equal$4];
    caml_register_global(656,Int64,"Int64");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$2(n){return n + 1 | 0}
    function pred$2(n){return n - 1 | 0}
    function abs$2(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$2=-2147483648,max_int$2=2147483647;
    function lognot$1(n){return n ^ -1}
    function to_string$2(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$1(s)
     {try
       {var _uo_=[0,caml_int_of_string(s)];return _uo_}
      catch(_up_)
       {_up_ = caml_wrap_exception(_up_);
        if(_up_[1] === Failure)return 0;
        throw _up_}}
    var compare$5=caml_int_compare;
    function equal$5(x,y){return 0 === caml_int_compare(x,y)?1:0}
    var
     Nativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$2,
       pred$2,
       abs$2,
       size,
       max_int$2,
       min_int$2,
       lognot$1,
       of_string_opt$1,
       to_string$2,
       compare$5,
       equal$5];
    caml_register_global(657,Nativeint,"Nativeint");
    function engine(tbl,state,buf)
     {var result=runtime.caml_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _un_=buf[12];
        buf[12] = [0,_un_[1],_un_[2],_un_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var result=runtime.caml_new_lex_engine(tbl,state,buf);
      if(0 <= result)
       {buf[11] = buf[12];
        var _um_=buf[12];
        buf[12] = [0,_um_[1],_um_[2],_um_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(f)
     {var
       aux_buffer=caml_create_bytes(512),
       _ua_=[0],
       _ub_=0,
       _uc_=0,
       _ud_=0,
       _ue_=0,
       _uf_=0,
       _ug_=0,
       _uh_=0,
       _ui_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_grow_buffer);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_uk_=t.length - 1 - 1 | 0,_uj_=0;
                  if(! (_uk_ < 0))
                   {var i=_uj_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[i + 1];
                      if(0 <= v)caml_check_bound(t,i)[i + 1] = v - s | 0;
                      var _ul_=i + 1 | 0;
                      if(_uk_ !== i){var i=_ul_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _ui_,
              _uh_,
              _ug_,
              _uf_,
              _ue_,
              _ud_,
              _uc_,
              _ub_,
              _ua_,
              zero_pos,
              zero_pos]}
    function from_channel(ic)
     {return from_function(function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(s)
     {var
       _t3_=[0],
       _t4_=1,
       _t5_=0,
       _t6_=0,
       _t7_=0,
       _t8_=0,
       _t9_=0,
       _t__=caml_ml_string_length(s),
       _t$_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _t$_,
              _t__,
              _t9_,
              _t8_,
              _t7_,
              _t6_,
              _t5_,
              _t4_,
              _t3_,
              zero_pos,
              zero_pos]}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var lcp=lexbuf[12];
      lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]];
      return 0}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var _t2_=lb[12];
      lb[12] = [0,_t2_[1],_t2_[2],_t2_[3],0];
      lb[3] = 0;
      return 0}
    var
     Lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(658,Lexing,"Lexing");
    var
     YYexit=[248,cst_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _tX_=env[13],
                _tY_=
                 caml_call1(caml_check_bound(tables[1],_tX_)[_tX_ + 1],env),
                _tZ_=4,
                cmd$0=_tZ_,
                arg$1=_tY_}
             catch(_t1_)
              {_t1_ = caml_wrap_exception(_t1_);
               if(_t1_ !== Parse_error)throw _t1_;
               var cmd$0=5,arg$1=0}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _t0_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_t0_)[_t0_ + 1] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[tok + 1] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _tW_=env[11] - n | 0;return caml_check_bound(env[2],_tW_)[_tW_ + 1]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _tT_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_tT_)[_tT_ + 1],
           _tU_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_tU_)[_tU_ + 1];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _tV_=env[11];
        return caml_check_bound(env[4],_tV_)[_tV_ + 1]}}
    function symbol_end_pos(param)
     {var _tS_=env[11];return caml_check_bound(env[4],_tS_)[_tS_ + 1]}
    function rhs_start_pos(n)
     {var _tR_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_tR_)[_tR_ + 1]}
    function rhs_end_pos(n)
     {var _tQ_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_tQ_)[_tQ_ + 1]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_tP_){return runtime.caml_set_parser_trace(_tP_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(659,Parsing,"Parsing");
    var
     Set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _tO_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tO_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_tJ_=height(lr);
               if(_tJ_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_tK_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_tK_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_tL_=height(rl);
               if(_tL_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_tM_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_tM_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _tN_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_tN_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tI_=param$0[1];
               if(_tI_){var param$0=_tI_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tH_=param$0[1];
               if(_tH_){var param$0=_tH_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tF_=param$0[3],_tG_=param$0[2];
               if(_tF_){var param$0=_tF_;continue}
               return _tG_}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _tD_=param$0[3],_tE_=param$0[2];
               if(_tD_){var param$0=_tD_;continue}
               return [0,_tE_]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _tC_=param[1];
             if(_tC_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_tC_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _tB_=remove_min_elt(match);
               return join(t,min_elt(match),_tB_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _N_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _tA_=0 === c?1:0;
               if(_tA_)return _tA_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _tz_=remove_min_elt(r);return bal(l,min_elt(r),_tz_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _tx_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_tx_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _ty_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_ty_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _tt_=split(v1,match),
                _tu_=_tt_[1];
               if(0 === _tt_[2])
                {var r2=_tt_[3],_tv_=inter(r1,r2);
                 return concat(inter(l1,_tu_),_tv_)}
               var r2$0=_tt_[3],_tw_=inter(r1,r2$0);
               return join(inter(l1,_tu_),v1,_tw_)}
             return 0}
           return 0}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _tp_=split(v1,match),
                _tq_=_tp_[1];
               if(0 === _tp_[2])
                {var r2=_tp_[3],_tr_=diff(r1,r2);
                 return join(diff(l1,_tq_),v1,_tr_)}
               var r2$0=_tp_[3],_ts_=diff(r1,r2$0);
               return concat(diff(l1,_tq_),_ts_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _tm_=subset(l1,l2);
                   if(_tm_){var s1$0=r1,s2$0=r2;continue}
                   return _tm_}
                 if(0 <= c)
                  {var _tn_=subset([0,0,v1,r1,0],r2);
                   if(_tn_){var s1$0=l1;continue}
                   return _tn_}
                 var _to_=subset([0,l1,v1,0,0],l2);
                 if(_to_){var s1$0=r1;continue}
                 return _to_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tj_=caml_call1(p,v);
               if(_tj_)
                {var _tk_=for_all(p,l);
                 if(_tk_){var param$0=r;continue}
                 var _tl_=_tk_}
               else
                var _tl_=_tj_;
               return _tl_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _tg_=caml_call1(p,v);
               if(_tg_)
                var _th_=_tg_;
               else
                {var _ti_=exists(p,l);
                 if(! _ti_){var param$0=r;continue}
                 var _th_=_ti_}
               return _th_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0)if(r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _te_=concat(lf,rf);return [0,join(lt,v,rt),_te_]}
             var _tf_=join(lf,v,rf);
             return [0,concat(lt,rt),_tf_]}
           return _O_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_td_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _td_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0)if(v === v$0)if(r === r$0)return t;
             if(0 === l$0)
              var switch$0=0;
             else
              var
               _tc_=max_elt(l$0),
               switch$0=0 <= caml_call2(Ord[1],_tc_,v$0)?1:0;
             if(! switch$0)
              {if(0 === r$0)
                var switch$1=0;
               else
                var
                 _tb_=min_elt(r$0),
                 switch$1=0 <= caml_call2(Ord[1],v$0,_tb_)?1:0;
               if(! switch$1)return join(l$0,v$0,r$0)}
             return union(l$0,add(v$0,r$0))}
           return 0}
         function of_list(l)
          {if(l)
            {var _s2_=l[2],_s3_=l[1];
             if(_s2_)
              {var _s4_=_s2_[2],_s5_=_s2_[1];
               if(_s4_)
                {var _s6_=_s4_[2],_s7_=_s4_[1];
                 if(_s6_)
                  {var _s8_=_s6_[2],_s9_=_s6_[1];
                   if(_s8_)
                    {if(_s8_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _s__=l[2];
                                 if(_s__)
                                  {var l$4=_s__[2],x1=_s__[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _s$_=l[2];
                                 if(_s$_)
                                  {var _ta_=_s$_[2];
                                   if(_ta_)
                                    {var l$5=_ta_[2],x2=_ta_[1],x1$0=_s$_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_P_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_s8_[1];
                     return add(x4,add(_s9_,add(_s7_,add(_s5_,singleton(_s3_)))))}
                   return add(_s9_,add(_s7_,add(_s5_,singleton(_s3_))))}
                 return add(_s7_,add(_s5_,singleton(_s3_)))}
               return add(_s5_,singleton(_s3_))}
             return singleton(_s3_)}
           return empty}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list]}];
    caml_register_global(660,Set,"Set");
    var
     Map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_s1_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s1_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_sW_=height(lr);
               if(_sW_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _sX_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_sX_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_sY_=height(rl);
               if(_sY_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _sZ_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_sZ_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _s0_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_s0_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _sV_=0 === c?1:0;
               if(_sV_)return _sV_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sU_=param$0[1];
               if(_sU_){var param$0=_sU_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sT_=param$0[1];
               if(_sT_){var param$0=_sT_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sQ_=param$0[4],_sR_=param$0[3],_sS_=param$0[2];
               if(_sQ_){var param$0=_sQ_;continue}
               return [0,_sS_,_sR_]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _sN_=param$0[4],_sO_=param$0[3],_sP_=param$0[2];
               if(_sN_){var param$0=_sN_;continue}
               return [0,[0,_sP_,_sO_]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _sM_=param[1];
             if(_sM_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_sM_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _sv_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _sv_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _sv_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sJ_=caml_call2(p,v,d);
               if(_sJ_)
                {var _sK_=for_all(p,l);
                 if(_sK_){var param$0=r;continue}
                 var _sL_=_sK_}
               else
                var _sL_=_sJ_;
               return _sL_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _sG_=caml_call2(p,v,d);
               if(_sG_)
                var _sH_=_sG_;
               else
                {var _sI_=exists(p,l);
                 if(! _sI_){var param$0=r;continue}
                 var _sH_=_sI_}
               return _sH_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _Q_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _sC_=merge(f,r1,r2),
                _sD_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_sD_,_sC_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _sE_=merge(f,r1$0,r2$0),
              _sF_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_sF_,_sE_)}
           throw [0,Assert_failure,_R_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0)if(r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _sA_=concat(lf,rf);return [0,join(lt,v,d,rt),_sA_]}
             var _sB_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_sB_]}
           return _S_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _sx_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_sx_)
                  {var _sy_=caml_call2(cmp,d1,d2);
                   if(_sy_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _sz_=_sy_}
                 else
                  var _sz_=_sx_;
                 return _sz_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_sw_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _sw_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi]}];
    caml_register_global(661,Map,"Map");
    var Empty=[248,cst_Stack_Empty,caml_fresh_oo_id(0)];
    function create(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$2(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _su_=s[1];
      if(_su_)
       {var tl=_su_[2],hd=_su_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function top(s)
     {var _st_=s[1];if(_st_){var hd=_st_[1];return hd}throw Empty}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$3(f,s){return iter(f,s[1])}
    function fold(f,acc,s){return fold_left(f,acc,s[1])}
    var
     Stack=
      [0,Empty,create,push,pop,top,clear,copy$2,is_empty,length$1,iter$3,fold];
    caml_register_global(662,Stack,"Stack");
    var Empty$0=[248,cst_Queue_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_ss_=q[3];
      return _ss_
              ?(q[1] = q[1] + 1 | 0,_ss_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _sr_=q[2];if(_sr_){var content=_sr_[1];return content}throw Empty$0}
    function take(q)
     {var _so_=q[2];
      if(_so_)
       {var _sp_=_so_[1],_sq_=_so_[2];
        return _sq_?(q[1] = q[1] - 1 | 0,q[2] = _sq_,_sp_):(clear$0(q),_sp_)}
      throw Empty$0}
    function copy$3(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$4(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$0(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _sm_=0 < q1[1]?1:0;
      if(_sm_)
       {var _sn_=q2[3];
        return _sn_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _sn_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _sm_}
    var
     Queue=
      [0,
       Empty$0,
       create$0,
       add,
       add,
       take,
       take,
       peek,
       peek,
       clear$0,
       copy$3,
       is_empty$0,
       length$2,
       iter$4,
       fold$0,
       transfer];
    caml_register_global(663,Queue,"Queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        blk[1] = result;
        caml_obj_set_tag(blk,250);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      blk[1] = result;
      caml_obj_set_tag(blk,250);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(664,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250)if(t !== 246)if(t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(665,Lazy,"Lazy");
    var
     Failure$0=[248,cst_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_T_]}
           case 2:
            var
             f=d$0[1],
             _si_=caml_obj_tag(f),
             d$1=250 === _si_?f[1]:246 === _si_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _sj_=d$0[1],_sk_=_sj_[1];
            if(_sk_)
             {var _sl_=_sk_[1];
              if(_sl_){var a$0=_sl_[1];_sj_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_sj_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _sj_[1] = _U_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _sd_=s[2];
        if(typeof _sd_ === "number")
         return 0;
        else
         switch(_sd_[0])
          {case 0:var a=_sd_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_V_]}
           case 2:
            var
             f=_sd_[1],
             _se_=caml_obj_tag(f),
             _sf_=250 === _se_?f[1]:246 === _se_?force_lazy_block(f):f;
            s[2] = _sf_;
            continue;
           case 3:
            var _sg_=_sd_[1],_sh_=_sg_[1];
            if(_sh_){var a$1=_sh_[1];return a$1}
            var x=caml_call1(_sg_[2],s[1]);
            _sg_[1] = [0,x];
            return x;
           default:
            var b=_sd_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _sb_=s[2];
        if(typeof _sb_ !== "number")
         switch(_sb_[0])
          {case 0:var d=_sb_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _sc_=_sb_[1];
            if(_sc_[1]){s[1] = s[1] + 1 | 0;_sc_[1] = 0;return 0}
            break;
           case 4:
            var b=_sb_[1];s[1] = s[1] + 1 | 0;b[4] = b[4] + 1 | 0;return 0
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$0(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$5(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$0(l)
     {var _sa_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_sa_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _r$_=data(s);return [0,[0,0,[1,data(i),_r$_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r9_)
                  {var _r__=data(s);return [1,data(caml_call1(f,0)),_r__]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_r7_)
                  {var _r8_=data(s);return [0,caml_call1(f,0),_r8_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_r6_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_r5_){return data(caml_call1(f,0))}]]]]}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$5);
      return print_newline(0)}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$6);
          dump_data(f,d);
          return print_string(cst$7);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$8);
          dump_data(f,d2);
          return print_string(cst$9);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    var
     Stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$0,
       of_string$0,
       of_bytes,
       of_channel,
       iter$5,
       next,
       empty$0,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(666,Stream,"Stream");
    function create$1(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$2(b,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((b[2] - len | 0) < ofs))return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$2(src,srcoff,dst,dstoff,len)
     {if(0 <= len)
       if(0 <= srcoff)
        if(! ((src[2] - len | 0) < srcoff))
         if(0 <= dstoff)
          if(! ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
           return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs)if(! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var len=b[3],new_len=[0,len];
      for(;;)
       {if(new_len[1] < (b[2] + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((b[2] + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buffer);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        return 0}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_W_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_X_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_Y_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_Z_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,___];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_$_]}
    function add_substring(b,s,offset,len)
     {var _r2_=offset < 0?1:0;
      if(_r2_)
       var _r3_=_r2_;
      else
       var
        _r4_=len < 0?1:0,
        _r3_=_r4_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_r3_)invalid_arg(cst_Buffer_add_substring_add_subbytes);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,s,offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      blit$0(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,s)}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len$1)
     {var _r0_=len$1 < 0?1:0,_r1_=_r0_ || (max_string_length < len$1?1:0);
      if(_r1_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len$1 | 0))resize(b,len$1);
      var len=len$1;
      for(;;)
       {var _rZ_=0 < len?1:0;
        if(_rZ_)
         {var n=input(ic,b[1],b[2],len);
          b[2] = b[2] + n | 0;
          if(0 === n)throw End_of_file;
          var len$0=len - n | 0,len=len$0;
          continue}
        return _rZ_}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start);
            if(40 === opening)
             var switch$0=0;
            else
             if(123 === opening)
              var switch$0=0;
             else
              {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
               for(;;)
                {if(lim$0 <= i$3)
                  var stop=lim$0;
                 else
                  {var
                    match=caml_string_get(s,i$3),
                    switch$1=
                     91 <= match
                      ?97 <= match?123 <= match?0:1:95 === match?1:0
                      :58 <= match?65 <= match?1:0:48 <= match?1:0;
                   if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                   var stop=i$3}
                 var
                  match$0=[0,sub$0(s,start,stop - start | 0),stop],
                  switch$0=1;
                 break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _rX_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_aa_];var _rX_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _rX_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _rY_=92 === previous?1:0;
        return _rY_?add_char(b,previous):_rY_}}
    function truncate(b,len)
     {if(0 <= len)if(! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    var
     Buffer=
      [0,
       create$1,
       contents,
       to_bytes,
       sub$2,
       blit$2,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate];
    caml_register_global(667,Buffer,"Buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _rW_=i + 1 | 0;
        if(31 !== i){var i=_rW_;continue}
        return char_set$0}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_rV_=[0,ndec];else var _rV_=0;
          return [0,[8,0,pad_of_pad_opt(pad_opt$5),_rV_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    var default_float_precision=-6;
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _rT_=len < min_len?1:0;
      if(_rT_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _rU_=0}
      else
       var _rU_=_rT_;
      return _rU_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 12:return 117;
        case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 0:
        case 1:
        case 2:return 100;
        default:return 105}}
    function char_of_fconv(fconv)
     {switch(fconv)
       {case 15:return 70;
        case 0:
        case 1:
        case 2:return 102;
        case 3:
        case 4:
        case 5:return 101;
        case 6:
        case 7:
        case 8:return 69;
        case 9:
        case 10:
        case 11:return 103;
        case 12:
        case 13:
        case 14:return 71;
        case 16:
        case 17:
        case 18:return 104;
        default:return 72}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_new_string("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_new_string("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")
       return 0 === prec?0:buffer_add_string(buf,cst$10);
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_new_string("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv)
       {case 1:
        case 4:
        case 7:
        case 10:
        case 13:
        case 17:
        case 20:return buffer_add_char(buf,43);
        case 2:
        case 5:
        case 8:
        case 11:
        case 14:
        case 18:
        case 21:return buffer_add_char(buf,32);
        default:return 0}}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$11;
         case 1:return cst$12;
         case 2:return cst$13;
         case 3:return cst$14;
         case 4:return cst$15;
         case 5:return cst$16;
         default:return cst$17}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return _g_(cst$18,make$0(1,c))}}
    function string_of_formatting_gen(formatting_gen)
     {if(0 === formatting_gen[0])
       {var match=formatting_gen[1],str=match[2];return str}
      var match$0=formatting_gen[1],str$0=match$0[2];
      return str$0}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$19):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _rR_=caml_ml_string_length(str) - 1 | 0,_rQ_=0;
      if(! (_rR_ < 0))
       {var i=_rQ_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _rS_=i + 1 | 0;
          if(_rR_ !== i){var i=_rS_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$20);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$21);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$22);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$23);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$25);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           bprint_string_literal(buf,cst$26);
           bprint_string_literal(buf,string_of_formatting_gen(fmting_gen));
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _rG_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_rL_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _rM_=is_in_char_set(_rL_,c);
                 if(_rM_)
                  var
                   _rN_=is_in_char_set(_rL_,before),
                   _rO_=_rN_?is_in_char_set(_rL_,after):_rN_,
                   _rP_=1 - _rO_;
                 else
                  var _rP_=_rM_;
                 return _rP_}
               return is_alone},
            is_alone=is_alone$0(_rG_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_rG_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0;
               if(48 < switcher >>> 0)
                var switch$0=210 <= switcher?(print_char(buf,255),1):0;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 var switch$0=0}
               if(! switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_rG_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var match$0=char_of_int(i$1),switcher$1=match$0 - 45 | 0;
                 if(48 < switcher$1 >>> 0)
                  var
                   switch$1=
                    210 <= switcher$1
                     ?(print_char(buf,254),print_char(buf,255),1)
                     :0;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     var switch$1=0}
                   else
                    var switch$1=0}
                 if(! switch$1)
                  {if(! is_in_char_set(_rG_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0)
                      if(is_in_char_set(_rG_,char_of_int(j$0)))
                       {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _rH_=108;break;
             case 1:var _rH_=110;break;
             default:var _rH_=78}
           buffer_add_char(buf,_rH_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$1=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$1[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _rJ_=int_of_custom_arity(arity),
            _rI_=1;
           if(! (_rJ_ < 1))
            {var i$8=_rI_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _rK_=i$8 + 1 | 0;
               if(_rJ_ !== i$8){var i$8=_rK_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _ri_=function(param){return 0},
         _rj_=function(param){return 0},
         _rk_=function(param){return 0};
        return [0,function(param){return 0},_rk_,_rj_,_ri_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _rl_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_rl_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _rm_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _rm_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _rn_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _rn_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _ro_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _ro_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _rp_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _rp_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _rq_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _rq_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _rr_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _rr_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _rs_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _rs_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _rt_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _rt_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _ru_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _rv_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _rw_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _rw_,
                  _rv_,
                  _ru_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _rx_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _rx_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _ry_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _ry_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _rz_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _rz_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _rA_=function(param){caml_call1(de$12,0);return 0},
           _rB_=function(param){caml_call1(ed$12,0);return 0},
           _rC_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _rC_,
                  _rB_,
                  _rA_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _rD_=function(param){caml_call1(de$13,0);return 0},
           _rE_=function(param){caml_call1(ed$13,0);return 0},
           _rF_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _rF_,
                  _rE_,
                  _rD_]}}
    function trans(ty1,match)
     {if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:var switch$0=0;break;
          case 11:var switch$0=1;break;
          case 12:var switch$0=2;break;
          case 13:var switch$0=3;break;
          case 14:var switch$0=4;break;
          case 8:var switch$0=5;break;
          case 9:var switch$0=6;break;
          default:throw [0,Assert_failure,_ab_]}
      else
       switch(ty1[0])
        {case 0:
          var _q1_=ty1[1];
          if(typeof match === "number")
           var switch$1=1;
          else
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_q1_,rest2)];
             case 8:var switch$0=5,switch$1=0;break;
             case 9:var switch$0=6,switch$1=0;break;
             case 10:var switch$0=0,switch$1=0;break;
             case 11:var switch$0=1,switch$1=0;break;
             case 12:var switch$0=2,switch$1=0;break;
             case 13:var switch$0=3,switch$1=0;break;
             case 14:var switch$0=4,switch$1=0;break;
             default:var switch$1=1}
          if(switch$1)var switch$0=7;
          break;
         case 1:
          var _q2_=ty1[1];
          if(typeof match === "number")
           var switch$2=1;
          else
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_q2_,rest2$0)];
             case 8:var switch$0=5,switch$2=0;break;
             case 9:var switch$0=6,switch$2=0;break;
             case 10:var switch$0=0,switch$2=0;break;
             case 11:var switch$0=1,switch$2=0;break;
             case 12:var switch$0=2,switch$2=0;break;
             case 13:var switch$0=3,switch$2=0;break;
             case 14:var switch$0=4,switch$2=0;break;
             default:var switch$2=1}
          if(switch$2)var switch$0=7;
          break;
         case 2:
          var _q3_=ty1[1];
          if(typeof match === "number")
           var switch$3=1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_q3_,rest2$1)];
             case 8:var switch$0=5,switch$3=0;break;
             case 9:var switch$0=6,switch$3=0;break;
             case 10:var switch$0=0,switch$3=0;break;
             case 11:var switch$0=1,switch$3=0;break;
             case 12:var switch$0=2,switch$3=0;break;
             case 13:var switch$0=3,switch$3=0;break;
             case 14:var switch$0=4,switch$3=0;break;
             default:var switch$3=1}
          if(switch$3)var switch$0=7;
          break;
         case 3:
          var _q4_=ty1[1];
          if(typeof match === "number")
           var switch$4=1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_q4_,rest2$2)];
             case 8:var switch$0=5,switch$4=0;break;
             case 9:var switch$0=6,switch$4=0;break;
             case 10:var switch$0=0,switch$4=0;break;
             case 11:var switch$0=1,switch$4=0;break;
             case 12:var switch$0=2,switch$4=0;break;
             case 13:var switch$0=3,switch$4=0;break;
             case 14:var switch$0=4,switch$4=0;break;
             default:var switch$4=1}
          if(switch$4)var switch$0=7;
          break;
         case 4:
          var _q5_=ty1[1];
          if(typeof match === "number")
           var switch$5=1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_q5_,rest2$3)];
             case 8:var switch$0=5,switch$5=0;break;
             case 9:var switch$0=6,switch$5=0;break;
             case 10:var switch$0=0,switch$5=0;break;
             case 11:var switch$0=1,switch$5=0;break;
             case 12:var switch$0=2,switch$5=0;break;
             case 13:var switch$0=3,switch$5=0;break;
             case 14:var switch$0=4,switch$5=0;break;
             default:var switch$5=1}
          if(switch$5)var switch$0=7;
          break;
         case 5:
          var _q6_=ty1[1];
          if(typeof match === "number")
           var switch$6=1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_q6_,rest2$4)];
             case 8:var switch$0=5,switch$6=0;break;
             case 9:var switch$0=6,switch$6=0;break;
             case 10:var switch$0=0,switch$6=0;break;
             case 11:var switch$0=1,switch$6=0;break;
             case 12:var switch$0=2,switch$6=0;break;
             case 13:var switch$0=3,switch$6=0;break;
             case 14:var switch$0=4,switch$6=0;break;
             default:var switch$6=1}
          if(switch$6)var switch$0=7;
          break;
         case 6:
          var _q7_=ty1[1];
          if(typeof match === "number")
           var switch$7=1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_q7_,rest2$5)];
             case 8:var switch$0=5,switch$7=0;break;
             case 9:var switch$0=6,switch$7=0;break;
             case 10:var switch$0=0,switch$7=0;break;
             case 11:var switch$0=1,switch$7=0;break;
             case 12:var switch$0=2,switch$7=0;break;
             case 13:var switch$0=3,switch$7=0;break;
             case 14:var switch$0=4,switch$7=0;break;
             default:var switch$7=1}
          if(switch$7)var switch$0=7;
          break;
         case 7:
          var _q8_=ty1[1];
          if(typeof match === "number")
           var switch$8=1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_q8_,rest2$6)];
             case 8:var switch$0=5,switch$8=0;break;
             case 9:var switch$0=6,switch$8=0;break;
             case 10:var switch$0=0,switch$8=0;break;
             case 11:var switch$0=1,switch$8=0;break;
             case 12:var switch$0=2,switch$8=0;break;
             case 13:var switch$0=3,switch$8=0;break;
             case 14:var switch$0=4,switch$8=0;break;
             default:var switch$8=1}
          if(switch$8)var switch$0=7;
          break;
         case 8:
          var _q9_=ty1[2],_q__=ty1[1];
          if(typeof match === "number")
           var switch$9=1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_q$_=trans(_q9_,rest2$7);
              return [8,trans(_q__,ty2),_q$_];
             case 10:var switch$0=0,switch$9=0;break;
             case 11:var switch$0=1,switch$9=0;break;
             case 12:var switch$0=2,switch$9=0;break;
             case 13:var switch$0=3,switch$9=0;break;
             case 14:var switch$0=4,switch$9=0;break;
             default:var switch$9=1}
          if(switch$9)throw [0,Assert_failure,_ak_];
          break;
         case 9:
          var _ra_=ty1[3],_rb_=ty1[2],_rc_=ty1[1];
          if(typeof match === "number")
           var switch$10=1;
          else
           switch(match[0])
            {case 8:var switch$0=5,switch$10=0;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_rb_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_rc_,ty22,trans(_ra_,rest2$8)];
             case 10:var switch$0=0,switch$10=0;break;
             case 11:var switch$0=1,switch$10=0;break;
             case 12:var switch$0=2,switch$10=0;break;
             case 13:var switch$0=3,switch$10=0;break;
             case 14:var switch$0=4,switch$10=0;break;
             default:var switch$10=1}
          if(switch$10)throw [0,Assert_failure,_al_];
          break;
         case 10:
          var _rd_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_rd_,rest2$9)]}
          throw [0,Assert_failure,_am_];
         case 11:
          var _re_=ty1[1];
          if(typeof match === "number")
           var switch$11=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$11=0;break;
             case 11:var rest2$10=match[1];return [11,trans(_re_,rest2$10)];
             default:var switch$11=1}
          if(switch$11)throw [0,Assert_failure,_an_];
          break;
         case 12:
          var _rf_=ty1[1];
          if(typeof match === "number")
           var switch$12=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$12=0;break;
             case 11:var switch$0=1,switch$12=0;break;
             case 12:var rest2$11=match[1];return [12,trans(_rf_,rest2$11)];
             default:var switch$12=1}
          if(switch$12)throw [0,Assert_failure,_ao_];
          break;
         case 13:
          var _rg_=ty1[1];
          if(typeof match === "number")
           var switch$13=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$13=0;break;
             case 11:var switch$0=1,switch$13=0;break;
             case 12:var switch$0=2,switch$13=0;break;
             case 13:var rest2$12=match[1];return [13,trans(_rg_,rest2$12)];
             default:var switch$13=1}
          if(switch$13)throw [0,Assert_failure,_ap_];
          break;
         default:
          var _rh_=ty1[1];
          if(typeof match === "number")
           var switch$14=1;
          else
           switch(match[0])
            {case 10:var switch$0=0,switch$14=0;break;
             case 11:var switch$0=1,switch$14=0;break;
             case 12:var switch$0=2,switch$14=0;break;
             case 13:var switch$0=3,switch$14=0;break;
             case 14:var rest2$13=match[1];return [14,trans(_rh_,rest2$13)];
             default:var switch$14=1}
          if(switch$14)throw [0,Assert_failure,_aq_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ae_];
        case 1:throw [0,Assert_failure,_af_];
        case 2:throw [0,Assert_failure,_ag_];
        case 3:throw [0,Assert_failure,_ah_];
        case 4:throw [0,Assert_failure,_ai_];
        case 5:throw [0,Assert_failure,_ac_];
        case 6:throw [0,Assert_failure,_ad_];
        default:throw [0,Assert_failure,_aj_]}}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _qZ_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_q0_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _q0_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_q0_,_qZ_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?0 === prec?fmtty:[2,fmtty]:fmtty}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mismatch,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(0 === prec)
         {var rest=match[2],pad$0=match[1];return [0,pad$0,0,rest]}
        var _qY_=match[2];
        if(typeof _qY_ !== "number" && 2 === _qY_[0])
         {var rest$0=_qY_[1],pad$1=match[1];return [0,pad$1,1,rest$0]}
        throw Type_mismatch}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_format(fmt,fmtty)
     {var _qX_=type_format_gen(fmt,fmtty);
      if(typeof _qX_[2] === "number"){var fmt$0=_qX_[1];return fmt$0}
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           _qs_=type_padding(pad,fmtty),
           _qt_=_qs_[2],
           _qu_=_qs_[1];
          if(typeof _qt_ !== "number" && 1 === _qt_[0])
           {var
             fmtty_rest$1=_qt_[1],
             match$1=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$1[2],
             fmt$2=match$1[1];
            return [0,[2,_qu_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           _qv_=type_padding(pad$0,fmtty),
           _qw_=_qv_[2],
           _qx_=_qv_[1];
          if(typeof _qw_ !== "number" && 1 === _qw_[0])
           {var
             fmtty_rest$2=_qw_[1],
             match$2=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$2[2],
             fmt$3=match$2[1];
            return [0,[3,_qx_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           _qy_=type_padprec(pad$1,prec,fmtty),
           _qz_=_qy_[3],
           _qA_=_qy_[2],
           _qB_=_qy_[1];
          if(typeof _qz_ !== "number" && 2 === _qz_[0])
           {var
             fmtty_rest$3=_qz_[1],
             match$3=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$3[2],
             fmt$4=match$3[1];
            return [0,[4,iconv,_qB_,_qA_,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$0=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           _qC_=type_padprec(pad$2,prec$0,fmtty),
           _qD_=_qC_[3],
           _qE_=_qC_[2],
           _qF_=_qC_[1];
          if(typeof _qD_ !== "number" && 3 === _qD_[0])
           {var
             fmtty_rest$4=_qD_[1],
             match$4=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$4[2],
             fmt$5=match$4[1];
            return [0,[5,iconv$0,_qF_,_qE_,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$1=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           _qG_=type_padprec(pad$3,prec$1,fmtty),
           _qH_=_qG_[3],
           _qI_=_qG_[2],
           _qJ_=_qG_[1];
          if(typeof _qH_ !== "number" && 4 === _qH_[0])
           {var
             fmtty_rest$5=_qH_[1],
             match$5=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$5[2],
             fmt$6=match$5[1];
            return [0,[6,iconv$1,_qJ_,_qI_,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$2=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           _qK_=type_padprec(pad$4,prec$2,fmtty),
           _qL_=_qK_[3],
           _qM_=_qK_[2],
           _qN_=_qK_[1];
          if(typeof _qL_ !== "number" && 5 === _qL_[0])
           {var
             fmtty_rest$6=_qL_[1],
             match$6=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$6[2],
             fmt$7=match$6[1];
            return [0,[7,iconv$2,_qN_,_qM_,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$3=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           _qO_=type_padprec(pad$5,prec$3,fmtty),
           _qP_=_qO_[3],
           _qQ_=_qO_[2],
           _qR_=_qO_[1];
          if(typeof _qP_ !== "number" && 6 === _qP_[0])
           {var
             fmtty_rest$7=_qP_[1],
             match$7=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$7[2],
             fmt$8=match$7[1];
            return [0,[8,fconv,_qR_,_qQ_,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           _qS_=type_padding(pad$6,fmtty),
           _qT_=_qS_[2],
           _qU_=_qS_[1];
          if(typeof _qT_ !== "number" && 7 === _qT_[0])
           {var
             fmtty_rest$8=_qT_[1],
             match$8=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$8[2],
             fmt$9=match$8[1];
            return [0,[9,_qU_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$9=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$9[2],
           fmt$10=match$9[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$10=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$10[2],
           fmt$11=match$10[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$11=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$11[2],
           fmt$12=match$11[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$12=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$12[2],
             fmt$13=match$12[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _qV_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_qV_))
             throw Type_mismatch;
            var
             match$13=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$13[2],
             fmt$14=match$13[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$14=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$14[2],
             fmt$15=match$14[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$15=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$15[2],
             fmt$16=match$15[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$16=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$16[2],
           fmt$17=match$16[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$20=formatting_gen[1],
             str$0=match$20[2],
             fmt1=match$20[1],
             match$21=type_format_gen(fmt1,fmtty),
             fmtty2=match$21[2],
             fmt2=match$21[1],
             match$22=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$22[2],
             fmt3=match$22[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$23=formatting_gen[1],
           str$1=match$23[2],
           fmt1$0=match$23[1],
           match$24=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$24[2],
           fmt2$0=match$24[1],
           match$25=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$25[2],
           fmt3$0=match$25[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$17=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$17[2],
             fmt$18=match$17[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$18=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$18[2],
             fmt$19=match$18[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$19=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$19[2],
             fmt$20=match$19[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$26=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$26[2],
                 fmt$21=match$26[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _qW_=type_ignored_format_substitution(sub_fmtty$3,rest,fmtty),
               match$27=_qW_[2],
               fmtty$22=match$27[2],
               fmt$22=match$27[1],
               sub_fmtty$4=_qW_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_format_substitution(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substitution(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substitution
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substitution
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substitution
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substitution
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substitution
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substitution
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substitution
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substitution
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _qq_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_qq_))
             throw Type_mismatch;
            var _qr_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_qr_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substitution
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substitution
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substitution
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substitution
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substitution
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _qp_=2 === padty$0?48:32,res=make(width$0,_qp_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         if(0 < len)
          {if(43 === caml_string_get(str,0))
            var switch$1=1;
           else
            if(45 === caml_string_get(str,0))
             var switch$1=1;
            else
             if(32 === caml_string_get(str,0))
              var switch$1=1;
             else
              var switch$0=0,switch$1=0;
           if(switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0);
             var switch$0=1}}
         else
          var switch$0=0;
         if(! switch$0)
          {if(1 < len)
            if(48 === caml_string_get(str,0))
             {if(120 === caml_string_get(str,1))
               var switch$3=1;
              else
               if(88 === caml_string_get(str,1))
                var switch$3=1;
               else
                var switch$2=0,switch$3=0;
              if(switch$3)
               {caml_bytes_set(res,1,caml_string_get(str,1));
                blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0);
                var switch$2=1}}
            else
             var switch$2=0;
           else
            var switch$2=0;
           if(! switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return res}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0);
      if(58 <= c)
       var switch$0=71 <= c?5 < (c - 97 | 0) >>> 0?1:0:65 <= c?0:1;
      else
       {if(32 === c)
         var switch$1=1;
        else
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0))
               if(1 < len)
                {var
                  switch$2=
                   120 === caml_string_get(str,1)
                    ?0
                    :88 === caml_string_get(str,1)?0:1;
                 if(! switch$2)
                  {var res$1=make(prec$0 + 2 | 0,48);
                   caml_bytes_set(res$1,1,caml_string_get(str,1));
                   blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                   return res$1}}
              var switch$0=0,switch$1=0;
              break;
             case 0:
             case 2:var switch$1=1;break;
             case 1:
             case 3:
             case 4:var switch$0=1,switch$1=0;break;
             default:var switch$0=0,switch$1=0}}
         else
          var switch$0=1,switch$1=0;
        if(switch$1)
         {if(len < (prec$0 + 1 | 0))
           {var res$0=make(prec$0 + 1 | 0,48);
            caml_bytes_set(res$0,0,c);
            blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
            return res$0}
          var switch$0=1}}
      if(! switch$0)
       if(len < prec$0)
        {var res=make(prec$0,48);
         blit$0(str,0,res,prec$0 - len | 0,len);
         return res}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return res}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 0:var _qo_=cst_d$2;break;
        case 1:var _qo_=cst_d$3;break;
        case 2:var _qo_=cst_d$4;break;
        case 3:var _qo_=cst_i$0;break;
        case 4:var _qo_=cst_i$1;break;
        case 5:var _qo_=cst_i$2;break;
        case 6:var _qo_=cst_x;break;
        case 7:var _qo_=cst_x$0;break;
        case 8:var _qo_=cst_X$0;break;
        case 9:var _qo_=cst_X$1;break;
        case 10:var _qo_=cst_o;break;
        case 11:var _qo_=cst_o$0;break;
        default:var _qo_=cst_u}
      return caml_format_int(_qo_,n)}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 0:var _qn_=cst_ld;break;
        case 1:var _qn_=cst_ld$0;break;
        case 2:var _qn_=cst_ld$1;break;
        case 3:var _qn_=cst_li$0;break;
        case 4:var _qn_=cst_li$1;break;
        case 5:var _qn_=cst_li$2;break;
        case 6:var _qn_=cst_lx;break;
        case 7:var _qn_=cst_lx$0;break;
        case 8:var _qn_=cst_lX;break;
        case 9:var _qn_=cst_lX$0;break;
        case 10:var _qn_=cst_lo;break;
        case 11:var _qn_=cst_lo$0;break;
        default:var _qn_=cst_lu}
      return caml_format_int(_qn_,n)}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 0:var _qm_=cst_nd;break;
        case 1:var _qm_=cst_nd$0;break;
        case 2:var _qm_=cst_nd$1;break;
        case 3:var _qm_=cst_ni$0;break;
        case 4:var _qm_=cst_ni$1;break;
        case 5:var _qm_=cst_ni$2;break;
        case 6:var _qm_=cst_nx;break;
        case 7:var _qm_=cst_nx$0;break;
        case 8:var _qm_=cst_nX;break;
        case 9:var _qm_=cst_nX$0;break;
        case 10:var _qm_=cst_no;break;
        case 11:var _qm_=cst_no$0;break;
        default:var _qm_=cst_nu}
      return caml_format_int(_qm_,n)}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 0:var _ql_=cst_Ld;break;
        case 1:var _ql_=cst_Ld$0;break;
        case 2:var _ql_=cst_Ld$1;break;
        case 3:var _ql_=cst_Li$0;break;
        case 4:var _ql_=cst_Li$1;break;
        case 5:var _ql_=cst_Li$2;break;
        case 6:var _ql_=cst_Lx;break;
        case 7:var _ql_=cst_Lx$0;break;
        case 8:var _ql_=cst_LX;break;
        case 9:var _ql_=cst_LX$0;break;
        case 10:var _ql_=cst_Lo;break;
        case 11:var _ql_=cst_Lo$0;break;
        default:var _ql_=cst_Lu}
      return caml_int64_format(_ql_,n)}
    function convert_float(fconv,prec$0,x)
     {if(16 <= fconv)
       {if(17 <= fconv)
         switch(fconv - 17 | 0)
          {case 2:var switch$0=0;break;
           case 0:
           case 3:var sign=43,switch$0=1;break;
           default:var sign=32,switch$0=1}
        else
         var switch$0=0;
        if(! switch$0)var sign=45;
        var str=runtime.caml_hexstring_of_float(x,prec$0,sign);
        return 19 <= fconv?uppercase_ascii$1(str):str}
      if(15 === fconv)
       var _qi_=cst_12g$0;
      else
       {var prec=abs(prec$0),symb=char_of_fconv(fconv),buf=buffer_create(16);
        buffer_add_char(buf,37);
        bprint_fconv_flag(buf,fconv);
        buffer_add_char(buf,46);
        buffer_add_string(buf,caml_new_string("" + prec));
        buffer_add_char(buf,symb);
        var _qi_=buffer_contents(buf)}
      var str$0=caml_format_float(_qi_,x);
      if(15 === fconv)
       {var
         len=caml_ml_string_length(str$0),
         match$0=runtime.caml_classify_float(x);
        if(3 === match$0)return x < 0?cst_neg_infinity:cst_infinity;
        if(4 <= match$0)return cst_nan;
        var i=0;
        for(;;)
         {if(i === len)
           var _qk_=0;
          else
           {var
             match=caml_string_get(str$0,i),
             _qj_=match - 46 | 0,
             switch$1=
              23 < _qj_ >>> 0?55 === _qj_?1:0:21 < (_qj_ - 1 | 0) >>> 0?1:0;
            if(! switch$1){var i$0=i + 1 | 0,i=i$0;continue}
            var _qk_=1}
          return _qk_?str$0:_g_(str$0,cst$27)}}
      return str$0}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_int_padding_precision(k,o,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return 0 === match
                 ?function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,o,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _qf_=pad[2],_qg_=pad[1];
          if(typeof match === "number")
           return 0 === match
                   ?function(x)
                     {var str=fix_padding(_qg_,_qf_,caml_call2(trans,iconv,x));
                      return make_printf(k,o,[4,acc,str],fmt)}
                   :function(p,x)
                     {var
                       str=
                        fix_padding
                         (_qg_,_qf_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,o,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_qg_,_qf_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,o,[4,acc,str],fmt)}}
        var _qh_=pad[1];
        if(typeof match === "number")
         return 0 === match
                 ?function(w,x)
                   {var str=fix_padding(_qh_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,o,[4,acc,str],fmt)}
                 :function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_qh_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,o,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_qh_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,o,[4,acc,str],fmt)}}}
    function make_padding(k,o,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,o,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,o,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,o,new_acc,fmt)}}}
    function make_printf$0(counter,k,o,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call2(k$0,o,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,o,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,res];
             return make_printf(k$0,o,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding
                   (k$0,o,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,o,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(x)
                        {var str=convert_float(fconv,default_float_precision,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)}
                      :function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _qc_=pad$5[2],_qd_=pad$5[1];
               if(typeof prec$3 === "number")
                return 0 === prec$3
                        ?function(x)
                          {var
                            str=convert_float(fconv,default_float_precision,x),
                            str$0=fix_padding(_qd_,_qc_,str);
                           return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                        :function(p,x)
                          {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p,x));
                           return make_printf(k$0,o,[4,acc$0,str],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_qd_,_qc_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
             var _qe_=pad$5[1];
             if(typeof prec$3 === "number")
              return 0 === prec$3
                      ?function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision,x),
                          str$0=fix_padding(_qe_,w,str);
                         return make_printf(k$0,o,[4,acc$0,str$0],rest$7)}
                      :function(w,p,x)
                        {var str=fix_padding(_qe_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,o,[4,acc$0,str],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_qe_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,o,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,o,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str)
            {return make_printf(k$0,o,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,o,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      o,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,o,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _qa_=fmt$0[1];
           if(0 === _qa_[0])
            {var
              rest$13=fmt$0[2],
              match=_qa_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(koc,kacc)
                  {return make_printf(k,koc,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_qa_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(koc,kacc)
                {return make_printf(k,koc,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_ar_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,o,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,o,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];
             return make_printf(k$0,o,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,o,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,o,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _qb_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,o,acc$0,rest$19,arity,_qb_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,o,acc$0,rest$19,arity,_qb_])}}
    function make_ignored_param$0(counter,k,o,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:throw [0,Assert_failure,_as_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,o,acc,fmtty,fmt)}
          return caml_trampoline_return
                  (make_from_fmtty$0,[0,k,o,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,o,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}}
    function make_from_fmtty$0(counter,k,o,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,o,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,o,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,o,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,o,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_p$_)
           {return make_from_fmtty(k,o,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,o,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_at_];
         default:throw [0,Assert_failure,_au_]}}
    function make_invalid_arg(counter,k,o,acc,fmt)
     {var _p__=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p__,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p__,fmt])}
    function make_custom$0(counter,k,o,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,o,acc,rest,arity$0,caml_call1(f,x))}}
      var _p9_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,o,_p9_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,o,_p9_,rest])}
    function make_printf(k,o,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,o,acc,fmt))}
    function make_ignored_param(k,o,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,o,acc,ign,fmt))}
    function make_from_fmtty(k,o,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,o,acc,fmtty,fmt))}
    function make_custom(k,o,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,o,acc,rest,arity,f))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {var _pF_=make_iprintf(k,o,fmt);return function(_pX_){return _pF_}}
          var _pG_=make_iprintf(k,o,fmt),_pH_=function(_pW_){return _pG_};
          return function(_pV_){return _pH_}}
        var _pI_=make_iprintf(k,o,fmt);
        return function(_pU_){return _pI_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(0 === prec)
             {var _pJ_=make_iprintf(k,o,fmt);
              return function(_p8_){return _pJ_}}
            var _pK_=make_iprintf(k,o,fmt),_pL_=function(_p7_){return _pK_};
            return function(_p6_){return _pL_}}
          var _pM_=make_iprintf(k,o,fmt);
          return function(_p5_){return _pM_}}
        if(typeof prec === "number")
         {if(0 === prec)
           {var _pN_=make_iprintf(k,o,fmt),_pO_=function(_p4_){return _pN_};
            return function(_p3_){return _pO_}}
          var
           _pP_=make_iprintf(k,o,fmt),
           _pQ_=function(_p2_){return _pP_},
           _pR_=function(_p1_){return _pQ_};
          return function(_p0_){return _pR_}}
        var _pS_=make_iprintf(k,o,fmt),_pT_=function(_pZ_){return _pS_};
        return function(_pY_){return _pT_}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_oW_=make_iprintf(k$0,o,rest);
           return function(_pE_){return _oW_};
          case 1:
           var rest$0=fmt$0[1],_oX_=make_iprintf(k$0,o,rest$0);
           return function(_pD_){return _oX_};
          case 2:
           var _oY_=fmt$0[1];
           if(typeof _oY_ === "number")
            {var rest$1=fmt$0[2],_oZ_=make_iprintf(k$0,o,rest$1);
             return function(_pz_){return _oZ_}}
           else
            {if(0 === _oY_[0])
              {var rest$2=fmt$0[2],_o0_=make_iprintf(k$0,o,rest$2);
               return function(_pC_){return _o0_}}
             var
              rest$3=fmt$0[2],
              _o1_=make_iprintf(k$0,o,rest$3),
              _o2_=function(_pB_){return _o1_};
             return function(_pA_){return _o2_}}
          case 3:
           var _o3_=fmt$0[1];
           if(typeof _o3_ === "number")
            {var rest$4=fmt$0[2],_o4_=make_iprintf(k$0,o,rest$4);
             return function(_pv_){return _o4_}}
           else
            {if(0 === _o3_[0])
              {var rest$5=fmt$0[2],_o5_=make_iprintf(k$0,o,rest$5);
               return function(_py_){return _o5_}}
             var
              rest$6=fmt$0[2],
              _o6_=make_iprintf(k$0,o,rest$6),
              _o7_=function(_px_){return _o6_};
             return function(_pw_){return _o7_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _o8_=fmt$0[1];
           if(typeof _o8_ === "number")
            {var rest$12=fmt$0[2],_o9_=make_iprintf(k$0,o,rest$12);
             return function(_pr_){return _o9_}}
           else
            {if(0 === _o8_[0])
              {var rest$13=fmt$0[2],_o__=make_iprintf(k$0,o,rest$13);
               return function(_pu_){return _o__}}
             var
              rest$14=fmt$0[2],
              _o$_=make_iprintf(k$0,o,rest$14),
              _pa_=function(_pt_){return _o$_};
             return function(_ps_){return _pa_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_pb_=make_iprintf(k$0,o,rest$15);
           return function(_pq_){return _pb_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _pc_=make_iprintf(k$0,o,rest$17),
            _pd_=function(_pp_){return _pc_};
           return function(_po_){return _pd_};
          case 16:
           var rest$18=fmt$0[1],_pe_=make_iprintf(k$0,o,rest$18);
           return function(_pn_){return _pe_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _pf_=fmt$0[1];
           if(0 === _pf_[0])
            {var
              rest$19=fmt$0[2],
              match=_pf_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_pf_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_av_];
          case 20:
           var rest$21=fmt$0[3],_pg_=make_iprintf(k$0,o,rest$21);
           return function(_pm_){return _pg_};
          case 21:
           var rest$22=fmt$0[2],_ph_=make_iprintf(k$0,o,rest$22);
           return function(_pl_){return _ph_};
          case 22:
           var rest$23=fmt$0[1],_pi_=make_iprintf(k$0,o,rest$23);
           return function(_pk_){return _pi_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_pj_=0;
           return make_ignored_param
                   (function(x,param){return caml_call1(k$0,x)},
                    o,
                    _pj_,
                    ign,
                    rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_oU_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_oV_){return _oU_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _oS_=acc$0[2],_oT_=acc$0[1];
           if(0 === _oS_[0])
            {var acc$1=_oS_[1];
             output_acc(o,_oT_);
             output_string(o,cst$28);
             var acc$0=acc$1;
             continue}
           var acc$2=_oS_[1];
           output_acc(o,_oT_);
           output_string(o,cst$29);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oQ_=acc$0[2],_oR_=acc$0[1];
           if(0 === _oQ_[0])
            {var acc$1=_oQ_[1];
             bufput_acc(b,_oR_);
             add_string(b,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_oQ_[1];
           bufput_acc(b,_oR_);
           add_string(b,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _oO_=acc$0[2],_oP_=acc$0[1];
           if(0 === _oO_[0])
            {var acc$1=_oO_[1];
             strput_acc(b,_oP_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_oO_[1];
           strput_acc(b,_oP_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$1(256);
      function k(param,acc)
       {strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$34))return _aw_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_ax_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match)if(32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var
           match=caml_string_get(str,j$0),
           switch$0=48 <= match?58 <= match?0:1:45 === match?1:0;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _oM_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_oM_}
       catch(_oN_)
        {_oN_ = caml_wrap_exception(_oN_);
         if(_oN_[1] !== Failure)throw _oN_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      if(caml_string_notequal(box_name,cst$35))
       if(caml_string_notequal(box_name,cst_b$0))
        if(caml_string_notequal(box_name,cst_h))
         if(caml_string_notequal(box_name,cst_hov))
          if(caml_string_notequal(box_name,cst_hv))
           if(caml_string_notequal(box_name,cst_v))
            var box_type=invalid_box(0),switch$0=1;
           else
            var box_type=1,switch$0=1;
          else
           var box_type=2,switch$0=1;
         else
          var box_type=3,switch$0=1;
        else
         var box_type=0,switch$0=1;
       else
        var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=0 === prec?[0,0,fmt]:[0,1,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ay_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_az_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_aA_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _oL_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_oL_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aM_;
            else
             {var c=caml_string_get(str,str_ind$0);
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  var switch$0=0;
                 else
                  switch(switcher)
                   {case 0:
                     var
                      match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]],
                      switch$0=1}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var
                      match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 1:var switch$0=0;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]],
                      switch$0=1}}
                else
                 var switch$0=0;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]],
                 switch$0=1;
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aN_,fmt_rest$5]],
                      switch$0=1;
                     break;
                    case 5:
                     if((str_ind$0 + 1 | 0) < end_ind)
                      if(37 === caml_string_get(str,str_ind$0 + 1 | 0))
                       var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]],
                        switch$0=1,
                        switch$1=0;
                      else
                       var switch$1=1;
                     else
                      var switch$1=1;
                     if(switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]],
                       switch$0=1;
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aO_,fmt_rest$8]],
                      switch$0=1;
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]],
                      switch$0=1;
                     break;
                    case 27:
                     var
                      match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 28:
                     var
                      match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind),
                      switch$0=1;
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]],
                      switch$0=1;
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]],
                      switch$0=1;
                     break;
                    default:var switch$0=0}}
                else
                 var switch$0=0;
              if(! switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number")if(0 === match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aH_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$36);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$37)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        if(124 <= symb)
         var switch$0=0;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]],
             switch$0=1;
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _ok_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _ok_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_ok_,switch$0=1;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind),switch$0=1;break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _om_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_om_,
             switch$0=1;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_os_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _os_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_os_,switch$0=1;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _ot_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _ot_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_ot_,switch$0=1;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _oK_=i + 1 | 0;
                    if(c !== i){var i=_oK_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aQ_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _oJ_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_oJ_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_oJ_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0);
                  if(46 <= c$1)
                   if(64 === c$1)
                    var switch$0=0;
                   else
                    {if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}
                     var switch$0=1}
                  else
                   if(37 === c$1)
                    var switch$0=0;
                   else
                    {if(45 <= c$1)
                      {var str_ind$2=str_ind$0 + 1 | 0;
                       if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                       var c$2=caml_string_get(str,str_ind$2);
                       if(37 === c$2)
                        {if((str_ind$2 + 1 | 0) === end_ind)
                          unexpected_end_of_format(end_ind);
                         var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                         if(37 !== c$3)
                          if(64 !== c$3)return fail_single_percent(str_ind$2);
                         add_range(c$0,c$3);
                         var _oH_=str_ind$2 + 2 | 0;
                         if(counter < 50)
                          {var counter$2=counter + 1 | 0;
                           return parse_char_set_content(counter$2,_oH_,end_ind)}
                         return caml_trampoline_return
                                 (parse_char_set_content,[0,_oH_,end_ind])}
                       if(93 === c$2)
                        {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                       add_range(c$0,c$2);
                       var _oI_=str_ind$2 + 1 | 0;
                       if(counter < 50)
                        {var counter$1=counter + 1 | 0;
                         return parse_char_set_content(counter$1,_oI_,end_ind)}
                       return caml_trampoline_return
                               (parse_char_set_content,[0,_oI_,end_ind])}
                     var switch$0=1}
                  if(! switch$0)
                   if(37 === c$0)
                    {add_char(c$1);
                     var _oG_=str_ind$0 + 1 | 0;
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return parse_char_set_content(counter$0,_oG_,end_ind)}
                     return caml_trampoline_return
                             (parse_char_set_content,[0,_oG_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,str_ind$1=str_ind$0,reverse=1;
            else
             var str_ind$1=str_ind,reverse=0;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _oy_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _oy_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_oy_,switch$0=1;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]],
             switch$0=1;
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _oz_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _oA_=_oz_;
              else
               var
                _oA_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,
                     cst_non_zero_widths_are_unsupported_for_c_conversions);
              var _oB_=_oA_}
            else
             var _oB_=char_format(fmt_rest$21);
            var fmt_result=_oB_,switch$0=1;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _oC_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_oC_,
             switch$0=1;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _oD_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _oD_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_oD_,switch$0=1;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]],
             switch$0=1;
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _oE_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _oE_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_oE_,switch$0=1;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _ol_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _ol_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_ol_,switch$0=1;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]],
             switch$0=1;
            break;
           case 76:
           case 108:
           case 110:
            if(str_ind === end_ind)
             var switch$1=1;
            else
             {var symb$0=caml_string_get(str,str_ind),_oF_=symb$0 - 88 | 0;
              if(32 < _oF_ >>> 0)
               var switch$2=0;
              else
               switch(_oF_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _or_=1,switch$2=1;break;
                 default:var switch$2=0}
              if(! switch$2)var _or_=0;
              if(_or_)var switch$0=0,switch$1=0;else var switch$1=1}
            if(switch$1)
             {var match$15=parse(str_ind,end_ind),fmt_rest$13=match$15[1];
              if(108 <= symb)
               if(111 <= symb)
                var switch$3=0;
               else
                {var switcher$0=symb - 108 | 0;
                 switch(switcher$0)
                  {case 0:var counter=0,switch$3=1;break;
                   case 1:var switch$3=0;break;
                   default:var counter=1,switch$3=1}}
              else
               if(76 === symb)var counter=2,switch$3=1;else var switch$3=0;
              if(! switch$3)throw [0,Assert_failure,_aU_];
              if(get_ign(0))
               var ignored$5=[11,counter],_oq_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _oq_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_oq_,switch$0=1}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=caml_call3(failwith_message(_aL_),str,pct_ind,symb),
             switch$0=1;
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _ou_=get_space(0),
             _ov_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_ov_,_ou_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _ow_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _ox_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_ox_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _ow_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_ow_,switch$0=1;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             plus$2=get_plus(0),
             plus$3=plus$2,
             space$2=space$1;
            for(;;)
             {if(0 === plus$3)
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$1=symb - 101 | 0;
                   if(3 < switcher$1 >>> 0)
                    var switch$4=0;
                   else
                    switch(switcher$1)
                     {case 0:var fconv=3,switch$4=1;break;
                      case 1:var fconv=0,switch$4=1;break;
                      case 2:var fconv=9,switch$4=1;break;
                      default:var fconv=16,switch$4=1}}
                 else
                  if(69 <= symb)
                   {var switcher$2=symb - 69 | 0;
                    switch(switcher$2)
                     {case 0:var fconv=6,switch$4=1;break;
                      case 1:var fconv=15,switch$4=1;break;
                      case 2:var fconv=12,switch$4=1;break;
                      default:var fconv=19,switch$4=1}}
                  else
                   var switch$4=0;
                 if(! switch$4)throw [0,Assert_failure,_aW_]}
               else
                {if(73 <= symb)
                  {var switcher$3=symb - 101 | 0;
                   if(3 < switcher$3 >>> 0)
                    var switch$5=0;
                   else
                    switch(switcher$3)
                     {case 0:var fconv=5,switch$5=1;break;
                      case 1:var fconv=2,switch$5=1;break;
                      case 2:var fconv=11,switch$5=1;break;
                      default:var fconv=18,switch$5=1}}
                 else
                  if(69 <= symb)
                   {var switcher$4=symb - 69 | 0;
                    switch(switcher$4)
                     {case 0:var fconv=8,switch$5=1;break;
                      case 1:var switch$5=0;break;
                      case 2:var fconv=14,switch$5=1;break;
                      default:var fconv=21,switch$5=1}}
                  else
                   var switch$5=0;
                 if(! switch$5)
                  {if(legacy_behavior$0){var space$2=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$48)}}
              else
               if(0 === space$2)
                {if(73 <= symb)
                  {var switcher$5=symb - 101 | 0;
                   if(3 < switcher$5 >>> 0)
                    var switch$6=0;
                   else
                    switch(switcher$5)
                     {case 0:var fconv=4,switch$6=1;break;
                      case 1:var fconv=1,switch$6=1;break;
                      case 2:var fconv=10,switch$6=1;break;
                      default:var fconv=17,switch$6=1}}
                 else
                  if(69 <= symb)
                   {var switcher$6=symb - 69 | 0;
                    switch(switcher$6)
                     {case 0:var fconv=7,switch$6=1;break;
                      case 1:var switch$6=0;break;
                      case 2:var fconv=13,switch$6=1;break;
                      default:var fconv=20,switch$6=1}}
                  else
                   var switch$6=0;
                 if(! switch$6)
                  {if(legacy_behavior$0){var plus$3=0;continue}
                   var fconv=incompatible_flag(pct_ind,str_ind,symb,cst$49)}}
               else
                {if(legacy_behavior$0){var space$2=0;continue}
                 var fconv=incompatible_flag(pct_ind,str_ind,32,cst$50)}
              var match$13=parse(str_ind,end_ind),fmt_rest$11=match$13[1];
              if(get_ign(0))
               {var match=get_prec(0);
                if(typeof match === "number")
                 var
                  _on_=
                   0 === match?0:incompatible_flag(pct_ind,str_ind,95,cst$38);
                else
                 var ndec=match[1],_on_=[0,ndec];
                var
                 ignored$4=[6,get_pad_opt(95),_on_],
                 _oo_=[0,[23,ignored$4,fmt_rest$11]]}
              else
               var
                _op_=get_prec(0),
                match$14=make_padprec_fmt_ebb(get_pad(0),_op_,fmt_rest$11),
                fmt_rest$12=match$14[3],
                prec$3=match$14[2],
                pad$5=match$14[1],
                _oo_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
              var fmt_result=_oo_,switch$0=1;
              break}
            break;
           default:var switch$0=0}
        if(! switch$0)
         {if(108 <= symb)
           if(111 <= symb)
            var switch$7=0;
           else
            {var switcher=symb - 108 | 0;
             switch(switcher)
              {case 0:
                var
                 _n6_=caml_string_get(str,str_ind),
                 _n7_=get_space(0),
                 _n8_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_n8_,_n7_,_n6_),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _n9_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _n$_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_n$_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _n9_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _n__=_n9_,switch$8=1;
                break;
               case 1:var switch$7=0,switch$8=0;break;
               default:
                var
                 _oa_=caml_string_get(str,str_ind),
                 _ob_=get_space(0),
                 _oc_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_oc_,_ob_,_oa_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _od_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _oe_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_oe_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _od_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _n__=_od_,switch$8=1}
             if(switch$8)var fmt_result=_n__,switch$7=1}
          else
           if(76 === symb)
            {var
              _of_=caml_string_get(str,str_ind),
              _og_=get_space(0),
              _oh_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_oh_,_og_,_of_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _oi_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _oj_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_oj_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _oi_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_oi_,switch$7=1}
           else
            var switch$7=0;
          if(! switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aI_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _nX_=1 - plus_used[1],plus$0=_nX_?plus:_nX_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$39);
          var _nY_=1 - hash_used[1],hash$0=_nY_?hash:_nY_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$40);
          var _nZ_=1 - space_used[1],space$0=_nZ_?space:_nZ_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _n0_=1 - pad_used[1],_n1_=_n0_?caml_notequal([0,pad],_aJ_):_n0_;
          if(_n1_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _n2_=1 - prec_used[1],
           _n3_=_n2_?caml_notequal([0,prec],_aK_):_n2_;
          if(_n3_)
           {var _n4_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_n4_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$42)}
        var _n5_=1 - ign_used[1],ign$0=_n5_?ign:_n5_;
        if(ign$0)
         {var
           switch$9=
            38 <= symb
             ?44 === symb?0:64 === symb?0:1
             :33 === symb?0:37 <= symb?0:1,
           switch$10=switch$9?0:legacy_behavior$0?1:0;
          if(! switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$43)}
        return fmt_result}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number")if(0 === match)return parse_conv(0);
          if(0 === minus)
           {if(typeof match === "number")return parse_conv(_aE_);
            var n=match[1];
            return parse_conv([0,1,n])}
          if(typeof match === "number")return parse_conv(_aF_);
          var n$0=match[1];
          return parse_conv([0,0,n$0])}
        return parse_conv(pad)}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _nW_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_nW_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aD_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _nT_=flag[1],_nU_=_nT_?1 - legacy_behavior$0:_nT_;
          if(_nU_)
           {var _nV_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aB_),str,str_ind,_nV_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _nO_=space[1],
           _nP_=hash[1],
           _nQ_=plus[1],
           _nR_=minus[1],
           _nS_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            0 === _nS_
             ?0 === _nR_?1:0
             :0 === _nR_
               ?2
               :legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0),
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _nR_,
                       _nQ_,
                       _nP_,
                       _nO_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _nR_,
                     _nQ_,
                     _nP_,
                     _nO_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_nR_,_nQ_,_nP_,_nO_,ign,_aC_)}}}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str];
            if(is_open_tag)
             var formatting$0=[0,sub_format$0];
            else
             {if(typeof sub_fmt === "number")
               var switch$0=0;
              else
               if(11 === sub_fmt[0])
                if(typeof sub_fmt[2] === "number")
                 {var str$0=sub_fmt[1];
                  try
                   {open_box_of_string(str$0);var switch$1=1}
                  catch(_nN_)
                   {_nN_ = caml_wrap_exception(_nN_);
                    if(_nN_[1] !== Failure)throw _nN_;
                    var switch$0=1,switch$1=0}
                  if(switch$1)var switch$0=1}
                else
                 var switch$0=0;
               else
                var switch$0=0;
              var formatting$0=[1,sub_format$0]}
            var _nL_=[0,[18,formatting$0,fmt_rest$0]];
            return _nL_}
          throw Not_found}
        catch(_nM_)
         {_nM_ = caml_wrap_exception(_nM_);
          if(_nM_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _nM_}}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _nE_=str_ind === end_ind?1:0,
           _nF_=_nE_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_nF_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$0?58 <= match$0?0:1:45 === match$0?1:0;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nG_=[0,s,width,0],
             _nH_=str_ind_3 + 1 | 0,
             next_ind=_nH_,
             formatting_lit$0=_nG_,
             switch$1=1;
           else
            var switch$1=0;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _nI_=[0,s$0,width,offset],
               _nJ_=str_ind_5 + 1 | 0,
               next_ind=_nJ_,
               formatting_lit$0=_nI_,
               switch$1=1}
            else
             var switch$1=0}
          if(! switch$1)throw Not_found}
        catch(_nK_)
         {_nK_ = caml_wrap_exception(_nK_);
          if(_nK_ !== Not_found)if(_nK_[1] !== Failure)throw _nK_;
          var next_ind=str_ind,formatting_lit$0=formatting_lit}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=48 <= match$2?58 <= match$2?0:1:45 === match$2?1:0;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _nC_=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _nC_=0;
          var _nB_=_nC_}
        catch(_nD_)
         {_nD_ = caml_wrap_exception(_nD_);
          if(_nD_ !== Not_found)if(_nD_[1] !== Failure)throw _nD_;
          var _nB_=0}
        if(_nB_)
         {var
           match=_nB_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aP_,fmt_rest$0]]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aR_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aS_]}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aT_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aX_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {if(0 === plus$0)
           if(0 === hash$0)
            if(0 === space$0)
             {var switcher=symb - 88 | 0;
              if(32 < switcher >>> 0)
               var switch$0=1;
              else
               switch(switcher)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6;
                 default:var switch$0=1}}
            else
             {if(100 === symb)return 2;
              if(105 === symb)return 5;
              var switch$0=1}
           else
            if(0 === space$0)
             {if(88 === symb)return 9;
              if(111 === symb)return 11;
              if(120 === symb)return 7;
              var switch$0=0}
            else
             var switch$0=0;
          else
           if(0 === hash$0)
            if(0 === space$0)
             {if(100 === symb)return 1;
              if(105 === symb)return 4;
              var switch$0=1}
            else
             var switch$0=1;
           else
            var switch$0=0;
          if(! switch$0)
           {var switcher$0=symb - 88 | 0;
            if(! (32 < switcher$0 >>> 0))
             switch(switcher$0)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$47)
               }}
          if(0 === plus$0)
           {if(0 === space$0)throw [0,Assert_failure,_aV_];
            if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$44)}
          if(0 === space$0)
           {if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$45)}
          if(legacy_behavior$0){var space$0=0;continue}
          return incompatible_flag(pct_ind,str_ind,32,cst$46)}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _nz_=[0,type_format(fmt,fmtty),str];return _nz_}
      catch(_nA_)
       {_nA_ = caml_wrap_exception(_nA_);
        if(_nA_ === Type_mismatch)
         {var _ny_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aY_),str,_ny_)}
        throw _nA_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _nw_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _nw_}
      catch(_nx_)
       {_nx_ = caml_wrap_exception(_nx_);
        if(_nx_ === Type_mismatch)
         return caml_call2(failwith_message(_aZ_),str,str$0);
        throw _nx_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_formatting_gen,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(668,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_nv_=0;
      return make_printf
              (function(o,acc){output_acc(o,acc);return caml_call1(k,o)},
               o,
               _nv_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_nu_=0;
      return make_printf
              (function(b,acc){bufput_acc(b,acc);return caml_call1(k,b)},
               b,
               _nu_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_nt_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_ns_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_nr_){return 0},oc,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(param,acc)
       {var buf=create$1(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ksprintf];
    caml_register_global(669,Printf,"Printf");
    var
     Bad=[248,cst_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$0=t;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _nq_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_nq_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_np_=_g_(prefix,h);
        return _g_
                (fold_left(function(x,y){return _g_(x,_g_(sep,y))},_np_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a2_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _nm_=0,_nk_=_nm_}
      catch(_no_)
       {_no_ = caml_wrap_exception(_no_);
        if(_no_ !== Not_found)throw _no_;
        var
         _nk_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_options],0]}
      try
       {assoc3(cst_help$1,speclist);var _nl_=0,add2=_nl_}
      catch(_nn_)
       {_nn_ = caml_wrap_exception(_nn_);
        if(_nn_ !== Not_found)throw _nn_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_options$0],
           0]}
      return append(speclist,append(_nk_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a3_),errmsg);
      var _nh_=add_help(speclist);
      return iter
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _ni_=0 < caml_ml_string_length(doc)?1:0;
                 if(_ni_)
                  {if(11 === spec[0])
                    {var l=spec[1],_nj_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a1_),key,_nj_,doc)}
                   return caml_call2(bprintf(buf,_a0_),key,doc)}
                 return _ni_},
               _nh_)}
    function usage_string(speclist,errmsg)
     {var b=create$1(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _ng_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a4_),_ng_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _ne_=[0,bool_of_string(x)];return _ne_}
      catch(_nf_)
       {_nf_ = caml_wrap_exception(_nf_);
        if(_nf_[1] === Invalid_argument)return 0;
        throw _nf_}}
    function int_of_string_opt$0(x)
     {try
       {var _nc_=[0,caml_int_of_string(x)];return _nc_}
      catch(_nd_)
       {_nd_ = caml_wrap_exception(_nd_);
        if(_nd_[1] === Failure)return 0;
        throw _nd_}}
    function float_of_string_opt$0(x)
     {try
       {var _na_=[0,caml_float_of_string(x)];return _na_}
      catch(_nb_)
       {_nb_ = caml_wrap_exception(_nb_);
        if(_nb_[1] === Failure)return 0;
        throw _nb_}}
    function parse_and_expand_argv_dynamic_aux
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$1(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[initpos + 1]
           :cst$54;
        switch(error[0])
         {case 0:
           var _m$_=error[1];
           if(caml_string_notequal(_m$_,cst_help$3))
            if(caml_string_notequal(_m$_,cst_help$4))
             caml_call2(bprintf(b,_a5_),progname,_m$_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a8_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a9_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a__),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a6_))
         if(! caml_equal(error,_a7_))return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var _m4_=current[1],s=caml_check_bound(argv[1],_m4_)[_m4_ + 1];
            if(1 <= caml_ml_string_length(s))
             if(45 === caml_string_get(s,0))
              {try
                {var
                  follow$1=0,
                  _m6_=assoc3(s,speclist[1]),
                  action=_m6_,
                  follow$0=follow$1}
               catch(_m9_)
                {_m9_ = caml_wrap_exception(_m9_);
                 if(_m9_ !== Not_found)throw _m9_;
                 try
                  {var
                    match=split$0(s),
                    arg=match[2],
                    keyword=match[1],
                    follow=[0,arg],
                    _m5_=assoc3(keyword,speclist[1])}
                 catch(_m__)
                  {_m__ = caml_wrap_exception(_m__);
                   if(_m__ === Not_found)throw [0,Stop,[0,s]];
                   throw _m__}
                 var action=_m5_,follow$0=follow}
               var
                no_arg$0=
                 function(s,follow)
                  {function no_arg(param)
                    {if(follow)
                      {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                     return 0}
                   return no_arg},
                no_arg=no_arg$0(s,follow$0),
                get_arg$0=
                 function(s,follow)
                  {function get_arg(param)
                    {if(follow){var arg=follow[1];return arg}
                     if((current[1] + 1 | 0) < argv[1].length - 1)
                      {var _m8_=current[1] + 1 | 0;
                       return caml_check_bound(argv[1],_m8_)[_m8_ + 1]}
                     throw [0,Stop,[2,s]]}
                   return get_arg},
                get_arg=get_arg$0(s,follow$0),
                consume_arg$0=
                 function(follow)
                  {function consume_arg(param)
                    {return follow?0:(current[1]++,0)}
                   return consume_arg},
                consume_arg=consume_arg$0(follow$0),
                treat_action$0=
                 function(s,no_arg,get_arg,consume_arg)
                  {function treat_action(param)
                    {switch(param[0])
                      {case 0:var f=param[1];return caml_call1(f,0);
                       case 1:
                        var
                         f$0=param[1],
                         arg=get_arg(0),
                         match=bool_of_string_opt$0(arg);
                        if(match)
                         {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg,cst_a_boolean]];
                       case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                       case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                       case 4:
                        var f$1=param[1],arg$0=get_arg(0);
                        caml_call1(f$1,arg$0);
                        return consume_arg(0);
                       case 5:
                        var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                       case 6:
                        var
                         f$2=param[1],
                         arg$1=get_arg(0),
                         match$0=int_of_string_opt$0(arg$1);
                        if(match$0)
                         {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                       case 7:
                        var
                         r$2=param[1],
                         arg$2=get_arg(0),
                         match$1=int_of_string_opt$0(arg$2);
                        if(match$1)
                         {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                       case 8:
                        var
                         f$3=param[1],
                         arg$3=get_arg(0),
                         match$2=float_of_string_opt$0(arg$3);
                        if(match$2)
                         {var x$1=match$2[1];
                          caml_call1(f$3,x$1);
                          return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$3,cst_a_float]];
                       case 9:
                        var
                         r$3=param[1],
                         arg$4=get_arg(0),
                         match$3=float_of_string_opt$0(arg$4);
                        if(match$3)
                         {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                        throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                       case 10:var specs=param[1];return iter(treat_action,specs);
                       case 11:
                        var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                        if(mem(arg$5,symb))
                         {caml_call1(f$4,arg$5);return consume_arg(0)}
                        throw [0,
                               Stop,
                               [1,
                                s,
                                arg$5,
                                _g_(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                       case 12:
                        var f$5=param[1];
                        for(;;)
                         {if(current[1] < (argv[1].length - 1 - 1 | 0))
                           {var _m7_=current[1] + 1 | 0;
                            caml_call1(f$5,caml_check_bound(argv[1],_m7_)[_m7_ + 1]);
                            consume_arg(0);
                            continue}
                          return 0}
                       default:
                        var f$6=param[1];
                        if(1 - allow_expand)
                         throw [0,
                                Invalid_argument,
                                cst_Arg_Expand_is_is_only_allowed_with_Arg_parse_and_expand_argv_dynamic];
                        var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                        consume_arg(0);
                        var
                         before=sub$1(argv[1],0,current[1] + 1 | 0),
                         after=
                          sub$1
                           (argv[1],
                            current[1] + 1 | 0,
                            (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                        argv[1]
                        =
                        caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                        return 0}}
                   return treat_action},
                treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
               treat_action(action);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Bad){var m=exn[2];throw convert_error([3,m])}
            if(exn[1] === Stop){var e=exn[2];throw convert_error(e)}
            throw exn}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_aux
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_aux
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _m3_=parse_argv(0,_t_,l,f,msg);return _m3_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a$_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_ba_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _m2_=parse_argv_dynamic(0,_t_,l,f,msg);return _m2_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bb_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bc_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,_t_],
         spec=[0,l],
         current$0=[0,current[1]],
         _m1_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _m1_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bd_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_be_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_mZ_)
       {_mZ_ = caml_wrap_exception(_mZ_);
        if(_mZ_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_m0_)
           {_m0_ = caml_wrap_exception(_m0_);
            if(_m0_ === Not_found)return len;
            throw _m0_}
          return loop(n + 1 | 0)}
        throw _mZ_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$1
              (function(c)
                {if(9 === c)if(! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map
              (function(ksd)
                {var _mX_=ksd[2],_mY_=ksd[1];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _mX_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _mY_,
                             _mX_,
                             _g_(cst$59,_g_(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_mY_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_mY_,_mX_,_g_(prefix,_g_(spaces,suffix))]}
                   return [0,_mY_,_mX_,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$1(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s);
          if(0 < len)
           if(13 === caml_string_get(s,len - 1 | 0))
            var _mW_=sub$0(s,0,len - 1 | 0),switch$0=1;
           else
            var switch$0=0;
          else
           var switch$0=0;
          if(! switch$0)var _mW_=s;
          var word=_mW_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      function read(param)
       {try
         {var
           c=caml_ml_input_char(ic),
           _mU_=c === sep?(stash(0),read(0)):(add_char(buf,c),read(0));
          return _mU_}
        catch(_mV_)
         {_mV_ = caml_wrap_exception(_mV_);
          if(_mV_ === End_of_file)
           {var _mT_=0 < buf[2]?1:0;return _mT_?stash(0):_mT_}
          throw _mV_}}
      read(0);
      caml_ml_close_channel(ic);
      return of_list(rev(words[1]))}
    var _bf_=10,_bg_=1;
    function read_arg(_mS_){return read_aux(_bg_,_bf_,_mS_)}
    var _bh_=0,_bi_=0;
    function read_arg0(_mR_){return read_aux(_bi_,_bh_,_mR_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$2(function(s){return caml_call2(fprintf(oc,_bj_),s,sep)},args);
      return close_out(oc)}
    var _bk_=10;
    function write_arg(_mP_,_mQ_){return write_aux(_bk_,_mP_,_mQ_)}
    var _bl_=0;
    function write_arg0(_mN_,_mO_){return write_aux(_bl_,_mN_,_mO_)}
    var
     Arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(670,Arg,"Arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[i + 1];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bm_),f)
                :caml_obj_tag(f) === 253?string_of_float(f):cst$60
              :caml_call1(sprintf(_bn_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _mL_=other_fields(x,i + 1 | 0),_mM_=field(x,i);
      return caml_call2(sprintf(_bo_),_mM_,_mL_)}
    function fields(x)
     {var match=x.length - 1;
      if(2 < match >>> 0)
       {var _mI_=other_fields(x,2),_mJ_=field(x,1);
        return caml_call2(sprintf(_bp_),_mJ_,_mI_)}
      switch(match)
       {case 0:return cst$62;
        case 1:return cst$63;
        default:var _mK_=field(x,1);return caml_call1(sprintf(_bq_),_mK_)}}
    function to_string$3(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try {var _mG_=caml_call1(hd,x),_mF_=_mG_}catch(_mH_){var _mF_=0}
            if(_mF_){var s=_mF_[1];return s}
            var param$0=tl;
            continue}
          if(x === Out_of_memory)return cst_Out_of_memory;
          if(x === Stack_overflow)return cst_Stack_overflow;
          if(x[1] === Match_failure)
           {var match=x[2],char$0=match[3],line=match[2],file=match[1];
            return caml_call5
                    (sprintf(locfmt),
                     file,
                     line,
                     char$0,
                     char$0 + 5 | 0,
                     cst_Pattern_matching_failed)}
          if(x[1] === Assert_failure)
           {var
             match$0=x[2],
             char$1=match$0[3],
             line$0=match$0[2],
             file$0=match$0[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$0,
                     line$0,
                     char$1,
                     char$1 + 6 | 0,
                     cst_Assertion_failed)}
          if(x[1] === Undefined_recursive_module)
           {var
             match$1=x[2],
             char$2=match$1[3],
             line$1=match$1[2],
             file$1=match$1[1];
            return caml_call5
                    (sprintf(locfmt),
                     file$1,
                     line$1,
                     char$2,
                     char$2 + 6 | 0,
                     cst_Undefined_recursive_module)}
          if(0 === caml_obj_tag(x))
           {var constructor=x[1][1];return _g_(constructor,fields(x))}
          return x[1]}}
      return conv(printers[1])}
    function print(fct,arg)
     {try
       {var _mE_=caml_call1(fct,arg);return _mE_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _mD_=to_string$3(x);
        caml_call1(eprintf(_br_),_mD_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _mC_=caml_call1(fct,arg);return _mC_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _mB_=to_string$3(x);
        caml_call1(eprintf(_bs_),_mB_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos
                  ?cst_Raised_by_primitive_operation_at
                  :cst_Called_from}
      if(0 === slot[0])
       {var
         _mu_=slot[5],
         _mv_=slot[4],
         _mw_=slot[3],
         _mx_=slot[6]?cst_inlined:cst$64,
         _my_=slot[2],
         _mz_=info(slot[1]);
        return [0,caml_call6(sprintf(_bt_),_mz_,_my_,_mx_,_mw_,_mv_,_mu_)]}
      if(slot[1])return 0;
      var _mA_=info(0);
      return [0,caml_call1(sprintf(_bu_),_mA_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_ms_=a.length - 1 - 1 | 0,_mr_=0;
        if(! (_ms_ < 0))
         {var i=_mr_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bv_),str)}
            var _mt_=i + 1 | 0;
            if(_ms_ !== i){var i=_mt_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bw_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtrace(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$1(1024),_mp_=a.length - 1 - 1 | 0,_mo_=0;
        if(! (_mp_ < 0))
         {var i=_mo_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[i + 1]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bx_),str)}
            var _mq_=i + 1 | 0;
            if(_mp_ !== i){var i=_mq_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_cannot_print_stack_backtrace}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _mn_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[i + 1],
             _mm_=0 === param[0]?1:0;
            if(! _mm_){var i$0=i - 1 | 0,i=i$0;continue}
            var _mn_=_mm_}
          return _mn_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtrace(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    var uncaught_exception_handler=[0,0];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = [0,fn];return 0}
    function _by_(_ml_){return runtime.caml_raw_backtrace_next_slot(_ml_)}
    function _bz_(_mk_){return runtime.caml_convert_raw_backtrace_slot(_mk_)}
    function _bA_(_mj_,_mi_)
     {return runtime.caml_raw_backtrace_slot(_mj_,_mi_)}
    function _bB_(_mh_){return runtime.caml_raw_backtrace_length(_mh_)}
    var
     _bC_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       format_backtrace_slot];
    function _bD_(_mg_){return runtime.caml_get_current_callstack(_mg_)}
    function _bE_(_mf_){return caml_get_exception_raw_backtrace(_mf_)}
    function _bF_(_me_){return runtime.caml_backtrace_status(_me_)}
    var
     Printexc=
      [0,
       to_string$3,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_md_){return runtime.caml_record_backtrace(_md_)},
       _bF_,
       register_printer,
       _bE_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       _bD_,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bC_,
       _bB_,
       _bA_,
       _bz_,
       _by_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(675,Printexc,"Printexc");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_lY_=st[4];
      caml_call1(fprintf(c,_bG_),_lY_);
      var _lZ_=st[5];
      caml_call1(fprintf(c,_bH_),_lZ_);
      var _l0_=st[14];
      caml_call1(fprintf(c,_bI_),_l0_);
      fprintf(c,_bJ_);
      var
       _l1_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bK_),_l1_)),
       _l2_=st[1];
      caml_call2(fprintf(c,_bL_),l1,_l2_);
      var _l3_=st[2];
      caml_call2(fprintf(c,_bM_),l1,_l3_);
      var _l4_=st[3];
      caml_call2(fprintf(c,_bN_),l1,_l4_);
      fprintf(c,_bO_);
      var
       _l5_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bP_),_l5_)),
       _l6_=st[15];
      caml_call2(fprintf(c,_bQ_),l2,_l6_);
      var _l7_=st[6];
      caml_call2(fprintf(c,_bR_),l2,_l7_);
      var _l8_=st[8];
      caml_call2(fprintf(c,_bS_),l2,_l8_);
      var _l9_=st[10];
      caml_call2(fprintf(c,_bT_),l2,_l9_);
      var _l__=st[12];
      caml_call2(fprintf(c,_bU_),l2,_l__);
      var _l$_=st[13];
      caml_call2(fprintf(c,_bV_),l2,_l$_);
      fprintf(c,_bW_);
      var _ma_=st[9];
      caml_call1(fprintf(c,_bX_),_ma_);
      var _mb_=st[11];
      caml_call1(fprintf(c,_bY_),_mb_);
      var _mc_=st[7];
      return caml_call1(fprintf(c,_bZ_),_mc_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _b0_(_lX_){return runtime.caml_final_release(_lX_)}
    function _b1_(_lW_,_lV_)
     {return runtime.caml_final_register_called_without_value(_lW_,_lV_)}
    var
     Gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_lU_,_lT_){return runtime.caml_final_register(_lU_,_lT_)},
       _b1_,
       _b0_,
       create_alarm,
       delete_alarm];
    caml_register_global(676,Gc,"Gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(b)}
    function substring(str,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_string_length(str) - len | 0) < ofs))
         return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len){return substring(b,ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _lS_=10 <= n?87:48;return n + _lS_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _lR_=i + 1 | 0;
        if(15 !== i){var i=_lR_;continue}
        return result}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_lP_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _lP_ | 0));
        var _lQ_=i + 1 | 0;
        if(15 !== i){var i=_lQ_;continue}
        return result}}
    var
     Digest=
      [0,
       compare$2,
       equal$2,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(677,Digest,"Digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[i$0 + 1] = i$0;
        var _lO_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_lO_;continue}
        var accu=[0,cst_x$1],_lK_=54 + max(55,l) | 0,_lJ_=0;
        if(! (_lK_ < 0))
         {var i=_lJ_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[k + 1];
            accu[1] = string(_g_(accu[1],caml_new_string("" + x)));
            var
             _lL_=accu[1],
             _lF_=caml_string_get(_lL_,3) << 24,
             _lG_=caml_string_get(_lL_,2) << 16,
             _lH_=caml_string_get(_lL_,1) << 8,
             _lI_=((caml_string_get(_lL_,0) + _lH_ | 0) + _lG_ | 0) + _lF_ | 0,
             _lM_=(caml_check_bound(s[1],j)[j + 1] ^ _lI_) & 1073741823;
            caml_check_bound(s[1],j)[j + 1] = _lM_;
            var _lN_=i + 1 | 0;
            if(_lK_ !== i){var i=_lN_;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$1(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$1(caml_sys_random_seed(0))}
    function copy$4(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _lC_=s[2],
       curval=caml_check_bound(s[1],_lC_)[_lC_ + 1],
       _lD_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_lD_)[_lD_ + 1]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _lE_=s[2];
      caml_check_bound(s[1],_lE_)[_lE_ + 1] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound))
       if(0 < bound)
        for(;;)
         {var r=bits(s),v=caml_mod(r,bound);
          if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
          return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b3_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$1,bound),_b2_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824 + r2) / 1073741824 * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b4_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$3(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$4(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b5_=
      [0,
       make$1,
       make_self_init,
       copy$4,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Random=
      [0,
       init$3,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b5_,
       get_state,
       set_state];
    caml_register_global(678,Random,"Random");
    function hash$0(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function ongoing_traversal(h)
     {var _lA_=h.length - 1 < 4?1:0,_lB_=_lA_ || (h[4] < 0?1:0);return _lB_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cK_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cK_}
    catch(_ly_)
     {_ly_ = caml_wrap_exception(_ly_);
      if(_ly_ !== Not_found)throw _ly_;
      try
       {var _cJ_=caml_sys_getenv(cst_CAMLRUNPARAM),_b6_=_cJ_}
      catch(_lz_)
       {_lz_ = caml_wrap_exception(_lz_);
        if(_lz_ !== Not_found)throw _lz_;
        var _b6_=cst$65}
      var params=_b6_}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_lx_){return caml_call1(_b5_[2],0)}];
    function create$2(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x))
         if(! (max_array_length < (x * 2 | 0)))
          {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _lv_=caml_obj_tag(prng),
          _lw_=250 === _lv_?prng[1]:246 === _lv_?force_lazy_block(prng):prng,
          seed=caml_call1(_b5_[4],_lw_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {h[1] = 0;
      var len=h[2].length - 1,_lt_=len - 1 | 0,_ls_=0;
      if(! (_lt_ < 0))
       {var i=_ls_;
        for(;;)
         {caml_check_bound(h[2],i)[i + 1] = 0;
          var _lu_=i + 1 | 0;
          if(_lt_ !== i){var i=_lu_;continue}
          break}}
      return 0}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1)
       if(len !== abs(h[4]))
        {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b7_]}
          return prec$0}}
      return 0}
    function copy$5(init)
     {var _lp_=init[4],_lq_=init[3],_lr_=map$2(copy_bucketlist,init[2]);
      return [0,init[1],_lr_,_lq_,_lp_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _lg_=nsize < max_array_length?1:0;
      if(_lg_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _li_=osize - 1 | 0,_lh_=0;
        if(! (_li_ < 0))
         {var i$0=_lh_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[i$0 + 1],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[nidx + 1];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[nidx + 1] = cell$0;
                caml_check_bound(ndata_tail,nidx)[nidx + 1] = cell$0;
                var cell=next;
                continue}
              var _lo_=i$0 + 1 | 0;
              if(_li_ !== i$0){var i$0=_lo_;continue a}
              break}
            break}}
        if(inplace)
         {var _lk_=nsize - 1 | 0,_lj_=0;
          if(! (_lk_ < 0))
           {var i=_lj_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[i + 1];
              if(match$0)match$0[3] = 0;
              var _ln_=i + 1 | 0;
              if(_lk_ !== i){var i=_ln_;continue}
              break}}
          var _ll_=0}
        else
         var _ll_=inplace;
        var _lm_=_ll_}
      else
       var _lm_=_lg_;
      return _lm_}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
      caml_check_bound(h[2],i)[i + 1] = bucket;
      h[1] = h[1] + 1 | 0;
      var _lf_=h[2].length - 1 << 1 < h[1]?1:0;
      return _lf_?resize$0(key_index,h):_lf_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[i + 1],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :caml_check_bound(h[2],i)[i + 1] = next}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _le_=key_index(h,key),match=caml_check_bound(h[2],_le_)[_le_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _ld_=key_index(h,key),match=caml_check_bound(h[2],_ld_)[_ld_ + 1];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _lc_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_lc_)[_lc_ + 1])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[i + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _k$_=0}
        else
         var _k$_=1;
        if(_k$_)
         {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _la_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_la_)return resize$0(key_index,h);
          var _lb_=_la_}
        else
         var _lb_=_k$_;
        return _lb_}}
    function mem$1(h,key)
     {var
       _k__=key_index(h,key),
       param$0=caml_check_bound(h[2],_k__)[_k__ + 1],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_k9_=0 === caml_compare(k,key)?1:0;
          if(_k9_)return _k9_;
          var param=next;
          continue}
        return 0}}
    function iter$6(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_k5_=d.length - 1 - 1 | 0,_k4_=0;
        if(! (_k5_ < 0))
         {var i=_k4_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[i + 1]);
            var _k8_=i + 1 | 0;
            if(_k5_ !== i){var i=_k8_;continue}
            break}}
        var _k6_=1 - old_trav,_k7_=_k6_?flip_ongoing_traversal(h):_k6_;
        return _k7_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[i + 1] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0?(prec$0[3] = 0,0):caml_check_bound(h[2],i)[i + 1] = 0}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _k1_=d.length - 1 - 1 | 0,_k0_=0;
        if(! (_k1_ < 0))
         {var i=_k0_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[i + 1]);
            var _k3_=i + 1 | 0;
            if(_k1_ !== i){var i=_k3_;continue}
            break}}
        var _k2_=0;
        return _k2_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$1(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_kW_=d.length - 1 - 1 | 0,_kV_=0;
        if(! (_kW_ < 0))
         {var i=_kV_;
          for(;;)
           {var _kY_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[i + 1],_kY_);
            var _kZ_=i + 1 | 0;
            if(_kW_ !== i){var i=_kZ_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _kX_=accu[1];
        return _kX_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _kS_=h[2],
       _kT_=0,
       mbl=
        fold_left$0(function(m,b){return max(m,bucket_length(0,b))},_kT_,_kS_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _kU_=h[2];
      iter$2
       (function(b)
         {var l=bucket_length(0,b);
          return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
        _kU_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _kR_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _kR_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _kQ_=h[2].length - 1 << 1 < h[1]?1:0;
        return _kQ_?resize$0(key_index,h):_kQ_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[i + 1],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :caml_check_bound(h[2],i)[i + 1] = next}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _kP_=key_index(h,key),match=caml_check_bound(h[2],_kP_)[_kP_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _kO_=key_index(h,key),match=caml_check_bound(h[2],_kO_)[_kO_ + 1];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _kN_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_kN_)[_kN_ + 1])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[i + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _kK_=0}
          else
           var _kK_=1;
          if(_kK_)
           {caml_check_bound(h[2],i)[i + 1] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _kL_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_kL_)return resize$0(key_index,h);
            var _kM_=_kL_}
          else
           var _kM_=_kK_;
          return _kM_}}
      function mem(h,key)
       {var
         _kJ_=key_index(h,key),
         param$0=caml_check_bound(h[2],_kJ_)[_kJ_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_kI_=caml_call2(H[1],k,key);
            if(_kI_)return _kI_;
            var param=next;
            continue}
          return 0}}
      return [0,
              create$2,
              clear$2,
              reset$0,
              copy$5,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$6,
              filter_map_inplace,
              fold$1,
              length$4,
              stats]}
    function Make(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       _kH_=include[1];
      function create(sz){return caml_call2(_kH_,_b8_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats]}
    var
     Hashtbl=
      [0,
       create$2,
       clear$2,
       reset$0,
       copy$5,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$1,
       remove,
       replace,
       iter$6,
       filter_map_inplace,
       fold$1,
       length$4,
       randomize,
       is_randomized,
       stats,
       Make,
       MakeSeeded,
       hash$0,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(679,Hashtbl,"Hashtbl");
    function length$5(x){return x.length - 1 - 2 | 0}
    function fill$1(ar,ofs,len,x)
     {if(0 <= ofs)
       if(0 <= len)
        if(! (length$5(ar) < (ofs + len | 0)))
         {var _kF_=(ofs + len | 0) - 1 | 0;
          if(! (_kF_ < ofs))
           {var i=ofs;
            for(;;)
             {caml_weak_set(ar,i,x);
              var _kG_=i + 1 | 0;
              if(_kF_ !== i){var i=_kG_;continue}
              break}}
          return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$0(H)
     {var emptybucket=caml_weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _kD_=t[1].length - 1 - 1 | 0,_kC_=0;
        if(! (_kD_ < 0))
         {var i=_kC_;
          for(;;)
           {caml_check_bound(t[1],i)[i + 1] = emptybucket;
            caml_check_bound(t[2],i)[i + 1] = [0];
            var _kE_=i + 1 | 0;
            if(_kD_ !== i){var i=_kE_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _kB_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _kB_,
                 init)}
      function iter(f,t)
       {var _kA_=t[1],i=0;
        return iter$2
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=caml_weak_get(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _kA_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _kz_=caml_weak_check(b,i$0)?1:0,
           accu$1=accu$0 + _kz_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _ku_=0,_kv_=t[1],_kw_=0;
        return fold_right$0
                (function(_kx_,_ky_){return count_bucket(_kw_,_kx_,_ky_)},
                 _kv_,
                 _ku_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)
             failwith(cst_Weak_Make_hash_bucket_cannot_grow_more);
            var
             newbucket=caml_weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            caml_weak_blit(bucket$0,0,newbucket,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket,sz,d);
            caml_check_bound(newhashes,sz)[sz + 1] = h;
            caml_check_bound(t[1],index)[index + 1] = newbucket;
            caml_check_bound(t[2],index)[index + 1] = newhashes;
            var _kq_=sz <= t[3]?1:0,_kr_=_kq_?t[3] < newsz?1:0:_kq_;
            if(_kr_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _kj_=t[5],
                 bucket=caml_check_bound(t[1],_kj_)[_kj_ + 1],
                 _kk_=t[5],
                 hbucket=caml_check_bound(t[2],_kk_)[_kk_ + 1],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(caml_weak_check(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(caml_weak_check(bucket,j))
                       {caml_weak_blit(bucket,j,bucket,i$0,1);
                        var _kl_=caml_check_bound(hbucket,j)[j + 1];
                        caml_check_bound(hbucket,i$0)[i$0 + 1] = _kl_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _km_=t[5];
                      caml_check_bound(t[1],_km_)[_km_ + 1] = emptybucket;
                      var _kn_=t[5];
                      caml_check_bound(t[2],_kn_)[_kn_ + 1] = [0]}
                    else
                     {caml_obj_truncate(bucket,prev_len + 2 | 0);
                      caml_obj_truncate(hbucket,prev_len)}
                    var _ko_=t[3] < n?1:0,_kp_=_ko_?prev_len <= t[3]?1:0:_ko_;
                    if(_kp_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _kt_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_kt_;continue}
                break}}
            var _ks_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_ks_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_ki_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=caml_weak_check(ob,i$0);
                      if(0 === match){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      var
                       oh=caml_check_bound(t[2],j)[j + 1],
                       setter$0=
                        function(i)
                         {function setter(nb,ni,param)
                           {return caml_weak_blit(ob,i,nb,ni,1)}
                          return setter},
                       setter=setter$0(i$0),
                       h=caml_check_bound(oh,i$0)[i$0 + 1];
                      add_aux(newt,setter,0,h,get_index(newt,h));
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _ki_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _ks_}
          if(caml_weak_check(bucket$0,i$3))
           {var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          return caml_check_bound(hashes,i$3)[i$3 + 1] = h}}
      function add(t,d)
       {var h=caml_call1(H[2],d);
        return add_aux(t,caml_weak_set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,
                 d,
                 function(h,index)
                  {add_aux(t,caml_weak_set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=caml_weak_get(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _kh_=0;
        return find_shadow
                (t,d,function(w,i){return caml_weak_set(w,i,0)},_kh_)}
      function mem(t,d)
       {var _kg_=0;return find_shadow(t,d,function(w,i){return 1},_kg_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[index + 1],
         hashes=caml_check_bound(t[2],index)[index + 1],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[i + 1])
           {var match=caml_weak_get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=caml_weak_get(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$2(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _j__=0,
         totlen=
          fold_left$0(function(_kf_,_ke_){return _kf_ + _ke_ | 0},_j__,lens),
         _j$_=len - 1 | 0,
         _kb_=len / 2 | 0,
         _ka_=caml_check_bound(lens,_j$_)[_j$_ + 1],
         _kc_=caml_check_bound(lens,_kb_)[_kb_ + 1],
         _kd_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_kd_,_kc_,_ka_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Weak=
      [0,
       caml_weak_create,
       length$5,
       caml_weak_set,
       caml_weak_get,
       caml_weak_get_copy,
       caml_weak_check,
       fill$1,
       caml_weak_blit,
       Make$0];
    caml_register_global(680,Weak,"Weak");
    function add_queue(x,q)
     {var c=[0,x,0],_j9_=q[1];
      return _j9_?(q[1] = c,_j9_[2] = c,0):(q[1] = c,q[2] = c,0)}
    var Empty_queue=[248,cst_Format_Empty_queue,caml_fresh_oo_id(0)];
    function take_queue(q)
     {var _j8_=q[2];
      if(_j8_)
       {var x=_j8_[1],tl=_j8_[2];q[2] = tl;if(0 === tl)q[1] = 0;return x}
      throw Empty_queue}
    function pp_enqueue(state,token)
     {var len=token[3];
      state[13] = state[13] + len | 0;
      return add_queue(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function break_new_line(state,offset,width)
     {pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      return caml_call1(state[21],state[10])}
    function break_line(state,width){return break_new_line(state,0,width)}
    function break_same_line(state,width)
     {state[9] = state[9] - width | 0;return caml_call1(state[20],width)}
    function pp_force_break_line(state)
     {var _j5_=state[2];
      if(_j5_)
       {var
         match=_j5_[1],
         width=match[2],
         bl_ty=match[1],
         _j6_=state[9] < width?1:0;
        if(_j6_)
         {if(0 !== bl_ty)return 5 <= bl_ty?0:break_line(state,width);
          var _j7_=0}
        else
         var _j7_=_j6_;
        return _j7_}
      return pp_output_newline(state)}
    function pp_skip_token(state)
     {var match=take_queue(state[28]),size=match[1],len=match[3];
      state[12] = state[12] - len | 0;
      state[9] = state[9] + size | 0;
      return 0}
    function format_pp_token(state,size,param)
     {if(typeof param === "number")
       switch(param)
        {case 0:
          var _jU_=state[3];
          if(_jU_)
           {var
             match=_jU_[1],
             tabs=match[1],
             add_tab=
              function(n,ls)
               {if(ls)
                 {var l=ls[2],x=ls[1];
                  return runtime.caml_lessthan(n,x)
                          ?[0,n,ls]
                          :[0,x,add_tab(n,l)]}
                return [0,n,0]};
            tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1]);
            return 0}
          return 0;
         case 1:
          var _jV_=state[2];
          if(_jV_){var ls=_jV_[2];state[2] = ls;return 0}
          return 0;
         case 2:
          var _jW_=state[3];
          if(_jW_){var ls$0=_jW_[2];state[3] = ls$0;return 0}
          return 0;
         case 3:
          var _jX_=state[2];
          if(_jX_)
           {var match$0=_jX_[1],width=match$0[2];
            return break_line(state,width)}
          return pp_output_newline(state);
         case 4:
          var _jY_=state[10] !== (state[6] - state[9] | 0)?1:0;
          return _jY_?pp_skip_token(state):_jY_;
         default:
          var _jZ_=state[5];
          if(_jZ_)
           {var
             tags=_jZ_[2],
             tag_name=_jZ_[1],
             marker=caml_call1(state[25],tag_name);
            pp_output_string(state,marker);
            state[5] = tags;
            return 0}
          return 0}
      else
       switch(param[0])
        {case 0:
          var s=param[1];
          state[9] = state[9] - size | 0;
          pp_output_string(state,s);
          state[11] = 0;
          return 0;
         case 1:
          var off=param[2],n=param[1],_j0_=state[2];
          if(_j0_)
           {var match$1=_j0_[1],width$0=match$1[2],ty=match$1[1];
            switch(ty)
             {case 0:return break_same_line(state,n);
              case 1:return break_new_line(state,off,width$0);
              case 2:return break_new_line(state,off,width$0);
              case 3:
               return state[9] < size
                       ?break_new_line(state,off,width$0)
                       :break_same_line(state,n);
              case 4:
               return state[11]
                       ?break_same_line(state,n)
                       :state[9] < size
                         ?break_new_line(state,off,width$0)
                         :((state[6] - width$0 | 0) + off | 0) < state[10]
                           ?break_new_line(state,off,width$0)
                           :break_same_line(state,n);
              default:return break_same_line(state,n)}}
          return 0;
         case 2:
          var
           off$0=param[2],
           n$0=param[1],
           insertion_point=state[6] - state[9] | 0,
           _j1_=state[3];
          if(_j1_)
           {var
             match$2=_j1_[1],
             tabs$0=match$2[1],
             find=
              function(n,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var l=param$0[2],x=param$0[1];
                    if(caml_greaterequal(x,n))return x;
                    var param$0=l;
                    continue}
                  throw Not_found}},
             _j2_=tabs$0[1];
            if(_j2_)
             {var x=_j2_[1];
              try
               {var _j3_=find(insertion_point,tabs$0[1]),x$0=_j3_}
              catch(_j4_)
               {_j4_ = caml_wrap_exception(_j4_);
                if(_j4_ !== Not_found)throw _j4_;
                var x$0=x}
              var tab=x$0}
            else
             var tab=insertion_point;
            var offset=tab - insertion_point | 0;
            return 0 <= offset
                    ?break_same_line(state,offset + n$0 | 0)
                    :break_new_line(state,tab + off$0 | 0,state[6])}
          return 0;
         case 3:
          var
           ty$0=param[2],
           off$1=param[1],
           insertion_point$0=state[6] - state[9] | 0;
          if(state[8] < insertion_point$0)pp_force_break_line(state);
          var
           offset$0=state[9] - off$1 | 0,
           bl_type=1 === ty$0?1:state[9] < size?ty$0:5;
          state[2] = [0,[0,bl_type,offset$0],state[2]];
          return 0;
         case 4:var tbox=param[1];state[3] = [0,tbox,state[3]];return 0;
         default:
          var tag_name$0=param[1],marker$0=caml_call1(state[24],tag_name$0);
          pp_output_string(state,marker$0);
          state[5] = [0,tag_name$0,state[5]];
          return 0}}
    function advance_loop(state)
     {for(;;)
       {var _jQ_=state[28][2];
        if(_jQ_)
         {var
           x=_jQ_[1],
           size=x[1],
           len=x[3],
           tok=x[2],
           _jR_=size < 0?1:0,
           _jS_=_jR_?(state[13] - state[12] | 0) < state[9]?1:0:_jR_,
           _jT_=1 - _jS_;
          if(_jT_)
           {take_queue(state[28]);
            var size$0=0 <= size?size:pp_infinity;
            format_pp_token(state,size$0,tok);
            state[12] = len + state[12] | 0;
            continue}
          return _jT_}
        throw Empty_queue}}
    function advance_left(state)
     {try
       {var _jO_=advance_loop(state);return _jO_}
      catch(_jP_)
       {_jP_ = caml_wrap_exception(_jP_);
        if(_jP_ === Empty_queue)return 0;
        throw _jP_}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    var q_elem=[0,-1,_b9_,0],scan_stack_bottom=[0,[0,-1,q_elem],0];
    function clear_scan_stack(state){state[1] = scan_stack_bottom;return 0}
    function set_size(state,ty)
     {var _jK_=state[1];
      if(_jK_)
       {var
         match=_jK_[1],
         queue_elem=match[2],
         left_tot=match[1],
         size=queue_elem[1],
         t=_jK_[2],
         tok=queue_elem[2];
        if(left_tot < state[12])return clear_scan_stack(state);
        if(typeof tok !== "number")
         switch(tok[0])
          {case 3:
            var
             _jM_=1 - ty,
             _jN_=
              _jM_?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):_jM_;
            return _jN_;
           case 1:
           case 2:
            var
             _jL_=
              ty?(queue_elem[1] = state[13] + size | 0,state[1] = t,0):ty;
            return _jL_
           }
        return 0}
      return 0}
    function scan_push(state,b,tok)
     {pp_enqueue(state,tok);
      if(b)set_size(state,1);
      state[1] = [0,[0,state[13],tok],state[1]];
      return 0}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var elem=[0,- state[13] | 0,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _jI_=state[14] === state[15]?1:0;
      if(_jI_)
       {var _jJ_=state[16],len=caml_ml_string_length(_jJ_);
        return enqueue_string_as(state,len,_jJ_)}
      return _jI_}
    function pp_close_box(state,param)
     {var _jG_=1 < state[14]?1:0;
      if(_jG_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,0,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _jH_=0}
      else
       var _jH_=_jG_;
      return _jH_}
    function pp_open_tag(state,tag_name)
     {if(state[22])
       {state[4] = [0,tag_name,state[4]];caml_call1(state[26],tag_name)}
      var _jF_=state[23];
      return _jF_?pp_enqueue(state,[0,0,[5,tag_name],0]):_jF_}
    function pp_close_tag(state,param)
     {if(state[23])pp_enqueue(state,[0,0,5,0]);
      var _jC_=state[22];
      if(_jC_)
       {var _jD_=state[4];
        if(_jD_)
         {var tags=_jD_[2],tag_name=_jD_[1];
          caml_call1(state[27],tag_name);
          state[4] = tags;
          return 0}
        var _jE_=0}
      else
       var _jE_=_jC_;
      return _jE_}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_tag_functions(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      var _jB_=state[28];
      _jB_[1] = 0;
      _jB_[2] = 0;
      clear_scan_stack(state);
      state[2] = 0;
      state[3] = 0;
      state[4] = 0;
      state[5] = 0;
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _jA_=state[4];
      iter(function(param){return pp_close_tag(state,0)},_jA_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _jz_=state[14] < state[15]?1:0;
      return _jz_?enqueue_string_as(state,size,s):_jz_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_new_string("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,string_of_float(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _jy_=state[14] < state[15]?1:0;
      return _jy_?enqueue_advance(state,[0,0,3,0]):_jy_}
    function pp_print_if_newline(state,param)
     {var _jx_=state[14] < state[15]?1:0;
      return _jx_?enqueue_advance(state,[0,0,4,0]):_jx_}
    function pp_print_break(state,width,offset)
     {var _jw_=state[14] < state[15]?1:0;
      if(_jw_)
       {var elem=[0,- state[13] | 0,[1,width,offset],width];
        return scan_push(state,1,elem)}
      return _jw_}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _jv_=state[14] < state[15]?1:0;
      if(_jv_)
       {var elem=[0,0,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _jv_}
    function pp_close_tbox(state,param)
     {var _js_=1 < state[14]?1:0;
      if(_js_)
       {var _jt_=state[14] < state[15]?1:0;
        if(_jt_)
         {var elem=[0,0,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _ju_=0}
        else
         var _ju_=_jt_}
      else
       var _ju_=_js_;
      return _ju_}
    function pp_print_tbreak(state,width,offset)
     {var _jr_=state[14] < state[15]?1:0;
      if(_jr_)
       {var elem=[0,- state[13] | 0,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _jr_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _jq_=state[14] < state[15]?1:0;
      if(_jq_){var elem=[0,0,0,0];return enqueue_advance(state,elem)}
      return _jq_}
    function pp_set_max_boxes(state,n)
     {var _jo_=1 < n?1:0,_jp_=_jo_?(state[15] = n,0):_jo_;return _jp_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var n$1=state[6] - n$0 | 0,_jn_=1 <= n$1?1:0;
      if(_jn_)
       {var n=pp_limit(n$1);
        state[7] = n;
        state[8] = state[6] - state[7] | 0;
        return pp_rinit(state)}
      return _jn_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _jm_=1 <= n?1:0;
      if(_jm_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _jm_}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functions(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functions(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$66,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _jl_=0 < n$0?1:0;
        if(_jl_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _jl_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_ji_,_jj_,_jk_){return output_substring(oc,_ji_,_jj_,_jk_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_jh_){return display_newline(state,_jh_)};
      state[20] = function(_jg_){return display_indent(state,_jg_)};
      state[21] = function(_jf_){return display_indent(state,_jf_)};
      return 0}
    function default_pp_mark_open_tag(s){return _g_(cst$68,_g_(s,cst$67))}
    function default_pp_mark_close_tag(s){return _g_(cst$70,_g_(s,cst$69))}
    function default_pp_print_open_tag(_je_){return 0}
    function default_pp_print_close_tag(_jd_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=[0,0,0],sys_tok=[0,-1,_b__,0];
      add_queue(sys_tok,pp_queue);
      var sys_scan_stack=[0,[0,1,sys_tok],scan_stack_bottom];
      return [0,
              sys_scan_stack,
              0,
              0,
              0,
              0,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$71,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _i7_(_jc_){return 0}
      function _i8_(_jb_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_ja_){return 0},_i8_,_i7_);
      ppf[19] = function(_i$_){return display_newline(ppf,_i$_)};
      ppf[20] = function(_i__){return display_indent(ppf,_i__)};
      ppf[21] = function(_i9_){return display_indent(ppf,_i9_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _i3_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_i4_,_i5_,_i6_)
                {return output_substring(oc,_i4_,_i5_,_i6_)},
               _i3_)}
    function formatter_of_buffer(b)
     {function _iY_(_i2_){return 0}
      return make_formatter
              (function(_iZ_,_i0_,_i1_)
                {return add_substring(b,_iZ_,_i0_,_i1_)},
               _iY_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$1(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_buffer(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_iX_){return add_symbolic_output_item(sob,0)}
      function h(_iW_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_iV_){return pp_open_hbox(std_formatter,_iV_)}
    function open_vbox(_iU_){return pp_open_vbox(std_formatter,_iU_)}
    function open_hvbox(_iT_){return pp_open_hvbox(std_formatter,_iT_)}
    function open_hovbox(_iS_){return pp_open_hovbox(std_formatter,_iS_)}
    function open_box(_iR_){return pp_open_box(std_formatter,_iR_)}
    function close_box(_iQ_){return pp_close_box(std_formatter,_iQ_)}
    function open_tag(_iP_){return pp_open_tag(std_formatter,_iP_)}
    function close_tag(_iO_){return pp_close_tag(std_formatter,_iO_)}
    function print_as(_iM_,_iN_){return pp_print_as(std_formatter,_iM_,_iN_)}
    function print_string$0(_iL_){return pp_print_string(std_formatter,_iL_)}
    function print_int$0(_iK_){return pp_print_int(std_formatter,_iK_)}
    function print_float$0(_iJ_){return pp_print_float(std_formatter,_iJ_)}
    function print_char$0(_iI_){return pp_print_char(std_formatter,_iI_)}
    function print_bool(_iH_){return pp_print_bool(std_formatter,_iH_)}
    function print_break(_iF_,_iG_)
     {return pp_print_break(std_formatter,_iF_,_iG_)}
    function print_cut(_iE_){return pp_print_cut(std_formatter,_iE_)}
    function print_space(_iD_){return pp_print_space(std_formatter,_iD_)}
    function force_newline(_iC_){return pp_force_newline(std_formatter,_iC_)}
    function print_flush(_iB_){return pp_print_flush(std_formatter,_iB_)}
    function print_newline$0(_iA_)
     {return pp_print_newline(std_formatter,_iA_)}
    function print_if_newline(_iz_)
     {return pp_print_if_newline(std_formatter,_iz_)}
    function open_tbox(_iy_){return pp_open_tbox(std_formatter,_iy_)}
    function close_tbox(_ix_){return pp_close_tbox(std_formatter,_ix_)}
    function print_tbreak(_iv_,_iw_)
     {return pp_print_tbreak(std_formatter,_iv_,_iw_)}
    function set_tab(_iu_){return pp_set_tab(std_formatter,_iu_)}
    function print_tab(_it_){return pp_print_tab(std_formatter,_it_)}
    function set_margin(_is_){return pp_set_margin(std_formatter,_is_)}
    function get_margin(_ir_){return std_formatter[6]}
    function set_max_indent(_iq_)
     {return pp_set_max_indent(std_formatter,_iq_)}
    function get_max_indent(_ip_){return std_formatter[8]}
    function set_max_boxes(_io_){return pp_set_max_boxes(std_formatter,_io_)}
    function get_max_boxes(_in_){return std_formatter[15]}
    function over_max_boxes(_im_)
     {return pp_over_max_boxes(std_formatter,_im_)}
    function set_ellipsis_text(_il_)
     {return pp_set_ellipsis_text(std_formatter,_il_)}
    function get_ellipsis_text(_ik_){return std_formatter[16]}
    function set_formatter_out_channel(_ij_)
     {return pp_set_formatter_out_channel(std_formatter,_ij_)}
    function set_formatter_out_functions(_ii_)
     {return pp_set_formatter_out_functions(std_formatter,_ii_)}
    function get_formatter_out_functions(_ih_)
     {return pp_get_formatter_out_functions(std_formatter,_ih_)}
    function set_formatter_output_functions(_if_,_ig_)
     {return pp_set_formatter_output_functions(std_formatter,_if_,_ig_)}
    function get_formatter_output_functions(_ie_)
     {return pp_get_formatter_output_functions(std_formatter,_ie_)}
    function set_formatter_tag_functions(_id_)
     {return pp_set_formatter_tag_functions(std_formatter,_id_)}
    function get_formatter_tag_functions(_ic_)
     {return pp_get_formatter_tag_functions(std_formatter,_ic_)}
    function set_print_tags(_ib_)
     {return pp_set_print_tags(std_formatter,_ib_)}
    function get_print_tags(_ia_){return std_formatter[22]}
    function set_mark_tags(_h$_){return pp_set_mark_tags(std_formatter,_h$_)}
    function get_mark_tags(_h__){return std_formatter[23]}
    function set_tags(_h9_){return pp_set_tags(std_formatter,_h9_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _h7_=param$0[2],_h8_=param$0[1];
          if(_h7_)
           {caml_call2(pp_v,ppf,_h8_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=_h7_;
            continue}
          return caml_call2(pp_v,ppf,_h8_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _h6_=left[1] !== len?1:0;
        return _h6_?flush(0):_h6_}}
    function compute_tag(output,tag_acc)
     {var buf=create$1(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$2(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hW_=acc[2],_hX_=acc[1];
          if(0 === _hW_[0])
           {var acc$0=_hW_[1];
            output_acc$0(ppf,_hX_);
            return pp_open_tag(ppf,compute_tag(output_acc$0,acc$0))}
          var acc$1=_hW_[1];
          output_acc$0(ppf,_hX_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hY_=acc[1];
          if(typeof _hY_ === "number")
           var switch$1=1;
          else
           if(0 === _hY_[0])
            {var _hZ_=_hY_[2];
             if(typeof _hZ_ === "number")
              var switch$2=1;
             else
              if(1 === _hZ_[0])
               var
                s$0=acc[2],
                size=_hZ_[2],
                p$1=_hY_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hY_,switch$0=2;
          break;
         case 3:
          var _h0_=acc[1];
          if(typeof _h0_ === "number")
           var switch$3=1;
          else
           if(0 === _h0_[0])
            {var _h1_=_h0_[2];
             if(typeof _h1_ === "number")
              var switch$4=1;
             else
              if(1 === _h1_[0])
               var
                c$0=acc[2],
                size$0=_h1_[2],
                p$3=_h0_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_h0_,switch$0=3;
          break;
         case 4:
          var _h2_=acc[1];
          if(typeof _h2_ === "number")
           var switch$5=1;
          else
           if(0 === _h2_[0])
            {var _h3_=_h2_[2];
             if(typeof _h3_ === "number")
              var switch$6=1;
             else
              if(1 === _h3_[0])
               var
                s$0=acc[2],
                size=_h3_[2],
                p$1=_h2_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_h2_,switch$0=2;
          break;
         case 5:
          var _h4_=acc[1];
          if(typeof _h4_ === "number")
           var switch$7=1;
          else
           if(0 === _h4_[0])
            {var _h5_=_h4_[2];
             if(typeof _h5_ === "number")
              var switch$8=1;
             else
              if(1 === _h5_[0])
               var
                c$0=acc[2],
                size$0=_h5_[2],
                p$3=_h4_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_h4_,switch$0=3;
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _hK_=acc[2],_hL_=acc[1];
          if(0 === _hK_[0])
           {var acc$0=_hK_[1];
            strput_acc$0(ppf,_hL_);
            return pp_open_tag(ppf,compute_tag(strput_acc$0,acc$0))}
          var acc$1=_hK_[1];
          strput_acc$0(ppf,_hL_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _hM_=acc[1];
          if(typeof _hM_ === "number")
           var switch$1=1;
          else
           if(0 === _hM_[0])
            {var _hN_=_hM_[2];
             if(typeof _hN_ === "number")
              var switch$2=1;
             else
              if(1 === _hN_[0])
               var
                s$0=acc[2],
                size=_hN_[2],
                p$1=_hM_[1],
                switch$0=0,
                switch$1=0,
                switch$2=0;
              else
               var switch$2=1;
             if(switch$2)var switch$1=1}
           else
            var switch$1=1;
          if(switch$1)var s=acc[2],p$0=_hM_,switch$0=2;
          break;
         case 3:
          var _hO_=acc[1];
          if(typeof _hO_ === "number")
           var switch$3=1;
          else
           if(0 === _hO_[0])
            {var _hP_=_hO_[2];
             if(typeof _hP_ === "number")
              var switch$4=1;
             else
              if(1 === _hP_[0])
               var
                c$0=acc[2],
                size$0=_hP_[2],
                p$3=_hO_[1],
                switch$0=1,
                switch$3=0,
                switch$4=0;
              else
               var switch$4=1;
             if(switch$4)var switch$3=1}
           else
            var switch$3=1;
          if(switch$3)var c=acc[2],p$2=_hO_,switch$0=3;
          break;
         case 4:
          var _hQ_=acc[1];
          if(typeof _hQ_ === "number")
           var switch$5=1;
          else
           if(0 === _hQ_[0])
            {var _hR_=_hQ_[2];
             if(typeof _hR_ === "number")
              var switch$6=1;
             else
              if(1 === _hR_[0])
               var
                s$0=acc[2],
                size=_hR_[2],
                p$1=_hQ_[1],
                switch$0=0,
                switch$5=0,
                switch$6=0;
              else
               var switch$6=1;
             if(switch$6)var switch$5=1}
           else
            var switch$5=1;
          if(switch$5)var s=acc[2],p$0=_hQ_,switch$0=2;
          break;
         case 5:
          var _hS_=acc[1];
          if(typeof _hS_ === "number")
           var switch$7=1;
          else
           if(0 === _hS_[0])
            {var _hT_=_hS_[2];
             if(typeof _hT_ === "number")
              var switch$8=1;
             else
              if(1 === _hT_[0])
               var
                c$0=acc[2],
                size$0=_hT_[2],
                p$3=_hS_[1],
                switch$0=1,
                switch$7=0,
                switch$8=0;
              else
               var switch$8=1;
             if(switch$8)var switch$7=1}
           else
            var switch$7=1;
          if(switch$7)var c=acc[2],p$2=_hS_,switch$0=3;
          break;
         case 6:
          var _hU_=acc[1];
          if(typeof _hU_ !== "number" && 0 === _hU_[0])
           {var _hV_=_hU_[2];
            if(typeof _hV_ !== "number" && 1 === _hV_[0])
             {var f$1=acc[2],size$1=_hV_[2],p$4=_hU_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_hU_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_hJ_=0;
      return make_printf
              (function(ppf,acc)
                {output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               ppf,
               _hJ_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function fprintf$0(ppf)
     {function _hG_(_hI_){return 0}
      return function(_hH_){return kfprintf$0(_hG_,ppf,_hH_)}}
    function ifprintf$0(ppf)
     {function _hD_(_hF_){return 0}
      return function(_hE_){return ikfprintf$0(_hD_,ppf,_hE_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function ksprintf$0(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(param,acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,0,fmt)}
    function sprintf$0(fmt){return ksprintf$0(function(s){return s},fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(ppf,acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,ppf,0,fmt)}
    function asprintf(fmt){return kasprintf(function(s){return s},fmt)}
    at_exit(print_flush);
    function pp_set_all_formatter_output_functions(state,f,g,h,i)
     {pp_set_formatter_output_functions(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_functions(_hz_,_hA_,_hB_,_hC_)
     {return pp_set_all_formatter_output_functions
              (std_formatter,_hz_,_hA_,_hB_,_hC_)}
    function get_all_formatter_output_functions(_hy_)
     {return pp_get_all_formatter_output_functions(std_formatter,_hy_)}
    function bprintf$0(b,param)
     {var fmt=param[1];
      function k(ppf,acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,formatter_of_buffer(b),0,fmt)}
    var
     Format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       ifprintf$0,
       kfprintf$0,
       ikfprintf$0,
       ksprintf$0,
       kasprintf,
       bprintf$0,
       ksprintf$0,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions];
    caml_register_global(681,Format,"Format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_hx_)
       {_hx_ = caml_wrap_exception(_hx_);
        if(_hx_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _hx_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _hw_=ib[9];
      if(typeof _hw_ === "number")
       return 0 === _hw_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _hw_[0])return cst_unnamed_Pervasives_input_channel;
        var fname=_hw_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$3(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$1(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$3(1,next)}
    var _b$_=0;
    function from_function$0(_hv_){return create$3(_b$_,_hv_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$3(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$72,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$73))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_hu_){return open_in_file(open_in,_hu_)}
    function from_file_bin(_ht_){return open_in_file(open_in_bin,_ht_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in(ib)
     {var _hs_=ib[9];
      if(typeof _hs_ === "number")
       return 0;
      else
       {if(0 === _hs_[0]){var ic=_hs_[1];return caml_ml_close_channel(ic)}
        var ic$0=_hs_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _hq_=assq(ic,memo[1]);return _hq_}
      catch(_hr_)
       {_hr_ = caml_wrap_exception(_hr_);
        if(_hr_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _hr_}}
    function memo_from_channel(_hp_)
     {return memo_from_ic(scan_raise_at_end,_hp_)}
    var Scan_failure=[248,cst_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ca_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cb_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_found_in_float_token)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexadecimal_notation)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cd_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_hn_=1 - ib[1];
         if(_hn_)
          {var
            _ho_=c - 9 | 0,
            switch$0=
             4 < _ho_ >>> 0?23 === _ho_?1:0:1 < (_ho_ - 2 | 0) >>> 0?1:0;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _hn_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$2)
              ?caml_string_notequal(s,cst_true$2)
                ?bad_input(caml_call1(sprintf(_ce_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cf_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=_g_(cst_0b,token_string(ib));break;
        case 3:var tok=_g_(cst_0o,token_string(ib));break;
        case 4:var tok=_g_(cst_0u,token_string(ib));break;
        case 5:var tok=_g_(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l)
       if(43 === caml_string_get(tok,0))return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_cg_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_ch_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_hl_,_hm_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_hl_,_hm_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_hj_,_hk_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_hj_,_hk_)}
    function is_hexa_digit(param)
     {var
       _hi_=param - 48 | 0,
       switch$0=
        22 < _hi_ >>> 0
         ?5 < (_hi_ - 49 | 0) >>> 0?0:1
         :6 < (_hi_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function scan_hexadecimal_int(_hg_,_hh_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_hg_,_hh_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal_int(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal_int(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             var switch$0=120 === c$0?1:0}
           else
            if(88 === c$0)
             var switch$0=1;
            else
             {if(98 <= c$0)
               return scan_binary_int(store_char(width,ib,c$0),ib);
              var switch$0=0}
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c)if(101 !== c)return width;
      return scan_optionally_signed_decimal_int(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _hd_=len - 1 | 0,
       _hc_=0;
      if(! (_hd_ < 0))
       {var i=_hc_;
        for(;;)
         {var c=peek_char(ib),_he_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _he_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _hf_=i + 1 | 0;
          if(_hd_ !== i){var i=_hf_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _g1_=0 === width?1:0,_g2_=_g1_ || end_of_input(ib);
      if(_g2_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _g3_=0 === width$0?1:0,
       _g4_=_g3_ || end_of_input(ib);
      if(_g4_)bad_hex_float(0);
      var c=peek_char(ib);
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _g5_=0 === width$1?1:0,
             _g6_=_g5_ || end_of_input(ib);
            if(_g6_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}
          var switch$0=0}
        else
         var switch$0=26 === switcher?1:0}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _g9_=0 === width$3?1:0,
           _g__=_g9_ || end_of_input(ib);
          if(_g__)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4)
           if(! end_of_input(ib))
            {var
              match=peek_char(ib),
              _g$_=match - 46 | 0,
              switch$1=
               34 < _g$_ >>> 0?66 === _g$_?1:0:32 < (_g$_ - 1 | 0) >>> 0?1:0,
              width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
             if(0 !== width$5)
              if(! end_of_input(ib))
               {var c$0=peek_char(ib);
                if(46 === c$0)
                 {var width$6=store_char(width$5,ib,c$0);
                  if(0 === width$6)
                   var switch$2=0;
                  else
                   if(end_of_input(ib))
                    var switch$2=0;
                   else
                    {var match$0=peek_char(ib);
                     if(80 === match$0)
                      var switch$3=0;
                     else
                      if(112 === match$0)
                       var switch$3=0;
                      else
                       var
                        precision$0=min(width$6,precision),
                        width$10=
                         width$6
                         -
                         (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                         |
                         0,
                        switch$3=1;
                     if(! switch$3)var width$10=width$6;
                     var width$7=width$10,switch$2=1}
                  if(! switch$2)var width$7=width$6;
                  var width$8=width$7}
                else
                 var width$8=width$5;
                if(0 !== width$8)
                 if(! end_of_input(ib))
                  {var c$1=peek_char(ib);
                   if(80 !== c$1)if(112 !== c$1)return width$8;
                   var
                    width$9=store_char(width$8,ib,c$1),
                    _ha_=0 === width$9?1:0,
                    _hb_=_ha_ || end_of_input(ib);
                   if(_hb_)bad_hex_float(0);
                   return scan_optionally_signed_decimal_int(width$9,ib)}
                return width$8}
             return width$5}
          return width$4}
        var switch$0=73 === c?1:0}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _g7_=0 === width$2?1:0,
         _g8_=_g7_ || end_of_input(ib);
        if(_g8_)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _gX_=0 === width?1:0,_gY_=_gX_ || end_of_input(ib);
      if(_gY_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _gZ_=0 === width$0?1:0,
       _g0_=_gZ_ || end_of_input(ib);
      if(_g0_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _gJ_=0 === width?1:0,_gK_=_gJ_ || end_of_input(ib);
      if(_gK_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _gL_=0 === width$0?1:0,
       _gM_=_gL_ || end_of_input(ib);
      if(_gM_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _gN_=0 === width$1?1:0,
           _gO_=_gN_ || end_of_input(ib);
          if(_gO_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _gP_=0 === width$2?1:0,
          _gQ_=_gP_ || end_of_input(ib);
         if(_gQ_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0)
          if(120 !== c$0)return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _gR_=0 === width$3?1:0,
          _gS_=_gR_ || end_of_input(ib);
         if(_gS_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _gT_=0 === width$4?1:0,
          _gU_=_gT_ || end_of_input(ib);
         if(_gU_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1);
            if(0 === width$5)
             var switch$1=0;
            else
             if(end_of_input(ib))
              var switch$1=0;
             else
              {var match=peek_char(ib);
               if(80 === match)
                var switch$2=0;
               else
                if(112 === match)
                 var switch$2=0;
                else
                 var
                  precision$0=min(width$5,precision),
                  width$10=
                   width$5
                   -
                   (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                   |
                   0,
                  switch$2=1;
               if(! switch$2)var width$10=width$5;
               var width$6=width$10,switch$1=1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6,switch$0=0}
          else
           var switch$0=1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)
            var width$7=width$4,switch$0=0;
           else
            var switch$0=1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8)
          if(! end_of_input(ib))
           {var c$2=peek_char(ib);
            if(80 !== c$2)if(112 !== c$2)return width$8;
            var
             width$9=store_char(width$8,ib,c$2),
             _gV_=0 === width$9?1:0,
             _gW_=_gV_ || end_of_input(ib);
            if(_gW_)bad_hex_float(0);
            return scan_optionally_signed_decimal_int(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var
         _gI_=c - 9 | 0,
         switch$0=4 < _gI_ >>> 0?23 === _gI_?1:0:1 < (_gI_ - 2 | 0) >>> 0?1:0;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_cc_),message)):c}
    function check_next_char_for_char(_gG_,_gH_)
     {return check_next_char(cst_a_Char,_gG_,_gH_)}
    function check_next_char_for_string(_gE_,_gF_)
     {return check_next_char(cst_a_String,_gE_,_gF_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib);
      if(40 <= c0)
       if(58 <= c0)
        {var switcher$0=c0 - 92 | 0;
         if(28 < switcher$0 >>> 0)
          var switch$0=0;
         else
          switch(switcher$0)
           {case 28:
             var
              get_digit=
               function(param)
                {var
                  c=next_char(ib),
                  _gD_=c - 48 | 0,
                  switch$0=
                   22 < _gD_ >>> 0
                    ?5 < (_gD_ - 49 | 0) >>> 0?0:1
                    :6 < (_gD_ - 10 | 0) >>> 0?1:0;
                 return switch$0?c:bad_input_escape(c)},
              c1=get_digit(0),
              c2=get_digit(0),
              _gz_=hexadecimal_value_of_char(c2),
              c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _gz_ | 0;
             if(0 <= c$0)
              if(255 < c$0)
               var switch$1=0;
              else
               var _gB_=char_of_int(c$0),switch$1=1;
             else
              var switch$1=0;
             if(! switch$1)
              var _gB_=bad_input(caml_call2(sprintf(_cj_),c1,c2));
             return store_char(width - 2 | 0,ib,_gB_);
            case 0:
            case 6:
            case 18:
            case 22:
            case 24:var switch$0=1;break;
            default:var switch$0=0}}
       else
        {if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0;
           if(0 <= c)
            if(255 < c)var switch$2=0;else var _gC_=char_of_int(c),switch$2=1;
           else
            var switch$2=0;
           if(! switch$2)
            var _gC_=bad_input(caml_call3(sprintf(_ci_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_gC_)}
         var switch$0=0}
      else
       var switch$0=34 === c0?1:39 <= c0?1:0;
      if(switch$0)
       {if(110 <= c0)
         if(117 <= c0)
          var switch$3=0;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _gA_=10,switch$3=1;break;
             case 4:var _gA_=13,switch$3=1;break;
             case 6:var _gA_=9,switch$3=1;break;
             default:var switch$3=0}}
        else
         if(98 === c0)var _gA_=8,switch$3=1;else var switch$3=0;
        if(! switch$3)var _gA_=c0;
        return store_char(width,ib,_gA_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _gx_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_gx_)}
              return caml_trampoline_return(skip_spaces,[0,_gx_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _gy_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_gy_)}
                return caml_trampoline_return(skip_spaces,[0,_gy_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_gt_=0 < i$0?1:0;
          if(_gt_)
           {var _gu_=1 - ib[1];
            if(_gu_)
             var _gv_=is_in_char_set(char_set,c),_gw_=_gv_?c !== stp?1:0:_gv_;
            else
             var _gw_=_gu_}
          else
           var _gw_=_gt_;
          if(_gw_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _gw_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _gs_=1 - ib[1];
        if(_gs_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _gs_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_cl_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cm_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_gq_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_gq_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_gq_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _gr_=fmt$0[1];
           if(0 === _gr_[0])
            {var
              rest$0=fmt$0[2],
              match=_gr_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_gr_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(0 === prec)
           {caml_call3(scan,max_int,max_int,ib);
            var x=caml_call1(token,ib);
            return [0,x,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion)}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(0 === pad[1])return invalid_arg(cst_scanf_bad_conversion$0);
          var _gp_=pad[2];
          if(typeof prec === "number")
           {if(0 === prec)
             {caml_call3(scan,_gp_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            return invalid_arg(cst_scanf_bad_conversion$1)}
          var p$0=prec[1];
          caml_call3(scan,_gp_,p$0,ib);
          var x$2=caml_call1(token,ib);
          return [0,x$2,make_scanf(ib,fmt,readers)]}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _ga_=fmt$0[2],_gb_=fmt$0[1];
           if(typeof _ga_ !== "number")
            switch(_ga_[0])
             {case 17:
               var
                rest$1=_ga_[2],
                fmting_lit=_ga_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$1];
               return pad_prec_scanf
                       (ib,str_rest,readers,_gb_,0,scan$0,token_string);
              case 18:
               var _gc_=_ga_[1];
               if(0 === _gc_[0])
                {var
                  rest$2=_ga_[2],
                  match$0=_gc_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cn_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$2),
                          readers,
                          _gb_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$3=_ga_[2],
                match$1=_gc_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_co_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$3),
                        readers,
                        _gb_,
                        0,
                        scan$2,
                        token_string)
              }
           var scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,_ga_,readers,_gb_,0,scan,token_string);
          case 3:
           var
            rest$4=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$4,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$5=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$5,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$6=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$7=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$8=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           var _gd_=fmt$0[1];
           if(15 === _gd_)
            {var rest$9=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$9,readers,pad$4,prec$3,scan_caml_float,token_float)}
           if(16 <= _gd_)
            {var rest$10=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
             return pad_prec_scanf
                     (ib,rest$10,readers,pad$5,prec$4,scan_hex_float,token_float)}
           var rest$11=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
           return pad_prec_scanf
                   (ib,rest$11,readers,pad$6,prec$5,scan_float,token_float);
          case 9:
           var
            rest$12=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_go_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_ck_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$12,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$13=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$13;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$14=fmt$0[2],str$0=fmt$0[1];
           iter$1(function(_gn_){return check_char(ib,_gn_)},str$0);
           var fmt$0=rest$14;
           continue;
          case 12:
           var rest$15=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$15;
           continue;
          case 13:
           var rest$16=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _ge_=format_of_string_fmtty(s,fmtty),fmt$3=_ge_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$16,readers)];
          case 14:
           var rest$17=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _gg_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=_gg_,
              fmt$4=fmt$8}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _gf_=bad_input(msg$0),
              fmt$5=_gf_[1],
              fmt$4=_gf_[2]}
           return [0,
                   [0,fmt$5,s$0],
                   make_scanf(ib,concat_fmt(fmt$4,rest$17),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$18=fmt$0[2],
            formatting_lit=fmt$0[1],
            _gh_=string_of_formatting_lit(formatting_lit);
           iter$1(function(_gm_){return check_char(ib,_gm_)},_gh_);
           var fmt$0=rest$18;
           continue;
          case 18:
           var _gi_=fmt$0[1];
           if(0 === _gi_[0])
            {var rest$19=fmt$0[2],match$4=_gi_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$19),fmt$0=fmt$10;
             continue}
           var rest$20=fmt$0[2],match$5=_gi_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$20),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _gj_=fmt$0[3],_gk_=fmt$0[2],_gl_=fmt$0[1];
           if(typeof _gj_ !== "number" && 17 === _gj_[0])
            {var
              rest$21=_gj_[2],
              fmting_lit$0=_gj_[1],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_gl_);
             scan_chars_in_char_set(_gk_,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$21];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var width=width_of_pad_opt(_gl_);
           scan_chars_in_char_set(_gk_,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,_gj_,readers)];
          case 21:
           var
            rest$22=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$22,readers)];
          case 22:
           var rest$23=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$23,readers)];
          case 23:
           var
            rest$24=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$24),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cp_];
          default:
           return invalid_arg(cst_scanf_bad_conversion_custom_converter)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _f$_=[0,make_scanf(ib,fmt,readers)],_f__=_f$_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          if(exc[1] === Scan_failure)
           var switch$0=0;
          else
           if(exc[1] === Failure)
            var switch$0=0;
           else
            if(exc === End_of_file)
             var switch$0=0;
            else
             {if(exc[1] !== Invalid_argument)throw exc;
              var
               msg=exc[2],
               _f9_=
                invalid_arg
                 (_g_(msg,_g_(cst_in_format,_g_(escaped$1(str),cst$74)))),
               switch$0=1}
          if(! switch$0)var _f9_=[1,exc];
          var _f__=_f9_}
        if(0 === _f__[0]){var args=_f__[1];return apply(f,args)}
        var exc=_f__[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _f8_=format_of_string_format(str,format),fmt=_f8_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {var l=caml_ml_string_length(s);
      function _f7_(x){return x}
      var b=create$1(l + 2 | 0);
      add_char(b,34);
      var _f5_=l - 1 | 0,_f4_=0;
      if(! (_f5_ < 0))
       {var i=_f4_;
        for(;;)
         {var c=caml_string_get(s,i);
          if(34 === c)add_char(b,92);
          add_char(b,c);
          var _f6_=i + 1 | 0;
          if(_f5_ !== i){var i=_f6_;continue}
          break}}
      add_char(b,34);
      return sscanf_format(contents(b),fmt,_f7_)}
    function unescaped(s)
     {function _f3_(x){return x}
      return caml_call1(sscanf(_g_(cst$76,_g_(s,cst$75)),_cq_),_f3_)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(682,Scanf,"Scanf");
    var register=caml_register_named_value;
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Callback=[0,register,register_exception];
    caml_register_global(683,Callback,"Callback");
    function copy$6(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_f0_=caml_ml_string_length(s) - 1 | 0,_fZ_=0;
      if(! (_f0_ < 0))
       {var i=_fZ_;
        for(;;)
         {var _f1_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _f1_ | 0;
          var _f2_=i + 1 | 0;
          if(_f0_ !== i){var i=_f2_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    var
     compare$6=caml_string_compare,
     Vars=caml_call1(Map[1],[0,compare$6]),
     compare$7=caml_string_compare,
     Meths=caml_call1(Map[1],[0,compare$7]),
     compare$8=caml_int_compare,
     Labs=caml_call1(Map[1],[0,compare$8]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _fT_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _fT_;
      var _fV_=len - 1 | 0,_fU_=0;
      if(! (_fV_ < 0))
       {var i=_fU_;
        for(;;)
         {var
           _fX_=(i * 2 | 0) + 3 | 0,
           _fW_=caml_check_bound(pub_labels,i)[i + 1];
          caml_check_bound(methods,_fX_)[_fX_ + 1] = _fW_;
          var _fY_=i + 1 | 0;
          if(_fV_ !== i){var i=_fY_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_fR_=old_size < new_size?1:0;
      if(_fR_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _fS_=0}
      else
       var _fS_=_fR_;
      return _fS_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _fP_=caml_call2(Meths[27],name,table[3]);return _fP_}
      catch(_fQ_)
       {_fQ_ = caml_wrap_exception(_fQ_);
        if(_fQ_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _fQ_}}
    function get_method_labels(table,names)
     {return map$2(function(_fO_){return get_method_label(table,_fO_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[27],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[label + 1]
                =
                element)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _fM_=assoc(label,table[6]);return _fM_}
      catch(_fN_)
       {_fN_ = caml_wrap_exception(_fN_);
        if(_fN_ === Not_found)
         return caml_check_bound(table[2],label)[label + 1];
        throw _fN_}}
    function to_list$0(arr){return arr === 0?0:to_list(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$0(vars),
       virt_meths$0=to_list$0(virt_meths),
       concr_meths$0=to_list$0(concr_meths),
       virt_meth_labs=
        map(function(_fL_){return get_method_label(table,_fL_)},virt_meths$0),
       concr_meth_labs=
        map(function(_fK_){return get_method_label(table,_fK_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _fB_=Vars[1],_fC_=table[7];
      function _fD_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_fD_,_fC_,_fB_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _fG_=by_label[1];
          try
           {var _fI_=caml_call2(Labs[27],label,table[4]),_fH_=_fI_}
          catch(_fJ_)
           {_fJ_ = caml_wrap_exception(_fJ_);
            if(_fJ_ !== Not_found)throw _fJ_;
            var _fH_=1}
          by_label[1] = caml_call3(Labs[4],label,_fH_,_fG_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _fE_=0,_fF_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _fF_,
        _fE_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left
       (function(s,v)
         {var _fA_=caml_call2(Vars[27],v,table[7]);
          return caml_call3(Vars[4],v,_fA_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _fz_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _fz_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _fx_=caml_call2(Vars[27],name,table[7]);return _fx_}
      catch(_fy_)
       {_fy_ = caml_wrap_exception(_fy_);
        if(_fy_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$77))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _fy_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _fp_=nmeths - 1 | 0,
       _fo_=0;
      if(! (_fp_ < 0))
       {var i$0=_fo_;
        for(;;)
         {var
           _fv_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[i$0 + 1]);
          caml_check_bound(res,i$0)[i$0 + 1] = _fv_;
          var _fw_=i$0 + 1 | 0;
          if(_fp_ !== i$0){var i$0=_fw_;continue}
          break}}
      var _fr_=nvals - 1 | 0,_fq_=0;
      if(! (_fr_ < 0))
       {var i=_fq_;
        for(;;)
         {var
           _ft_=i + nmeths | 0,
           _fs_=new_variable(table,caml_check_bound(vals,i)[i + 1]);
          caml_check_bound(res,_ft_)[_ft_ + 1] = _fs_;
          var _fu_=i + 1 | 0;
          if(_fr_ !== i){var i=_fu_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _fm_=caml_call2(Vars[27],name,table[7]);return _fm_}
      catch(_fn_)
       {_fn_ = caml_wrap_exception(_fn_);
        if(_fn_ === Not_found)throw [0,Assert_failure,_cr_];
        throw _fn_}}
    function get_variables(table,names)
     {return map$2(function(_fl_){return get_variable(table,_fl_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(public_methods === 0)return new_table([0]);
      var
       tags=map$2(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _fg_=0,
       _fh_=to_array(concr_meths),
       _fi_=
        [0,
         map$2
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_fh_),
         _fg_],
       _fj_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$2(function(_fk_){return get_variable(cla,_fk_)},_fj_),
                 _fi_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_ff_=0 !== inits?1:0;
      return _ff_?iter_f(obj,inits):_ff_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initializers(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cv_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_fb_=0;
      if(! (n < 0))
       {var i=_fb_;
        for(;;)
         {var _fd_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[i + 1],_fd_,0];
          var _fe_=i + 1 | 0;
          if(n !== i){var i=_fe_;continue}
          break}}
      var _fc_=r[1];
      if(tables){tables[2] = _fc_;return res}
      throw [0,Assert_failure,_cs_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[i + 1],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cx_]}
                if(tables$0)
                 {var _fa_=tables$0[3];
                  if(_fa_){var tables$0=_fa_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_ct_]}
                throw [0,Assert_failure,_cw_]}
              throw [0,Assert_failure,_cu_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table);
      if(0 === (n % 2 | 0))
       var switch$0=0;
      else
       if((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n)
        var switch$0=0;
       else
        var n$0=new_method(table),switch$0=1;
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[n$0 + 1] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _e6_=i[1],
           label=caml_check_bound(methods,_e6_)[_e6_ + 1],
           next=
            function(param)
             {i[1]++;
              var _e$_=i[1];
              return caml_check_bound(methods,_e$_)[_e$_ + 1]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[n + 1]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[e + 1][n + 1]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][n + 1],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[n + 1] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[n + 1])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[e + 1][n + 1])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][n + 1],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[n + 1])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[e + 1][n + 1])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][n + 1],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[n + 1],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[e + 1][n + 1],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][n + 1],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[m + 1])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][n + 1],obj,obj[e + 1][m + 1])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _e9_=caml_call1(obj[1][m + 1],obj);
                     return caml_call2(obj[1][n + 1],obj,_e9_)}}
                 (n$15,m$1);
              break;
             case 20:
              var m$2=next(0),x$9=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,x)
                  {return function(obj)
                    {return caml_call1(caml_get_public_method(x,m,0),x)}}
                 (m$2,x$9);
              break;
             case 21:
              var m$3=next(0),n$16=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e8_=obj[n + 1];
                     return caml_call1(caml_get_public_method(_e8_,m,0),_e8_)}}
                 (m$3,n$16);
              break;
             case 22:
              var m$4=next(0),e$4=next(0),n$17=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,e,n)
                  {return function(obj)
                    {var _e7_=obj[e + 1][n + 1];
                     return caml_call1(caml_get_public_method(_e7_,m,0),_e7_)}}
                 (m$4,e$4,n$17);
              break;
             default:
              var m$5=next(0),n$18=next(0);
              new_cache(table);
              var
               clo$0=
                function(m,n)
                  {return function(obj)
                    {var _e__=caml_call1(obj[1][n + 1],obj);
                     return caml_call1(caml_get_public_method(_e__,m,0),_e__)}}
                 (m$5,n$18)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$6,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initializers,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(684,CamlinternalOO,"CamlinternalOO");
    var Oo=[0,copy$6,public_method_label,public_method_label];
    caml_register_global(685,Oo,"Oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(686,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Hashtbl[1],0,17);
      iter
       (function(s){return caml_call3(Hashtbl[5],kwd_table,s,[0,s])},keywords);
      function ident_or_keyword(id)
       {try
         {var _e4_=caml_call2(Hashtbl[6],kwd_table,id);return _e4_}
        catch(_e5_)
         {_e5_ = caml_wrap_exception(_e5_);
          if(_e5_ === Not_found)return [1,id];
          throw _e5_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _e2_=caml_call2(Hashtbl[6],kwd_table,s);return _e2_}
        catch(_e3_)
         {_e3_ = caml_wrap_exception(_e3_);
          if(_e3_ === Not_found)throw [0,Error,_g_(cst_Illegal_character,s)];
          throw _e3_}}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _e1_=match[1],switcher=_e1_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_e1_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _e0_=match[1],switch$0=43 === _e0_?0:45 === _e0_?0:1;
          if(! switch$0)
           {junk(strm);store(_e0_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _eX_=match[1];
            if(58 <= _eX_)
             {var switch$0=69 === _eX_?0:101 === _eX_?0:1;
              if(! switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _eX_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _eY_=match$0[1],_eZ_=_eY_ - 69 | 0;
                    if(32 < _eZ_ >>> 0)
                     {var switcher=_eZ_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_eY_);continue}}
                    else
                     {var switcher$0=_eZ_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _eX_){junk(s);store(_eX_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eV_=match[1];
            if(94 <= _eV_)
             var
              _eW_=_eV_ - 95 | 0,
              switch$0=30 < _eW_ >>> 0?32 <= _eW_?1:0:29 === _eW_?0:1;
            else
             if(65 <= _eV_)
              var switch$0=92 === _eV_?0:1;
             else
              if(33 <= _eV_)
               switch(_eV_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:var switch$0=0;break;
                 default:var switch$0=1}
              else
               var switch$0=1;
            if(! switch$0){junk(strm);store(_eV_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _eU_=match[1],switcher=_eU_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_eU_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eS_=match[1];
            if(91 <= _eS_)
             var
              _eT_=_eS_ - 95 | 0,
              switch$0=27 < _eT_ >>> 0?97 <= _eT_?0:1:1 === _eT_?1:0;
            else
             var
              switch$0=
               48 <= _eS_?6 < (_eS_ - 58 | 0) >>> 0?0:1:39 === _eS_?0:1;
            if(! switch$0){junk(strm);store(_eS_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _eJ_=match[1];
            if(124 <= _eJ_)
             var switch$0=127 <= _eJ_?192 <= _eJ_?1:0:125 === _eJ_?0:2;
            else
             {var _eK_=_eJ_ - 65 | 0;
              if(57 < _eK_ >>> 0)
               if(58 <= _eK_)
                var switch$0=0;
               else
                {var switcher=_eK_ + 65 | 0;
                 switch(switcher)
                  {case 34:
                    junk(strm);
                    reset_buffer(0);
                    for(;;)
                     {var match$1=peek$0(strm);
                      if(match$1)
                       {var _eM_=match$1[1];
                        if(34 === _eM_){junk(strm);return [0,[4,get_string(0)]]}
                        if(92 === _eM_)
                         {junk(strm);
                          try
                           {var c$0=escape(strm)}
                          catch(_eR_)
                           {_eR_ = caml_wrap_exception(_eR_);
                            if(_eR_ === Failure$0)throw [0,Error,cst$80];
                            throw _eR_}
                          store(c$0);
                          continue}
                        junk(strm);
                        store(_eM_);
                        continue}
                      throw Failure$0}
                   case 39:
                    junk(strm);
                    try
                     {var match$2=peek$0(strm);
                      if(! match$2)throw Failure$0;
                      var _eN_=match$2[1];
                      if(92 === _eN_)
                       {junk(strm);
                        try
                         {var _eO_=escape(strm)}
                        catch(_eQ_)
                         {_eQ_ = caml_wrap_exception(_eQ_);
                          if(_eQ_ === Failure$0)throw [0,Error,cst$81];
                          throw _eQ_}
                        var c=_eO_}
                      else
                       {junk(strm);var c=_eN_}}
                    catch(_eP_)
                     {_eP_ = caml_wrap_exception(_eP_);
                      if(_eP_ === Failure$0)throw [0,Error,cst$78];
                      throw _eP_}
                    var match$0=peek$0(strm);
                    if(match$0)
                     if(39 === match$0[1]){junk(strm);return [0,[5,c]]}
                    throw [0,Error,cst$79];
                   case 40:
                    junk(strm);
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return maybe_comment(counter$0,strm)}
                    return caml_trampoline_return(maybe_comment,[0,strm]);
                   case 45:junk(strm);return neg_number(strm);
                   case 9:
                   case 10:
                   case 12:
                   case 13:
                   case 26:
                   case 32:junk(strm);continue;
                   case 48:
                   case 49:
                   case 50:
                   case 51:
                   case 52:
                   case 53:
                   case 54:
                   case 55:
                   case 56:
                   case 57:
                    junk(strm);reset_buffer(0);store(_eJ_);return number(strm);
                   case 33:
                   case 35:
                   case 36:
                   case 37:
                   case 38:
                   case 42:
                   case 43:
                   case 47:
                   case 58:
                   case 60:
                   case 61:
                   case 62:
                   case 63:
                   case 64:var switch$0=2;break;
                   default:var switch$0=0}}
              else
               {var _eL_=_eK_ - 26 | 0;
                if(5 < _eL_ >>> 0)
                 var switch$0=1;
                else
                 switch(_eL_)
                  {case 4:var switch$0=1;break;
                   case 1:
                   case 3:var switch$0=2;break;
                   default:var switch$0=0}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_eJ_)];
              case 1:
               junk(strm);reset_buffer(0);store(_eJ_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_eJ_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match)
         if(42 === match[1])
          {junk(strm);
           comment(strm);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return next_token$0(counter$0,strm)}
           return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _eG_=match[1];
          if(58 <= _eG_)
           {var switcher=_eG_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _eG_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _eH_=match$0[1],switcher$0=_eH_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _eI_=match$1[1],switcher$1=_eI_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_eG_ - 48 | 0) * 100 | 0)
                               +
                               ((_eH_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_eI_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$83]}}
             throw [0,Error,cst$82]}
          junk(strm);
          return _eG_}
        throw Failure$0}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _eF_=match$1[1];
                    if(41 === _eF_){junk(strm);return 0}
                    if(42 === _eF_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Genlex=[0,make_lexer];
    caml_register_global(687,Genlex,"Genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_eE_){return caml_call1(_b5_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x))
           if(! (max_array_length < (x * 2 | 0)))
            {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _eC_=caml_obj_tag(prng),
            _eD_=250 === _eC_?prng[1]:246 === _eC_?force_lazy_block(prng):prng,
            seed=caml_call1(_b5_[4],_eD_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_eA_=len - 1 | 0,_ez_=0;
        if(! (_eA_ < 0))
         {var i=_ez_;
          for(;;)
           {caml_check_bound(h[2],i)[i + 1] = 0;
            var _eB_=i + 1 | 0;
            if(_eA_ !== i){var i=_eB_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _ew_=init[4],_ex_=init[3],_ey_=copy$1(init[2]);
        return [0,init[1],_ey_,_ex_,_ew_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hkey=param$0[1];
              if(caml_call1(H[7],c))return [0,hkey,c,do_bucket(rest)];
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_et_=d.length - 1 - 1 | 0,_es_=0;
        if(! (_et_ < 0))
         {var i=_es_;
          for(;;)
           {var _eu_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _eu_;
            var _ev_=i + 1 | 0;
            if(_et_ !== i){var i=_ev_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _em_=nsize < max_array_length?1:0,
         _en_=_em_?(osize >>> 1 | 0) <= h[1]?1:0:_em_;
        if(_en_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var nidx=key_index(h,hkey);
                return ndata[nidx + 1]
                       =
                       [0,hkey,data,caml_check_bound(ndata,nidx)[nidx + 1]]}
              return 0},
           _ep_=osize - 1 | 0,
           _eo_=0;
          if(! (_ep_ < 0))
           {var i=_eo_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[i + 1]);
              var _er_=i + 1 | 0;
              if(_ep_ !== i){var i=_er_;continue}
              break}}
          var _eq_=0}
        else
         var _eq_=_en_;
        return _eq_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[i + 1]];
        caml_check_bound(h[2],i)[i + 1] = bucket;
        h[1] = h[1] + 1 | 0;
        var _el_=h[2].length - 1 << 1 < h[1]?1:0;
        return _el_?resize(h):_el_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              return [0,hk,c,remove_bucket(next)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _ek_=remove_bucket(caml_check_bound(h[2],i)[i + 1]);
        return caml_check_bound(h[2],i)[i + 1] = _ek_}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ej_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ej_)[_ej_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ei_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ei_)[_ei_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param=rest;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var rest=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$0=rest;
              continue}
            return 0}}
        var _eh_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_eh_)[_eh_ + 1])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var next=param$0[3],c=param$0[2],hk=param$0[1];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(0 === match)return caml_call3(H[6],c,key,info);
                var param$0=next;
                continue}
              var param$0=next;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[i + 1];
        try
         {var _ef_=replace_bucket(l);return _ef_}
        catch(_eg_)
         {_eg_ = caml_wrap_exception(_eg_);
          if(_eg_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[i + 1] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _ee_=h[2].length - 1 << 1 < h[1]?1:0;
            return _ee_?resize(h):_ee_}
          throw _eg_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _ed_=key_index(h,hkey),
         param$0=caml_check_bound(h[2],_ed_)[_ed_ + 1],
         param=param$0;
        for(;;)
         {if(param)
           {var rest=param[3],c=param[2],hk=param[1];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(0 === match)return 1;
              var param=rest;
              continue}
            var param=rest;
            continue}
          return 0}}
      function iter(f,h)
       {var d$0=h[2],_eb_=d$0.length - 1 - 1 | 0,_ea_=0;
        if(! (_eb_ < 0))
         {var i=_ea_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[i + 1],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  {var d=match$0[1],k=match[1];
                   caml_call2(f,k,d);
                   var switch$0=1}
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                var param=rest;
                continue}
              var _ec_=i + 1 | 0;
              if(_eb_ !== i){var i=_ec_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_d9_=d$0.length - 1 - 1 | 0,_d8_=0;
        if(! (_d9_ < 0))
         {var i=_d8_;
          a:
          for(;;)
           {var
             _d__=accu$1[1],
             b$0=caml_check_bound(d$0,i)[i + 1],
             b=b$0,
             accu=_d__;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c);
                if(match)
                 if(match$0)
                  var
                   d=match$0[1],
                   k=match[1],
                   accu$0=caml_call3(f,k,d,accu),
                   switch$0=1;
                 else
                  var switch$0=0;
                else
                 var switch$0=0;
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _d$_=i + 1 | 0;
              if(_d9_ !== i){var i=_d$_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match)
               if(match$0)
                {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                 if(match$1)
                  {var new_d=match$1[1];
                   caml_call3(H[6],c,k,new_d);
                   return [0,hk,c,do_bucket(rest)]}
                 var param$0=rest;
                 continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_d5_=d.length - 1 - 1 | 0,_d4_=0;
        if(! (_d5_ < 0))
         {var i=_d4_;
          for(;;)
           {var _d6_=do_bucket(caml_check_bound(d,i)[i + 1]);
            caml_check_bound(d,i)[i + 1] = _d6_;
            var _d7_=i + 1 | 0;
            if(_d5_ !== i){var i=_d7_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _d1_=h[2],
         _d2_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length(0,b))},_d2_,_d1_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _d3_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length(0,b);
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _d3_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$0=rest;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _dY_=h[2],
         _dZ_=0,
         mbl=
          fold_left$0
           (function(m,b){return max(m,bucket_length_alive(0,b))},_dZ_,_dY_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _d0_=h[2];
        iter$2
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            return histo[l + 1] = caml_check_bound(histo,l)[l + 1] + 1 | 0},
          _d0_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$4(param){return caml_call1(_H_[1],1)}
    function get_key(t){return caml_call2(_H_[3],t,0)}
    function get_key_copy(t){return caml_call2(_H_[4],t,0)}
    function set_key(t,k){return caml_call3(_H_[5],t,0,k)}
    function unset_key(t){return caml_call2(_H_[6],t,0)}
    function check_key(t){return caml_call2(_H_[7],t,0)}
    function blit_key(t1,t2){return caml_call5(_H_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_H_[9],t)}
    function get_data_copy(t){return caml_call1(_H_[10],t)}
    function set_data(t,d){return caml_call2(_H_[11],t,d)}
    function unset_data(t){return caml_call1(_H_[12],t)}
    function check_data(t){return caml_call1(_H_[13],t)}
    function blit_data(t1,t2){return caml_call2(_H_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$4(0);set_data(c,d);set_key(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$1,get_key,set_key_data,check_key])}
    function Make$1(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dX_=include[1];
      function create(sz){return caml_call2(_dX_,_cy_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_H_[1],2)}
    function get_key1(t){return caml_call2(_H_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_H_[4],t,0)}
    function set_key1(t,k){return caml_call3(_H_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_H_[6],t,0)}
    function check_key1(t){return caml_call2(_H_[7],t,0)}
    function get_key2(t){return caml_call2(_H_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_H_[4],t,1)}
    function set_key2(t,k){return caml_call3(_H_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_H_[6],t,1)}
    function check_key2(t){return caml_call2(_H_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_H_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_H_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_H_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_H_[9],t)}
    function get_data_copy$0(t){return caml_call1(_H_[10],t)}
    function set_data$0(t,d){return caml_call2(_H_[11],t,d)}
    function unset_data$0(t){return caml_call1(_H_[12],t)}
    function check_data$0(t){return caml_call1(_H_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_H_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$5(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _dW_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _dW_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0)
          {var k2$0=match$0[1],k1$0=match[1];
           if(caml_call2(H1[1],k1,k1$0))if(caml_call2(H2[1],k2,k2$0))return 0;
           return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match)
         if(match$0){var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _dV_=check_key1(c);return _dV_?check_key2(c):_dV_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$2(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_dT_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_dT_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dU_=include[1];
      function create(sz){return caml_call2(_dU_,_cz_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    function create$6(n){return caml_call1(_H_[1],n)}
    function length$6(k){return caml_call1(_H_[2],k)}
    function get_key$0(t,n){return caml_call2(_H_[3],t,n)}
    function get_key_copy$0(t,n){return caml_call2(_H_[4],t,n)}
    function set_key$0(t,n,k){return caml_call3(_H_[5],t,n,k)}
    function unset_key$0(t,n){return caml_call2(_H_[6],t,n)}
    function check_key$0(t,n){return caml_call2(_H_[7],t,n)}
    function blit_key$0(t1,o1,t2,o2,l)
     {return caml_call5(_H_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_H_[9],t)}
    function get_data_copy$1(t){return caml_call1(_H_[10],t)}
    function set_data$1(t,d){return caml_call2(_H_[11],t,d)}
    function unset_data$1(t){return caml_call1(_H_[12],t)}
    function check_data$1(t){return caml_call1(_H_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_H_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$6(k.length - 1);
        set_data$1(c,d);
        var _dR_=k.length - 1 - 1 | 0,_dQ_=0;
        if(! (_dR_ < 0))
         {var i=_dQ_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _dS_=i + 1 | 0;
            if(_dR_ !== i){var i=_dS_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_dM_=k.length - 1 - 1 | 0,_dL_=0;
        if(! (_dM_ < 0))
         {var i=_dL_;
          for(;;)
           {var _dN_=h[1],_dO_=caml_check_bound(k,i)[i + 1];
            h[1] = (caml_call2(H[2],seed,_dO_) * 65599 | 0) + _dN_ | 0;
            var _dP_=i + 1 | 0;
            if(_dM_ !== i){var i=_dP_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$0(c,i);
            if(match)
             {var ki=match[1],_dK_=caml_check_bound(k,i)[i + 1];
              if(caml_call2(H[1],_dK_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$0(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$0(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[i + 1] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _dI_=k.length - 1 - 1 | 0,_dH_=0;
        if(! (_dI_ < 0))
         {var i=_dH_;
          for(;;)
           {set_key$0(c,i,caml_check_bound(k,i)[i + 1]);
            var _dJ_=i + 1 | 0;
            if(_dI_ !== i){var i=_dJ_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _dE_=i < 0?1:0;
          if(_dE_)
           var _dF_=_dE_;
          else
           {var _dG_=check_key$0(c,i);
            if(_dG_){var i$0=i - 1 | 0,i=i$0;continue}
            var _dF_=_dG_}
          return _dF_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$3(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       clean=include[17],
       stats_alive=include[18],
       _dD_=include[1];
      function create(sz){return caml_call2(_dD_,_cA_,sz)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              clean,
              stats_alive]}
    var
     Ephemeron=
      [0,
       [0,
        create$4,
        get_key,
        get_key_copy,
        set_key,
        unset_key,
        check_key,
        blit_key,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$1,
        MakeSeeded$1],
       [0,
        create$5,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$2,
        MakeSeeded$2],
       [0,
        create$6,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$3,
        MakeSeeded$3],
       [0,
        function(_dC_)
         {return MakeSeeded$0
                  ([0,_dC_[3],_dC_[1],_dC_[2],_dC_[5],_dC_[4],_dC_[6],_dC_[7]])}]];
    caml_register_global(688,Ephemeron,"Ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$84))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$85))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _dA_=caml_ml_string_length(n) < 1?1:0,
       _dB_=_dA_ || (47 !== caml_string_get(n,0)?1:0);
      return _dB_}
    function is_implicit(n)
     {var _dv_=is_relative(n);
      if(_dv_)
       {var
         _dw_=caml_ml_string_length(n) < 2?1:0,
         _dx_=_dw_ || caml_string_notequal(sub$0(n,0,2),cst$87);
        if(_dx_)
         var
          _dy_=caml_ml_string_length(n) < 3?1:0,
          _dz_=_dy_ || caml_string_notequal(sub$0(n,0,3),cst$86);
        else
         var _dz_=_dx_}
      else
       var _dz_=_dv_;
      return _dz_}
    function check_suffix(name,suff)
     {var
       _dt_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _du_=
        _dt_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_dt_;
      return _du_}
    try
     {var _cI_=caml_sys_getenv(cst_TMPDIR),_cB_=_cI_}
    catch(_ds_)
     {_ds_ = caml_wrap_exception(_ds_);
      if(_ds_ !== Not_found)throw _ds_;
      var _cB_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,39);
      var _dq_=l - 1 | 0,_dp_=0;
      if(! (_dq_ < 0))
       {var i=_dp_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _dr_=i + 1 | 0;
          if(_dq_ !== i){var i=_dr_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function basename(_do_)
     {return generic_basename(is_dir_sep,current_dir_name,_do_)}
    function dirname(_dn_)
     {return generic_dirname(is_dir_sep,current_dir_name,_dn_)}
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_dk_=47 === c?1:0;
      if(_dk_)
       var _dl_=_dk_;
      else
       var _dm_=92 === c?1:0,_dl_=_dm_ || (58 === c?1:0);
      return _dl_}
    function is_relative$0(n)
     {var
       _de_=caml_ml_string_length(n) < 1?1:0,
       _df_=_de_ || (47 !== caml_string_get(n,0)?1:0);
      if(_df_)
       {var
         _dg_=caml_ml_string_length(n) < 1?1:0,
         _dh_=_dg_ || (92 !== caml_string_get(n,0)?1:0);
        if(_dh_)
         var
          _di_=caml_ml_string_length(n) < 2?1:0,
          _dj_=_di_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _dj_=_dh_}
      else
       var _dj_=_df_;
      return _dj_}
    function is_implicit$0(n)
     {var _c7_=is_relative$0(n);
      if(_c7_)
       {var
         _c8_=caml_ml_string_length(n) < 2?1:0,
         _c9_=_c8_ || caml_string_notequal(sub$0(n,0,2),cst$91);
        if(_c9_)
         {var
           _c__=caml_ml_string_length(n) < 2?1:0,
           _c$_=_c__ || caml_string_notequal(sub$0(n,0,2),cst$90);
          if(_c$_)
           {var
             _da_=caml_ml_string_length(n) < 3?1:0,
             _db_=_da_ || caml_string_notequal(sub$0(n,0,3),cst$89);
            if(_db_)
             var
              _dc_=caml_ml_string_length(n) < 3?1:0,
              _dd_=_dc_ || caml_string_notequal(sub$0(n,0,3),cst$88);
            else
             var _dd_=_db_}
          else
           var _dd_=_c$_}
        else
         var _dd_=_c9_}
      else
       var _dd_=_c7_;
      return _dd_}
    function check_suffix$0(name,suff)
     {var _c4_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_c4_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _c5_=lowercase_ascii$1(suff),
        _c6_=caml_string_equal(lowercase_ascii$1(s),_c5_);
      else
       var _c6_=_c4_;
      return _c6_}
    try
     {var _cH_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cH_}
    catch(_c3_)
     {_c3_ = caml_wrap_exception(_c3_);
      if(_c3_ !== Not_found)throw _c3_;
      var temp_dir_name=cst$92}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$1(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _c1_=1;
        if(! (n < 1))
         {var j=_c1_;
          for(;;)
           {add_char(b,92);
            var _c2_=j + 1 | 0;
            if(n !== j){var j=_c2_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _cZ_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_cZ_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_cZ_,i$0])}
          if(92 === c)
           {var _c0_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_c0_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_c0_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _cY_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_cY_)}
            return caml_trampoline_return(loop$0,[0,_cY_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function drive_and_path(s)
     {var _cU_=2 <= caml_ml_string_length(s)?1:0;
      if(_cU_)
       var
        param=caml_string_get(s,0),
        switch$0=91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0,
        _cV_=switch$0?1:0,
        _cW_=_cV_?58 === caml_string_get(s,1)?1:0:_cV_;
      else
       var _cW_=_cU_;
      if(_cW_)
       {var _cX_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_cX_]}
      return [0,cst$93,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return _g_(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    function basename$1(_cT_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_cT_)}
    function dirname$1(_cS_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_cS_)}
    if(caml_string_notequal(os_type,cst_Cygwin))
     if(caml_string_notequal(os_type,cst_Win32))
      var
       current_dir_name$2=current_dir_name,
       parent_dir_name$2=parent_dir_name,
       dir_sep$2=dir_sep,
       is_dir_sep$1=is_dir_sep,
       is_relative$1=is_relative,
       is_implicit$1=is_implicit,
       check_suffix$1=check_suffix,
       temp_dir_name$0=_cB_,
       quote$1=quote,
       basename$2=basename,
       dirname$2=dirname,
       switch$0=1;
     else
      var
       _cG_=
        [0,
         current_dir_name$0,
         parent_dir_name$0,
         dir_sep$0,
         is_dir_sep$0,
         is_relative$0,
         is_implicit$0,
         check_suffix$0,
         temp_dir_name,
         quote$0,
         basename$0,
         dirname$0],
       switch$0=0;
    else
     var
      _cG_=
       [0,
        current_dir_name$1,
        parent_dir_name$1,
        dir_sep$1,
        is_dir_sep$0,
        is_relative$0,
        is_implicit$0,
        check_suffix$0,
        _cB_,
        quote,
        basename$1,
        dirname$1],
      switch$0=0;
    if(! switch$0)
     var
      current_dir_name$2=_cG_[1],
      parent_dir_name$2=_cG_[2],
      dir_sep$2=_cG_[3],
      is_dir_sep$1=is_dir_sep$0,
      is_relative$1=is_relative$0,
      is_implicit$1=is_implicit$0,
      check_suffix$1=check_suffix$0,
      temp_dir_name$0=_cG_[8],
      quote$1=_cG_[9],
      basename$2=_cG_[10],
      dirname$2=_cG_[11];
    function concat$2(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l)
       if(! is_dir_sep$1(dirname,l - 1 | 0))
        return _g_(dirname,_g_(dir_sep$2,filename));
      return _g_(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1)
         if(! is_dir_sep$1(name,i$1))
          {if(46 === caml_string_get(name,i$1))
            {var i$2=i$1 - 1 | 0,i=i$2;
             for(;;)
              {if(0 <= i)
                if(! is_dir_sep$1(name,i))
                 {if(46 === caml_string_get(name,i))
                   {var i$0=i - 1 | 0,i=i$0;continue}
                  return caml_ml_string_length(name) - i$1 | 0}
               return 0}}
           var i$3=i$1 - 1 | 0,i$1=i$3;
           continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$94:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_cR_){return caml_call1(_b5_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _cP_=caml_obj_tag(prng$0),
       _cQ_=
        250 === _cP_?prng$0[1]:246 === _cP_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b5_[4],_cQ_) & 16777215;
      return concat$2(temp_dir,caml_call3(sprintf(_cC_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cD_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1e3 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_cN_,_cM_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cE_;
      if(_cN_)var sth$0=_cN_[1],perms=sth$0;else var perms=384;
      if(_cM_)
       var sth$1=_cM_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _cO_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _cO_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1e3 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$2,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1];
    caml_register_global(689,Filename,"Filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$3(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$2,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0)return i;
      if(i == 0)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1 + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1 + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0)if(x[2] == 0)return _cF_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1 + Math.sqrt(1 + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1 + q$0 * q$0)));
      if(0 <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0 <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _cL_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_cL_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Complex=
      [0,
       zero$2,
       one$2,
       i,
       neg,
       conj,
       add$1,
       sub$3,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(690,Complex,"Complex");
    var
     ArrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$0,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list,
       of_list,
       iter$2,
       map$2,
       iteri$2,
       mapi$2,
       fold_left$0,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       Floatarray];
    caml_register_global(691,ArrayLabels,"ArrayLabels");
    var
     ListLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter,
       iteri,
       map,
       mapi,
       rev_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_all,
       find_all,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge];
    caml_register_global(692,ListLabels,"ListLabels");
    var
     BytesLabels=
      [0,
       make,
       init$0,
       empty,
       copy,
       of_string,
       to_string,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$0,
       iteri$0,
       map$0,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$1,
       equal$1,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(693,BytesLabels,"BytesLabels");
    var
     StringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$1,
       iteri$1,
       map$1,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$2,
       equal$2,
       split_on_char];
    caml_register_global(694,StringLabels,"StringLabels");
    var MoreLabels=[0,Hashtbl,Map,Set];
    caml_register_global(695,MoreLabels,"MoreLabels");
    var StdLabels=[0,0,0,0,0];
    caml_register_global(696,StdLabels,"StdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$7(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_native_code(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code
                         (time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_native_code(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$7,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_native_code
                         (time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snapshots(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_native_code(event_name)})}
    var
     Spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snapshots];
    caml_register_global(697,Spacetime,"Spacetime");
    var CamlinternalBigarray=[0];
    caml_register_global(698,CamlinternalBigarray,"CamlinternalBigarray");
    return}
  (function(){return this}()));


//# 1 ".js/js_of_ocaml/js_of_ocaml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_from_string=runtime.caml_js_from_string,
     caml_js_get=runtime.caml_js_get,
     caml_js_html_escape=runtime.caml_js_html_escape,
     caml_js_set=runtime.caml_js_set,
     caml_js_to_byte_string=runtime.caml_js_to_byte_string,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_js_wrap_callback=runtime.caml_js_wrap_callback,
     caml_js_wrap_meth_callback=runtime.caml_js_wrap_meth_callback,
     caml_jsbytes_of_string=runtime.caml_jsbytes_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseFloat=caml_new_string("parseFloat"),
     cst_parseInt=caml_new_string("parseInt"),
     cst_Js_Error=caml_new_string("Js.Error"),
     cst_jsError=caml_new_string("jsError"),
     cst_g=caml_new_string("g"),
     cst=caml_new_string("[\\][()\\\\|+*.?{}^$]"),
     cst_is_not_a_valid_length$0=caml_new_string(" is not a valid length"),
     cst_d_d_deg_grad_rad_turns=
      caml_new_string("^(\\d*(?:\\.\\d*))(deg|grad|rad|turns)$"),
     cst_length_conversion_error$0=
      caml_new_string("length conversion error: "),
     cst_deg$0=caml_new_string("deg"),
     cst_grad$0=caml_new_string("grad"),
     cst_rad$0=caml_new_string("rad"),
     cst_turns$0=caml_new_string("turns"),
     cst_deg=caml_new_string("deg"),
     cst_grad=caml_new_string("grad"),
     cst_rad=caml_new_string("rad"),
     cst_turns=caml_new_string("turns"),
     cst_is_not_a_valid_length=caml_new_string(" is not a valid length"),
     cst_0$0=caml_new_string("0"),
     cst_d_d_s_S=caml_new_string("^(\\d*(?:\\.\\d*)?)\\s*(\\S*)$"),
     cst_length_conversion_error=caml_new_string("length conversion error: "),
     cst_pc$0=caml_new_string("pc"),
     cst_ch$0=caml_new_string("ch"),
     cst_cm$0=caml_new_string("cm"),
     cst_em$0=caml_new_string("em"),
     cst_ex$0=caml_new_string("ex"),
     cst_gd$0=caml_new_string("gd"),
     cst_in$0=caml_new_string("in"),
     cst_mm$0=caml_new_string("mm"),
     cst_pt$0=caml_new_string("pt"),
     cst_px$0=caml_new_string("px"),
     cst_rem$0=caml_new_string("rem"),
     cst_vh$0=caml_new_string("vh"),
     cst_vm$0=caml_new_string("vm"),
     cst_vw$0=caml_new_string("vw"),
     cst_0=caml_new_string("0"),
     cst_em=caml_new_string("em"),
     cst_ex=caml_new_string("ex"),
     cst_px=caml_new_string("px"),
     cst_gd=caml_new_string("gd"),
     cst_rem=caml_new_string("rem"),
     cst_vw=caml_new_string("vw"),
     cst_vh=caml_new_string("vh"),
     cst_vm=caml_new_string("vm"),
     cst_ch=caml_new_string("ch"),
     cst_mm=caml_new_string("mm"),
     cst_cm=caml_new_string("cm"),
     cst_in=caml_new_string("in"),
     cst_pt=caml_new_string("pt"),
     cst_pc=caml_new_string("pc"),
     cst$1=caml_new_string("): "),
     cst_color_conversion_error$0=caml_new_string("color conversion error ("),
     cst$0=caml_new_string("): "),
     cst_color_conversion_error=caml_new_string("color conversion error ("),
     cst_is_not_a_valid_color$0=caml_new_string(" is not a valid color"),
     cst_rgba_d_d_d_d_d=
      caml_new_string
       ("(rgba?)\\((?:(\\d*),(\\d*),(\\d*)(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgba_d_d_d_d_d$0=
      caml_new_string
       ("(rgba?)\\((?:(\\d*)%,(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_hsla_d_d_d_d_d=
      caml_new_string
       ("(hsla?)\\((?:(\\d*),(\\d*)%,(\\d*)%(?:,(\\d*(?:\\.\\d*)?))?)\\)"),
     cst_rgb=caml_new_string("rgb"),
     cst_rgba=caml_new_string("rgba"),
     cst_rgb$0=caml_new_string("rgb"),
     cst_rgba$0=caml_new_string("rgba"),
     cst_hsl=caml_new_string("hsl"),
     cst_hsla=caml_new_string("hsla"),
     cst_rgb_s_d_s_d_s_d=
      caml_new_string("^rgb\\(\\s*\\d*,\\s*\\d*,\\s*\\d*\\)$"),
     cst_rgb_s_d_s_d_s_d$0=
      caml_new_string("^rgb\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d=
      caml_new_string("^rgba\\(\\s*\\d*,\\s*\\d*,\\s*\\d*,\\d*\\.?\\d*\\)$"),
     cst_rgba_s_d_s_d_s_d_d_d$0=
      caml_new_string
       ("^rgba\\(\\s*\\d*%,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_hsl_s_d_s_d_s_d=
      caml_new_string("^hsl\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%\\)$"),
     cst_hsla_s_d_s_d_s_d_d_d=
      caml_new_string("^hsla\\(\\s*\\d*,\\s*\\d*%,\\s*\\d*%,\\d*\\.?\\d*\\)$"),
     cst_is_not_a_valid_color=caml_new_string(" is not a valid color"),
     cst_is_out_of_valid_range=caml_new_string(" is out of valid range"),
     partial=[8,0,0,0,[12,41,0]],
     partial$0=[12,41,0],
     cst_lightgrey$0=caml_new_string("lightgrey"),
     cst_darkslategray$0=caml_new_string("darkslategray"),
     cst_cornsilk$0=caml_new_string("cornsilk"),
     cst_blue$0=caml_new_string("blue"),
     cst_aliceblue$0=caml_new_string("aliceblue"),
     cst_antiquewhite$0=caml_new_string("antiquewhite"),
     cst_aqua$0=caml_new_string("aqua"),
     cst_aquamarine$0=caml_new_string("aquamarine"),
     cst_azure$0=caml_new_string("azure"),
     cst_beige$0=caml_new_string("beige"),
     cst_bisque$0=caml_new_string("bisque"),
     cst_black$0=caml_new_string("black"),
     cst_blanchedalmond$0=caml_new_string("blanchedalmond"),
     cst_blueviolet$0=caml_new_string("blueviolet"),
     cst_brown$0=caml_new_string("brown"),
     cst_burlywood$0=caml_new_string("burlywood"),
     cst_cadetblue$0=caml_new_string("cadetblue"),
     cst_chartreuse$0=caml_new_string("chartreuse"),
     cst_chocolate$0=caml_new_string("chocolate"),
     cst_coral$0=caml_new_string("coral"),
     cst_cornflowerblue$0=caml_new_string("cornflowerblue"),
     cst_darkkhaki$0=caml_new_string("darkkhaki"),
     cst_crimson$0=caml_new_string("crimson"),
     cst_cyan$0=caml_new_string("cyan"),
     cst_darkblue$0=caml_new_string("darkblue"),
     cst_darkcyan$0=caml_new_string("darkcyan"),
     cst_darkgoldenrod$0=caml_new_string("darkgoldenrod"),
     cst_darkgray$0=caml_new_string("darkgray"),
     cst_darkgreen$0=caml_new_string("darkgreen"),
     cst_darkgrey$0=caml_new_string("darkgrey"),
     cst_darkmagenta$0=caml_new_string("darkmagenta"),
     cst_darkolivegreen$0=caml_new_string("darkolivegreen"),
     cst_darkorange$0=caml_new_string("darkorange"),
     cst_darkorchid$0=caml_new_string("darkorchid"),
     cst_darkred$0=caml_new_string("darkred"),
     cst_darksalmon$0=caml_new_string("darksalmon"),
     cst_darkseagreen$0=caml_new_string("darkseagreen"),
     cst_darkslateblue$0=caml_new_string("darkslateblue"),
     cst_greenyellow$0=caml_new_string("greenyellow"),
     cst_floralwhite$0=caml_new_string("floralwhite"),
     cst_darkslategrey$0=caml_new_string("darkslategrey"),
     cst_darkturquoise$0=caml_new_string("darkturquoise"),
     cst_darkviolet$0=caml_new_string("darkviolet"),
     cst_deeppink$0=caml_new_string("deeppink"),
     cst_deepskyblue$0=caml_new_string("deepskyblue"),
     cst_dimgray$0=caml_new_string("dimgray"),
     cst_dimgrey$0=caml_new_string("dimgrey"),
     cst_dodgerblue$0=caml_new_string("dodgerblue"),
     cst_firebrick$0=caml_new_string("firebrick"),
     cst_forestgreen$0=caml_new_string("forestgreen"),
     cst_fuchsia$0=caml_new_string("fuchsia"),
     cst_gainsboro$0=caml_new_string("gainsboro"),
     cst_ghostwhite$0=caml_new_string("ghostwhite"),
     cst_gold$0=caml_new_string("gold"),
     cst_goldenrod$0=caml_new_string("goldenrod"),
     cst_gray$0=caml_new_string("gray"),
     cst_green$0=caml_new_string("green"),
     cst_lavenderblush$0=caml_new_string("lavenderblush"),
     cst_grey$0=caml_new_string("grey"),
     cst_honeydew$0=caml_new_string("honeydew"),
     cst_hotpink$0=caml_new_string("hotpink"),
     cst_indianred$0=caml_new_string("indianred"),
     cst_indigo$0=caml_new_string("indigo"),
     cst_ivory$0=caml_new_string("ivory"),
     cst_khaki$0=caml_new_string("khaki"),
     cst_lavender$0=caml_new_string("lavender"),
     cst_lawngreen$0=caml_new_string("lawngreen"),
     cst_lemonchiffon$0=caml_new_string("lemonchiffon"),
     cst_lightblue$0=caml_new_string("lightblue"),
     cst_lightcoral$0=caml_new_string("lightcoral"),
     cst_lightcyan$0=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow$0=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray$0=caml_new_string("lightgray"),
     cst_lightgreen$0=caml_new_string("lightgreen"),
     cst_paleturquoise$0=caml_new_string("paleturquoise"),
     cst_mediumslateblue$0=caml_new_string("mediumslateblue"),
     cst_limegreen$0=caml_new_string("limegreen"),
     cst_lightpink$0=caml_new_string("lightpink"),
     cst_lightsalmon$0=caml_new_string("lightsalmon"),
     cst_lightseagreen$0=caml_new_string("lightseagreen"),
     cst_lightskyblue$0=caml_new_string("lightskyblue"),
     cst_lightslategray$0=caml_new_string("lightslategray"),
     cst_lightslategrey$0=caml_new_string("lightslategrey"),
     cst_lightsteelblue$0=caml_new_string("lightsteelblue"),
     cst_lightyellow$0=caml_new_string("lightyellow"),
     cst_lime$0=caml_new_string("lime"),
     cst_linen$0=caml_new_string("linen"),
     cst_magenta$0=caml_new_string("magenta"),
     cst_maroon$0=caml_new_string("maroon"),
     cst_mediumaquamarine$0=caml_new_string("mediumaquamarine"),
     cst_mediumblue$0=caml_new_string("mediumblue"),
     cst_mediumorchid$0=caml_new_string("mediumorchid"),
     cst_mediumpurple$0=caml_new_string("mediumpurple"),
     cst_mediumseagreen$0=caml_new_string("mediumseagreen"),
     cst_navy$0=caml_new_string("navy"),
     cst_mediumspringgreen$0=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise$0=caml_new_string("mediumturquoise"),
     cst_mediumvioletred$0=caml_new_string("mediumvioletred"),
     cst_midnightblue$0=caml_new_string("midnightblue"),
     cst_mintcream$0=caml_new_string("mintcream"),
     cst_mistyrose$0=caml_new_string("mistyrose"),
     cst_moccasin$0=caml_new_string("moccasin"),
     cst_navajowhite$0=caml_new_string("navajowhite"),
     cst_oldlace$0=caml_new_string("oldlace"),
     cst_olive$0=caml_new_string("olive"),
     cst_olivedrab$0=caml_new_string("olivedrab"),
     cst_orange$0=caml_new_string("orange"),
     cst_orangered$0=caml_new_string("orangered"),
     cst_orchid$0=caml_new_string("orchid"),
     cst_palegoldenrod$0=caml_new_string("palegoldenrod"),
     cst_palegreen$0=caml_new_string("palegreen"),
     cst_skyblue$0=caml_new_string("skyblue"),
     cst_rosybrown$0=caml_new_string("rosybrown"),
     cst_palevioletred$0=caml_new_string("palevioletred"),
     cst_papayawhip$0=caml_new_string("papayawhip"),
     cst_peachpuff$0=caml_new_string("peachpuff"),
     cst_peru$0=caml_new_string("peru"),
     cst_pink$0=caml_new_string("pink"),
     cst_plum$0=caml_new_string("plum"),
     cst_powderblue$0=caml_new_string("powderblue"),
     cst_purple$0=caml_new_string("purple"),
     cst_red$0=caml_new_string("red"),
     cst_royalblue$0=caml_new_string("royalblue"),
     cst_saddlebrown$0=caml_new_string("saddlebrown"),
     cst_salmon$0=caml_new_string("salmon"),
     cst_sandybrown$0=caml_new_string("sandybrown"),
     cst_seagreen$0=caml_new_string("seagreen"),
     cst_seashell$0=caml_new_string("seashell"),
     cst_sienna$0=caml_new_string("sienna"),
     cst_silver$0=caml_new_string("silver"),
     cst_thistle$0=caml_new_string("thistle"),
     cst_slateblue$0=caml_new_string("slateblue"),
     cst_slategray$0=caml_new_string("slategray"),
     cst_slategrey$0=caml_new_string("slategrey"),
     cst_snow$0=caml_new_string("snow"),
     cst_springgreen$0=caml_new_string("springgreen"),
     cst_steelblue$0=caml_new_string("steelblue"),
     cst_tan$0=caml_new_string("tan"),
     cst_teal$0=caml_new_string("teal"),
     cst_tomato$0=caml_new_string("tomato"),
     cst_turquoise$0=caml_new_string("turquoise"),
     cst_violet$0=caml_new_string("violet"),
     cst_wheat$0=caml_new_string("wheat"),
     cst_white$0=caml_new_string("white"),
     cst_whitesmoke$0=caml_new_string("whitesmoke"),
     cst_yellow$0=caml_new_string("yellow"),
     cst_yellowgreen$0=caml_new_string("yellowgreen"),
     cst_is_not_a_valid_color_name=
      caml_new_string(" is not a valid color name"),
     cst_aliceblue=caml_new_string("aliceblue"),
     cst_antiquewhite=caml_new_string("antiquewhite"),
     cst_aqua=caml_new_string("aqua"),
     cst_aquamarine=caml_new_string("aquamarine"),
     cst_azure=caml_new_string("azure"),
     cst_beige=caml_new_string("beige"),
     cst_bisque=caml_new_string("bisque"),
     cst_black=caml_new_string("black"),
     cst_blanchedalmond=caml_new_string("blanchedalmond"),
     cst_blue=caml_new_string("blue"),
     cst_blueviolet=caml_new_string("blueviolet"),
     cst_brown=caml_new_string("brown"),
     cst_burlywood=caml_new_string("burlywood"),
     cst_cadetblue=caml_new_string("cadetblue"),
     cst_chartreuse=caml_new_string("chartreuse"),
     cst_chocolate=caml_new_string("chocolate"),
     cst_coral=caml_new_string("coral"),
     cst_cornflowerblue=caml_new_string("cornflowerblue"),
     cst_cornsilk=caml_new_string("cornsilk"),
     cst_crimson=caml_new_string("crimson"),
     cst_cyan=caml_new_string("cyan"),
     cst_darkblue=caml_new_string("darkblue"),
     cst_darkcyan=caml_new_string("darkcyan"),
     cst_darkgoldenrod=caml_new_string("darkgoldenrod"),
     cst_darkgray=caml_new_string("darkgray"),
     cst_darkgreen=caml_new_string("darkgreen"),
     cst_darkgrey=caml_new_string("darkgrey"),
     cst_darkkhaki=caml_new_string("darkkhaki"),
     cst_darkmagenta=caml_new_string("darkmagenta"),
     cst_darkolivegreen=caml_new_string("darkolivegreen"),
     cst_darkorange=caml_new_string("darkorange"),
     cst_darkorchid=caml_new_string("darkorchid"),
     cst_darkred=caml_new_string("darkred"),
     cst_darksalmon=caml_new_string("darksalmon"),
     cst_darkseagreen=caml_new_string("darkseagreen"),
     cst_darkslateblue=caml_new_string("darkslateblue"),
     cst_darkslategray=caml_new_string("darkslategray"),
     cst_darkslategrey=caml_new_string("darkslategrey"),
     cst_darkturquoise=caml_new_string("darkturquoise"),
     cst_darkviolet=caml_new_string("darkviolet"),
     cst_deeppink=caml_new_string("deeppink"),
     cst_deepskyblue=caml_new_string("deepskyblue"),
     cst_dimgray=caml_new_string("dimgray"),
     cst_dimgrey=caml_new_string("dimgrey"),
     cst_dodgerblue=caml_new_string("dodgerblue"),
     cst_firebrick=caml_new_string("firebrick"),
     cst_floralwhite=caml_new_string("floralwhite"),
     cst_forestgreen=caml_new_string("forestgreen"),
     cst_fuchsia=caml_new_string("fuchsia"),
     cst_gainsboro=caml_new_string("gainsboro"),
     cst_ghostwhite=caml_new_string("ghostwhite"),
     cst_gold=caml_new_string("gold"),
     cst_goldenrod=caml_new_string("goldenrod"),
     cst_gray=caml_new_string("gray"),
     cst_grey=caml_new_string("grey"),
     cst_green=caml_new_string("green"),
     cst_greenyellow=caml_new_string("greenyellow"),
     cst_honeydew=caml_new_string("honeydew"),
     cst_hotpink=caml_new_string("hotpink"),
     cst_indianred=caml_new_string("indianred"),
     cst_indigo=caml_new_string("indigo"),
     cst_ivory=caml_new_string("ivory"),
     cst_khaki=caml_new_string("khaki"),
     cst_lavender=caml_new_string("lavender"),
     cst_lavenderblush=caml_new_string("lavenderblush"),
     cst_lawngreen=caml_new_string("lawngreen"),
     cst_lemonchiffon=caml_new_string("lemonchiffon"),
     cst_lightblue=caml_new_string("lightblue"),
     cst_lightcoral=caml_new_string("lightcoral"),
     cst_lightcyan=caml_new_string("lightcyan"),
     cst_lightgoldenrodyellow=caml_new_string("lightgoldenrodyellow"),
     cst_lightgray=caml_new_string("lightgray"),
     cst_lightgreen=caml_new_string("lightgreen"),
     cst_lightgrey=caml_new_string("lightgrey"),
     cst_lightpink=caml_new_string("lightpink"),
     cst_lightsalmon=caml_new_string("lightsalmon"),
     cst_lightseagreen=caml_new_string("lightseagreen"),
     cst_lightskyblue=caml_new_string("lightskyblue"),
     cst_lightslategray=caml_new_string("lightslategray"),
     cst_lightslategrey=caml_new_string("lightslategrey"),
     cst_lightsteelblue=caml_new_string("lightsteelblue"),
     cst_lightyellow=caml_new_string("lightyellow"),
     cst_lime=caml_new_string("lime"),
     cst_limegreen=caml_new_string("limegreen"),
     cst_linen=caml_new_string("linen"),
     cst_magenta=caml_new_string("magenta"),
     cst_maroon=caml_new_string("maroon"),
     cst_mediumaquamarine=caml_new_string("mediumaquamarine"),
     cst_mediumblue=caml_new_string("mediumblue"),
     cst_mediumorchid=caml_new_string("mediumorchid"),
     cst_mediumpurple=caml_new_string("mediumpurple"),
     cst_mediumseagreen=caml_new_string("mediumseagreen"),
     cst_mediumslateblue=caml_new_string("mediumslateblue"),
     cst_mediumspringgreen=caml_new_string("mediumspringgreen"),
     cst_mediumturquoise=caml_new_string("mediumturquoise"),
     cst_mediumvioletred=caml_new_string("mediumvioletred"),
     cst_midnightblue=caml_new_string("midnightblue"),
     cst_mintcream=caml_new_string("mintcream"),
     cst_mistyrose=caml_new_string("mistyrose"),
     cst_moccasin=caml_new_string("moccasin"),
     cst_navajowhite=caml_new_string("navajowhite"),
     cst_navy=caml_new_string("navy"),
     cst_oldlace=caml_new_string("oldlace"),
     cst_olive=caml_new_string("olive"),
     cst_olivedrab=caml_new_string("olivedrab"),
     cst_orange=caml_new_string("orange"),
     cst_orangered=caml_new_string("orangered"),
     cst_orchid=caml_new_string("orchid"),
     cst_palegoldenrod=caml_new_string("palegoldenrod"),
     cst_palegreen=caml_new_string("palegreen"),
     cst_paleturquoise=caml_new_string("paleturquoise"),
     cst_palevioletred=caml_new_string("palevioletred"),
     cst_papayawhip=caml_new_string("papayawhip"),
     cst_peachpuff=caml_new_string("peachpuff"),
     cst_peru=caml_new_string("peru"),
     cst_pink=caml_new_string("pink"),
     cst_plum=caml_new_string("plum"),
     cst_powderblue=caml_new_string("powderblue"),
     cst_purple=caml_new_string("purple"),
     cst_red=caml_new_string("red"),
     cst_rosybrown=caml_new_string("rosybrown"),
     cst_royalblue=caml_new_string("royalblue"),
     cst_saddlebrown=caml_new_string("saddlebrown"),
     cst_salmon=caml_new_string("salmon"),
     cst_sandybrown=caml_new_string("sandybrown"),
     cst_seagreen=caml_new_string("seagreen"),
     cst_seashell=caml_new_string("seashell"),
     cst_sienna=caml_new_string("sienna"),
     cst_silver=caml_new_string("silver"),
     cst_skyblue=caml_new_string("skyblue"),
     cst_slateblue=caml_new_string("slateblue"),
     cst_slategray=caml_new_string("slategray"),
     cst_slategrey=caml_new_string("slategrey"),
     cst_snow=caml_new_string("snow"),
     cst_springgreen=caml_new_string("springgreen"),
     cst_steelblue=caml_new_string("steelblue"),
     cst_tan=caml_new_string("tan"),
     cst_teal=caml_new_string("teal"),
     cst_thistle=caml_new_string("thistle"),
     cst_tomato=caml_new_string("tomato"),
     cst_turquoise=caml_new_string("turquoise"),
     cst_violet=caml_new_string("violet"),
     cst_wheat=caml_new_string("wheat"),
     cst_white=caml_new_string("white"),
     cst_whitesmoke=caml_new_string("whitesmoke"),
     cst_yellow=caml_new_string("yellow"),
     cst_yellowgreen=caml_new_string("yellowgreen"),
     cst_can_t_retrieve_file_name_not_implemented=
      caml_new_string("can't retrieve file name: not implemented"),
     cst_endings=caml_new_string("endings"),
     cst_type=caml_new_string("type"),
     cst_loadstart=caml_new_string("loadstart"),
     cst_progress=caml_new_string("progress"),
     cst_abort=caml_new_string("abort"),
     cst_error=caml_new_string("error"),
     cst_load=caml_new_string("load"),
     cst_loadend=caml_new_string("loadend"),
     cst_a$1=caml_new_string("a"),
     cst_area$1=caml_new_string("area"),
     cst_audio$1=caml_new_string("audio"),
     cst_base$1=caml_new_string("base"),
     cst_blockquote$1=caml_new_string("blockquote"),
     cst_body$1=caml_new_string("body"),
     cst_br$1=caml_new_string("br"),
     cst_button$1=caml_new_string("button"),
     cst_canvas$1=caml_new_string("canvas"),
     cst_caption$1=caml_new_string("caption"),
     cst_col$1=caml_new_string("col"),
     cst_colgroup$1=caml_new_string("colgroup"),
     cst_del$1=caml_new_string("del"),
     cst_div$1=caml_new_string("div"),
     cst_dl$1=caml_new_string("dl"),
     cst_embed$1=caml_new_string("embed"),
     cst_fieldset$1=caml_new_string("fieldset"),
     cst_form$1=caml_new_string("form"),
     cst_frame$1=caml_new_string("frame"),
     cst_frameset$1=caml_new_string("frameset"),
     cst_h1$1=caml_new_string("h1"),
     cst_h2$1=caml_new_string("h2"),
     cst_h3$1=caml_new_string("h3"),
     cst_h4$1=caml_new_string("h4"),
     cst_h5$1=caml_new_string("h5"),
     cst_h6$1=caml_new_string("h6"),
     cst_head$1=caml_new_string("head"),
     cst_hr$1=caml_new_string("hr"),
     cst_html$1=caml_new_string("html"),
     cst_iframe$1=caml_new_string("iframe"),
     cst_img$1=caml_new_string("img"),
     cst_input$2=caml_new_string("input"),
     cst_ins$1=caml_new_string("ins"),
     cst_label$1=caml_new_string("label"),
     cst_legend$1=caml_new_string("legend"),
     cst_li$1=caml_new_string("li"),
     cst_link$1=caml_new_string("link"),
     cst_map$1=caml_new_string("map"),
     cst_meta$1=caml_new_string("meta"),
     cst_object$1=caml_new_string("object"),
     cst_ol$1=caml_new_string("ol"),
     cst_optgroup$1=caml_new_string("optgroup"),
     cst_option$1=caml_new_string("option"),
     cst_p$1=caml_new_string("p"),
     cst_param$1=caml_new_string("param"),
     cst_pre$1=caml_new_string("pre"),
     cst_q$1=caml_new_string("q"),
     cst_script$1=caml_new_string("script"),
     cst_select$2=caml_new_string("select"),
     cst_style$1=caml_new_string("style"),
     cst_table$1=caml_new_string("table"),
     cst_tbody$1=caml_new_string("tbody"),
     cst_td$1=caml_new_string("td"),
     cst_textarea$1=caml_new_string("textarea"),
     cst_tfoot$1=caml_new_string("tfoot"),
     cst_th$1=caml_new_string("th"),
     cst_thead$1=caml_new_string("thead"),
     cst_title$1=caml_new_string("title"),
     cst_tr$1=caml_new_string("tr"),
     cst_ul$1=caml_new_string("ul"),
     cst_video$1=caml_new_string("video"),
     cst_KeyH=caml_new_string("KeyH"),
     cst_Digit6=caml_new_string("Digit6"),
     cst_BrowserRefresh=caml_new_string("BrowserRefresh"),
     cst_Backslash=caml_new_string("Backslash"),
     cst_AltLeft=caml_new_string("AltLeft"),
     cst_AltRight=caml_new_string("AltRight"),
     cst_ArrowDown=caml_new_string("ArrowDown"),
     cst_ArrowLeft=caml_new_string("ArrowLeft"),
     cst_ArrowRight=caml_new_string("ArrowRight"),
     cst_ArrowUp=caml_new_string("ArrowUp"),
     cst_Backquote=caml_new_string("Backquote"),
     cst_Backspace=caml_new_string("Backspace"),
     cst_BracketLeft=caml_new_string("BracketLeft"),
     cst_BracketRight=caml_new_string("BracketRight"),
     cst_BrowserBack=caml_new_string("BrowserBack"),
     cst_BrowserFavorites=caml_new_string("BrowserFavorites"),
     cst_BrowserForward=caml_new_string("BrowserForward"),
     cst_BrowserHome=caml_new_string("BrowserHome"),
     cst_Delete=caml_new_string("Delete"),
     cst_BrowserSearch=caml_new_string("BrowserSearch"),
     cst_BrowserStop=caml_new_string("BrowserStop"),
     cst_CapsLock=caml_new_string("CapsLock"),
     cst_Comma=caml_new_string("Comma"),
     cst_ContextMenu=caml_new_string("ContextMenu"),
     cst_ControlLeft=caml_new_string("ControlLeft"),
     cst_ControlRight=caml_new_string("ControlRight"),
     cst_Digit0=caml_new_string("Digit0"),
     cst_Digit1=caml_new_string("Digit1"),
     cst_Digit2=caml_new_string("Digit2"),
     cst_Digit3=caml_new_string("Digit3"),
     cst_Digit4=caml_new_string("Digit4"),
     cst_Digit5=caml_new_string("Digit5"),
     cst_F6=caml_new_string("F6"),
     cst_F1=caml_new_string("F1"),
     cst_Digit7=caml_new_string("Digit7"),
     cst_Digit8=caml_new_string("Digit8"),
     cst_Digit9=caml_new_string("Digit9"),
     cst_End=caml_new_string("End"),
     cst_Enter=caml_new_string("Enter"),
     cst_Equal=caml_new_string("Equal"),
     cst_Escape=caml_new_string("Escape"),
     cst_F10=caml_new_string("F10"),
     cst_F11=caml_new_string("F11"),
     cst_F12=caml_new_string("F12"),
     cst_F2=caml_new_string("F2"),
     cst_F3=caml_new_string("F3"),
     cst_F4=caml_new_string("F4"),
     cst_F5=caml_new_string("F5"),
     cst_KeyA=caml_new_string("KeyA"),
     cst_F7=caml_new_string("F7"),
     cst_F8=caml_new_string("F8"),
     cst_F9=caml_new_string("F9"),
     cst_Home=caml_new_string("Home"),
     cst_Insert=caml_new_string("Insert"),
     cst_IntlBackslash=caml_new_string("IntlBackslash"),
     cst_IntlYen=caml_new_string("IntlYen"),
     cst_KeyB=caml_new_string("KeyB"),
     cst_KeyC=caml_new_string("KeyC"),
     cst_KeyD=caml_new_string("KeyD"),
     cst_KeyE=caml_new_string("KeyE"),
     cst_KeyF=caml_new_string("KeyF"),
     cst_KeyG=caml_new_string("KeyG"),
     cst_Numpad4=caml_new_string("Numpad4"),
     cst_KeyX=caml_new_string("KeyX"),
     cst_KeyP=caml_new_string("KeyP"),
     cst_KeyI=caml_new_string("KeyI"),
     cst_KeyJ=caml_new_string("KeyJ"),
     cst_KeyK=caml_new_string("KeyK"),
     cst_KeyL=caml_new_string("KeyL"),
     cst_KeyM=caml_new_string("KeyM"),
     cst_KeyN=caml_new_string("KeyN"),
     cst_KeyO=caml_new_string("KeyO"),
     cst_KeyQ=caml_new_string("KeyQ"),
     cst_KeyR=caml_new_string("KeyR"),
     cst_KeyS=caml_new_string("KeyS"),
     cst_KeyT=caml_new_string("KeyT"),
     cst_KeyU=caml_new_string("KeyU"),
     cst_KeyV=caml_new_string("KeyV"),
     cst_KeyW=caml_new_string("KeyW"),
     cst_MetaRight=caml_new_string("MetaRight"),
     cst_KeyY=caml_new_string("KeyY"),
     cst_KeyZ=caml_new_string("KeyZ"),
     cst_MediaPlayPause=caml_new_string("MediaPlayPause"),
     cst_MediaStop=caml_new_string("MediaStop"),
     cst_MediaTrackNext=caml_new_string("MediaTrackNext"),
     cst_MediaTrackPrevious=caml_new_string("MediaTrackPrevious"),
     cst_MetaLeft=caml_new_string("MetaLeft"),
     cst_Minus=caml_new_string("Minus"),
     cst_NumLock=caml_new_string("NumLock"),
     cst_Numpad0=caml_new_string("Numpad0"),
     cst_Numpad1=caml_new_string("Numpad1"),
     cst_Numpad2=caml_new_string("Numpad2"),
     cst_Numpad3=caml_new_string("Numpad3"),
     cst_PageUp=caml_new_string("PageUp"),
     cst_NumpadDivide=caml_new_string("NumpadDivide"),
     cst_Numpad5=caml_new_string("Numpad5"),
     cst_Numpad6=caml_new_string("Numpad6"),
     cst_Numpad7=caml_new_string("Numpad7"),
     cst_Numpad8=caml_new_string("Numpad8"),
     cst_Numpad9=caml_new_string("Numpad9"),
     cst_NumpadAdd=caml_new_string("NumpadAdd"),
     cst_NumpadDecimal=caml_new_string("NumpadDecimal"),
     cst_NumpadEnter=caml_new_string("NumpadEnter"),
     cst_NumpadEqual=caml_new_string("NumpadEqual"),
     cst_NumpadMultiply=caml_new_string("NumpadMultiply"),
     cst_NumpadSubtract=caml_new_string("NumpadSubtract"),
     cst_OSLeft=caml_new_string("OSLeft"),
     cst_OSRight=caml_new_string("OSRight"),
     cst_PageDown=caml_new_string("PageDown"),
     cst_ShiftRight=caml_new_string("ShiftRight"),
     cst_Pause=caml_new_string("Pause"),
     cst_Period=caml_new_string("Period"),
     cst_PrintScreen=caml_new_string("PrintScreen"),
     cst_Quote=caml_new_string("Quote"),
     cst_ScrollLock=caml_new_string("ScrollLock"),
     cst_Semicolon=caml_new_string("Semicolon"),
     cst_ShiftLeft=caml_new_string("ShiftLeft"),
     cst_Slash=caml_new_string("Slash"),
     cst_Space=caml_new_string("Space"),
     cst_Tab=caml_new_string("Tab"),
     cst_VolumeDown=caml_new_string("VolumeDown"),
     cst_VolumeMute=caml_new_string("VolumeMute"),
     cst_VolumeUp=caml_new_string("VolumeUp"),
     cst_mouseout$0=caml_new_string("mouseout"),
     cst_mouseover$0=caml_new_string("mouseover"),
     cst_video$0=caml_new_string("video"),
     cst_audio$0=caml_new_string("audio"),
     cst_ul$0=caml_new_string("ul"),
     cst_tr$0=caml_new_string("tr"),
     cst_title$0=caml_new_string("title"),
     cst_thead$0=caml_new_string("thead"),
     cst_th$0=caml_new_string("th"),
     cst_tfoot$0=caml_new_string("tfoot"),
     cst_textarea$0=caml_new_string("textarea"),
     cst_td$0=caml_new_string("td"),
     cst_tbody$0=caml_new_string("tbody"),
     cst_table$0=caml_new_string("table"),
     cst_style$0=caml_new_string("style"),
     cst_select$1=caml_new_string("select"),
     cst_script$0=caml_new_string("script"),
     cst_q$0=caml_new_string("q"),
     cst_pre$0=caml_new_string("pre"),
     cst_param$0=caml_new_string("param"),
     cst_p$0=caml_new_string("p"),
     cst_option$0=caml_new_string("option"),
     cst_optgroup$0=caml_new_string("optgroup"),
     cst_ol$0=caml_new_string("ol"),
     cst_object$0=caml_new_string("object"),
     cst_meta$0=caml_new_string("meta"),
     cst_map$0=caml_new_string("map"),
     cst_link$0=caml_new_string("link"),
     cst_li$0=caml_new_string("li"),
     cst_legend$0=caml_new_string("legend"),
     cst_label$0=caml_new_string("label"),
     cst_ins$0=caml_new_string("ins"),
     cst_input$1=caml_new_string("input"),
     cst_img$0=caml_new_string("img"),
     cst_iframe$0=caml_new_string("iframe"),
     cst_html$0=caml_new_string("html"),
     cst_hr$0=caml_new_string("hr"),
     cst_head$0=caml_new_string("head"),
     cst_h6$0=caml_new_string("h6"),
     cst_h5$0=caml_new_string("h5"),
     cst_h4$0=caml_new_string("h4"),
     cst_h3$0=caml_new_string("h3"),
     cst_h2$0=caml_new_string("h2"),
     cst_h1$0=caml_new_string("h1"),
     cst_frame$0=caml_new_string("frame"),
     cst_frameset$0=caml_new_string("frameset"),
     cst_form$0=caml_new_string("form"),
     cst_embed$0=caml_new_string("embed"),
     cst_fieldset$0=caml_new_string("fieldset"),
     cst_dl$0=caml_new_string("dl"),
     cst_div$0=caml_new_string("div"),
     cst_del$0=caml_new_string("del"),
     cst_colgroup$0=caml_new_string("colgroup"),
     cst_col$0=caml_new_string("col"),
     cst_caption$0=caml_new_string("caption"),
     cst_canvas$0=caml_new_string("canvas"),
     cst_button$0=caml_new_string("button"),
     cst_br$0=caml_new_string("br"),
     cst_body$0=caml_new_string("body"),
     cst_blockquote$0=caml_new_string("blockquote"),
     cst_base$0=caml_new_string("base"),
     cst_area$0=caml_new_string("area"),
     cst_a$0=caml_new_string("a"),
     cst_canvas=caml_new_string("canvas"),
     cst_video=caml_new_string("video"),
     cst_audio=caml_new_string("audio"),
     cst_iframe=caml_new_string("iframe"),
     cst_frame=caml_new_string("frame"),
     cst_frameset=caml_new_string("frameset"),
     cst_address=caml_new_string("address"),
     cst_noscript=caml_new_string("noscript"),
     cst_dt=caml_new_string("dt"),
     cst_dd=caml_new_string("dd"),
     cst_abbr=caml_new_string("abbr"),
     cst_var=caml_new_string("var"),
     cst_kbd=caml_new_string("kbd"),
     cst_samp=caml_new_string("samp"),
     cst_code=caml_new_string("code"),
     cst_dfn=caml_new_string("dfn"),
     cst_cite=caml_new_string("cite"),
     cst_strong=caml_new_string("strong"),
     cst_em$1=caml_new_string("em"),
     cst_small=caml_new_string("small"),
     cst_big=caml_new_string("big"),
     cst_b=caml_new_string("b"),
     cst_i=caml_new_string("i"),
     cst_tt=caml_new_string("tt"),
     cst_span=caml_new_string("span"),
     cst_sup=caml_new_string("sup"),
     cst_sub=caml_new_string("sub"),
     cst_td=caml_new_string("td"),
     cst_th=caml_new_string("th"),
     cst_tr=caml_new_string("tr"),
     cst_tbody=caml_new_string("tbody"),
     cst_tfoot=caml_new_string("tfoot"),
     cst_thead=caml_new_string("thead"),
     cst_colgroup=caml_new_string("colgroup"),
     cst_col=caml_new_string("col"),
     cst_caption=caml_new_string("caption"),
     cst_table=caml_new_string("table"),
     cst_script=caml_new_string("script"),
     cst_area=caml_new_string("area"),
     cst_map=caml_new_string("map"),
     cst_param=caml_new_string("param"),
     cst_object=caml_new_string("object"),
     cst_img=caml_new_string("img"),
     cst_a=caml_new_string("a"),
     cst_del=caml_new_string("del"),
     cst_ins=caml_new_string("ins"),
     cst_hr=caml_new_string("hr"),
     cst_br=caml_new_string("br"),
     cst_pre=caml_new_string("pre"),
     cst_blockquote=caml_new_string("blockquote"),
     cst_q=caml_new_string("q"),
     cst_h6=caml_new_string("h6"),
     cst_h5=caml_new_string("h5"),
     cst_h4=caml_new_string("h4"),
     cst_h3=caml_new_string("h3"),
     cst_h2=caml_new_string("h2"),
     cst_h1=caml_new_string("h1"),
     cst_p=caml_new_string("p"),
     cst_embed=caml_new_string("embed"),
     cst_div=caml_new_string("div"),
     cst_li=caml_new_string("li"),
     cst_dl=caml_new_string("dl"),
     cst_ol=caml_new_string("ol"),
     cst_ul=caml_new_string("ul"),
     cst_legend=caml_new_string("legend"),
     cst_fieldset=caml_new_string("fieldset"),
     cst_label=caml_new_string("label"),
     cst_button=caml_new_string("button"),
     cst_textarea=caml_new_string("textarea"),
     cst_input$0=caml_new_string("input"),
     cst_select$0=caml_new_string("select"),
     cst_option=caml_new_string("option"),
     cst_optgroup=caml_new_string("optgroup"),
     cst_form=caml_new_string("form"),
     cst_body=caml_new_string("body"),
     cst_style=caml_new_string("style"),
     cst_base=caml_new_string("base"),
     cst_meta=caml_new_string("meta"),
     cst_title=caml_new_string("title"),
     cst_link=caml_new_string("link"),
     cst_head=caml_new_string("head"),
     cst_html=caml_new_string("html"),
     cst_click=caml_new_string("click"),
     cst_dblclick=caml_new_string("dblclick"),
     cst_mousedown=caml_new_string("mousedown"),
     cst_mouseup=caml_new_string("mouseup"),
     cst_mouseover=caml_new_string("mouseover"),
     cst_mousemove=caml_new_string("mousemove"),
     cst_mouseout=caml_new_string("mouseout"),
     cst_keypress=caml_new_string("keypress"),
     cst_keydown=caml_new_string("keydown"),
     cst_keyup=caml_new_string("keyup"),
     cst_mousewheel=caml_new_string("mousewheel"),
     cst_DOMMouseScroll=caml_new_string("DOMMouseScroll"),
     cst_touchstart=caml_new_string("touchstart"),
     cst_touchmove=caml_new_string("touchmove"),
     cst_touchend=caml_new_string("touchend"),
     cst_touchcancel=caml_new_string("touchcancel"),
     cst_dragstart=caml_new_string("dragstart"),
     cst_dragend=caml_new_string("dragend"),
     cst_dragenter=caml_new_string("dragenter"),
     cst_dragover=caml_new_string("dragover"),
     cst_dragleave=caml_new_string("dragleave"),
     cst_drag=caml_new_string("drag"),
     cst_drop=caml_new_string("drop"),
     cst_hashchange=caml_new_string("hashchange"),
     cst_change=caml_new_string("change"),
     cst_input=caml_new_string("input"),
     cst_timeupdate=caml_new_string("timeupdate"),
     cst_submit=caml_new_string("submit"),
     cst_scroll=caml_new_string("scroll"),
     cst_focus=caml_new_string("focus"),
     cst_blur=caml_new_string("blur"),
     cst_load$0=caml_new_string("load"),
     cst_unload=caml_new_string("unload"),
     cst_beforeunload=caml_new_string("beforeunload"),
     cst_resize=caml_new_string("resize"),
     cst_orientationchange=caml_new_string("orientationchange"),
     cst_popstate=caml_new_string("popstate"),
     cst_error$0=caml_new_string("error"),
     cst_abort$0=caml_new_string("abort"),
     cst_select=caml_new_string("select"),
     cst_online=caml_new_string("online"),
     cst_offline=caml_new_string("offline"),
     cst_checking=caml_new_string("checking"),
     cst_noupdate=caml_new_string("noupdate"),
     cst_downloading=caml_new_string("downloading"),
     cst_progress$0=caml_new_string("progress"),
     cst_updateready=caml_new_string("updateready"),
     cst_cached=caml_new_string("cached"),
     cst_obsolete=caml_new_string("obsolete"),
     cst_DOMContentLoaded=caml_new_string("DOMContentLoaded"),
     cst_animationstart=caml_new_string("animationstart"),
     cst_animationend=caml_new_string("animationend"),
     cst_animationiteration=caml_new_string("animationiteration"),
     cst_animationcancel=caml_new_string("animationcancel"),
     cst_canplay=caml_new_string("canplay"),
     cst_canplaythrough=caml_new_string("canplaythrough"),
     cst_durationchange=caml_new_string("durationchange"),
     cst_emptied=caml_new_string("emptied"),
     cst_ended=caml_new_string("ended"),
     cst_loadeddata=caml_new_string("loadeddata"),
     cst_loadedmetadata=caml_new_string("loadedmetadata"),
     cst_loadstart$0=caml_new_string("loadstart"),
     cst_pause=caml_new_string("pause"),
     cst_play=caml_new_string("play"),
     cst_playing=caml_new_string("playing"),
     cst_ratechange=caml_new_string("ratechange"),
     cst_seeked=caml_new_string("seeked"),
     cst_seeking=caml_new_string("seeking"),
     cst_stalled=caml_new_string("stalled"),
     cst_suspend=caml_new_string("suspend"),
     cst_volumechange=caml_new_string("volumechange"),
     cst_waiting=caml_new_string("waiting"),
     cst_Dom_html_Canvas_not_available=
      caml_new_string("Dom_html.Canvas_not_available"),
     cst_vkern$0=caml_new_string("vkern"),
     cst_view$0=caml_new_string("view"),
     cst_use$0=caml_new_string("use"),
     cst_tspan$0=caml_new_string("tspan"),
     cst_tref$0=caml_new_string("tref"),
     cst_title$3=caml_new_string("title"),
     cst_textpath$0=caml_new_string("textpath"),
     cst_text$0=caml_new_string("text"),
     cst_symbol$0=caml_new_string("symbol"),
     cst_switch$0=caml_new_string("switch"),
     cst_svg$0=caml_new_string("svg"),
     cst_style$3=caml_new_string("style"),
     cst_stop$0=caml_new_string("stop"),
     cst_set$0=caml_new_string("set"),
     cst_script$3=caml_new_string("script"),
     cst_rect$0=caml_new_string("rect"),
     cst_radialgradient$0=caml_new_string("radialgradient"),
     cst_polyline$0=caml_new_string("polyline"),
     cst_polygon$0=caml_new_string("polygon"),
     cst_parttern$0=caml_new_string("parttern"),
     cst_path$0=caml_new_string("path"),
     cst_mpath$0=caml_new_string("mpath"),
     cst_missing_glyph$0=caml_new_string("missing-glyph"),
     cst_metadata$0=caml_new_string("metadata"),
     cst_mask$0=caml_new_string("mask"),
     cst_lineargradient$0=caml_new_string("lineargradient"),
     cst_line$0=caml_new_string("line"),
     cst_image$0=caml_new_string("image"),
     cst_hkern$0=caml_new_string("hkern"),
     cst_glyphref$0=caml_new_string("glyphref"),
     cst_glyph$0=caml_new_string("glyph"),
     cst_g$1=caml_new_string("g"),
     cst_foreignobject$0=caml_new_string("foreignobject"),
     cst_font_face_uri$0=caml_new_string("font-face-uri"),
     cst_font_face_src$0=caml_new_string("font-face-src"),
     cst_font_face_name$0=caml_new_string("font-face-name"),
     cst_font_face_format$0=caml_new_string("font-face-format"),
     cst_font_face$0=caml_new_string("font-face"),
     cst_font$0=caml_new_string("font"),
     cst_filter$0=caml_new_string("filter"),
     cst_ellipse$0=caml_new_string("ellipse"),
     cst_desc$0=caml_new_string("desc"),
     cst_defs$0=caml_new_string("defs"),
     cst_cursor$0=caml_new_string("cursor"),
     cst_clippath$0=caml_new_string("clippath"),
     cst_circle$0=caml_new_string("circle"),
     cst_animatetransform$0=caml_new_string("animatetransform"),
     cst_animatemotion$0=caml_new_string("animatemotion"),
     cst_animatecolor$0=caml_new_string("animatecolor"),
     cst_animate$0=caml_new_string("animate"),
     cst_altglyphitem$0=caml_new_string("altglyphitem"),
     cst_altglyphdef$0=caml_new_string("altglyphdef"),
     cst_altglyph$0=caml_new_string("altglyph"),
     cst_a$3=caml_new_string("a"),
     cst_vkern=caml_new_string("vkern"),
     cst_view=caml_new_string("view"),
     cst_use=caml_new_string("use"),
     cst_tspan=caml_new_string("tspan"),
     cst_tref=caml_new_string("tref"),
     cst_title$2=caml_new_string("title"),
     cst_textpath=caml_new_string("textpath"),
     cst_text=caml_new_string("text"),
     cst_symbol=caml_new_string("symbol"),
     cst_switch=caml_new_string("switch"),
     cst_svg=caml_new_string("svg"),
     cst_style$2=caml_new_string("style"),
     cst_stop=caml_new_string("stop"),
     cst_set=caml_new_string("set"),
     cst_script$2=caml_new_string("script"),
     cst_rect=caml_new_string("rect"),
     cst_radialgradient=caml_new_string("radialgradient"),
     cst_polyline=caml_new_string("polyline"),
     cst_polygon=caml_new_string("polygon"),
     cst_parttern=caml_new_string("parttern"),
     cst_path=caml_new_string("path"),
     cst_mpath=caml_new_string("mpath"),
     cst_missing_glyph=caml_new_string("missing-glyph"),
     cst_metadata=caml_new_string("metadata"),
     cst_mask=caml_new_string("mask"),
     cst_lineargradient=caml_new_string("lineargradient"),
     cst_line=caml_new_string("line"),
     cst_image=caml_new_string("image"),
     cst_hkern=caml_new_string("hkern"),
     cst_glyphref=caml_new_string("glyphref"),
     cst_glyph=caml_new_string("glyph"),
     cst_g$0=caml_new_string("g"),
     cst_foreignobject=caml_new_string("foreignobject"),
     cst_font_face_uri=caml_new_string("font-face-uri"),
     cst_font_face_src=caml_new_string("font-face-src"),
     cst_font_face_name=caml_new_string("font-face-name"),
     cst_font_face_format=caml_new_string("font-face-format"),
     cst_font_face=caml_new_string("font-face"),
     cst_font=caml_new_string("font"),
     cst_filter=caml_new_string("filter"),
     cst_ellipse=caml_new_string("ellipse"),
     cst_desc=caml_new_string("desc"),
     cst_defs=caml_new_string("defs"),
     cst_cursor=caml_new_string("cursor"),
     cst_clippath=caml_new_string("clippath"),
     cst_circle=caml_new_string("circle"),
     cst_animatetransform=caml_new_string("animatetransform"),
     cst_animatemotion=caml_new_string("animatemotion"),
     cst_animatecolor=caml_new_string("animatecolor"),
     cst_animate=caml_new_string("animate"),
     cst_altglyphitem=caml_new_string("altglyphitem"),
     cst_altglyphdef=caml_new_string("altglyphdef"),
     cst_altglyph=caml_new_string("altglyph"),
     cst_a$2=caml_new_string("a"),
     cst_Dom_svg_SVGError=caml_new_string("Dom_svg.SVGError"),
     cst_checkbox=caml_new_string("checkbox"),
     cst_file=caml_new_string("file"),
     cst_password=caml_new_string("password"),
     cst_radio=caml_new_string("radio"),
     cst_reset=caml_new_string("reset"),
     cst_submit$0=caml_new_string("submit"),
     cst_text$1=caml_new_string("text"),
     dummy_string=caml_new_string(""),
     cst_Jstable_keys=caml_new_string("Jstable.keys"),
     js_of_ocaml_version=caml_new_string("3.2.0"),
     git_version=caml_new_string(""),
     cst$39=caml_new_string(""),
     cst$15=caml_new_string(""),
     cst$23=caml_new_string(""),
     cst$16=caml_new_string("#"),
     cst$17=caml_new_string("?"),
     cst$22=caml_new_string(""),
     cst$18=caml_new_string("/"),
     cst$19=caml_new_string("/"),
     cst$21=caml_new_string(":"),
     cst$20=caml_new_string(""),
     cst_http$1=caml_new_string("http://"),
     cst$24=caml_new_string(""),
     cst$32=caml_new_string(""),
     cst$25=caml_new_string("#"),
     cst$26=caml_new_string("?"),
     cst$31=caml_new_string(""),
     cst$27=caml_new_string("/"),
     cst$28=caml_new_string("/"),
     cst$30=caml_new_string(":"),
     cst$29=caml_new_string(""),
     cst_https$1=caml_new_string("https://"),
     cst$33=caml_new_string(""),
     cst$38=caml_new_string(""),
     cst$34=caml_new_string("#"),
     cst$35=caml_new_string("?"),
     cst$37=caml_new_string(""),
     cst$36=caml_new_string("/"),
     cst_file$2=caml_new_string("file://"),
     cst$14=caml_new_string(""),
     cst$13=caml_new_string(""),
     cst$12=caml_new_string(""),
     cst$11=caml_new_string(""),
     cst$10=caml_new_string(""),
     cst$9=caml_new_string(""),
     cst$8=caml_new_string(""),
     cst$6=caml_new_string("="),
     cst$7=caml_new_string("&"),
     cst$4=caml_new_string(""),
     cst$5=caml_new_string(""),
     cst_file$0=caml_new_string("file"),
     cst_file$1=caml_new_string("file:"),
     cst_http=caml_new_string("http"),
     cst_http$0=caml_new_string("http:"),
     cst_https=caml_new_string("https"),
     cst_https$0=caml_new_string("https:"),
     cst$3=caml_new_string(" "),
     cst_2B=caml_new_string("%2B"),
     cst_Url_Local_exn=caml_new_string("Url.Local_exn"),
     cst$2=caml_new_string("+"),
     cst_Url_Not_an_http_protocol=caml_new_string("Url.Not_an_http_protocol"),
     cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9=
      caml_new_string
       ("^([Hh][Tt][Tt][Pp][Ss]?)://([0-9a-zA-Z.-]+|\\[[0-9a-zA-Z.-]+\\]|\\[[0-9A-Fa-f:.]+\\])?(:([0-9]+))?(/([^\\?#]*)(\\?([^#]*))?(#(.*))?)?$"),
     cst_Ff_Ii_Ll_Ee=
      caml_new_string
       ("^([Ff][Ii][Ll][Ee])://([^\\?#]*)(\\?([^#]*))?(#(.*))?$"),
     cst_webglcontextlost=caml_new_string("webglcontextlost"),
     cst_webglcontextrestored=caml_new_string("webglcontextrestored"),
     cst_webglcontextcreationerror=
      caml_new_string("webglcontextcreationerror"),
     cst_Worker_onmessage_is_undefined$0=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_onmessage_is_undefined=
      caml_new_string("Worker.onmessage is undefined"),
     cst_Worker_import_scripts_is_undefined=
      caml_new_string("Worker.import_scripts is undefined"),
     cst_readystatechange=caml_new_string("readystatechange"),
     cst_loadstart$1=caml_new_string("loadstart"),
     cst_progress$1=caml_new_string("progress"),
     cst_abort$1=caml_new_string("abort"),
     cst_error$1=caml_new_string("error"),
     cst_load$1=caml_new_string("load"),
     cst_timeout=caml_new_string("timeout"),
     cst_loadend$0=caml_new_string("loadend"),
     Pervasives=global_data.Pervasives,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Assert_failure=global_data.Assert_failure,
     Invalid_argument=global_data.Invalid_argument,
     Printf=global_data.Printf,
     Failure=global_data.Failure,
     List=global_data.List,
     Not_found=global_data.Not_found,
     Array=global_data.Array,
     Uchar=global_data.Uchar,
     String$0=global_data.String,
     global=joo_global_object,
     Unsafe=[0,global],
     no_handler=null,
     t37=undefined,
     _d_=[0,caml_new_string("lib/regexp.ml"),35,64],
     _b3_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b4_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b5_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b6_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bP_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bQ_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bR_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bS_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bT_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bU_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bV_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bW_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bX_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bY_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bZ_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b0_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b1_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _b2_=[0,[8,0,0,0,[2,0,0]],caml_new_string("%f%s")],
     _bO_=
      caml_list_of_js_array
       ([caml_new_string("aliceblue"),
         caml_new_string("antiquewhite"),
         caml_new_string("aqua"),
         caml_new_string("aquamarine"),
         caml_new_string("azure"),
         caml_new_string("beige"),
         caml_new_string("bisque"),
         caml_new_string("black"),
         caml_new_string("blanchedalmond"),
         caml_new_string("blue"),
         caml_new_string("blueviolet"),
         caml_new_string("brown"),
         caml_new_string("burlywood"),
         caml_new_string("cadetblue"),
         caml_new_string("chartreuse"),
         caml_new_string("chocolate"),
         caml_new_string("coral"),
         caml_new_string("cornflowerblue"),
         caml_new_string("cornsilk"),
         caml_new_string("crimson"),
         caml_new_string("cyan"),
         caml_new_string("darkblue"),
         caml_new_string("darkcyan"),
         caml_new_string("darkgoldenrod"),
         caml_new_string("darkgray"),
         caml_new_string("darkgreen"),
         caml_new_string("darkgrey"),
         caml_new_string("darkkhaki"),
         caml_new_string("darkmagenta"),
         caml_new_string("darkolivegreen"),
         caml_new_string("darkorange"),
         caml_new_string("darkorchid"),
         caml_new_string("darkred"),
         caml_new_string("darksalmon"),
         caml_new_string("darkseagreen"),
         caml_new_string("darkslateblue"),
         caml_new_string("darkslategray"),
         caml_new_string("darkslategrey"),
         caml_new_string("darkturquoise"),
         caml_new_string("darkviolet"),
         caml_new_string("deeppink"),
         caml_new_string("deepskyblue"),
         caml_new_string("dimgray"),
         caml_new_string("dimgrey"),
         caml_new_string("dodgerblue"),
         caml_new_string("firebrick"),
         caml_new_string("floralwhite"),
         caml_new_string("forestgreen"),
         caml_new_string("fuchsia"),
         caml_new_string("gainsboro"),
         caml_new_string("ghostwhite"),
         caml_new_string("gold"),
         caml_new_string("goldenrod"),
         caml_new_string("gray"),
         caml_new_string("green"),
         caml_new_string("greenyellow"),
         caml_new_string("grey"),
         caml_new_string("honeydew"),
         caml_new_string("hotpink"),
         caml_new_string("indianred"),
         caml_new_string("indigo"),
         caml_new_string("ivory"),
         caml_new_string("khaki"),
         caml_new_string("lavender"),
         caml_new_string("lavenderblush"),
         caml_new_string("lawngreen"),
         caml_new_string("lemonchiffon"),
         caml_new_string("lightblue"),
         caml_new_string("lightcoral"),
         caml_new_string("lightcyan"),
         caml_new_string("lightgoldenrodyellow"),
         caml_new_string("lightgray"),
         caml_new_string("lightgreen"),
         caml_new_string("lightgrey"),
         caml_new_string("lightpink"),
         caml_new_string("lightsalmon"),
         caml_new_string("lightseagreen"),
         caml_new_string("lightskyblue"),
         caml_new_string("lightslategray"),
         caml_new_string("lightslategrey"),
         caml_new_string("lightsteelblue"),
         caml_new_string("lightyellow"),
         caml_new_string("lime"),
         caml_new_string("limegreen"),
         caml_new_string("linen"),
         caml_new_string("magenta"),
         caml_new_string("maroon"),
         caml_new_string("mediumaquamarine"),
         caml_new_string("mediumblue"),
         caml_new_string("mediumorchid"),
         caml_new_string("mediumpurple"),
         caml_new_string("mediumseagreen"),
         caml_new_string("mediumslateblue"),
         caml_new_string("mediumspringgreen"),
         caml_new_string("mediumturquoise"),
         caml_new_string("mediumvioletred"),
         caml_new_string("midnightblue"),
         caml_new_string("mintcream"),
         caml_new_string("mistyrose"),
         caml_new_string("moccasin"),
         caml_new_string("navajowhite"),
         caml_new_string("navy"),
         caml_new_string("oldlace"),
         caml_new_string("olive"),
         caml_new_string("olivedrab"),
         caml_new_string("orange"),
         caml_new_string("orangered"),
         caml_new_string("orchid"),
         caml_new_string("palegoldenrod"),
         caml_new_string("palegreen"),
         caml_new_string("paleturquoise"),
         caml_new_string("palevioletred"),
         caml_new_string("papayawhip"),
         caml_new_string("peachpuff"),
         caml_new_string("peru"),
         caml_new_string("pink"),
         caml_new_string("plum"),
         caml_new_string("powderblue"),
         caml_new_string("purple"),
         caml_new_string("red"),
         caml_new_string("rosybrown"),
         caml_new_string("royalblue"),
         caml_new_string("saddlebrown"),
         caml_new_string("salmon"),
         caml_new_string("sandybrown"),
         caml_new_string("seagreen"),
         caml_new_string("seashell"),
         caml_new_string("sienna"),
         caml_new_string("silver"),
         caml_new_string("skyblue"),
         caml_new_string("slateblue"),
         caml_new_string("slategray"),
         caml_new_string("slategrey"),
         caml_new_string("snow"),
         caml_new_string("springgreen"),
         caml_new_string("steelblue"),
         caml_new_string("tan"),
         caml_new_string("teal"),
         caml_new_string("thistle"),
         caml_new_string("tomato"),
         caml_new_string("turquoise"),
         caml_new_string("violet"),
         caml_new_string("wheat"),
         caml_new_string("white"),
         caml_new_string("whitesmoke"),
         caml_new_string("yellow"),
         caml_new_string("yellowgreen")]),
     _bN_=
      [0,
       [12,35,[4,8,[0,2,2],0,[4,8,[0,2,2],0,[4,8,[0,2,2],0,0]]]],
       caml_new_string("#%02X%02X%02X")],
     _bH_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,0,0,0,[12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,41,0]]]]]]],
       caml_new_string("rgb(%d,%d,%d)")],
     _bI_=
      [0,
       [11,
        caml_new_string("rgb("),
        [4,
         0,
         0,
         0,
         [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]]],
       caml_new_string("rgb(%d%%,%d%%,%d%%)")],
     _bJ_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,44,[4,0,0,0,[12,44,[8,0,0,0,[12,41,0]]]]]]]]],
       caml_new_string("rgba(%d,%d,%d,%f)")],
     _bK_=
      [0,
       [11,
        caml_new_string("rgba("),
        [4,
         0,
         0,
         0,
         [12,
          37,
          [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,44,partial]]]]]]]]]],
       caml_new_string("rgba(%d%%,%d%%,%d%%,%f)")],
     _bL_=
      [0,
       [11,
        caml_new_string("hsl("),
        [4,
         0,
         0,
         0,
         [12,44,[4,0,0,0,[12,37,[12,44,[4,0,0,0,[12,37,[12,41,0]]]]]]]]],
       caml_new_string("hsl(%d,%d%%,%d%%)")],
     _bM_=
      [0,
       [11,
        caml_new_string("hsla("),
        [4,
         0,
         0,
         0,
         [12,
          44,
          [4,
           0,
           0,
           0,
           [12,37,[12,44,[4,0,0,0,[12,37,[12,44,[8,0,0,0,partial$0]]]]]]]]]],
       caml_new_string("hsla(%d,%d%%,%d%%,%f)")],
     _e_=[0,240,248,255],
     _f_=[0,250,235,215],
     _g_=[0,0,255,255],
     _h_=[0,127,255,212],
     _i_=[0,240,255,255],
     _j_=[0,245,245,220],
     _k_=[0,255,228,196],
     _l_=[0,0,0,0],
     _m_=[0,255,235,205],
     _n_=[0,0,0,255],
     _o_=[0,138,43,226],
     _p_=[0,165,42,42],
     _q_=[0,222,184,135],
     _r_=[0,95,158,160],
     _s_=[0,127,255,0],
     _t_=[0,210,105,30],
     _u_=[0,255,127,80],
     _v_=[0,100,149,237],
     _w_=[0,255,248,220],
     _x_=[0,220,20,60],
     _y_=[0,0,255,255],
     _z_=[0,0,0,139],
     _A_=[0,0,139,139],
     _B_=[0,184,134,11],
     _C_=[0,169,169,169],
     _D_=[0,0,100,0],
     _E_=[0,169,169,169],
     _F_=[0,189,183,107],
     _G_=[0,139,0,139],
     _H_=[0,85,107,47],
     _I_=[0,255,140,0],
     _J_=[0,153,50,204],
     _K_=[0,139,0,0],
     _L_=[0,233,150,122],
     _M_=[0,143,188,143],
     _N_=[0,72,61,139],
     _O_=[0,47,79,79],
     _P_=[0,47,79,79],
     _Q_=[0,0,206,209],
     _R_=[0,148,0,211],
     _S_=[0,255,20,147],
     _T_=[0,0,191,255],
     _U_=[0,105,105,105],
     _V_=[0,105,105,105],
     _W_=[0,30,144,255],
     _X_=[0,178,34,34],
     _Y_=[0,255,250,240],
     _Z_=[0,34,139,34],
     ___=[0,255,0,255],
     _$_=[0,220,220,220],
     _aa_=[0,248,248,255],
     _ab_=[0,255,215,0],
     _ac_=[0,218,165,32],
     _ad_=[0,128,128,128],
     _ae_=[0,128,128,128],
     _af_=[0,0,128,0],
     _ag_=[0,173,255,47],
     _ah_=[0,240,255,240],
     _ai_=[0,255,105,180],
     _aj_=[0,205,92,92],
     _ak_=[0,75,0,130],
     _al_=[0,255,255,240],
     _am_=[0,240,230,140],
     _an_=[0,230,230,250],
     _ao_=[0,255,240,245],
     _ap_=[0,124,252,0],
     _aq_=[0,255,250,205],
     _ar_=[0,173,216,230],
     _as_=[0,240,128,128],
     _at_=[0,224,255,255],
     _au_=[0,250,250,210],
     _av_=[0,211,211,211],
     _aw_=[0,144,238,144],
     _ax_=[0,211,211,211],
     _ay_=[0,255,182,193],
     _az_=[0,255,160,122],
     _aA_=[0,32,178,170],
     _aB_=[0,135,206,250],
     _aC_=[0,119,136,153],
     _aD_=[0,119,136,153],
     _aE_=[0,176,196,222],
     _aF_=[0,255,255,224],
     _aG_=[0,0,255,0],
     _aH_=[0,50,205,50],
     _aI_=[0,250,240,230],
     _aJ_=[0,255,0,255],
     _aK_=[0,128,0,0],
     _aL_=[0,102,205,170],
     _aM_=[0,0,0,205],
     _aN_=[0,186,85,211],
     _aO_=[0,147,112,219],
     _aP_=[0,60,179,113],
     _aQ_=[0,123,104,238],
     _aR_=[0,0,250,154],
     _aS_=[0,72,209,204],
     _aT_=[0,199,21,133],
     _aU_=[0,25,25,112],
     _aV_=[0,245,255,250],
     _aW_=[0,255,228,225],
     _aX_=[0,255,228,181],
     _aY_=[0,255,222,173],
     _aZ_=[0,0,0,128],
     _a0_=[0,253,245,230],
     _a1_=[0,128,128,0],
     _a2_=[0,107,142,35],
     _a3_=[0,255,165,0],
     _a4_=[0,255,69,0],
     _a5_=[0,218,112,214],
     _a6_=[0,238,232,170],
     _a7_=[0,152,251,152],
     _a8_=[0,175,238,238],
     _a9_=[0,219,112,147],
     _a__=[0,255,239,213],
     _a$_=[0,255,218,185],
     _ba_=[0,205,133,63],
     _bb_=[0,255,192,203],
     _bc_=[0,221,160,221],
     _bd_=[0,176,224,230],
     _be_=[0,128,0,128],
     _bf_=[0,255,0,0],
     _bg_=[0,188,143,143],
     _bh_=[0,65,105,225],
     _bi_=[0,139,69,19],
     _bj_=[0,250,128,114],
     _bk_=[0,244,164,96],
     _bl_=[0,46,139,87],
     _bm_=[0,255,245,238],
     _bn_=[0,160,82,45],
     _bo_=[0,192,192,192],
     _bp_=[0,135,206,235],
     _bq_=[0,106,90,205],
     _br_=[0,112,128,144],
     _bs_=[0,112,128,144],
     _bt_=[0,255,250,250],
     _bu_=[0,0,255,127],
     _bv_=[0,70,130,180],
     _bw_=[0,210,180,140],
     _bx_=[0,0,128,128],
     _by_=[0,216,191,216],
     _bz_=[0,255,99,71],
     _bA_=[0,64,224,208],
     _bB_=[0,238,130,238],
     _bC_=[0,245,222,179],
     _bD_=[0,255,255,255],
     _bE_=[0,245,245,245],
     _bF_=[0,255,255,0],
     _bG_=[0,154,205,50],
     _b7_=[0,caml_new_string("lib/dom.ml"),276,66],
     _b8_=[0,caml_new_string("transparent")],
     _b9_=[0,caml_new_string("native")],
     _cb_=[0,caml_new_string("lib/dom_html.ml"),1657,57],
     _ca_=[0,caml_new_string("lib/dom_html.ml"),1656,59],
     _b$_=
      [0,
       [11,
        caml_new_string("getElementById_exn: "),
        [3,0,[11,caml_new_string(" not found"),0]]],
       caml_new_string("getElementById_exn: %S not found")],
     _ce_=[0,caml_new_string("lib/form.ml"),172,9],
     _cd_=[0,1],
     _ch_=[0,caml_new_string(""),0],
     _cm_=[0,caml_new_string("lib/xmlHttpRequest.ml"),86,2];
    function return$0(_gG_){return _gG_}
    function map(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function bind(x,f){return x == no_handler?no_handler:caml_call1(f,x)}
    function test(x){return 1 - (x == no_handler?1:0)}
    function iter(x,f)
     {var _gF_=1 - (x == no_handler?1:0);return _gF_?caml_call1(f,x):_gF_}
    function case$0(x,f,g)
     {return x == no_handler?caml_call1(f,0):caml_call1(g,x)}
    function get(x,f){return x == no_handler?caml_call1(f,0):x}
    function option(x){if(x){var x$0=x[1];return x$0}return no_handler}
    function to_option(x)
     {function _gE_(x){return [0,x]}
      return case$0(x,function(param){return 0},_gE_)}
    var
     Opt=
      [0,no_handler,return$0,map,bind,test,iter,case$0,get,option,to_option];
    function return$1(_gD_){return _gD_}
    function map$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function bind$0(x,f){return x === t37?t37:caml_call1(f,x)}
    function test$0(x){return x !== t37?1:0}
    function iter$0(x,f)
     {var _gC_=x !== t37?1:0;return _gC_?caml_call1(f,x):_gC_}
    function case$1(x,f,g){return x === t37?caml_call1(f,0):caml_call1(g,x)}
    function get$0(x,f){return x === t37?caml_call1(f,0):x}
    function option$0(x){if(x){var x$0=x[1];return x$0}return t37}
    function to_option$0(x)
     {function _gB_(x){return [0,x]}
      return case$1(x,function(param){return 0},_gB_)}
    var
     Optdef=
      [0,
       t37,
       return$1,
       map$0,
       bind$0,
       test$0,
       iter$0,
       case$1,
       get$0,
       option$0,
       to_option$0];
    function coerce(x,f,g)
     {function _gz_(param){return caml_call1(g,x)}
      var _gA_=caml_call1(f,x);
      return caml_call2(Opt[8],_gA_,_gz_)}
    function coerce_opt(x,f,g)
     {function _gx_(param){return caml_call1(g,x)}
      var _gy_=caml_call2(Opt[4],x,f);
      return caml_call2(Opt[8],_gy_,_gx_)}
    var
     true$0=true,
     false$0=false,
     string_constr=Unsafe[1].String,
     regExp_withFlags=Unsafe[1].RegExp,
     object_constructor=Unsafe[1].Object;
    function object_keys(o){return object_constructor.keys(o)}
    var
     array_length=Unsafe[1].Array,
     array_get=caml_js_get,
     array_set=caml_js_set;
    function array_map(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call1(f,x)}))}
    function array_mapi(f,a)
     {return a.map
              (caml_js_wrap_callback
                (function(x,idx,param){return caml_call2(f,idx,x)}))}
    function str_array(_gw_){return _gw_}
    function match_result(_gv_){return _gv_}
    var
     date_ms=Unsafe[1].Date,
     math=Unsafe[1].Math,
     Error=[248,cst_Js_Error,caml_fresh_oo_id(0)],
     error_constr=Unsafe[1].Error;
    caml_call2(Callback[2],cst_jsError,[0,Error,{}]);
    function raise_js_error(exn){throw exn}
    var JSON=Unsafe[1].JSON;
    function decodeURI(s){return Unsafe[1].decodeURI(s)}
    function decodeURIComponent(s){return Unsafe[1].decodeURIComponent(s)}
    function encodeURI(s){return Unsafe[1].encodeURI(s)}
    function encodeURIComponent(s){return Unsafe[1].encodeURIComponent(s)}
    function escape(s){return Unsafe[1].escape(s)}
    function unescape(s){return Unsafe[1].unescape(s)}
    function isNaN(i){return Unsafe[1].isNaN(i) | 0}
    function parseInt(s)
     {var s$0=Unsafe[1].parseInt(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseInt):s$0}
    function parseFloat(s)
     {var s$0=Unsafe[1].parseFloat(s);
      return isNaN(s$0)?caml_call1(Pervasives[2],cst_parseFloat):s$0}
    function _a_(param)
     {if(param[1] === Error)
       {var e=param[2];return [0,caml_js_to_string(e.toString())]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function _b_(e)
     {return e instanceof array_length?0:[0,caml_js_to_string(e.toString())]}
    caml_call1(Printexc[8],_b_);
    function string_of_error(e){return caml_js_to_string(e.toString())}
    function export_js(field,x)
     {return runtime.caml_js_export_var(0)[field] = x}
    function export$0(field,x){return export_js(field.toString(),x)}
    function export_all(obj)
     {var keys=object_keys(obj);
      return keys.forEach
              (caml_js_wrap_callback
                (function(key,param,_gu_){return export_js(key,obj[key])}))}
    function _c_(_gt_){return _gt_}
    var
     Js=
      [0,
       no_handler,
       function(_gs_){return _gs_},
       t37,
       _c_,
       Opt,
       Optdef,
       true$0,
       false$0,
       string_constr,
       regExp_withFlags,
       regExp_withFlags,
       regExp_withFlags,
       object_keys,
       array_length,
       array_length,
       array_get,
       array_set,
       array_map,
       array_mapi,
       str_array,
       match_result,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       date_ms,
       math,
       error_constr,
       string_of_error,
       raise_js_error,
       Error,
       JSON,
       decodeURI,
       decodeURIComponent,
       encodeURI,
       encodeURIComponent,
       escape,
       unescape,
       isNaN,
       parseInt,
       parseFloat,
       coerce,
       coerce_opt,
       export$0,
       export_all,
       Unsafe];
    caml_register_global(1609,Js,"Js");
    function regexp(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"g")}
    function regexp_case_fold(s)
     {return new regExp_withFlags(caml_jsbytes_of_string(s),"gi")}
    function regexp_with_flag(s,f)
     {var _gr_=caml_call2(Pervasives[16],cst_g,f).toString();
      return new regExp_withFlags(caml_jsbytes_of_string(s),_gr_)}
    function blunt_str_array_get(a,i)
     {function _gq_(param){throw [0,Assert_failure,_d_]}
      return caml_js_to_byte_string(caml_call2(Optdef[8],a[i],_gq_))}
    function string_match(r,s,i)
     {r.lastIndex = i;
      var
       _go_=r.exec(caml_jsbytes_of_string(s)),
       _gp_=caml_call2(Opt[3],_go_,match_result);
      return caml_call1(Opt[10],_gp_)}
    function search_forward(r,s,i)
     {r.lastIndex = i;
      function _gl_(res){return [0,res.index,res]}
      var
       _gm_=r.exec(caml_jsbytes_of_string(s)),
       _gn_=caml_call2(Opt[3],_gm_,_gl_);
      return caml_call1(Opt[10],_gn_)}
    function matched_string(r){return blunt_str_array_get(r,0)}
    function matched_group(r,i)
     {var _gk_=caml_call2(Optdef[3],r[i],caml_js_to_byte_string);
      return caml_call1(Optdef[10],_gk_)}
    var quote_repl_re=new regExp_withFlags("[$]","g");
    function quote_repl(s)
     {return caml_jsbytes_of_string(s).replace(quote_repl_re,"$$$$")}
    function global_replace(r,s,s_by)
     {r.lastIndex = 0;
      var _gj_=quote_repl(s_by);
      return caml_js_to_byte_string(caml_jsbytes_of_string(s).replace(r,_gj_))}
    function replace_first(r,s,s_by)
     {var
       match=r.ignoreCase | 0,
       match$0=r.multiline | 0,
       flags=0 === match?0 === match$0?"":"m":0 === match$0?"i":"mi",
       r$0=new regExp_withFlags(r.source,flags),
       _gi_=quote_repl(s_by);
      return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(r$0,_gi_))}
    function list_of_js_array(a)
     {var idx$1=a.length - 1 | 0,accu=0,idx=idx$1;
      for(;;)
       {if(0 <= idx)
         {var
           idx$0=idx - 1 | 0,
           accu$0=[0,blunt_str_array_get(a,idx),accu],
           accu=accu$0,
           idx=idx$0;
          continue}
        return accu}}
    function split(r,s)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r))}
    function bounded_split(r,s,i)
     {r.lastIndex = 0;
      return list_of_js_array(caml_jsbytes_of_string(s).split(r,i))}
    var quote_re=regexp(cst);
    function quote(s)
     {return caml_js_to_byte_string
              (caml_jsbytes_of_string(s).replace(quote_re,"\\$&"))}
    function regexp_string(s){return regexp(quote(s))}
    function regexp_string_case_fold(s){return regexp_case_fold(quote(s))}
    var
     Regexp=
      [0,
       regexp,
       regexp_case_fold,
       regexp_with_flag,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_forward,
       matched_string,
       matched_group,
       global_replace,
       replace_first,
       split,
       bounded_split];
    caml_register_global(1611,Regexp,"Regexp");
    function string_of_name(param)
     {var _gh_=param;
      if(74 <= _gh_)
       {if(111 <= _gh_)
         switch(_gh_)
          {case 111:return cst_palevioletred;
           case 112:return cst_papayawhip;
           case 113:return cst_peachpuff;
           case 114:return cst_peru;
           case 115:return cst_pink;
           case 116:return cst_plum;
           case 117:return cst_powderblue;
           case 118:return cst_purple;
           case 119:return cst_red;
           case 120:return cst_rosybrown;
           case 121:return cst_royalblue;
           case 122:return cst_saddlebrown;
           case 123:return cst_salmon;
           case 124:return cst_sandybrown;
           case 125:return cst_seagreen;
           case 126:return cst_seashell;
           case 127:return cst_sienna;
           case 128:return cst_silver;
           case 129:return cst_skyblue;
           case 130:return cst_slateblue;
           case 131:return cst_slategray;
           case 132:return cst_slategrey;
           case 133:return cst_snow;
           case 134:return cst_springgreen;
           case 135:return cst_steelblue;
           case 136:return cst_tan;
           case 137:return cst_teal;
           case 138:return cst_thistle;
           case 139:return cst_tomato;
           case 140:return cst_turquoise;
           case 141:return cst_violet;
           case 142:return cst_wheat;
           case 143:return cst_white;
           case 144:return cst_whitesmoke;
           case 145:return cst_yellow;
           default:return cst_yellowgreen}
        switch(_gh_)
         {case 74:return cst_lightpink;
          case 75:return cst_lightsalmon;
          case 76:return cst_lightseagreen;
          case 77:return cst_lightskyblue;
          case 78:return cst_lightslategray;
          case 79:return cst_lightslategrey;
          case 80:return cst_lightsteelblue;
          case 81:return cst_lightyellow;
          case 82:return cst_lime;
          case 83:return cst_limegreen;
          case 84:return cst_linen;
          case 85:return cst_magenta;
          case 86:return cst_maroon;
          case 87:return cst_mediumaquamarine;
          case 88:return cst_mediumblue;
          case 89:return cst_mediumorchid;
          case 90:return cst_mediumpurple;
          case 91:return cst_mediumseagreen;
          case 92:return cst_mediumslateblue;
          case 93:return cst_mediumspringgreen;
          case 94:return cst_mediumturquoise;
          case 95:return cst_mediumvioletred;
          case 96:return cst_midnightblue;
          case 97:return cst_mintcream;
          case 98:return cst_mistyrose;
          case 99:return cst_moccasin;
          case 100:return cst_navajowhite;
          case 101:return cst_navy;
          case 102:return cst_oldlace;
          case 103:return cst_olive;
          case 104:return cst_olivedrab;
          case 105:return cst_orange;
          case 106:return cst_orangered;
          case 107:return cst_orchid;
          case 108:return cst_palegoldenrod;
          case 109:return cst_palegreen;
          default:return cst_paleturquoise}}
      if(37 <= _gh_)
       switch(_gh_)
        {case 37:return cst_darkslategrey;
         case 38:return cst_darkturquoise;
         case 39:return cst_darkviolet;
         case 40:return cst_deeppink;
         case 41:return cst_deepskyblue;
         case 42:return cst_dimgray;
         case 43:return cst_dimgrey;
         case 44:return cst_dodgerblue;
         case 45:return cst_firebrick;
         case 46:return cst_floralwhite;
         case 47:return cst_forestgreen;
         case 48:return cst_fuchsia;
         case 49:return cst_gainsboro;
         case 50:return cst_ghostwhite;
         case 51:return cst_gold;
         case 52:return cst_goldenrod;
         case 53:return cst_gray;
         case 54:return cst_grey;
         case 55:return cst_green;
         case 56:return cst_greenyellow;
         case 57:return cst_honeydew;
         case 58:return cst_hotpink;
         case 59:return cst_indianred;
         case 60:return cst_indigo;
         case 61:return cst_ivory;
         case 62:return cst_khaki;
         case 63:return cst_lavender;
         case 64:return cst_lavenderblush;
         case 65:return cst_lawngreen;
         case 66:return cst_lemonchiffon;
         case 67:return cst_lightblue;
         case 68:return cst_lightcoral;
         case 69:return cst_lightcyan;
         case 70:return cst_lightgoldenrodyellow;
         case 71:return cst_lightgray;
         case 72:return cst_lightgreen;
         default:return cst_lightgrey}
      switch(_gh_)
       {case 0:return cst_aliceblue;
        case 1:return cst_antiquewhite;
        case 2:return cst_aqua;
        case 3:return cst_aquamarine;
        case 4:return cst_azure;
        case 5:return cst_beige;
        case 6:return cst_bisque;
        case 7:return cst_black;
        case 8:return cst_blanchedalmond;
        case 9:return cst_blue;
        case 10:return cst_blueviolet;
        case 11:return cst_brown;
        case 12:return cst_burlywood;
        case 13:return cst_cadetblue;
        case 14:return cst_chartreuse;
        case 15:return cst_chocolate;
        case 16:return cst_coral;
        case 17:return cst_cornflowerblue;
        case 18:return cst_cornsilk;
        case 19:return cst_crimson;
        case 20:return cst_cyan;
        case 21:return cst_darkblue;
        case 22:return cst_darkcyan;
        case 23:return cst_darkgoldenrod;
        case 24:return cst_darkgray;
        case 25:return cst_darkgreen;
        case 26:return cst_darkgrey;
        case 27:return cst_darkkhaki;
        case 28:return cst_darkmagenta;
        case 29:return cst_darkolivegreen;
        case 30:return cst_darkorange;
        case 31:return cst_darkorchid;
        case 32:return cst_darkred;
        case 33:return cst_darksalmon;
        case 34:return cst_darkseagreen;
        case 35:return cst_darkslateblue;
        default:return cst_darkslategray}}
    function name_of_string(s)
     {var switch$0=caml_string_compare(s,cst_lightgrey$0);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 73;
        var switch$1=caml_string_compare(s,cst_paleturquoise$0);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 110;
          var switch$2=caml_string_compare(s,cst_skyblue$0);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 129;
            var switch$3=caml_string_compare(s,cst_thistle$0);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 138;
              if(! caml_string_notequal(s,cst_tomato$0))return 139;
              if(! caml_string_notequal(s,cst_turquoise$0))return 140;
              if(! caml_string_notequal(s,cst_violet$0))return 141;
              if(! caml_string_notequal(s,cst_wheat$0))return 142;
              if(! caml_string_notequal(s,cst_white$0))return 143;
              if(! caml_string_notequal(s,cst_whitesmoke$0))return 144;
              if(! caml_string_notequal(s,cst_yellow$0))return 145;
              if(! caml_string_notequal(s,cst_yellowgreen$0))return 146}
            else
             {if(! caml_string_notequal(s,cst_slateblue$0))return 130;
              if(! caml_string_notequal(s,cst_slategray$0))return 131;
              if(! caml_string_notequal(s,cst_slategrey$0))return 132;
              if(! caml_string_notequal(s,cst_snow$0))return 133;
              if(! caml_string_notequal(s,cst_springgreen$0))return 134;
              if(! caml_string_notequal(s,cst_steelblue$0))return 135;
              if(! caml_string_notequal(s,cst_tan$0))return 136;
              if(! caml_string_notequal(s,cst_teal$0))return 137}}
          else
           {var switch$4=caml_string_compare(s,cst_rosybrown$0);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 120;
              if(! caml_string_notequal(s,cst_royalblue$0))return 121;
              if(! caml_string_notequal(s,cst_saddlebrown$0))return 122;
              if(! caml_string_notequal(s,cst_salmon$0))return 123;
              if(! caml_string_notequal(s,cst_sandybrown$0))return 124;
              if(! caml_string_notequal(s,cst_seagreen$0))return 125;
              if(! caml_string_notequal(s,cst_seashell$0))return 126;
              if(! caml_string_notequal(s,cst_sienna$0))return 127;
              if(! caml_string_notequal(s,cst_silver$0))return 128}
            else
             {if(! caml_string_notequal(s,cst_palevioletred$0))return 111;
              if(! caml_string_notequal(s,cst_papayawhip$0))return 112;
              if(! caml_string_notequal(s,cst_peachpuff$0))return 113;
              if(! caml_string_notequal(s,cst_peru$0))return 114;
              if(! caml_string_notequal(s,cst_pink$0))return 115;
              if(! caml_string_notequal(s,cst_plum$0))return 116;
              if(! caml_string_notequal(s,cst_powderblue$0))return 117;
              if(! caml_string_notequal(s,cst_purple$0))return 118;
              if(! caml_string_notequal(s,cst_red$0))return 119}}}
        else
         {var switch$5=caml_string_compare(s,cst_mediumslateblue$0);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 92;
            var switch$6=caml_string_compare(s,cst_navy$0);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 101;
              if(! caml_string_notequal(s,cst_oldlace$0))return 102;
              if(! caml_string_notequal(s,cst_olive$0))return 103;
              if(! caml_string_notequal(s,cst_olivedrab$0))return 104;
              if(! caml_string_notequal(s,cst_orange$0))return 105;
              if(! caml_string_notequal(s,cst_orangered$0))return 106;
              if(! caml_string_notequal(s,cst_orchid$0))return 107;
              if(! caml_string_notequal(s,cst_palegoldenrod$0))return 108;
              if(! caml_string_notequal(s,cst_palegreen$0))return 109}
            else
             {if(! caml_string_notequal(s,cst_mediumspringgreen$0))return 93;
              if(! caml_string_notequal(s,cst_mediumturquoise$0))return 94;
              if(! caml_string_notequal(s,cst_mediumvioletred$0))return 95;
              if(! caml_string_notequal(s,cst_midnightblue$0))return 96;
              if(! caml_string_notequal(s,cst_mintcream$0))return 97;
              if(! caml_string_notequal(s,cst_mistyrose$0))return 98;
              if(! caml_string_notequal(s,cst_moccasin$0))return 99;
              if(! caml_string_notequal(s,cst_navajowhite$0))return 100}}
          else
           {var switch$7=caml_string_compare(s,cst_limegreen$0);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 83;
              if(! caml_string_notequal(s,cst_linen$0))return 84;
              if(! caml_string_notequal(s,cst_magenta$0))return 85;
              if(! caml_string_notequal(s,cst_maroon$0))return 86;
              if(! caml_string_notequal(s,cst_mediumaquamarine$0))return 87;
              if(! caml_string_notequal(s,cst_mediumblue$0))return 88;
              if(! caml_string_notequal(s,cst_mediumorchid$0))return 89;
              if(! caml_string_notequal(s,cst_mediumpurple$0))return 90;
              if(! caml_string_notequal(s,cst_mediumseagreen$0))return 91}
            else
             {if(! caml_string_notequal(s,cst_lightpink$0))return 74;
              if(! caml_string_notequal(s,cst_lightsalmon$0))return 75;
              if(! caml_string_notequal(s,cst_lightseagreen$0))return 76;
              if(! caml_string_notequal(s,cst_lightskyblue$0))return 77;
              if(! caml_string_notequal(s,cst_lightslategray$0))return 78;
              if(! caml_string_notequal(s,cst_lightslategrey$0))return 79;
              if(! caml_string_notequal(s,cst_lightsteelblue$0))return 80;
              if(! caml_string_notequal(s,cst_lightyellow$0))return 81;
              if(! caml_string_notequal(s,cst_lime$0))return 82}}}}
      else
       {var switch$8=caml_string_compare(s,cst_darkslategray$0);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 36;
          var switch$9=caml_string_compare(s,cst_greenyellow$0);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 56;
            var switch$10=caml_string_compare(s,cst_lavenderblush$0);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 64;
              if(! caml_string_notequal(s,cst_lawngreen$0))return 65;
              if(! caml_string_notequal(s,cst_lemonchiffon$0))return 66;
              if(! caml_string_notequal(s,cst_lightblue$0))return 67;
              if(! caml_string_notequal(s,cst_lightcoral$0))return 68;
              if(! caml_string_notequal(s,cst_lightcyan$0))return 69;
              if(! caml_string_notequal(s,cst_lightgoldenrodyellow$0))
               return 70;
              if(! caml_string_notequal(s,cst_lightgray$0))return 71;
              if(! caml_string_notequal(s,cst_lightgreen$0))return 72}
            else
             {if(! caml_string_notequal(s,cst_grey$0))return 54;
              if(! caml_string_notequal(s,cst_honeydew$0))return 57;
              if(! caml_string_notequal(s,cst_hotpink$0))return 58;
              if(! caml_string_notequal(s,cst_indianred$0))return 59;
              if(! caml_string_notequal(s,cst_indigo$0))return 60;
              if(! caml_string_notequal(s,cst_ivory$0))return 61;
              if(! caml_string_notequal(s,cst_khaki$0))return 62;
              if(! caml_string_notequal(s,cst_lavender$0))return 63}}
          else
           {var switch$11=caml_string_compare(s,cst_floralwhite$0);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 46;
              if(! caml_string_notequal(s,cst_forestgreen$0))return 47;
              if(! caml_string_notequal(s,cst_fuchsia$0))return 48;
              if(! caml_string_notequal(s,cst_gainsboro$0))return 49;
              if(! caml_string_notequal(s,cst_ghostwhite$0))return 50;
              if(! caml_string_notequal(s,cst_gold$0))return 51;
              if(! caml_string_notequal(s,cst_goldenrod$0))return 52;
              if(! caml_string_notequal(s,cst_gray$0))return 53;
              if(! caml_string_notequal(s,cst_green$0))return 55}
            else
             {if(! caml_string_notequal(s,cst_darkslategrey$0))return 37;
              if(! caml_string_notequal(s,cst_darkturquoise$0))return 38;
              if(! caml_string_notequal(s,cst_darkviolet$0))return 39;
              if(! caml_string_notequal(s,cst_deeppink$0))return 40;
              if(! caml_string_notequal(s,cst_deepskyblue$0))return 41;
              if(! caml_string_notequal(s,cst_dimgray$0))return 42;
              if(! caml_string_notequal(s,cst_dimgrey$0))return 43;
              if(! caml_string_notequal(s,cst_dodgerblue$0))return 44;
              if(! caml_string_notequal(s,cst_firebrick$0))return 45}}}
        else
         {var switch$12=caml_string_compare(s,cst_cornsilk$0);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 18;
            var switch$13=caml_string_compare(s,cst_darkkhaki$0);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 27;
              if(! caml_string_notequal(s,cst_darkmagenta$0))return 28;
              if(! caml_string_notequal(s,cst_darkolivegreen$0))return 29;
              if(! caml_string_notequal(s,cst_darkorange$0))return 30;
              if(! caml_string_notequal(s,cst_darkorchid$0))return 31;
              if(! caml_string_notequal(s,cst_darkred$0))return 32;
              if(! caml_string_notequal(s,cst_darksalmon$0))return 33;
              if(! caml_string_notequal(s,cst_darkseagreen$0))return 34;
              if(! caml_string_notequal(s,cst_darkslateblue$0))return 35}
            else
             {if(! caml_string_notequal(s,cst_crimson$0))return 19;
              if(! caml_string_notequal(s,cst_cyan$0))return 20;
              if(! caml_string_notequal(s,cst_darkblue$0))return 21;
              if(! caml_string_notequal(s,cst_darkcyan$0))return 22;
              if(! caml_string_notequal(s,cst_darkgoldenrod$0))return 23;
              if(! caml_string_notequal(s,cst_darkgray$0))return 24;
              if(! caml_string_notequal(s,cst_darkgreen$0))return 25;
              if(! caml_string_notequal(s,cst_darkgrey$0))return 26}}
          else
           {var switch$14=caml_string_compare(s,cst_blue$0);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 9;
              if(! caml_string_notequal(s,cst_blueviolet$0))return 10;
              if(! caml_string_notequal(s,cst_brown$0))return 11;
              if(! caml_string_notequal(s,cst_burlywood$0))return 12;
              if(! caml_string_notequal(s,cst_cadetblue$0))return 13;
              if(! caml_string_notequal(s,cst_chartreuse$0))return 14;
              if(! caml_string_notequal(s,cst_chocolate$0))return 15;
              if(! caml_string_notequal(s,cst_coral$0))return 16;
              if(! caml_string_notequal(s,cst_cornflowerblue$0))return 17}
            else
             {if(! caml_string_notequal(s,cst_aliceblue$0))return 0;
              if(! caml_string_notequal(s,cst_antiquewhite$0))return 1;
              if(! caml_string_notequal(s,cst_aqua$0))return 2;
              if(! caml_string_notequal(s,cst_aquamarine$0))return 3;
              if(! caml_string_notequal(s,cst_azure$0))return 4;
              if(! caml_string_notequal(s,cst_beige$0))return 5;
              if(! caml_string_notequal(s,cst_bisque$0))return 6;
              if(! caml_string_notequal(s,cst_black$0))return 7;
              if(! caml_string_notequal(s,cst_blanchedalmond$0))return 8}}}}
      throw [0,
             Invalid_argument,
             caml_call2(Pervasives[16],s,cst_is_not_a_valid_color_name)]}
    function rgb_of_name(param)
     {var _gg_=param;
      if(74 <= _gg_)
       {if(111 <= _gg_)
         switch(_gg_)
          {case 111:return _a9_;
           case 112:return _a__;
           case 113:return _a$_;
           case 114:return _ba_;
           case 115:return _bb_;
           case 116:return _bc_;
           case 117:return _bd_;
           case 118:return _be_;
           case 119:return _bf_;
           case 120:return _bg_;
           case 121:return _bh_;
           case 122:return _bi_;
           case 123:return _bj_;
           case 124:return _bk_;
           case 125:return _bl_;
           case 126:return _bm_;
           case 127:return _bn_;
           case 128:return _bo_;
           case 129:return _bp_;
           case 130:return _bq_;
           case 131:return _br_;
           case 132:return _bs_;
           case 133:return _bt_;
           case 134:return _bu_;
           case 135:return _bv_;
           case 136:return _bw_;
           case 137:return _bx_;
           case 138:return _by_;
           case 139:return _bz_;
           case 140:return _bA_;
           case 141:return _bB_;
           case 142:return _bC_;
           case 143:return _bD_;
           case 144:return _bE_;
           case 145:return _bF_;
           default:return _bG_}
        switch(_gg_)
         {case 74:return _ay_;
          case 75:return _az_;
          case 76:return _aA_;
          case 77:return _aB_;
          case 78:return _aC_;
          case 79:return _aD_;
          case 80:return _aE_;
          case 81:return _aF_;
          case 82:return _aG_;
          case 83:return _aH_;
          case 84:return _aI_;
          case 85:return _aJ_;
          case 86:return _aK_;
          case 87:return _aL_;
          case 88:return _aM_;
          case 89:return _aN_;
          case 90:return _aO_;
          case 91:return _aP_;
          case 92:return _aQ_;
          case 93:return _aR_;
          case 94:return _aS_;
          case 95:return _aT_;
          case 96:return _aU_;
          case 97:return _aV_;
          case 98:return _aW_;
          case 99:return _aX_;
          case 100:return _aY_;
          case 101:return _aZ_;
          case 102:return _a0_;
          case 103:return _a1_;
          case 104:return _a2_;
          case 105:return _a3_;
          case 106:return _a4_;
          case 107:return _a5_;
          case 108:return _a6_;
          case 109:return _a7_;
          default:return _a8_}}
      if(37 <= _gg_)
       switch(_gg_)
        {case 37:return _P_;
         case 38:return _Q_;
         case 39:return _R_;
         case 40:return _S_;
         case 41:return _T_;
         case 42:return _U_;
         case 43:return _V_;
         case 44:return _W_;
         case 45:return _X_;
         case 46:return _Y_;
         case 47:return _Z_;
         case 48:return ___;
         case 49:return _$_;
         case 50:return _aa_;
         case 51:return _ab_;
         case 52:return _ac_;
         case 53:return _ad_;
         case 54:return _ae_;
         case 55:return _af_;
         case 56:return _ag_;
         case 57:return _ah_;
         case 58:return _ai_;
         case 59:return _aj_;
         case 60:return _ak_;
         case 61:return _al_;
         case 62:return _am_;
         case 63:return _an_;
         case 64:return _ao_;
         case 65:return _ap_;
         case 66:return _aq_;
         case 67:return _ar_;
         case 68:return _as_;
         case 69:return _at_;
         case 70:return _au_;
         case 71:return _av_;
         case 72:return _aw_;
         default:return _ax_}
      switch(_gg_)
       {case 0:return _e_;
        case 1:return _f_;
        case 2:return _g_;
        case 3:return _h_;
        case 4:return _i_;
        case 5:return _j_;
        case 6:return _k_;
        case 7:return _l_;
        case 8:return _m_;
        case 9:return _n_;
        case 10:return _o_;
        case 11:return _p_;
        case 12:return _q_;
        case 13:return _r_;
        case 14:return _s_;
        case 15:return _t_;
        case 16:return _u_;
        case 17:return _v_;
        case 18:return _w_;
        case 19:return _x_;
        case 20:return _y_;
        case 21:return _z_;
        case 22:return _A_;
        case 23:return _B_;
        case 24:return _C_;
        case 25:return _D_;
        case 26:return _E_;
        case 27:return _F_;
        case 28:return _G_;
        case 29:return _H_;
        case 30:return _I_;
        case 31:return _J_;
        case 32:return _K_;
        case 33:return _L_;
        case 34:return _M_;
        case 35:return _N_;
        default:return _O_}}
    function rgb(a,r,g,b)
     {if(a){var a$0=a[1];return [3,[0,r,g,b,a$0]]}return [1,[0,r,g,b]]}
    function hsl(a,h,s,l)
     {if(a){var a$0=a[1];return [6,[0,h,s,l,a$0]]}return [5,[0,h,s,l]]}
    function string_of_t(param)
     {switch(param[0])
       {case 0:var n=param[1];return string_of_name(n);
        case 1:
         var match=param[1],b=match[3],g=match[2],r=match[1];
         return caml_call4(Printf[4],_bH_,r,g,b);
        case 2:
         var match$0=param[1],b$0=match$0[3],g$0=match$0[2],r$0=match$0[1];
         return caml_call4(Printf[4],_bI_,r$0,g$0,b$0);
        case 3:
         var
          match$1=param[1],
          a=match$1[4],
          b$1=match$1[3],
          g$1=match$1[2],
          r$1=match$1[1];
         return caml_call5(Printf[4],_bJ_,r$1,g$1,b$1,a);
        case 4:
         var
          match$2=param[1],
          a$0=match$2[4],
          b$2=match$2[3],
          g$2=match$2[2],
          r$2=match$2[1];
         return caml_call5(Printf[4],_bK_,r$2,g$2,b$2,a$0);
        case 5:
         var match$3=param[1],l=match$3[3],s=match$3[2],h=match$3[1];
         return caml_call4(Printf[4],_bL_,h,s,l);
        default:
         var
          match$4=param[1],
          a$1=match$4[4],
          l$0=match$4[3],
          s$0=match$4[2],
          h$0=match$4[1];
         return caml_call5(Printf[4],_bM_,h$0,s$0,l$0,a$1)}}
    function hex_of_rgb(param)
     {var blue=param[3],green=param[2],red=param[1];
      function in_range(i)
       {var _gd_=i < 0?1:0,_ge_=_gd_ || (255 < i?1:0);
        if(_ge_)
         {var _gf_=caml_call1(Pervasives[21],i);
          throw [0,
                 Invalid_argument,
                 caml_call2(Pervasives[16],_gf_,cst_is_out_of_valid_range)]}
        return _ge_}
      in_range(red);
      in_range(green);
      in_range(blue);
      return caml_call4(Printf[4],_bN_,red,green,blue)}
    function js_t_of_js_string(s)
     {var
       rgb_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d)),
       rgb_pct_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgb_s_d_s_d_s_d$0)),
       rgba_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d)),
       rgba_pct_re=
        new
         regExp_withFlags
         (caml_jsbytes_of_string(cst_rgba_s_d_s_d_s_d_d_d$0)),
       hsl_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsl_s_d_s_d_s_d)),
       hsla_re=
        new regExp_withFlags(caml_jsbytes_of_string(cst_hsla_s_d_s_d_s_d_d_d));
      if(! (rgb_re.test(s) | 0))
       if(! (rgba_re.test(s) | 0))
        if(! (rgb_pct_re.test(s) | 0))
         if(! (rgba_pct_re.test(s) | 0))
          if(! (hsl_re.test(s) | 0))
           if(! (hsla_re.test(s) | 0))
            {if(caml_call2(List[31],caml_js_to_string(s),_bO_))return s;
             throw [0,
                    Invalid_argument,
                    caml_call2
                     (Pervasives[16],
                      caml_js_to_string(s),
                      cst_is_not_a_valid_color)]}
      return s}
    function js(c)
     {if(0 === c[0]){var n=c[1];return string_of_name(n).toString()}
      return string_of_t(c).toString()}
    function ml(c)
     {var s=caml_js_to_string(c);
      try
       {var _f5_=[0,name_of_string(s)];return _f5_}
      catch(_f6_)
       {_f6_ = caml_wrap_exception(_f6_);
        if(_f6_[1] === Invalid_argument)
         {var
           fail=
            function(param)
             {throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],s,cst_is_not_a_valid_color$0)]},
           re_rgb=regexp(cst_rgba_d_d_d_d_d),
           re_rgb_pct=regexp(cst_rgba_d_d_d_d_d$0),
           re_hsl=regexp(cst_hsla_d_d_d_d_d),
           i_of_s_o=
            function(param)
             {if(param)
               {var i=param[1];
                try
                 {var _gb_=caml_int_of_string(i);return _gb_}
                catch(_gc_)
                 {_gc_ = caml_wrap_exception(_gc_);
                  if(_gc_[1] === Invalid_argument)
                   var s=_gc_[2];
                  else
                   {if(_gc_[1] !== Failure)throw _gc_;var s=_gc_[2]}
                  var
                   _f$_=caml_call2(Pervasives[16],cst$0,s),
                   _ga_=caml_call2(Pervasives[16],i,_f$_);
                  throw [0,
                         Invalid_argument,
                         caml_call2(Pervasives[16],cst_color_conversion_error,_ga_)]}}
              return fail(0)},
           f_of_s=
            function(f)
             {try
               {var _f9_=caml_float_of_string(f);return _f9_}
              catch(_f__)
               {_f__ = caml_wrap_exception(_f__);
                if(_f__[1] === Invalid_argument)
                 var s=_f__[2];
                else
                 {if(_f__[1] !== Failure)throw _f__;var s=_f__[2]}
                var
                 _f7_=caml_call2(Pervasives[16],cst$1,s),
                 _f8_=caml_call2(Pervasives[16],f,_f7_);
                throw [0,
                       Invalid_argument,
                       caml_call2(Pervasives[16],cst_color_conversion_error$0,_f8_)]}},
           match=string_match(re_rgb,s,0);
          if(match)
           {var
             r=match[1],
             red=matched_group(r,2),
             green=matched_group(r,3),
             blue=matched_group(r,4),
             alpha=matched_group(r,5),
             match$0=matched_group(r,1);
            if(match$0)
             {var _fN_=match$0[1];
              if(! caml_string_notequal(_fN_,cst_rgb))
               {if(alpha)return fail(0);
                var _fR_=i_of_s_o(blue),_fS_=i_of_s_o(green);
                return [1,[0,i_of_s_o(red),_fS_,_fR_]]}
              if(! caml_string_notequal(_fN_,cst_rgba))
               {if(alpha)
                 {var
                   a=alpha[1],
                   _fO_=f_of_s(a),
                   _fP_=i_of_s_o(blue),
                   _fQ_=i_of_s_o(green);
                  return [3,[0,i_of_s_o(red),_fQ_,_fP_,_fO_]]}
                return fail(0)}}
            return fail(0)}
          var match$1=string_match(re_rgb_pct,s,0);
          if(match$1)
           {var
             r$0=match$1[1],
             red$0=matched_group(r$0,2),
             green$0=matched_group(r$0,3),
             blue$0=matched_group(r$0,4),
             alpha$0=matched_group(r$0,5),
             match$2=matched_group(r$0,1);
            if(match$2)
             {var _fT_=match$2[1];
              if(! caml_string_notequal(_fT_,cst_rgb$0))
               {if(alpha$0)return fail(0);
                var _fX_=i_of_s_o(blue$0),_fY_=i_of_s_o(green$0);
                return [2,[0,i_of_s_o(red$0),_fY_,_fX_]]}
              if(! caml_string_notequal(_fT_,cst_rgba$0))
               {if(alpha$0)
                 {var
                   a$0=alpha$0[1],
                   _fU_=f_of_s(a$0),
                   _fV_=i_of_s_o(blue$0),
                   _fW_=i_of_s_o(green$0);
                  return [4,[0,i_of_s_o(red$0),_fW_,_fV_,_fU_]]}
                return fail(0)}}
            return fail(0)}
          var match$3=string_match(re_hsl,s,0);
          if(match$3)
           {var
             r$1=match$3[1],
             red$1=matched_group(r$1,2),
             green$1=matched_group(r$1,3),
             blue$1=matched_group(r$1,4),
             alpha$1=matched_group(r$1,5),
             match$4=matched_group(r$1,1);
            if(match$4)
             {var _fZ_=match$4[1];
              if(! caml_string_notequal(_fZ_,cst_hsl))
               {if(alpha$1)return fail(0);
                var _f3_=i_of_s_o(blue$1),_f4_=i_of_s_o(green$1);
                return [5,[0,i_of_s_o(red$1),_f4_,_f3_]]}
              if(! caml_string_notequal(_fZ_,cst_hsla))
               {if(alpha$1)
                 {var
                   a$1=alpha$1[1],
                   _f0_=f_of_s(a$1),
                   _f1_=i_of_s_o(blue$1),
                   _f2_=i_of_s_o(green$1);
                  return [6,[0,i_of_s_o(red$1),_f2_,_f1_,_f0_]]}
                return fail(0)}}
            return fail(0)}
          return fail(0)}
        throw _f6_}}
    function string_of_t$0(param)
     {if(typeof param === "number")
       return cst_0;
      else
       switch(param[0])
        {case 0:var f=param[1];return caml_call3(Printf[4],_bP_,f,cst_em);
         case 1:var f$0=param[1];return caml_call3(Printf[4],_bQ_,f$0,cst_ex);
         case 2:var f$1=param[1];return caml_call3(Printf[4],_bR_,f$1,cst_px);
         case 3:var f$2=param[1];return caml_call3(Printf[4],_bS_,f$2,cst_gd);
         case 4:
          var f$3=param[1];return caml_call3(Printf[4],_bT_,f$3,cst_rem);
         case 5:var f$4=param[1];return caml_call3(Printf[4],_bU_,f$4,cst_vw);
         case 6:var f$5=param[1];return caml_call3(Printf[4],_bV_,f$5,cst_vh);
         case 7:var f$6=param[1];return caml_call3(Printf[4],_bW_,f$6,cst_vm);
         case 8:var f$7=param[1];return caml_call3(Printf[4],_bX_,f$7,cst_ch);
         case 9:var f$8=param[1];return caml_call3(Printf[4],_bY_,f$8,cst_mm);
         case 10:
          var f$9=param[1];return caml_call3(Printf[4],_bZ_,f$9,cst_cm);
         case 11:
          var f$10=param[1];return caml_call3(Printf[4],_b0_,f$10,cst_in);
         case 12:
          var f$11=param[1];return caml_call3(Printf[4],_b1_,f$11,cst_pt);
         default:
          var f$12=param[1];return caml_call3(Printf[4],_b2_,f$12,cst_pc)}}
    function js$0(t){return string_of_t$0(t).toString()}
    function ml$0(t)
     {var s=caml_js_to_string(t);
      if(runtime.caml_string_equal(s,cst_0$0))return 0;
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length)]}
      var re=regexp(cst_d_d_s_S),match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _fL_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error,s$0)]}
            throw exn}
          var f$0=_fL_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _fM_=match$1[1],switch$0=caml_string_compare(_fM_,cst_pc$0);
          if(0 <= switch$0)
           {if(! (0 < switch$0))return [13,f$0];
            if(! caml_string_notequal(_fM_,cst_pt$0))return [12,f$0];
            if(! caml_string_notequal(_fM_,cst_px$0))return [2,f$0];
            if(! caml_string_notequal(_fM_,cst_rem$0))return [4,f$0];
            if(! caml_string_notequal(_fM_,cst_vh$0))return [6,f$0];
            if(! caml_string_notequal(_fM_,cst_vm$0))return [7,f$0];
            if(! caml_string_notequal(_fM_,cst_vw$0))return [5,f$0]}
          else
           {if(! caml_string_notequal(_fM_,cst_ch$0))return [8,f$0];
            if(! caml_string_notequal(_fM_,cst_cm$0))return [10,f$0];
            if(! caml_string_notequal(_fM_,cst_em$0))return [0,f$0];
            if(! caml_string_notequal(_fM_,cst_ex$0))return [1,f$0];
            if(! caml_string_notequal(_fM_,cst_gd$0))return [3,f$0];
            if(! caml_string_notequal(_fM_,cst_in$0))return [11,f$0];
            if(! caml_string_notequal(_fM_,cst_mm$0))return [9,f$0]}
          return fail(0)}
        return fail(0)}
      return fail(0)}
    var Length=[0,string_of_t$0,js$0,ml$0];
    function string_of_t$1(param)
     {switch(param[0])
       {case 0:var f=param[1];return caml_call3(Printf[4],_b3_,f,cst_deg);
        case 1:
         var f$0=param[1];return caml_call3(Printf[4],_b4_,f$0,cst_grad);
        case 2:var f$1=param[1];return caml_call3(Printf[4],_b5_,f$1,cst_rad);
        default:
         var f$2=param[1];return caml_call3(Printf[4],_b6_,f$2,cst_turns)}}
    function js$1(t){return string_of_t$1(t).toString()}
    function ml$1(j)
     {var s=caml_js_to_string(j),re=regexp(cst_d_d_deg_grad_rad_turns);
      function fail(param)
       {throw [0,
               Invalid_argument,
               caml_call2(Pervasives[16],s,cst_is_not_a_valid_length$0)]}
      var match=string_match(re,s,0);
      if(match)
       {var r=match[1],match$0=matched_group(r,1);
        if(match$0)
         {var f=match$0[1];
          try
           {var _fJ_=caml_float_of_string(f)}
          catch(exn)
           {exn = caml_wrap_exception(exn);
            if(exn[1] === Invalid_argument)
             {var s$0=exn[2];
              throw [0,
                     Invalid_argument,
                     caml_call2(Pervasives[16],cst_length_conversion_error$0,s$0)]}
            throw exn}
          var f$0=_fJ_}
        else
         var f$0=fail(0);
        var match$1=matched_group(r,2);
        if(match$1)
         {var _fK_=match$1[1];
          if(! caml_string_notequal(_fK_,cst_deg$0))return [0,f$0];
          if(! caml_string_notequal(_fK_,cst_grad$0))return [1,f$0];
          if(! caml_string_notequal(_fK_,cst_rad$0))return [2,f$0];
          if(! caml_string_notequal(_fK_,cst_turns$0))return [3,f$0]}
        return fail(0)}
      return fail(0)}
    var
     Angle=[0,string_of_t$1,js$1,ml$1],
     CSS=
      [0,
       [0,
        string_of_name,
        rgb_of_name,
        hex_of_rgb,
        rgb,
        hsl,
        string_of_t,
        js,
        ml,
        js_t_of_js_string],
       Length,
       Angle];
    caml_register_global(1616,CSS,"CSS");
    function list_of_nodeList(nodeList)
     {var length=nodeList.length,acc=0,i=0;
      for(;;)
       {if(i < length)
         {var _fI_=nodeList.item(i),match=caml_call1(Opt[10],_fI_);
          if(match)
           {var e=match[1],i$0=i + 1 | 0,acc$0=[0,e,acc],acc=acc$0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}
        return caml_call1(List[9],acc)}}
    var
     disconnected=1,
     preceding=2,
     following=4,
     contains=8,
     contained_by=16,
     implementation_specific=32;
    function has(t,mask){return (t & mask) === mask?1:0}
    function add(x,y){return x | y}
    var
     DocumentPosition=
      [0,
       disconnected,
       preceding,
       following,
       contains,
       contained_by,
       implementation_specific,
       has,
       add,
       add];
    function appendChild(p,n){p.appendChild(n);return 0}
    function removeChild(p,n){p.removeChild(n);return 0}
    function replaceChild(p,n,o){p.replaceChild(n,o);return 0}
    function insertBefore(p,n,o){p.insertBefore(n,o);return 0}
    function nodeType(e)
     {var match=e.nodeType;
      if(0 !== match)
       {var switcher=match - 1 | 0;
        switch(switcher)
         {case 0:return [0,e];case 1:return [1,e];case 2:case 3:return [2,e]}}
      return [3,e]}
    function cast(e,t){return e.nodeType === t?e:no_handler}
    function element(e){return cast(e,1)}
    function text(e)
     {if(3 !== e.nodeType)if(4 !== e.nodeType)return no_handler;return e}
    function attr(e){return cast(e,2)}
    function handler(f)
     {return function(e)
       {if(caml_call1(Opt[5],e))
         {var res=caml_call1(f,e);
          if(1 - (res | 0))e.preventDefault();
          return res}
        var e$0=event,res$0=caml_call1(f,e$0);
        if(1 - (res$0 | 0))e$0.returnValue = res$0;
        return res$0}}
    function full_handler(f)
     {return runtime.caml_js_wrap_meth_callback_unsafe
              (function(this$0,e)
                {if(caml_call1(Opt[5],e))
                  {var res=caml_call2(f,this$0,e);
                   if(1 - (res | 0))e.preventDefault();
                   return res}
                 var e$0=event,res$0=caml_call2(f,this$0,e$0);
                 if(1 - (res$0 | 0))e$0.returnValue = res$0;
                 return res$0})}
    function invoke_handler(f,this$0,event){return f.call(this$0,event)}
    function eventTarget(e)
     {function _fF_(param)
       {function _fH_(param){throw Not_found}
        return caml_call2(Opt[8],e.srcElement,_fH_)}
      var target=caml_call2(Opt[8],e.target,_fF_);
      if(target instanceof Unsafe[1].Node)
       {if(3 === target.nodeType)
         {var _fG_=function(param){throw [0,Assert_failure,_b7_]};
          return caml_call2(Opt[8],target.parentNode,_fG_)}
        return target}
      return target}
    var make=caml_js_from_string,Event=[0,make];
    function addEventListener(e,typ,h,capt)
     {if(e.addEventListener === t37)
       {var
         ev="on".concat(typ),
         callback=
          function(e)
           {var _fC_=[0,h,e,[0]];
            return function(_fD_,_fE_)
             {return runtime.caml_js_call(_fC_,_fD_,_fE_)}};
        e.attachEvent(ev,callback);
        return function(param){return e.detachEvent(ev,callback)}}
      e.addEventListener(typ,h,capt);
      return function(param){return e.removeEventListener(typ,h,capt)}}
    function removeEventListener(id){return caml_call1(id,0)}
    function preventDefault(ev)
     {return caml_call1(Optdef[5],ev.preventDefault)
              ?ev.preventDefault()
              :ev.returnValue = ! ! 0}
    var
     Dom=
      [0,
       DocumentPosition,
       insertBefore,
       replaceChild,
       removeChild,
       appendChild,
       list_of_nodeList,
       nodeType,
       [0,element,text,attr],
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       Event,
       addEventListener,
       removeEventListener,
       preventDefault];
    caml_register_global(1618,Dom,"Dom");
    var
     arrayBuffer=Unsafe[1].ArrayBuffer,
     int8Array_inBuffer=Unsafe[1].Int8Array,
     uint8Array_fromBuffer=Unsafe[1].Uint8Array,
     int16Array_inBuffer=Unsafe[1].Int16Array,
     uint16Array_inBuffer=Unsafe[1].Uint16Array,
     int32Array_inBuffer=Unsafe[1].Int32Array,
     uint32Array_inBuffer=Unsafe[1].Uint32Array,
     float32Array_inBuffer=Unsafe[1].Float32Array,
     float64Array_inBuffer=Unsafe[1].Float64Array,
     set=caml_js_set,
     get$1=caml_js_get,
     unsafe_get=caml_js_get,
     dataView=Unsafe[1].DataView;
    function of_arrayBuffer(ab)
     {var uint8=new uint8Array_fromBuffer(ab);
      return runtime.caml_string_of_array(uint8)}
    var
     String=[0,of_arrayBuffer],
     Typed_array=
      [0,
       arrayBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       int8Array_inBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       uint8Array_fromBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       int16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       uint16Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       int32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       uint32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float32Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       float64Array_inBuffer,
       set,
       get$1,
       unsafe_get,
       dataView,
       dataView,
       [0,runtime.bigstring_to_array_buffer,runtime.bigstring_of_array_buffer],
       String];
    caml_register_global(1619,Typed_array,"Typed_array");
    var blob_constr=Unsafe[1].Blob;
    function filter_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function blob_raw(contentType,endings,a)
     {var _fy_=0;
      if(endings)
       var _fz_=116179762 <= endings[1]?_b8_:_b9_,_fA_=_fz_;
      else
       var _fA_=0;
      var
       _fB_=[0,[0,cst_type,contentType],[0,[0,cst_endings,_fA_],_fy_]],
       options=
        filter_map
         (function(param)
           {var v=param[2],name=param[1];
            if(v){var v$0=v[1];return [0,[0,name,v$0.toString()]]}
            return 0},
          _fB_),
       options$0=
        options?runtime.caml_js_object(caml_call1(Array[12],options)):t37;
      return new blob_constr(caml_js_from_array(a),options$0)}
    function blob_from_string(contentType,endings,s)
     {return blob_raw(contentType,endings,[0,s.toString()])}
    function blob_from_any(contentType,endings,l)
     {function _fw_(param)
       {var _fx_=param[1];
        if(155580615 === _fx_){var s=param[2];return s}
        if(486041214 <= _fx_)
         {if(1037850489 <= _fx_){var a=param[2];return a}
          var a$0=param[2];
          return a$0}
        if(288368849 <= _fx_){var s$0=param[2];return s$0.toString()}
        var b=param[2];
        return b}
      var l$0=caml_call2(List[17],_fw_,l);
      return blob_raw(contentType,endings,caml_call1(Array[12],l$0))}
    function filename(file)
     {var match=caml_call1(Optdef[10],file.name);
      if(match){var name=match[1];return name}
      var match$0=caml_call1(Optdef[10],file.fileName);
      if(match$0){var name$0=match$0[1];return name$0}
      return caml_call1
              (Pervasives[2],cst_can_t_retrieve_file_name_not_implemented)}
    var doc_constr=Unsafe[1].Document;
    function document(e){return e instanceof doc_constr?e:no_handler}
    function blob(e){return e instanceof blob_constr?e:no_handler}
    function string(e)
     {return runtime.caml_equal(typeof e,"string")?e:no_handler}
    function arrayBuffer$0(e){return e instanceof arrayBuffer?e:no_handler}
    var
     loadstart=caml_call1(Event[1],cst_loadstart),
     progress=caml_call1(Event[1],cst_progress),
     abort=caml_call1(Event[1],cst_abort),
     error=caml_call1(Event[1],cst_error),
     load=caml_call1(Event[1],cst_load),
     loadend=caml_call1(Event[1],cst_loadend),
     ReaderEvent=[0,loadstart,progress,abort,error,load,loadend],
     fileReader=Unsafe[1].FileReader,
     File=
      [0,
       blob_from_string,
       blob_from_any,
       [0,document,blob,function(_fv_){return _fv_},string,arrayBuffer$0],
       ReaderEvent,
       filename,
       fileReader,
       addEventListener];
    caml_register_global(1621,File,"File");
    var
     onIE=runtime.caml_js_on_ie(0) | 0,
     click=caml_call1(Event[1],cst_click),
     dblclick=caml_call1(Event[1],cst_dblclick),
     mousedown=caml_call1(Event[1],cst_mousedown),
     mouseup=caml_call1(Event[1],cst_mouseup),
     mouseover=caml_call1(Event[1],cst_mouseover),
     mousemove=caml_call1(Event[1],cst_mousemove),
     mouseout=caml_call1(Event[1],cst_mouseout),
     keypress=caml_call1(Event[1],cst_keypress),
     keydown=caml_call1(Event[1],cst_keydown),
     keyup=caml_call1(Event[1],cst_keyup),
     mousewheel=caml_call1(Event[1],cst_mousewheel),
     DOMMouseScroll=caml_call1(Event[1],cst_DOMMouseScroll),
     touchstart=caml_call1(Event[1],cst_touchstart),
     touchmove=caml_call1(Event[1],cst_touchmove),
     touchend=caml_call1(Event[1],cst_touchend),
     touchcancel=caml_call1(Event[1],cst_touchcancel),
     dragstart=caml_call1(Event[1],cst_dragstart),
     dragend=caml_call1(Event[1],cst_dragend),
     dragenter=caml_call1(Event[1],cst_dragenter),
     dragover=caml_call1(Event[1],cst_dragover),
     dragleave=caml_call1(Event[1],cst_dragleave),
     drag=caml_call1(Event[1],cst_drag),
     drop=caml_call1(Event[1],cst_drop),
     hashchange=caml_call1(Event[1],cst_hashchange),
     change=caml_call1(Event[1],cst_change),
     input=caml_call1(Event[1],cst_input),
     timeupdate=caml_call1(Event[1],cst_timeupdate),
     submit=caml_call1(Event[1],cst_submit),
     scroll=caml_call1(Event[1],cst_scroll),
     focus=caml_call1(Event[1],cst_focus),
     blur=caml_call1(Event[1],cst_blur),
     load$0=caml_call1(Event[1],cst_load$0),
     unload=caml_call1(Event[1],cst_unload),
     beforeunload=caml_call1(Event[1],cst_beforeunload),
     resize=caml_call1(Event[1],cst_resize),
     orientationchange=caml_call1(Event[1],cst_orientationchange),
     popstate=caml_call1(Event[1],cst_popstate),
     error$0=caml_call1(Event[1],cst_error$0),
     abort$0=caml_call1(Event[1],cst_abort$0),
     select=caml_call1(Event[1],cst_select),
     online=caml_call1(Event[1],cst_online),
     offline=caml_call1(Event[1],cst_offline),
     checking=caml_call1(Event[1],cst_checking),
     noupdate=caml_call1(Event[1],cst_noupdate),
     downloading=caml_call1(Event[1],cst_downloading),
     progress$0=caml_call1(Event[1],cst_progress$0),
     updateready=caml_call1(Event[1],cst_updateready),
     cached=caml_call1(Event[1],cst_cached),
     obsolete=caml_call1(Event[1],cst_obsolete),
     domContentLoaded=caml_call1(Event[1],cst_DOMContentLoaded),
     animationstart=caml_call1(Event[1],cst_animationstart),
     animationend=caml_call1(Event[1],cst_animationend),
     animationiteration=caml_call1(Event[1],cst_animationiteration),
     animationcancel=caml_call1(Event[1],cst_animationcancel),
     canplay=caml_call1(Event[1],cst_canplay),
     canplaythrough=caml_call1(Event[1],cst_canplaythrough),
     durationchange=caml_call1(Event[1],cst_durationchange),
     emptied=caml_call1(Event[1],cst_emptied),
     ended=caml_call1(Event[1],cst_ended),
     loadeddata=caml_call1(Event[1],cst_loadeddata),
     loadedmetadata=caml_call1(Event[1],cst_loadedmetadata),
     loadstart$0=caml_call1(Event[1],cst_loadstart$0),
     pause=caml_call1(Event[1],cst_pause),
     play=caml_call1(Event[1],cst_play),
     playing=caml_call1(Event[1],cst_playing),
     ratechange=caml_call1(Event[1],cst_ratechange),
     seeked=caml_call1(Event[1],cst_seeked),
     seeking=caml_call1(Event[1],cst_seeking),
     stalled=caml_call1(Event[1],cst_stalled),
     suspend=caml_call1(Event[1],cst_suspend),
     volumechange=caml_call1(Event[1],cst_volumechange),
     waiting=caml_call1(Event[1],cst_waiting),
     make$0=Event[1],
     Event$0=
      [0,
       click,
       dblclick,
       mousedown,
       mouseup,
       mouseover,
       mousemove,
       mouseout,
       keypress,
       keydown,
       keyup,
       mousewheel,
       DOMMouseScroll,
       touchstart,
       touchmove,
       touchend,
       touchcancel,
       dragstart,
       dragend,
       dragenter,
       dragover,
       dragleave,
       drag,
       drop,
       hashchange,
       change,
       input,
       timeupdate,
       submit,
       scroll,
       focus,
       blur,
       load$0,
       unload,
       beforeunload,
       resize,
       orientationchange,
       popstate,
       error$0,
       abort$0,
       select,
       online,
       offline,
       checking,
       noupdate,
       downloading,
       progress$0,
       updateready,
       cached,
       obsolete,
       domContentLoaded,
       animationstart,
       animationend,
       animationiteration,
       animationcancel,
       canplay,
       canplaythrough,
       durationchange,
       emptied,
       ended,
       loadeddata,
       loadedmetadata,
       loadstart$0,
       pause,
       play,
       playing,
       ratechange,
       seeked,
       seeking,
       stalled,
       suspend,
       volumechange,
       waiting,
       make$0],
     d="2d";
    function location_origin(loc)
     {function _ft_(o){return o}
      function _fu_(param)
       {var protocol=loc.protocol,hostname=loc.hostname,port=loc.port;
        if(0 === protocol.length)if(0 === hostname.length)return "";
        var origin=protocol.concat("//",hostname);
        return 0 < port.length?origin.concat(":",loc.port):origin}
      return caml_call3(Optdef[7],loc.origin,_fu_,_ft_)}
    var _b__=Unsafe[1],document$0=_b__.document;
    function getElementById(id)
     {function _fq_(pnode){return pnode}
      function _fr_(param){throw Not_found}
      var _fs_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_fs_,_fr_,_fq_)}
    function getElementById_exn(id)
     {function _fm_(pnode){return pnode}
      function _fn_(param)
       {var _fp_=caml_call2(Printf[4],_b$_,id);
        return caml_call1(Pervasives[2],_fp_)}
      var _fo_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_fo_,_fn_,_fm_)}
    function getElementById_opt(id)
     {var _fl_=document$0.getElementById(id.toString());
      return caml_call1(Opt[10],_fl_)}
    function getElementById_coerce(id,coerce)
     {function _fh_(e)
       {var _fk_=caml_call1(coerce,e);return caml_call1(Opt[10],_fk_)}
      function _fi_(param){return 0}
      var _fj_=document$0.getElementById(id.toString());
      return caml_call3(Opt[7],_fj_,_fi_,_fh_)}
    function opt_iter(x,f){if(x){var v=x[1];return caml_call1(f,v)}return 0}
    function createElement(doc,name)
     {return doc.createElement(name.toString())}
    function unsafeCreateElement(doc,name){return createElement(doc,name)}
    var createElementSyntax=[0,785140586];
    function unsafeCreateElementEx(type,name,doc,elt)
     {for(;;)
       {if(0 === type)if(0 === name)return createElement(doc,elt);
        var _fb_=createElementSyntax[1];
        if(785140586 === _fb_)
         {try
           {var
             el=document$0.createElement('<input name="x">'),
             _fe_=el.tagName.toLowerCase() === "input"?1:0,
             _ff_=_fe_?el.name === "x"?1:0:_fe_,
             _fc_=_ff_}
          catch(_fg_){var _fc_=0}
          var _fd_=_fc_?982028505:-1003883683;
          createElementSyntax[1] = _fd_;
          continue}
        if(982028505 <= _fb_)
         {var a=new array_length();
          a.push("<",elt.toString());
          opt_iter
           (type,
            function(t){a.push(' type="',caml_js_html_escape(t),'"');return 0});
          opt_iter
           (name,
            function(n){a.push(' name="',caml_js_html_escape(n),'"');return 0});
          a.push(">");
          return doc.createElement(a.join(""))}
        var res=createElement(doc,elt);
        opt_iter(type,function(t){return res.type = t});
        opt_iter(name,function(n){return res.name = n});
        return res}}
    function createHtml(doc){return unsafeCreateElement(doc,cst_html)}
    function createHead(doc){return unsafeCreateElement(doc,cst_head)}
    function createLink(doc){return unsafeCreateElement(doc,cst_link)}
    function createTitle(doc){return unsafeCreateElement(doc,cst_title)}
    function createMeta(doc){return unsafeCreateElement(doc,cst_meta)}
    function createBase(doc){return unsafeCreateElement(doc,cst_base)}
    function createStyle(doc){return unsafeCreateElement(doc,cst_style)}
    function createBody(doc){return unsafeCreateElement(doc,cst_body)}
    function createForm(doc){return unsafeCreateElement(doc,cst_form)}
    function createOptgroup(doc){return unsafeCreateElement(doc,cst_optgroup)}
    function createOption(doc){return unsafeCreateElement(doc,cst_option)}
    function createSelect(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_select$0)}
    function createInput(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_input$0)}
    function createTextarea(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_textarea)}
    function createButton(type,name,doc)
     {return unsafeCreateElementEx(type,name,doc,cst_button)}
    function createLabel(doc){return unsafeCreateElement(doc,cst_label)}
    function createFieldset(doc){return unsafeCreateElement(doc,cst_fieldset)}
    function createLegend(doc){return unsafeCreateElement(doc,cst_legend)}
    function createUl(doc){return unsafeCreateElement(doc,cst_ul)}
    function createOl(doc){return unsafeCreateElement(doc,cst_ol)}
    function createDl(doc){return unsafeCreateElement(doc,cst_dl)}
    function createLi(doc){return unsafeCreateElement(doc,cst_li)}
    function createDiv(doc){return unsafeCreateElement(doc,cst_div)}
    function createEmbed(doc){return unsafeCreateElement(doc,cst_embed)}
    function createP(doc){return unsafeCreateElement(doc,cst_p)}
    function createH1(doc){return unsafeCreateElement(doc,cst_h1)}
    function createH2(doc){return unsafeCreateElement(doc,cst_h2)}
    function createH3(doc){return unsafeCreateElement(doc,cst_h3)}
    function createH4(doc){return unsafeCreateElement(doc,cst_h4)}
    function createH5(doc){return unsafeCreateElement(doc,cst_h5)}
    function createH6(doc){return unsafeCreateElement(doc,cst_h6)}
    function createQ(doc){return unsafeCreateElement(doc,cst_q)}
    function createBlockquote(doc)
     {return unsafeCreateElement(doc,cst_blockquote)}
    function createPre(doc){return unsafeCreateElement(doc,cst_pre)}
    function createBr(doc){return unsafeCreateElement(doc,cst_br)}
    function createHr(doc){return unsafeCreateElement(doc,cst_hr)}
    function createIns(doc){return unsafeCreateElement(doc,cst_ins)}
    function createDel(doc){return unsafeCreateElement(doc,cst_del)}
    function createA(doc){return unsafeCreateElement(doc,cst_a)}
    function createImg(doc){return unsafeCreateElement(doc,cst_img)}
    function createObject(doc){return unsafeCreateElement(doc,cst_object)}
    function createParam(doc){return unsafeCreateElement(doc,cst_param)}
    function createMap(doc){return unsafeCreateElement(doc,cst_map)}
    function createArea(doc){return unsafeCreateElement(doc,cst_area)}
    function createScript(doc){return unsafeCreateElement(doc,cst_script)}
    function createTable(doc){return unsafeCreateElement(doc,cst_table)}
    function createCaption(doc){return unsafeCreateElement(doc,cst_caption)}
    function createCol(doc){return unsafeCreateElement(doc,cst_col)}
    function createColgroup(doc){return unsafeCreateElement(doc,cst_colgroup)}
    function createThead(doc){return unsafeCreateElement(doc,cst_thead)}
    function createTfoot(doc){return unsafeCreateElement(doc,cst_tfoot)}
    function createTbody(doc){return unsafeCreateElement(doc,cst_tbody)}
    function createTr(doc){return unsafeCreateElement(doc,cst_tr)}
    function createTh(doc){return unsafeCreateElement(doc,cst_th)}
    function createTd(doc){return unsafeCreateElement(doc,cst_td)}
    function createSub(doc){return createElement(doc,cst_sub)}
    function createSup(doc){return createElement(doc,cst_sup)}
    function createSpan(doc){return createElement(doc,cst_span)}
    function createTt(doc){return createElement(doc,cst_tt)}
    function createI(doc){return createElement(doc,cst_i)}
    function createB(doc){return createElement(doc,cst_b)}
    function createBig(doc){return createElement(doc,cst_big)}
    function createSmall(doc){return createElement(doc,cst_small)}
    function createEm(doc){return createElement(doc,cst_em$1)}
    function createStrong(doc){return createElement(doc,cst_strong)}
    function createCite(doc){return createElement(doc,cst_cite)}
    function createDfn(doc){return createElement(doc,cst_dfn)}
    function createCode(doc){return createElement(doc,cst_code)}
    function createSamp(doc){return createElement(doc,cst_samp)}
    function createKbd(doc){return createElement(doc,cst_kbd)}
    function createVar(doc){return createElement(doc,cst_var)}
    function createAbbr(doc){return createElement(doc,cst_abbr)}
    function createDd(doc){return createElement(doc,cst_dd)}
    function createDt(doc){return createElement(doc,cst_dt)}
    function createNoscript(doc){return createElement(doc,cst_noscript)}
    function createAddress(doc){return createElement(doc,cst_address)}
    function createFrameset(doc){return unsafeCreateElement(doc,cst_frameset)}
    function createFrame(doc){return unsafeCreateElement(doc,cst_frame)}
    function createIframe(doc){return unsafeCreateElement(doc,cst_iframe)}
    function createAudio(doc){return unsafeCreateElement(doc,cst_audio)}
    function createVideo(doc){return unsafeCreateElement(doc,cst_video)}
    var
     Canvas_not_available=
      [248,cst_Dom_html_Canvas_not_available,caml_fresh_oo_id(0)];
    function createCanvas(doc)
     {var c=unsafeCreateElement(doc,cst_canvas);
      if(1 - caml_call1(Opt[5],c.getContext))throw Canvas_not_available;
      return c}
    var
     html_element=Unsafe[1].HTMLElement,
     element$0=
      html_element === t37
       ?function(e){return e.innerHTML === t37?no_handler:e}
       :function(e){return e instanceof html_element?e:no_handler};
    function unsafeCoerce(tag,e)
     {var _fa_=tag.toString();
      return e.tagName.toLowerCase() === _fa_?e:no_handler}
    function a(e){return unsafeCoerce(cst_a$0,e)}
    function area(e){return unsafeCoerce(cst_area$0,e)}
    function base(e){return unsafeCoerce(cst_base$0,e)}
    function blockquote(e){return unsafeCoerce(cst_blockquote$0,e)}
    function body(e){return unsafeCoerce(cst_body$0,e)}
    function br(e){return unsafeCoerce(cst_br$0,e)}
    function button(e){return unsafeCoerce(cst_button$0,e)}
    function canvas(e){return unsafeCoerce(cst_canvas$0,e)}
    function caption(e){return unsafeCoerce(cst_caption$0,e)}
    function col(e){return unsafeCoerce(cst_col$0,e)}
    function colgroup(e){return unsafeCoerce(cst_colgroup$0,e)}
    function del(e){return unsafeCoerce(cst_del$0,e)}
    function div(e){return unsafeCoerce(cst_div$0,e)}
    function dl(e){return unsafeCoerce(cst_dl$0,e)}
    function fieldset(e){return unsafeCoerce(cst_fieldset$0,e)}
    function embed(e){return unsafeCoerce(cst_embed$0,e)}
    function form(e){return unsafeCoerce(cst_form$0,e)}
    function frameset(e){return unsafeCoerce(cst_frameset$0,e)}
    function frame(e){return unsafeCoerce(cst_frame$0,e)}
    function h1(e){return unsafeCoerce(cst_h1$0,e)}
    function h2(e){return unsafeCoerce(cst_h2$0,e)}
    function h3(e){return unsafeCoerce(cst_h3$0,e)}
    function h4(e){return unsafeCoerce(cst_h4$0,e)}
    function h5(e){return unsafeCoerce(cst_h5$0,e)}
    function h6(e){return unsafeCoerce(cst_h6$0,e)}
    function head(e){return unsafeCoerce(cst_head$0,e)}
    function hr(e){return unsafeCoerce(cst_hr$0,e)}
    function html(e){return unsafeCoerce(cst_html$0,e)}
    function iframe(e){return unsafeCoerce(cst_iframe$0,e)}
    function img(e){return unsafeCoerce(cst_img$0,e)}
    function input$0(e){return unsafeCoerce(cst_input$1,e)}
    function ins(e){return unsafeCoerce(cst_ins$0,e)}
    function label(e){return unsafeCoerce(cst_label$0,e)}
    function legend(e){return unsafeCoerce(cst_legend$0,e)}
    function li(e){return unsafeCoerce(cst_li$0,e)}
    function link(e){return unsafeCoerce(cst_link$0,e)}
    function map$1(e){return unsafeCoerce(cst_map$0,e)}
    function meta(e){return unsafeCoerce(cst_meta$0,e)}
    function object(e){return unsafeCoerce(cst_object$0,e)}
    function ol(e){return unsafeCoerce(cst_ol$0,e)}
    function optgroup(e){return unsafeCoerce(cst_optgroup$0,e)}
    function option$1(e){return unsafeCoerce(cst_option$0,e)}
    function p(e){return unsafeCoerce(cst_p$0,e)}
    function param(e){return unsafeCoerce(cst_param$0,e)}
    function pre(e){return unsafeCoerce(cst_pre$0,e)}
    function q(e){return unsafeCoerce(cst_q$0,e)}
    function script(e){return unsafeCoerce(cst_script$0,e)}
    function select$0(e){return unsafeCoerce(cst_select$1,e)}
    function style(e){return unsafeCoerce(cst_style$0,e)}
    function table(e){return unsafeCoerce(cst_table$0,e)}
    function tbody(e){return unsafeCoerce(cst_tbody$0,e)}
    function td(e){return unsafeCoerce(cst_td$0,e)}
    function textarea(e){return unsafeCoerce(cst_textarea$0,e)}
    function tfoot(e){return unsafeCoerce(cst_tfoot$0,e)}
    function th(e){return unsafeCoerce(cst_th$0,e)}
    function thead(e){return unsafeCoerce(cst_thead$0,e)}
    function title(e){return unsafeCoerce(cst_title$0,e)}
    function tr(e){return unsafeCoerce(cst_tr$0,e)}
    function ul(e){return unsafeCoerce(cst_ul$0,e)}
    function audio(e){return unsafeCoerce(cst_audio$0,e)}
    function video(e){return unsafeCoerce(cst_video$0,e)}
    function unsafeCoerceEvent(constr,ev)
     {if(constr !== t37)if(ev instanceof constr)return ev;return no_handler}
    function mouseEvent(ev){return unsafeCoerceEvent(Unsafe[1].MouseEvent,ev)}
    function keyboardEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].KeyboardEvent,ev)}
    function wheelEvent(ev){return unsafeCoerceEvent(Unsafe[1].WheelEvent,ev)}
    function mouseScrollEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].MouseScrollEvent,ev)}
    function popStateEvent(ev)
     {return unsafeCoerceEvent(Unsafe[1].PopStateEvent,ev)}
    function eventRelatedTarget(e)
     {function _e9_(param)
       {var match=caml_js_to_string(e.type);
        if(caml_string_notequal(match,cst_mouseout$0))
         {if(caml_string_notequal(match,cst_mouseover$0))return no_handler;
          var _e__=function(param){throw [0,Assert_failure,_ca_]};
          return caml_call2(Optdef[8],e.fromElement,_e__)}
        function _e$_(param){throw [0,Assert_failure,_cb_]}
        return caml_call2(Optdef[8],e.toElement,_e$_)}
      return caml_call2(Optdef[8],e.relatedTarget,_e9_)}
    function eventAbsolutePosition(e)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              (e.clientX + body.scrollLeft | 0) + html.scrollLeft | 0,
              (e.clientY + body.scrollTop | 0) + html.scrollTop | 0]}
    function eventAbsolutePosition$0(e)
     {function _e5_(x)
       {function _e7_(y){return [0,x,y]}
        function _e8_(param){return eventAbsolutePosition(e)}
        return caml_call3(Optdef[7],e.pageY,_e8_,_e7_)}
      function _e6_(param){return eventAbsolutePosition(e)}
      return caml_call3(Optdef[7],e.pageX,_e6_,_e5_)}
    function elementClientPosition(e)
     {var
       r=e.getBoundingClientRect(),
       body=document$0.body,
       html=document$0.documentElement;
      return [0,
              ((r.left | 0) - body.clientLeft | 0) - html.clientLeft | 0,
              ((r.top | 0) - body.clientTop | 0) - html.clientTop | 0]}
    function getDocumentScroll(param)
     {var body=document$0.body,html=document$0.documentElement;
      return [0,
              body.scrollLeft + html.scrollLeft | 0,
              body.scrollTop + html.scrollTop | 0]}
    function buttonPressed(ev)
     {function _e3_(x){return x}
      function _e4_(param)
       {var match=ev.button,switcher=match - 1 | 0;
        if(! (3 < switcher >>> 0))
         switch(switcher)
          {case 0:return 1;case 1:return 3;case 2:break;default:return 2}
        return 0}
      return caml_call3(Optdef[7],ev.which,_e4_,_e3_)}
    function addMousewheelEventListener(e,h,capt)
     {var d=createDiv(document$0);
      d.setAttribute("onmousewheel","return;");
      if(typeof d.onmousewheel === "function")
       {var
         _eZ_=
          handler
           (function(e)
             {function _e1_(param){return 0}
              var
               dx=
                (- caml_call2(Optdef[8],e.wheelDeltaX,_e1_) | 0) / 40 | 0;
              function _e2_(param){return e.wheelDelta}
              var
               dy=
                (- caml_call2(Optdef[8],e.wheelDeltaY,_e2_) | 0) / 40 | 0;
              return caml_call3(h,e,dx,dy)});
        return addEventListener(e,Event$0[11],_eZ_,capt)}
      var
       _e0_=
        handler
         (function(e)
           {var d=e.detail;
            return e.axis === e.HORIZONTAL
                    ?caml_call3(h,e,d,0)
                    :caml_call3(h,e,0,d)});
      return addEventListener(e,Event$0[12],_e0_,capt)}
    function f(v)
     {var
       match=caml_js_to_string(v),
       switch$0=caml_string_compare(match,cst_KeyH);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 8;
        var switch$1=caml_string_compare(match,cst_Numpad4);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 72;
          var switch$2=caml_string_compare(match,cst_PageUp);
          if(0 <= switch$2)
           {if(! (0 < switch$2))return 98;
            var switch$3=caml_string_compare(match,cst_ShiftRight);
            if(0 <= switch$3)
             {if(! (0 < switch$3))return 91;
              if(! caml_string_notequal(match,cst_Slash))return 55;
              if(! caml_string_notequal(match,cst_Space))return 41;
              if(! caml_string_notequal(match,cst_Tab))return 39;
              if(! caml_string_notequal(match,cst_VolumeDown))return 103;
              if(! caml_string_notequal(match,cst_VolumeMute))return 102;
              if(! caml_string_notequal(match,cst_VolumeUp))return 104}
            else
             {if(! caml_string_notequal(match,cst_Pause))return 123;
              if(! caml_string_notequal(match,cst_Period))return 54;
              if(! caml_string_notequal(match,cst_PrintScreen))return 120;
              if(! caml_string_notequal(match,cst_Quote))return 50;
              if(! caml_string_notequal(match,cst_ScrollLock))return 119;
              if(! caml_string_notequal(match,cst_Semicolon))return 49;
              if(! caml_string_notequal(match,cst_ShiftLeft))return 90}}
          else
           {var switch$4=caml_string_compare(match,cst_NumpadDivide);
            if(0 <= switch$4)
             {if(! (0 < switch$4))return 84;
              if(! caml_string_notequal(match,cst_NumpadEnter))return 83;
              if(! caml_string_notequal(match,cst_NumpadEqual))return 82;
              if(! caml_string_notequal(match,cst_NumpadMultiply))return 78;
              if(! caml_string_notequal(match,cst_NumpadSubtract))return 79;
              if(! caml_string_notequal(match,cst_OSLeft))return 117;
              if(! caml_string_notequal(match,cst_OSRight))return 118;
              if(! caml_string_notequal(match,cst_PageDown))return 99}
            else
             {if(! caml_string_notequal(match,cst_Numpad5))return 73;
              if(! caml_string_notequal(match,cst_Numpad6))return 74;
              if(! caml_string_notequal(match,cst_Numpad7))return 75;
              if(! caml_string_notequal(match,cst_Numpad8))return 76;
              if(! caml_string_notequal(match,cst_Numpad9))return 77;
              if(! caml_string_notequal(match,cst_NumpadAdd))return 80;
              if(! caml_string_notequal(match,cst_NumpadDecimal))return 81}}}
        else
         {var switch$5=caml_string_compare(match,cst_KeyX);
          if(0 <= switch$5)
           {if(! (0 < switch$5))return 24;
            var switch$6=caml_string_compare(match,cst_MetaRight);
            if(0 <= switch$6)
             {if(! (0 < switch$6))return 89;
              if(! caml_string_notequal(match,cst_Minus))return 37;
              if(! caml_string_notequal(match,cst_NumLock))return 85;
              if(! caml_string_notequal(match,cst_Numpad0))return 68;
              if(! caml_string_notequal(match,cst_Numpad1))return 69;
              if(! caml_string_notequal(match,cst_Numpad2))return 70;
              if(! caml_string_notequal(match,cst_Numpad3))return 71}
            else
             {if(! caml_string_notequal(match,cst_KeyY))return 25;
              if(! caml_string_notequal(match,cst_KeyZ))return 26;
              if(! caml_string_notequal(match,cst_MediaPlayPause))return 107;
              if(! caml_string_notequal(match,cst_MediaStop))return 108;
              if(! caml_string_notequal(match,cst_MediaTrackNext))return 106;
              if(! caml_string_notequal(match,cst_MediaTrackPrevious))
               return 105;
              if(! caml_string_notequal(match,cst_MetaLeft))return 88}}
          else
           {var switch$7=caml_string_compare(match,cst_KeyP);
            if(0 <= switch$7)
             {if(! (0 < switch$7))return 16;
              if(! caml_string_notequal(match,cst_KeyQ))return 17;
              if(! caml_string_notequal(match,cst_KeyR))return 18;
              if(! caml_string_notequal(match,cst_KeyS))return 19;
              if(! caml_string_notequal(match,cst_KeyT))return 20;
              if(! caml_string_notequal(match,cst_KeyU))return 21;
              if(! caml_string_notequal(match,cst_KeyV))return 22;
              if(! caml_string_notequal(match,cst_KeyW))return 23}
            else
             {if(! caml_string_notequal(match,cst_KeyI))return 9;
              if(! caml_string_notequal(match,cst_KeyJ))return 10;
              if(! caml_string_notequal(match,cst_KeyK))return 11;
              if(! caml_string_notequal(match,cst_KeyL))return 12;
              if(! caml_string_notequal(match,cst_KeyM))return 13;
              if(! caml_string_notequal(match,cst_KeyN))return 14;
              if(! caml_string_notequal(match,cst_KeyO))return 15}}}}
      else
       {var switch$8=caml_string_compare(match,cst_Digit6);
        if(0 <= switch$8)
         {if(! (0 < switch$8))return 33;
          var switch$9=caml_string_compare(match,cst_F6);
          if(0 <= switch$9)
           {if(! (0 < switch$9))return 61;
            var switch$10=caml_string_compare(match,cst_KeyA);
            if(0 <= switch$10)
             {if(! (0 < switch$10))return 1;
              if(! caml_string_notequal(match,cst_KeyB))return 2;
              if(! caml_string_notequal(match,cst_KeyC))return 3;
              if(! caml_string_notequal(match,cst_KeyD))return 4;
              if(! caml_string_notequal(match,cst_KeyE))return 5;
              if(! caml_string_notequal(match,cst_KeyF))return 6;
              if(! caml_string_notequal(match,cst_KeyG))return 7}
            else
             {if(! caml_string_notequal(match,cst_F7))return 62;
              if(! caml_string_notequal(match,cst_F8))return 63;
              if(! caml_string_notequal(match,cst_F9))return 64;
              if(! caml_string_notequal(match,cst_Home))return 100;
              if(! caml_string_notequal(match,cst_Insert))return 44;
              if(! caml_string_notequal(match,cst_IntlBackslash))return 121;
              if(! caml_string_notequal(match,cst_IntlYen))return 122}}
          else
           {var switch$11=caml_string_compare(match,cst_F1);
            if(0 <= switch$11)
             {if(! (0 < switch$11))return 56;
              if(! caml_string_notequal(match,cst_F10))return 65;
              if(! caml_string_notequal(match,cst_F11))return 66;
              if(! caml_string_notequal(match,cst_F12))return 67;
              if(! caml_string_notequal(match,cst_F2))return 57;
              if(! caml_string_notequal(match,cst_F3))return 58;
              if(! caml_string_notequal(match,cst_F4))return 59;
              if(! caml_string_notequal(match,cst_F5))return 60}
            else
             {if(! caml_string_notequal(match,cst_Digit7))return 34;
              if(! caml_string_notequal(match,cst_Digit8))return 35;
              if(! caml_string_notequal(match,cst_Digit9))return 36;
              if(! caml_string_notequal(match,cst_End))return 101;
              if(! caml_string_notequal(match,cst_Enter))return 40;
              if(! caml_string_notequal(match,cst_Equal))return 38;
              if(! caml_string_notequal(match,cst_Escape))return 42}}}
        else
         {var switch$12=caml_string_compare(match,cst_BrowserRefresh);
          if(0 <= switch$12)
           {if(! (0 < switch$12))return 113;
            var switch$13=caml_string_compare(match,cst_Delete);
            if(0 <= switch$13)
             {if(! (0 < switch$13))return 45;
              if(! caml_string_notequal(match,cst_Digit0))return 27;
              if(! caml_string_notequal(match,cst_Digit1))return 28;
              if(! caml_string_notequal(match,cst_Digit2))return 29;
              if(! caml_string_notequal(match,cst_Digit3))return 30;
              if(! caml_string_notequal(match,cst_Digit4))return 31;
              if(! caml_string_notequal(match,cst_Digit5))return 32}
            else
             {if(! caml_string_notequal(match,cst_BrowserSearch))return 110;
              if(! caml_string_notequal(match,cst_BrowserStop))return 114;
              if(! caml_string_notequal(match,cst_CapsLock))return 46;
              if(! caml_string_notequal(match,cst_Comma))return 53;
              if(! caml_string_notequal(match,cst_ContextMenu))return 109;
              if(! caml_string_notequal(match,cst_ControlLeft))return 86;
              if(! caml_string_notequal(match,cst_ControlRight))return 87}}
          else
           {var switch$14=caml_string_compare(match,cst_Backslash);
            if(0 <= switch$14)
             {if(! (0 < switch$14))return 52;
              if(! caml_string_notequal(match,cst_Backspace))return 43;
              if(! caml_string_notequal(match,cst_BracketLeft))return 47;
              if(! caml_string_notequal(match,cst_BracketRight))return 48;
              if(! caml_string_notequal(match,cst_BrowserBack))return 116;
              if(! caml_string_notequal(match,cst_BrowserFavorites))
               return 112;
              if(! caml_string_notequal(match,cst_BrowserForward))return 115;
              if(! caml_string_notequal(match,cst_BrowserHome))return 111}
            else
             {if(! caml_string_notequal(match,cst_AltLeft))return 92;
              if(! caml_string_notequal(match,cst_AltRight))return 93;
              if(! caml_string_notequal(match,cst_ArrowDown))return 97;
              if(! caml_string_notequal(match,cst_ArrowLeft))return 94;
              if(! caml_string_notequal(match,cst_ArrowRight))return 95;
              if(! caml_string_notequal(match,cst_ArrowUp))return 96;
              if(! caml_string_notequal(match,cst_Backquote))return 51}}}}
      return 0}
    function try_key_code_left(param)
     {if(19 <= param)
       {if(91 === param)return 88}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 90;case 1:return 86;default:return 92}}
      return 0}
    function try_key_code_right(param)
     {if(19 <= param)
       {if(91 === param)return 89}
      else
       if(16 <= param)
        {var switcher=param - 16 | 0;
         switch(switcher){case 0:return 91;case 1:return 87;default:return 93}}
      return 0}
    function try_key_code_numpad(param)
     {if(47 <= param)
       {var switcher=param - 96 | 0;
        if(! (15 < switcher >>> 0))
         switch(switcher)
          {case 0:return 68;
           case 1:return 69;
           case 2:return 70;
           case 3:return 71;
           case 4:return 72;
           case 5:return 73;
           case 6:return 74;
           case 7:return 75;
           case 8:return 76;
           case 9:return 77;
           case 10:return 78;
           case 11:return 80;
           case 12:break;
           case 13:return 79;
           case 14:return 81;
           default:return 84}}
      else
       if(12 <= param)
        {var switcher$0=param - 12 | 0;
         switch(switcher$0)
          {case 0:return 73;
           case 1:return 83;
           case 21:return 77;
           case 22:return 71;
           case 23:return 69;
           case 24:return 75;
           case 25:return 72;
           case 26:return 76;
           case 27:return 74;
           case 28:return 70;
           case 33:return 68;
           case 34:return 81
           }}
      return 0}
    function try_key_code_normal(param)
     {var switcher=param - 8 | 0;
      if(! (214 < switcher >>> 0))
       {var _eY_=switcher;
        if(67 <= _eY_)
         switch(_eY_)
          {case 67:return 11;
           case 68:return 12;
           case 69:return 13;
           case 70:return 14;
           case 71:return 15;
           case 72:return 16;
           case 73:return 17;
           case 74:return 18;
           case 75:return 19;
           case 76:return 20;
           case 77:return 21;
           case 78:return 22;
           case 79:return 23;
           case 80:return 24;
           case 81:return 25;
           case 82:return 26;
           case 85:return 109;
           case 104:return 56;
           case 105:return 57;
           case 106:return 58;
           case 107:return 59;
           case 108:return 60;
           case 109:return 61;
           case 110:return 62;
           case 111:return 63;
           case 112:return 64;
           case 113:return 65;
           case 114:return 66;
           case 115:return 67;
           case 137:return 119;
           case 178:return 49;
           case 179:return 38;
           case 180:return 53;
           case 181:return 37;
           case 182:return 54;
           case 183:return 55;
           case 184:return 51;
           case 211:return 47;
           case 212:return 52;
           case 213:return 48;
           case 214:return 50
           }
        else
         switch(_eY_)
          {case 0:return 43;
           case 1:return 39;
           case 5:return 40;
           case 11:return 123;
           case 12:return 46;
           case 19:return 42;
           case 24:return 41;
           case 25:return 98;
           case 26:return 99;
           case 27:return 101;
           case 28:return 100;
           case 29:return 94;
           case 30:return 96;
           case 31:return 95;
           case 32:return 97;
           case 34:return 120;
           case 37:return 44;
           case 38:return 45;
           case 40:return 27;
           case 41:return 28;
           case 42:return 29;
           case 43:return 30;
           case 44:return 31;
           case 45:return 32;
           case 46:return 33;
           case 47:return 34;
           case 48:return 35;
           case 49:return 36;
           case 57:return 1;
           case 58:return 2;
           case 59:return 3;
           case 60:return 4;
           case 61:return 5;
           case 62:return 6;
           case 63:return 7;
           case 64:return 8;
           case 65:return 9;
           case 66:return 10
           }}
      return 0}
    function make_unidentified(param){return 0}
    function run_next(value,f,v){return 0 === v?caml_call1(f,value):v}
    function _cc_(x,f){return caml_call1(f,x)}
    function of_event(evt)
     {var _eR_=evt.keyCode;
      function _eS_(_eX_){return run_next(_eR_,try_key_code_normal,_eX_)}
      var match=evt.location,switcher=match - 1 | 0;
      if(2 < switcher >>> 0)
       var _eT_=make_unidentified;
      else
       switch(switcher)
        {case 0:
          var
           _eO_=evt.keyCode,
           _eT_=function(_eV_){return run_next(_eO_,try_key_code_left,_eV_)};
          break;
         case 1:
          var
           _eP_=evt.keyCode,
           _eT_=function(_eU_){return run_next(_eP_,try_key_code_right,_eU_)};
          break;
         default:
          var
           _eQ_=evt.keyCode,
           _eT_=function(_eW_){return run_next(_eQ_,try_key_code_numpad,_eW_)}}
      var value=evt.code;
      return _cc_
              (_cc_
                (_cc_
                  (0,
                   function(v)
                    {return 0 === v
                             ?caml_call3(Optdef[7],value,make_unidentified,f)
                             :v}),
                 _eT_),
               _eS_)}
    function char_of_int(value)
     {if(0 < value)
       try
        {var _eM_=[0,caml_call1(Uchar[8],value)];return _eM_}
       catch(_eN_){return 0}
      return 0}
    function empty_string(param){return ""}
    function none(param){return 0}
    function of_event$0(evt)
     {var key=caml_call2(Optdef[8],evt.key,empty_string),match=key.length;
      return 0 === match
              ?caml_call3(Optdef[7],evt.charCode,none,char_of_int)
              :1 === match?char_of_int(key.charCodeAt(0) | 0):0}
    function element$1(_eL_){return _eL_}
    function tagged(e)
     {var tag=caml_js_to_byte_string(e.tagName.toLowerCase());
      if(0 === caml_ml_string_length(tag))return [61,e];
      var match=runtime.caml_bytes_unsafe_get(tag,0),switcher=match - 97 | 0;
      if(! (21 < switcher >>> 0))
       switch(switcher)
        {case 0:
          return caml_string_notequal(tag,cst_a$1)
                  ?caml_string_notequal(tag,cst_area$1)
                    ?caml_string_notequal(tag,cst_audio$1)?[61,e]:[2,e]
                    :[1,e]
                  :[0,e];
         case 1:
          return caml_string_notequal(tag,cst_base$1)
                  ?caml_string_notequal(tag,cst_blockquote$1)
                    ?caml_string_notequal(tag,cst_body$1)
                      ?caml_string_notequal(tag,cst_br$1)
                        ?caml_string_notequal(tag,cst_button$1)?[61,e]:[7,e]
                        :[6,e]
                      :[5,e]
                    :[4,e]
                  :[3,e];
         case 2:
          return caml_string_notequal(tag,cst_canvas$1)
                  ?caml_string_notequal(tag,cst_caption$1)
                    ?caml_string_notequal(tag,cst_col$1)
                      ?caml_string_notequal(tag,cst_colgroup$1)?[61,e]:[11,e]
                      :[10,e]
                    :[9,e]
                  :[8,e];
         case 3:
          return caml_string_notequal(tag,cst_del$1)
                  ?caml_string_notequal(tag,cst_div$1)
                    ?caml_string_notequal(tag,cst_dl$1)?[61,e]:[14,e]
                    :[13,e]
                  :[12,e];
         case 4:return caml_string_notequal(tag,cst_embed$1)?[61,e]:[15,e];
         case 5:
          return caml_string_notequal(tag,cst_fieldset$1)
                  ?caml_string_notequal(tag,cst_form$1)
                    ?caml_string_notequal(tag,cst_frame$1)
                      ?caml_string_notequal(tag,cst_frameset$1)?[61,e]:[18,e]
                      :[19,e]
                    :[17,e]
                  :[16,e];
         case 7:
          return caml_string_notequal(tag,cst_h1$1)
                  ?caml_string_notequal(tag,cst_h2$1)
                    ?caml_string_notequal(tag,cst_h3$1)
                      ?caml_string_notequal(tag,cst_h4$1)
                        ?caml_string_notequal(tag,cst_h5$1)
                          ?caml_string_notequal(tag,cst_h6$1)
                            ?caml_string_notequal(tag,cst_head$1)
                              ?caml_string_notequal(tag,cst_hr$1)
                                ?caml_string_notequal(tag,cst_html$1)?[61,e]:[28,e]
                                :[27,e]
                              :[26,e]
                            :[25,e]
                          :[24,e]
                        :[23,e]
                      :[22,e]
                    :[21,e]
                  :[20,e];
         case 8:
          return caml_string_notequal(tag,cst_iframe$1)
                  ?caml_string_notequal(tag,cst_img$1)
                    ?caml_string_notequal(tag,cst_input$2)
                      ?caml_string_notequal(tag,cst_ins$1)?[61,e]:[32,e]
                      :[31,e]
                    :[30,e]
                  :[29,e];
         case 11:
          return caml_string_notequal(tag,cst_label$1)
                  ?caml_string_notequal(tag,cst_legend$1)
                    ?caml_string_notequal(tag,cst_li$1)
                      ?caml_string_notequal(tag,cst_link$1)?[61,e]:[36,e]
                      :[35,e]
                    :[34,e]
                  :[33,e];
         case 12:
          return caml_string_notequal(tag,cst_map$1)
                  ?caml_string_notequal(tag,cst_meta$1)?[61,e]:[38,e]
                  :[37,e];
         case 14:
          return caml_string_notequal(tag,cst_object$1)
                  ?caml_string_notequal(tag,cst_ol$1)
                    ?caml_string_notequal(tag,cst_optgroup$1)
                      ?caml_string_notequal(tag,cst_option$1)?[61,e]:[42,e]
                      :[41,e]
                    :[40,e]
                  :[39,e];
         case 15:
          return caml_string_notequal(tag,cst_p$1)
                  ?caml_string_notequal(tag,cst_param$1)
                    ?caml_string_notequal(tag,cst_pre$1)?[61,e]:[45,e]
                    :[44,e]
                  :[43,e];
         case 16:return caml_string_notequal(tag,cst_q$1)?[61,e]:[46,e];
         case 18:
          return caml_string_notequal(tag,cst_script$1)
                  ?caml_string_notequal(tag,cst_select$2)
                    ?caml_string_notequal(tag,cst_style$1)?[61,e]:[49,e]
                    :[48,e]
                  :[47,e];
         case 19:
          return caml_string_notequal(tag,cst_table$1)
                  ?caml_string_notequal(tag,cst_tbody$1)
                    ?caml_string_notequal(tag,cst_td$1)
                      ?caml_string_notequal(tag,cst_textarea$1)
                        ?caml_string_notequal(tag,cst_tfoot$1)
                          ?caml_string_notequal(tag,cst_th$1)
                            ?caml_string_notequal(tag,cst_thead$1)
                              ?caml_string_notequal(tag,cst_title$1)
                                ?caml_string_notequal(tag,cst_tr$1)?[61,e]:[58,e]
                                :[57,e]
                              :[56,e]
                            :[55,e]
                          :[54,e]
                        :[53,e]
                      :[52,e]
                    :[51,e]
                  :[50,e];
         case 20:return caml_string_notequal(tag,cst_ul$1)?[61,e]:[59,e];
         case 21:return caml_string_notequal(tag,cst_video$1)?[61,e]:[60,e]
         }
      return [61,e]}
    function opt_tagged(e)
     {function _eJ_(e){return [0,tagged(e)]}
      function _eK_(param){return 0}
      return caml_call3(Opt[7],e,_eK_,_eJ_)}
    function taggedEvent(ev)
     {function _eu_(ev){return [0,ev]}
      function _ev_(param)
       {function _ex_(ev){return [1,ev]}
        function _ey_(param)
         {function _eA_(ev){return [2,ev]}
          function _eB_(param)
           {function _eD_(ev){return [3,ev]}
            function _eE_(param)
             {function _eG_(ev){return [4,ev]}
              function _eH_(param){return [5,ev]}
              var _eI_=popStateEvent(ev);
              return caml_call3(Opt[7],_eI_,_eH_,_eG_)}
            var _eF_=mouseScrollEvent(ev);
            return caml_call3(Opt[7],_eF_,_eE_,_eD_)}
          var _eC_=wheelEvent(ev);
          return caml_call3(Opt[7],_eC_,_eB_,_eA_)}
        var _ez_=keyboardEvent(ev);
        return caml_call3(Opt[7],_ez_,_ey_,_ex_)}
      var _ew_=mouseEvent(ev);
      return caml_call3(Opt[7],_ew_,_ev_,_eu_)}
    function opt_taggedEvent(ev)
     {function _es_(ev){return [0,taggedEvent(ev)]}
      function _et_(param){return 0}
      return caml_call3(Opt[7],ev,_et_,_es_)}
    function stopPropagation(ev)
     {function _eq_(param){return ev.stopPropagation()}
      function _er_(param){return ev.cancelBubble = true$0}
      return caml_call3(Optdef[7],ev.stopPropagation,_er_,_eq_)}
    var
     requestAnimationFrame=
      runtime.caml_js_pure_expr
       (function(param)
         {var
           l=
            [0,
             _b__.requestAnimationFrame,
             [0,
              _b__.mozRequestAnimationFrame,
              [0,
               _b__.webkitRequestAnimationFrame,
               [0,
                _b__.oRequestAnimationFrame,
                [0,_b__.msRequestAnimationFrame,0]]]]];
          try
           {var
             _en_=function(c){return caml_call1(Optdef[5],c)},
             req=caml_call2(List[33],_en_,l),
             _eo_=function(callback){return req(callback)};
            return _eo_}
          catch(_ep_)
           {_ep_ = caml_wrap_exception(_ep_);
            if(_ep_ === Not_found)
             {var
               now=function(param){return new date_ms().getTime()},
               last=[0,now(0)];
              return function(callback)
               {var
                 t=now(0),
                 dt=last[1] + 16.6666666666666679 - t,
                 dt$0=dt < 0?0:dt;
                last[1] = t;
                _b__.setTimeout(callback,dt$0);
                return 0}}
            throw _ep_}});
    function hasPushState(param)
     {return caml_call1(Optdef[5],_b__.history.pushState)}
    function hasPlaceholder(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.placeholder)}
    function hasRequired(param)
     {var i=createInput(0,0,document$0);
      return caml_call1(Optdef[5],i.required)}
    var overflow_limit=2147483e3;
    function setTimeout(callback,d)
     {var id=[0,0];
      function loop(step,param)
       {if(2147483e3 < step)
         var step$0=overflow_limit,remain=step - 2147483e3;
        else
         var step$0=step,remain=0;
        var cb=remain == 0?callback:function(_em_){return loop(remain,_em_)};
        id[1] = [0,_b__.setTimeout(caml_js_wrap_callback(cb),step$0)];
        return 0}
      loop(d,0);
      return id}
    function clearTimeout(id)
     {var _el_=id[1];
      if(_el_){var x=_el_[1];id[1] = 0;return _b__.clearTimeout(x)}
      return 0}
    function js_array_of_collection(c){return [].slice.call(c)}
    var
     Dom_html=
      [0,
       d,
       document$0,
       getElementById_opt,
       getElementById_exn,
       getElementById_coerce,
       getElementById,
       location_origin,
       _b__,
       no_handler,
       handler,
       full_handler,
       invoke_handler,
       eventTarget,
       eventRelatedTarget,
       Event$0,
       addEventListener,
       removeEventListener,
       addMousewheelEventListener,
       buttonPressed,
       eventAbsolutePosition$0,
       elementClientPosition,
       getDocumentScroll,
       [0,of_event,try_key_code_normal],
       [0,of_event$0],
       createHtml,
       createHead,
       createLink,
       createTitle,
       createMeta,
       createBase,
       createStyle,
       createBody,
       createForm,
       createOptgroup,
       createOption,
       createSelect,
       createInput,
       createTextarea,
       createButton,
       createLabel,
       createFieldset,
       createLegend,
       createUl,
       createOl,
       createDl,
       createLi,
       createDiv,
       createEmbed,
       createP,
       createH1,
       createH2,
       createH3,
       createH4,
       createH5,
       createH6,
       createQ,
       createBlockquote,
       createPre,
       createBr,
       createHr,
       createIns,
       createDel,
       createA,
       createImg,
       createObject,
       createParam,
       createMap,
       createArea,
       createScript,
       createTable,
       createCaption,
       createCol,
       createColgroup,
       createThead,
       createTfoot,
       createTbody,
       createTr,
       createTh,
       createTd,
       createSub,
       createSup,
       createSpan,
       createTt,
       createI,
       createB,
       createBig,
       createSmall,
       createEm,
       createStrong,
       createCite,
       createDfn,
       createCode,
       createSamp,
       createKbd,
       createVar,
       createAbbr,
       createDd,
       createDt,
       createNoscript,
       createAddress,
       createFrameset,
       createFrame,
       createIframe,
       createAudio,
       createVideo,
       Canvas_not_available,
       createCanvas,
       element$1,
       tagged,
       opt_tagged,
       taggedEvent,
       opt_taggedEvent,
       stopPropagation,
       [0,
        element$0,
        a,
        area,
        audio,
        base,
        blockquote,
        body,
        br,
        button,
        canvas,
        caption,
        col,
        colgroup,
        del,
        div,
        embed,
        dl,
        fieldset,
        form,
        frameset,
        frame,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        head,
        hr,
        html,
        iframe,
        img,
        input$0,
        ins,
        label,
        legend,
        li,
        link,
        map$1,
        meta,
        object,
        ol,
        optgroup,
        option$1,
        p,
        param,
        pre,
        q,
        script,
        select$0,
        style,
        table,
        tbody,
        td,
        textarea,
        tfoot,
        th,
        thead,
        title,
        tr,
        ul,
        video,
        mouseEvent,
        keyboardEvent,
        wheelEvent,
        mouseScrollEvent,
        popStateEvent],
       setTimeout,
       clearTimeout,
       js_array_of_collection,
       requestAnimationFrame,
       runtime.caml_js_html_entities,
       onIE,
       hasPushState,
       hasPlaceholder,
       hasRequired];
    caml_register_global(1623,Dom_html,"Dom_html");
    function listen(opt,target,typ,cb)
     {if(opt)var sth=opt[1],capture=sth;else var capture=0;
      var _ek_=! ! capture;
      return addEventListener
              (target,
               typ,
               full_handler(function(n,e){return ! ! caml_call2(cb,n,e)}),
               _ek_)}
    var Dom_events=[0,Event$0,listen,removeEventListener];
    caml_register_global(1624,Dom_events,"Dom_events");
    var
     xmlns="http://www.w3.org/2000/svg",
     SVGError=[248,cst_Dom_svg_SVGError,caml_fresh_oo_id(0)];
    function createElement$0(doc,name)
     {return doc.createElementNS(xmlns,name.toString())}
    function unsafeCreateElement$0(doc,name){return createElement$0(doc,name)}
    function createA$0(doc){return unsafeCreateElement$0(doc,cst_a$2)}
    function createAltGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_altglyph)}
    function createAltGlyphDef(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphdef)}
    function createAltGlyphItem(doc)
     {return unsafeCreateElement$0(doc,cst_altglyphitem)}
    function createAnimate(doc){return unsafeCreateElement$0(doc,cst_animate)}
    function createAnimateColor(doc)
     {return unsafeCreateElement$0(doc,cst_animatecolor)}
    function createAnimateMotion(doc)
     {return unsafeCreateElement$0(doc,cst_animatemotion)}
    function createAnimateTransform(doc)
     {return unsafeCreateElement$0(doc,cst_animatetransform)}
    function createCircle(doc){return unsafeCreateElement$0(doc,cst_circle)}
    function createClipPath(doc)
     {return unsafeCreateElement$0(doc,cst_clippath)}
    function createCursor(doc){return unsafeCreateElement$0(doc,cst_cursor)}
    function createDefs(doc){return unsafeCreateElement$0(doc,cst_defs)}
    function createDesc(doc){return unsafeCreateElement$0(doc,cst_desc)}
    function createEllipse(doc){return unsafeCreateElement$0(doc,cst_ellipse)}
    function createFilter(doc){return unsafeCreateElement$0(doc,cst_filter)}
    function createFont(doc){return unsafeCreateElement$0(doc,cst_font)}
    function createFontFace(doc)
     {return unsafeCreateElement$0(doc,cst_font_face)}
    function createFontFaceFormat(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_format)}
    function createFontFaceName(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_name)}
    function createFontFaceSrc(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_src)}
    function createFontFaceUri(doc)
     {return unsafeCreateElement$0(doc,cst_font_face_uri)}
    function createForeignObject(doc)
     {return unsafeCreateElement$0(doc,cst_foreignobject)}
    function createG(doc){return unsafeCreateElement$0(doc,cst_g$0)}
    function createGlyph(doc){return unsafeCreateElement$0(doc,cst_glyph)}
    function createGlyphRef(doc)
     {return unsafeCreateElement$0(doc,cst_glyphref)}
    function createhkern(doc){return unsafeCreateElement$0(doc,cst_hkern)}
    function createImage(doc){return unsafeCreateElement$0(doc,cst_image)}
    function createLineElement(doc)
     {return unsafeCreateElement$0(doc,cst_line)}
    function createLinearElement(doc)
     {return unsafeCreateElement$0(doc,cst_lineargradient)}
    function createMask(doc){return unsafeCreateElement$0(doc,cst_mask)}
    function createMetaData(doc)
     {return unsafeCreateElement$0(doc,cst_metadata)}
    function createMissingGlyph(doc)
     {return unsafeCreateElement$0(doc,cst_missing_glyph)}
    function createMPath(doc){return unsafeCreateElement$0(doc,cst_mpath)}
    function createPath(doc){return unsafeCreateElement$0(doc,cst_path)}
    function createParttern(doc)
     {return unsafeCreateElement$0(doc,cst_parttern)}
    function createPolygon(doc){return unsafeCreateElement$0(doc,cst_polygon)}
    function createPolyline(doc)
     {return unsafeCreateElement$0(doc,cst_polyline)}
    function createRadialgradient(doc)
     {return unsafeCreateElement$0(doc,cst_radialgradient)}
    function createRect(doc){return unsafeCreateElement$0(doc,cst_rect)}
    function createScript$0(doc)
     {return unsafeCreateElement$0(doc,cst_script$2)}
    function createSet(doc){return unsafeCreateElement$0(doc,cst_set)}
    function createStop(doc){return unsafeCreateElement$0(doc,cst_stop)}
    function createStyle$0(doc){return unsafeCreateElement$0(doc,cst_style$2)}
    function createSvg(doc){return unsafeCreateElement$0(doc,cst_svg)}
    function createSwitch(doc){return unsafeCreateElement$0(doc,cst_switch)}
    function createSymbol(doc){return unsafeCreateElement$0(doc,cst_symbol)}
    function createTextElement(doc)
     {return unsafeCreateElement$0(doc,cst_text)}
    function createTextpath(doc)
     {return unsafeCreateElement$0(doc,cst_textpath)}
    function createTitle$0(doc){return unsafeCreateElement$0(doc,cst_title$2)}
    function createTref(doc){return unsafeCreateElement$0(doc,cst_tref)}
    function createTspan(doc){return unsafeCreateElement$0(doc,cst_tspan)}
    function createUse(doc){return unsafeCreateElement$0(doc,cst_use)}
    function createView(doc){return unsafeCreateElement$0(doc,cst_view)}
    function createvkern(doc){return unsafeCreateElement$0(doc,cst_vkern)}
    var svg_element=Unsafe[1].SVGElement,document$1=Unsafe[1].document;
    function getElementById$0(id)
     {function _eh_(e){if(e instanceof svg_element)return e;throw Not_found}
      function _ei_(param){throw Not_found}
      var _ej_=Unsafe[1].document.getElementById(id.toString());
      return caml_call3(Opt[7],_ej_,_ei_,_eh_)}
    function element$2(e){return e instanceof svg_element?e:no_handler}
    function unsafeCoerce$0(e,tag)
     {var _eg_=tag.toString();
      return e.tagName.toLowerCase() === _eg_?e:no_handler}
    function a$0(e){return unsafeCoerce$0(e,cst_a$3)}
    function altGlyph(e){return unsafeCoerce$0(e,cst_altglyph$0)}
    function altGlyphDef(e){return unsafeCoerce$0(e,cst_altglyphdef$0)}
    function altGlyphItem(e){return unsafeCoerce$0(e,cst_altglyphitem$0)}
    function animate(e){return unsafeCoerce$0(e,cst_animate$0)}
    function animateColor(e){return unsafeCoerce$0(e,cst_animatecolor$0)}
    function animateMotion(e){return unsafeCoerce$0(e,cst_animatemotion$0)}
    function animateTransform(e)
     {return unsafeCoerce$0(e,cst_animatetransform$0)}
    function circle(e){return unsafeCoerce$0(e,cst_circle$0)}
    function clipPath(e){return unsafeCoerce$0(e,cst_clippath$0)}
    function cursor(e){return unsafeCoerce$0(e,cst_cursor$0)}
    function defs(e){return unsafeCoerce$0(e,cst_defs$0)}
    function desc(e){return unsafeCoerce$0(e,cst_desc$0)}
    function ellipse(e){return unsafeCoerce$0(e,cst_ellipse$0)}
    function filter(e){return unsafeCoerce$0(e,cst_filter$0)}
    function font(e){return unsafeCoerce$0(e,cst_font$0)}
    function fontFace(e){return unsafeCoerce$0(e,cst_font_face$0)}
    function fontFaceFormat(e)
     {return unsafeCoerce$0(e,cst_font_face_format$0)}
    function fontFaceName(e){return unsafeCoerce$0(e,cst_font_face_name$0)}
    function fontFaceSrc(e){return unsafeCoerce$0(e,cst_font_face_src$0)}
    function fontFaceUri(e){return unsafeCoerce$0(e,cst_font_face_uri$0)}
    function foreignObject(e){return unsafeCoerce$0(e,cst_foreignobject$0)}
    function g(e){return unsafeCoerce$0(e,cst_g$1)}
    function glyph(e){return unsafeCoerce$0(e,cst_glyph$0)}
    function glyphRef(e){return unsafeCoerce$0(e,cst_glyphref$0)}
    function hkern(e){return unsafeCoerce$0(e,cst_hkern$0)}
    function image(e){return unsafeCoerce$0(e,cst_image$0)}
    function lineElement(e){return unsafeCoerce$0(e,cst_line$0)}
    function linearElement(e){return unsafeCoerce$0(e,cst_lineargradient$0)}
    function mask(e){return unsafeCoerce$0(e,cst_mask$0)}
    function metaData(e){return unsafeCoerce$0(e,cst_metadata$0)}
    function missingGlyph(e){return unsafeCoerce$0(e,cst_missing_glyph$0)}
    function mPath(e){return unsafeCoerce$0(e,cst_mpath$0)}
    function path(e){return unsafeCoerce$0(e,cst_path$0)}
    function parttern(e){return unsafeCoerce$0(e,cst_parttern$0)}
    function polygon(e){return unsafeCoerce$0(e,cst_polygon$0)}
    function polyline(e){return unsafeCoerce$0(e,cst_polyline$0)}
    function radialgradient(e){return unsafeCoerce$0(e,cst_radialgradient$0)}
    function rect(e){return unsafeCoerce$0(e,cst_rect$0)}
    function script$0(e){return unsafeCoerce$0(e,cst_script$3)}
    function set$0(e){return unsafeCoerce$0(e,cst_set$0)}
    function stop(e){return unsafeCoerce$0(e,cst_stop$0)}
    function style$0(e){return unsafeCoerce$0(e,cst_style$3)}
    function svg(e){return unsafeCoerce$0(e,cst_svg$0)}
    function switch$0(e){return unsafeCoerce$0(e,cst_switch$0)}
    function symbol(e){return unsafeCoerce$0(e,cst_symbol$0)}
    function textElement(e){return unsafeCoerce$0(e,cst_text$0)}
    function textpath(e){return unsafeCoerce$0(e,cst_textpath$0)}
    function title$0(e){return unsafeCoerce$0(e,cst_title$3)}
    function tref(e){return unsafeCoerce$0(e,cst_tref$0)}
    function tspan(e){return unsafeCoerce$0(e,cst_tspan$0)}
    function use(e){return unsafeCoerce$0(e,cst_use$0)}
    function view(e){return unsafeCoerce$0(e,cst_view$0)}
    function vkern(e){return unsafeCoerce$0(e,cst_vkern$0)}
    var
     Dom_svg=
      [0,
       xmlns,
       SVGError,
       createElement$0,
       createA$0,
       createAltGlyph,
       createAltGlyphDef,
       createAltGlyphItem,
       createAnimate,
       createAnimateColor,
       createAnimateMotion,
       createAnimateTransform,
       createCircle,
       createClipPath,
       createCursor,
       createDefs,
       createDesc,
       createEllipse,
       createFilter,
       createFont,
       createFontFace,
       createFontFaceFormat,
       createFontFaceName,
       createFontFaceSrc,
       createFontFaceUri,
       createForeignObject,
       createG,
       createGlyph,
       createGlyphRef,
       createhkern,
       createImage,
       createLineElement,
       createLinearElement,
       createMask,
       createMetaData,
       createMissingGlyph,
       createMPath,
       createPath,
       createParttern,
       createPolygon,
       createPolyline,
       createRadialgradient,
       createRect,
       createScript$0,
       createSet,
       createStop,
       createStyle$0,
       createSvg,
       createSwitch,
       createSymbol,
       createTextElement,
       createTextpath,
       createTitle$0,
       createTref,
       createTspan,
       createUse,
       createView,
       createvkern,
       svg_element,
       document$1,
       getElementById$0,
       [0,
        element$2,
        a$0,
        altGlyph,
        altGlyphDef,
        altGlyphItem,
        animate,
        animateColor,
        animateMotion,
        animateTransform,
        circle,
        clipPath,
        cursor,
        defs,
        desc,
        ellipse,
        filter,
        font,
        fontFace,
        fontFaceFormat,
        fontFaceName,
        fontFaceSrc,
        fontFaceUri,
        foreignObject,
        g,
        glyph,
        glyphRef,
        hkern,
        image,
        lineElement,
        linearElement,
        mask,
        metaData,
        missingGlyph,
        mPath,
        path,
        parttern,
        polygon,
        polyline,
        radialgradient,
        rect,
        script$0,
        set$0,
        stop,
        style$0,
        svg,
        switch$0,
        symbol,
        textElement,
        textpath,
        title$0,
        tref,
        tspan,
        use,
        view,
        vkern]];
    caml_register_global(1625,Dom_svg,"Dom_svg");
    function withCredentials(b)
     {var init={};init.withCredentials = ! ! b;return init}
    var
     eventSource=Unsafe[1].EventSource,
     eventSource_options=Unsafe[1].EventSource,
     EventSource=
      [0,withCredentials,eventSource,eventSource_options,addEventListener];
    caml_register_global(1626,EventSource,"EventSource");
    var console=runtime.caml_js_get_console(0),Firebug=[0,console];
    caml_register_global(1627,Firebug,"Firebug");
    var formData=Unsafe[1].FormData,formData_form=Unsafe[1].FormData;
    function filter_map$0(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var q=param$0[2],v=param$0[1],match=caml_call1(f,v);
          if(match){var v$0=match[1];return [0,v$0,filter_map$0(f,q)]}
          var param$0=q;
          continue}
        return 0}}
    function have_content(elt)
     {var _ee_=0 < elt.name.length?1:0,_ef_=_ee_?1 - (elt.disabled | 0):_ee_;
      return _ef_}
    function form_elements(get,form)
     {var length=form.elements.length;
      function _d4_(i)
       {var _ed_=form.elements.item(i);return caml_call1(Opt[10],_ed_)}
      var
       _d5_=caml_call2(Array[2],length,_d4_),
       elements=caml_call1(Array[11],_d5_);
      function _d6_(param)
       {if(param)
         {var v=param[1],match$3=tagged(v);
          switch(match$3[0])
           {case 31:
             var v$0=match$3[1];
             if(get)var sth=get[1],get$0=sth;else var get$0=0;
             if(have_content(v$0))
              {var
                name$1=caml_js_to_string(v$0.name),
                value=v$0.value,
                match=caml_js_to_byte_string(v$0.type.toLowerCase());
               if(caml_string_notequal(match,cst_checkbox))
                {if(! caml_string_notequal(match,cst_file))
                  {if(get$0)return [0,[0,name$1,[0,-976970511,value]],0];
                   var match$0=caml_call1(Optdef[10],v$0.files);
                   if(match$0)
                    {var list=match$0[1];
                     if(0 === list.length)
                      return [0,[0,name$1,[0,-976970511,""]],0];
                     var match$1=caml_call1(Optdef[10],v$0.multiple);
                     if(match$1)
                      if(0 !== match$1[1])
                       {var
                         _d$_=function(i){return list.item(i)},
                         _ea_=caml_call2(Array[2],list.length,_d$_),
                         _eb_=caml_call1(Array[11],_ea_);
                        return filter_map$0
                                (function(f)
                                  {var match=caml_call1(Opt[10],f);
                                   if(match)
                                    {var file=match[1];return [0,[0,name$1,[0,781515420,file]]]}
                                   return 0},
                                 _eb_)}
                     var _d__=list.item(0),match$2=caml_call1(Opt[10],_d__);
                     if(match$2)
                      {var file=match$2[1];
                       return [0,[0,name$1,[0,781515420,file]],0]}
                     return 0}
                   return 0}
                 if(caml_string_notequal(match,cst_password))
                  if(caml_string_notequal(match,cst_radio))
                   {if(caml_string_notequal(match,cst_reset))
                     if(caml_string_notequal(match,cst_submit$0))
                      {if(caml_string_notequal(match,cst_text$1))
                        return [0,[0,name$1,[0,-976970511,value]],0];
                       var switch$0=1,switch$1=0}
                     else
                      var switch$1=1;
                    else
                     var switch$1=1;
                    if(switch$1)return 0}
                  else
                   var switch$0=0;
                 else
                  var switch$0=1;
                 if(switch$0)return [0,[0,name$1,[0,-976970511,value]],0]}
               return v$0.checked | 0?[0,[0,name$1,[0,-976970511,value]],0]:0}
             return 0;
            case 48:
             var v$1=match$3[1];
             if(have_content(v$1))
              {var name$0=caml_js_to_string(v$1.name);
               if(v$1.multiple | 0)
                {var
                  _d8_=
                   function(i)
                    {var _ec_=v$1.options.item(i);
                     return caml_call1(Opt[10],_ec_)},
                  options=caml_call2(Array[2],v$1.options.length,_d8_),
                  _d9_=caml_call1(Array[11],options);
                 return filter_map$0
                         (function(param)
                           {if(param)
                             {var e=param[1];
                              return e.selected | 0
                                      ?[0,[0,name$0,[0,-976970511,e.value]]]
                                      :0}
                            return 0},
                          _d9_)}
               return [0,[0,name$0,[0,-976970511,v$1.value]],0]}
             return 0;
            case 53:
             var v$2=match$3[1];
             if(have_content(v$2))
              {var name=caml_js_to_string(v$2.name);
               return [0,[0,name,[0,-976970511,v$2.value]],0]}
             return 0;
            default:return 0}}
        return 0}
      var
       _d7_=caml_call2(List[17],_d6_,elements),
       contents=caml_call1(List[14],_d7_);
      return contents}
    function append(form_contents,form_elt)
     {if(891486873 <= form_contents[1])
       {var list=form_contents[2];list[1] = [0,form_elt,list[1]];return 0}
      var f=form_contents[2],_d2_=form_elt[2],_d3_=form_elt[1];
      if(781515420 <= _d2_[1])
       {var file=_d2_[2];return f.append(_d3_.toString(),file)}
      var s=_d2_[2];
      return f.append(_d3_.toString(),s)}
    function empty_form_contents(param)
     {var match=caml_call1(Optdef[10],formData);
      if(match){var constr=match[1];return [0,808620462,new constr()]}
      return [0,891486873,[0,0]]}
    function post_form_contents(form)
     {var contents=empty_form_contents(0),_dZ_=form_elements(0,form);
      function _d0_(_d1_){return append(contents,_d1_)}
      caml_call2(List[15],_d0_,_dZ_);
      return contents}
    function get_form_contents(form)
     {var _dV_=form_elements(_cd_,form);
      function _dW_(param)
       {var _dX_=param[2],_dY_=param[1];
        if(typeof _dX_ !== "number")
         if(-976970511 === _dX_[1])
          {var s=_dX_[2];return [0,_dY_,caml_js_to_string(s)]}
        throw [0,Assert_failure,_ce_]}
      return caml_call2(List[17],_dW_,_dV_)}
    var
     Form=
      [0,
       formData,
       formData_form,
       append,
       post_form_contents,
       get_form_contents,
       empty_form_contents,
       form_elements];
    caml_register_global(1628,Form,"Form");
    function empty_position_options(param){return {}}
    var
     x=Unsafe[1].navigator,
     geolocation=caml_call1(Optdef[5],x)?x.geolocation:x;
    function is_supported(param){return caml_call1(Optdef[5],geolocation)}
    var Geolocation=[0,empty_position_options,geolocation,is_supported];
    caml_register_global(1629,Geolocation,"Geolocation");
    function object_options(param){return {"localeMatcher":"best fit"}}
    function options(param)
     {return {"localeMatcher":"best fit",
              "usage":"sort",
              "sensitivity":"variant",
              "ignorePunctuation":false$0,
              "numeric":false$0,
              "caseFirst":"false"}}
    var Collator=[0,object_options,options];
    function options$0(param)
     {return {"localeMatcher":"best fit",
              "timeZone":t37,
              "hour12":t37,
              "hourCycle":t37,
              "formatMatcher":"best fit",
              "weekday":t37,
              "era":t37,
              "year":t37,
              "month":t37,
              "day":t37,
              "hour":t37,
              "minute":t37,
              "second":t37,
              "timeZoneName":t37}}
    var DateTimeFormat=[0,object_options,options$0];
    function options$1(param)
     {return {"localeMatcher":"best fit",
              "style":"decimal",
              "currency":t37,
              "currencyDisplay":t37,
              "useGrouping":true$0,
              "minimumIntegerDigits":t37,
              "minimumFractionDigits":t37,
              "maximumFractionDigits":t37,
              "minimumSignificantDigits":t37,
              "maximumSignificantDigits":t37}}
    var NumberFormat=[0,object_options,options$1];
    function options$2(param)
     {return {"localeMatcher":"best fit","type":"cardinal"}}
    var
     PluralRules=[0,object_options,options$2],
     intl=Unsafe[1].Intl,
     collator_constr=Unsafe[1].Intl.Collator,
     dateTimeFormat_constr=Unsafe[1].Intl.DateTimeFormat,
     numberFormat_constr=Unsafe[1].Intl.NumberFormat,
     pluralRules_constr=Unsafe[1].Intl.PluralRules;
    function is_supported$0(param){return caml_call1(Optdef[5],intl)}
    var
     Intl=
      [0,
       Collator,
       DateTimeFormat,
       NumberFormat,
       PluralRules,
       intl,
       collator_constr,
       dateTimeFormat_constr,
       numberFormat_constr,
       pluralRules_constr,
       is_supported$0];
    caml_register_global(1631,Intl,"Intl");
    var json=runtime.caml_json(0);
    function reviver(this$0,key,value)
     {return typeof value == typeof "foo"?caml_js_to_byte_string(value):value}
    var input_reviver=caml_js_wrap_meth_callback(reviver);
    function unsafe_input(s){return json.parse(s,input_reviver)}
    var mlString_constr=dummy_string.constructor;
    function output_reviver(key,value)
     {return value instanceof mlString_constr
              ?caml_jsbytes_of_string(value)
              :value}
    function output(obj){return json.stringify(obj,output_reviver)}
    var Json=[0,output,unsafe_input];
    caml_register_global(1632,Json,"Json");
    var obj=Unsafe[1].Object;
    function create(param){return new obj()}
    function add$0(t,k,v){return t[k.concat("_")] = v}
    function remove(t,k){return delete t[k.concat("_")]}
    function find(t,k){return t[k.concat("_")]}
    function keys(t)
     {var
       key_array=Unsafe[1].Object.keys(t),
       res=[0,0],
       _dR_=key_array.length - 1 | 0,
       _dQ_=0;
      if(! (_dR_ < 0))
       {var i=_dQ_;
        for(;;)
         {var
           _dS_=
            function(param){return caml_call1(Pervasives[2],cst_Jstable_keys)},
           key=caml_call2(Optdef[8],key_array[i],_dS_),
           _dT_=res[1];
          res[1] = [0,key.substring(0,key.length - 1 | 0),_dT_];
          var _dU_=i + 1 | 0;
          if(_dR_ !== i){var i=_dU_;continue}
          break}}
      return caml_call1(List[9],res[1])}
    var Jstable=[0,create,add$0,remove,find,keys];
    caml_register_global(1633,Jstable,"Jstable");
    function empty_mutation_observer_init(param){return {}}
    var mutationObserver=Unsafe[1].MutationObserver;
    function is_supported$1(param)
     {return caml_call1(Optdef[5],mutationObserver)}
    function observe
     (node,
      f,
      child_list,
      attributes,
      character_data,
      subtree,
      attribute_old_value,
      character_data_old_value,
      attribute_filter,
      param)
     {function opt_iter(x,f)
       {if(x){var x$0=x[1];return caml_call1(f,x$0)}return 0}
      var obs=new mutationObserver(caml_js_wrap_callback(f)),cfg={};
      opt_iter(child_list,function(v){return cfg.childList = v});
      opt_iter(attributes,function(v){return cfg.attributes = v});
      opt_iter(character_data,function(v){return cfg.characterData = v});
      opt_iter(subtree,function(v){return cfg.subtree = v});
      opt_iter
       (attribute_old_value,function(v){return cfg.attributeOldValue = v});
      opt_iter
       (character_data_old_value,
        function(v){return cfg.characterDataOldValue = v});
      opt_iter
       (attribute_filter,
        function(l)
         {return cfg.attributeFilter
                 =
                 caml_js_from_array(caml_call1(Array[12],l))});
      obs.observe(node,cfg);
      return obs}
    var
     MutationObserver=
      [0,empty_mutation_observer_init,mutationObserver,is_supported$1,observe];
    caml_register_global(1634,MutationObserver,"MutationObserver");
    var Lib_version=[0,js_of_ocaml_version,git_version];
    caml_register_global(1635,Lib_version,"Lib_version");
    function update_file(name,content)
     {var oc=caml_call1(Pervasives[48],name);
      caml_call2(Pervasives[54],oc,content);
      return caml_call1(Pervasives[64],oc)}
    function set_channel_flusher(out_channel,f)
     {var
       f$0=
        caml_js_wrap_callback
         (function(s){return caml_call1(f,caml_js_to_string(s))});
      return runtime.caml_ml_set_channel_output(out_channel,f$0)}
    function set_channel_filler(in_channel,f)
     {var f$0=caml_js_wrap_callback(f);
      return runtime.caml_ml_set_channel_refill(in_channel,f$0)}
    function mount(path,f)
     {return runtime.caml_mount_autoload
              (path,
               caml_js_wrap_callback
                (function(prefix,path){return caml_call2(f,prefix,path)}))}
    var
     unmount=runtime.caml_unmount,
     _cf_=runtime.caml_create_file,
     _cg_=runtime.caml_read_file_content,
     Sys_js=
      [0,
       set_channel_flusher,
       set_channel_filler,
       function(_dP_){return runtime.caml_list_mount_point(_dP_)},
       unmount,
       mount,
       _cg_,
       _cf_,
       update_file,
       js_of_ocaml_version];
    caml_register_global(1636,Sys_js,"Sys_js");
    var Local_exn=[248,cst_Url_Local_exn,caml_fresh_oo_id(0)];
    function interrupt(param){throw Local_exn}
    var
     plus_re=regexp_string(cst$2),
     plus_re_js_string=new regExp_withFlags("\\+","g");
    function urldecode_js_string_string(s)
     {plus_re_js_string.lastIndex = 0;
      return caml_js_to_byte_string
              (unescape(s.replace(plus_re_js_string," ")))}
    function urldecode(s)
     {return caml_js_to_byte_string
              (unescape
                (caml_jsbytes_of_string(global_replace(plus_re,s,cst$3))))}
    function urlencode(opt,s)
     {if(opt)var sth=opt[1],with_plus=sth;else var with_plus=1;
      if(with_plus)
       {var s$0=caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)));
        return global_replace(plus_re,s$0,cst_2B)}
      return caml_js_to_byte_string(escape(caml_jsbytes_of_string(s)))}
    var
     Not_an_http_protocol=
      [248,cst_Url_Not_an_http_protocol,caml_fresh_oo_id(0)],
     default_http_port=80,
     default_https_port=443;
    function path_of_path_string(s)
     {var l=caml_ml_string_length(s);
      function aux(i)
       {try
         {var _dN_=caml_call3(String$0[18],s,i,47),j=_dN_}
        catch(_dO_)
         {_dO_ = caml_wrap_exception(_dO_);
          if(_dO_ !== Not_found)throw _dO_;
          var j=l}
        var word=caml_call3(String$0[4],s,i,j - i | 0);
        return l <= j?[0,word,0]:[0,word,aux(j + 1 | 0)]}
      var a=aux(0);
      if(a)
       if(! caml_string_notequal(a[1],cst$4))
        {var _dM_=a[2];
         if(! _dM_)return 0;
         if(! caml_string_notequal(_dM_[1],cst$5))if(! _dM_[2])return _ch_}
      return a}
    function encode_arguments(l)
     {function _dH_(param)
       {var
         v=param[2],
         n=param[1],
         _dJ_=urlencode(0,v),
         _dK_=caml_call2(Pervasives[16],cst$6,_dJ_),
         _dL_=urlencode(0,n);
        return caml_call2(Pervasives[16],_dL_,_dK_)}
      var _dI_=caml_call2(List[17],_dH_,l);
      return caml_call2(String$0[7],cst$7,_dI_)}
    function decode_arguments_js_string(s)
     {var arr=s.split(caml_call2(String$0[1],1,38).toString()),len=arr.length;
      function aux(acc,idx)
       {var idx$0=idx;
        for(;;)
         {if(0 <= idx$0)
           try
            {var
              _dz_=idx$0 - 1 | 0,
              _dA_=
               function(s)
                {function _dF_(param)
                  {var
                    y=param[2],
                    x=param[1],
                    _dG_=urldecode_js_string_string(y);
                   return [0,urldecode_js_string_string(x),_dG_]}
                 var index=s.indexOf(caml_call2(String$0[1],1,61).toString());
                 if(0 <= index)
                  var
                   _dD_=s.slice(index + 1 | 0),
                   _dE_=[0,s.slice(0,index),_dD_];
                 else
                  var _dE_=t37;
                 return caml_call3(Optdef[7],_dE_,interrupt,_dF_)},
              _dB_=
               aux
                ([0,caml_call3(Optdef[7],arr[idx$0],interrupt,_dA_),acc],_dz_);
             return _dB_}
           catch(_dC_)
            {_dC_ = caml_wrap_exception(_dC_);
             if(_dC_ === Local_exn)
              {var idx$1=idx$0 - 1 | 0,idx$0=idx$1;continue}
             throw _dC_}
          return acc}}
      return aux(0,len - 1 | 0)}
    function decode_arguments(s)
     {return decode_arguments_js_string(caml_jsbytes_of_string(s))}
    var
     url_re=
      new
       regExp_withFlags
       (caml_jsbytes_of_string
         (cst_Hh_Tt_Tt_Pp_Ss_0_9a_zA_Z_0_9a_zA_Z_0_9A_Fa_f_0_9)),
     file_re=new regExp_withFlags(caml_jsbytes_of_string(cst_Ff_Ii_Ll_Ee));
    function url_of_js_string(s)
     {function _dg_(res)
       {var
         prot_string=caml_call2(Optdef[8],res[1],interrupt),
         match=caml_js_to_byte_string(prot_string.toLowerCase());
        if(caml_string_notequal(match,cst_file$0))
         if(caml_string_notequal(match,cst_file$1))
          {if(caml_string_notequal(match,cst_http))
            if(caml_string_notequal(match,cst_http$0))
             {if(caml_string_notequal(match,cst_https))
               if(caml_string_notequal(match,cst_https$0))
                var switch$0=1,switch$1=0;
               else
                var switch$1=1;
              else
               var switch$1=1;
              if(switch$1)var ssl=1,switch$0=2}
            else
             var switch$0=0;
           else
            var switch$0=0;
           switch(switch$0)
            {case 0:var ssl=0,switch$2=1;break;
             case 1:var switch$2=0;break;
             default:var switch$2=1}
           if(switch$2)
            {var
              _dq_=function(param){return caml_jsbytes_of_string(cst$9)},
              path_str=
               urldecode_js_string_string(caml_call2(Optdef[8],res[6],_dq_)),
              _dr_=function(param){return caml_jsbytes_of_string(cst$10)},
              _ds_=
               urldecode_js_string_string(caml_call2(Optdef[8],res[10],_dr_)),
              _dt_=function(param){return caml_jsbytes_of_string(cst$11)},
              _du_=
               decode_arguments_js_string(caml_call2(Optdef[8],res[8],_dt_)),
              _dv_=path_of_path_string(path_str),
              _dw_=function(param){return caml_jsbytes_of_string(cst$12)},
              s=caml_js_to_byte_string(caml_call2(Optdef[8],res[4],_dw_)),
              _dx_=
               caml_string_notequal(s,cst$8)?caml_int_of_string(s):ssl?443:80,
              url=
               [0,
                urldecode_js_string_string
                 (caml_call2(Optdef[8],res[2],interrupt)),
                _dx_,
                _dv_,
                path_str,
                _du_,
                _ds_],
              _dy_=ssl?[1,url]:[0,url];
             return [0,_dy_]}}
        throw Not_an_http_protocol}
      function _dh_(param)
       {function _dj_(res)
         {var
           path_str=
            urldecode_js_string_string(caml_call2(Optdef[8],res[2],interrupt));
          function _dm_(param){return caml_jsbytes_of_string(cst$13)}
          var _dn_=caml_js_to_byte_string(caml_call2(Optdef[8],res[6],_dm_));
          function _do_(param){return caml_jsbytes_of_string(cst$14)}
          var
           _dp_=
            decode_arguments_js_string(caml_call2(Optdef[8],res[4],_do_));
          return [0,[2,[0,path_of_path_string(path_str),path_str,_dp_,_dn_]]]}
        function _dk_(param){return 0}
        var _dl_=file_re.exec(s);
        return caml_call3(Opt[7],_dl_,_dk_,_dj_)}
      var _di_=url_re.exec(s);
      return caml_call3(Opt[7],_di_,_dh_,_dg_)}
    function url_of_string(s)
     {return url_of_js_string(caml_jsbytes_of_string(s))}
    function string_of_url(param)
     {switch(param[0])
       {case 0:
         var
          match=param[1],
          frag=match[6],
          args=match[5],
          path=match[3],
          port=match[2],
          host=match[1];
         if(caml_string_notequal(frag,cst$15))
          var
           _cF_=urlencode(0,frag),
           _cG_=caml_call2(Pervasives[16],cst$16,_cF_);
         else
          var _cG_=cst$23;
         if(args)
          var
           _cH_=encode_arguments(args),
           _cI_=caml_call2(Pervasives[16],cst$17,_cH_);
         else
          var _cI_=cst$22;
         var
          _cJ_=caml_call2(Pervasives[16],_cI_,_cG_),
          _cK_=function(x){return urlencode(0,x)},
          _cL_=caml_call2(List[17],_cK_,path),
          _cM_=caml_call2(String$0[7],cst$18,_cL_),
          _cN_=caml_call2(Pervasives[16],_cM_,_cJ_),
          _cO_=caml_call2(Pervasives[16],cst$19,_cN_);
         if(80 === port)
          var _cP_=cst$20;
         else
          var
           _cT_=caml_call1(Pervasives[21],port),
           _cP_=caml_call2(Pervasives[16],cst$21,_cT_);
         var
          _cQ_=caml_call2(Pervasives[16],_cP_,_cO_),
          _cR_=urlencode(0,host),
          _cS_=caml_call2(Pervasives[16],_cR_,_cQ_);
         return caml_call2(Pervasives[16],cst_http$1,_cS_);
        case 1:
         var
          match$0=param[1],
          frag$0=match$0[6],
          args$0=match$0[5],
          path$0=match$0[3],
          port$0=match$0[2],
          host$0=match$0[1];
         if(caml_string_notequal(frag$0,cst$24))
          var
           _cU_=urlencode(0,frag$0),
           _cV_=caml_call2(Pervasives[16],cst$25,_cU_);
         else
          var _cV_=cst$32;
         if(args$0)
          var
           _cW_=encode_arguments(args$0),
           _cX_=caml_call2(Pervasives[16],cst$26,_cW_);
         else
          var _cX_=cst$31;
         var
          _cY_=caml_call2(Pervasives[16],_cX_,_cV_),
          _cZ_=function(x){return urlencode(0,x)},
          _c0_=caml_call2(List[17],_cZ_,path$0),
          _c1_=caml_call2(String$0[7],cst$27,_c0_),
          _c2_=caml_call2(Pervasives[16],_c1_,_cY_),
          _c3_=caml_call2(Pervasives[16],cst$28,_c2_);
         if(443 === port$0)
          var _c4_=cst$29;
         else
          var
           _c8_=caml_call1(Pervasives[21],port$0),
           _c4_=caml_call2(Pervasives[16],cst$30,_c8_);
         var
          _c5_=caml_call2(Pervasives[16],_c4_,_c3_),
          _c6_=urlencode(0,host$0),
          _c7_=caml_call2(Pervasives[16],_c6_,_c5_);
         return caml_call2(Pervasives[16],cst_https$1,_c7_);
        default:
         var
          match$1=param[1],
          frag$1=match$1[4],
          args$1=match$1[3],
          path$1=match$1[1];
         if(caml_string_notequal(frag$1,cst$33))
          var
           _c9_=urlencode(0,frag$1),
           _c__=caml_call2(Pervasives[16],cst$34,_c9_);
         else
          var _c__=cst$38;
         if(args$1)
          var
           _c$_=encode_arguments(args$1),
           _da_=caml_call2(Pervasives[16],cst$35,_c$_);
         else
          var _da_=cst$37;
         var
          _db_=caml_call2(Pervasives[16],_da_,_c__),
          _dc_=function(x){return urlencode(0,x)},
          _dd_=caml_call2(List[17],_dc_,path$1),
          _de_=caml_call2(String$0[7],cst$36,_dd_),
          _df_=caml_call2(Pervasives[16],_de_,_db_);
         return caml_call2(Pervasives[16],cst_file$2,_df_)}}
    var _ci_=caml_call1(Optdef[2],_b__.location);
    if(caml_call1(Optdef[5],_ci_))
     var _cj_=_b__.location;
    else
     var
      t29="",
      t40=function(param,_cE_){return 0},
      t39=function(param,_cD_){return 0},
      t38=function(param){return 0},
      _cj_=
       {"href":t29,
        "protocol":t29,
        "host":t29,
        "hostname":t29,
        "port":t29,
        "pathname":t29,
        "search":t29,
        "hash":t29,
        "origin":t37,
        "reload":caml_js_wrap_meth_callback(t38),
        "replace":caml_js_wrap_meth_callback(t39),
        "assign":caml_js_wrap_meth_callback(t40)};
    var
     host=urldecode_js_string_string(_cj_.hostname),
     protocol=urldecode_js_string_string(_cj_.protocol),
     _ck_=0,
     port=
      function(param)
        {try
          {var _cB_=[0,caml_int_of_string(caml_js_to_byte_string(_cj_.port))];
           return _cB_}
         catch(_cC_)
          {_cC_ = caml_wrap_exception(_cC_);
           if(_cC_[1] === Failure)return 0;
           throw _cC_}}
       (_ck_),
     path_string=urldecode_js_string_string(_cj_.pathname),
     path$0=path_of_path_string(path_string),
     _cl_=_cj_.search.charAt(0) === "?"?_cj_.search.slice(1):_cj_.search,
     arguments$0=decode_arguments_js_string(_cl_);
    function get_fragment(param)
     {function _cx_(res){return caml_js_to_string(res[1])}
      function _cy_(param){return cst$39}
      var _cz_=new regExp_withFlags("#(.*)"),_cA_=_cj_.href.match(_cz_);
      return caml_call3(Opt[7],_cA_,_cy_,_cx_)}
    function set_fragment(s)
     {return _cj_.hash = caml_jsbytes_of_string(urlencode(0,s))}
    function get$2(param){return url_of_js_string(_cj_.href)}
    function set$1(u)
     {return _cj_.href = caml_jsbytes_of_string(string_of_url(u))}
    var
     as_string=urldecode_js_string_string(_cj_.href),
     Url=
      [0,
       urldecode,
       urlencode,
       default_http_port,
       default_https_port,
       path_of_path_string,
       encode_arguments,
       decode_arguments,
       url_of_string,
       string_of_url,
       [0,
        host,
        port,
        protocol,
        path_string,
        path$0,
        arguments$0,
        get_fragment,
        set_fragment,
        get$2,
        set$1,
        as_string]];
    caml_register_global(1638,Url,"Url");
    var
     defaultContextAttributes=
      {"alpha":true$0,
       "depth":true$0,
       "stencil":false$0,
       "antialias":true$0,
       "premultipliedAlpha":false$0,
       "preserveDrawingBuffer":false$0,
       "preferLowPowerToHighPerformance":false$0,
       "failIfMajorPerformanceCaveat":false$0},
     webglcontextlost=caml_call1(Event$0[73],cst_webglcontextlost),
     webglcontextrestored=caml_call1(Event$0[73],cst_webglcontextrestored),
     webglcontextcreationerror=
      caml_call1(Event$0[73],cst_webglcontextcreationerror),
     Event$1=
      [0,webglcontextlost,webglcontextrestored,webglcontextcreationerror];
    function getContext(c)
     {var ctx=c.getContext("webgl");
      return caml_call1(Opt[5],ctx)?ctx:c.getContext("experimental-webgl")}
    function getContextWithAttributes(c,attribs)
     {var ctx=c.getContext("webgl",attribs);
      return caml_call1(Opt[5],ctx)
              ?ctx
              :c.getContext("experimental-webgl",attribs)}
    var
     WebGL=
      [0,defaultContextAttributes,Event$1,getContext,getContextWithAttributes];
    caml_register_global(1639,WebGL,"WebGL");
    var webSocket=Unsafe[1].WebSocket;
    function is_supported$2(param){return caml_call1(Optdef[5],webSocket)}
    var WebSockets=[0,webSocket,webSocket,webSocket,is_supported$2];
    caml_register_global(1640,WebSockets,"WebSockets");
    var worker=Unsafe[1].Worker;
    function create$0(script){return new worker(script.toString())}
    function import_scripts(scripts)
     {if(Unsafe[1].importScripts === t37)
       caml_call1(Pervasives[1],cst_Worker_import_scripts_is_undefined);
      var
       _cv_=caml_call1(Array[12],scripts),
       _cw_=caml_call2(Array[15],caml_js_from_string,_cv_);
      return runtime.caml_js_fun_call(Unsafe[1].importScripts,_cw_)}
    function set_onmessage(handler)
     {if(Unsafe[1].onmessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined);
      function js_handler(ev){return caml_call1(handler,ev.data)}
      return Unsafe[1].onmessage = caml_js_wrap_callback(js_handler)}
    function post_message(msg)
     {if(Unsafe[1].postMessage === t37)
       caml_call1(Pervasives[1],cst_Worker_onmessage_is_undefined$0);
      return Unsafe[1].postMessage(msg)}
    var Worker=[0,create$0,import_scripts,set_onmessage,post_message];
    caml_register_global(1641,Worker,"Worker");
    var
     readystatechange=caml_call1(Event[1],cst_readystatechange),
     loadstart$1=caml_call1(Event[1],cst_loadstart$1),
     progress$1=caml_call1(Event[1],cst_progress$1),
     abort$1=caml_call1(Event[1],cst_abort$1),
     error$1=caml_call1(Event[1],cst_error$1),
     load$1=caml_call1(Event[1],cst_load$1),
     timeout=caml_call1(Event[1],cst_timeout),
     loadend$0=caml_call1(Event[1],cst_loadend$0),
     Event$2=
      [0,
       readystatechange,
       loadstart$1,
       progress$1,
       abort$1,
       error$1,
       load$1,
       timeout,
       loadend$0];
    function create$1(param)
     {var
       xmlHttpRequest=Unsafe[1].XMLHttpRequest,
       activeXObject=Unsafe[1].activeXObject;
      try
       {var _cq_=new xmlHttpRequest();return _cq_}
      catch(_cr_)
       {try
         {var _cp_=new activeXObject("Msxml2.XMLHTTP");return _cp_}
        catch(_cs_)
         {try
           {var _co_=new activeXObject("Msxml3.XMLHTTP");return _co_}
          catch(_ct_)
           {try
             {var _cn_=new activeXObject("Microsoft.XMLHTTP");return _cn_}
            catch(_cu_){throw [0,Assert_failure,_cm_]}}}}}
    var XmlHttpRequest=[0,create$1,Event$2];
    caml_register_global(1642,XmlHttpRequest,"XmlHttpRequest");
    var Js_of_ocaml=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(1643,Js_of_ocaml,"Js_of_ocaml");
    return}
  (function(){return this}()));


//# 1 ".js/sexplib0/sexplib0.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_format_float=runtime.caml_format_float,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$11=caml_new_string(""),
     cst$2=caml_new_string("("),
     cst$3=caml_new_string("()"),
     cst$4=caml_new_string(")"),
     cst$5=caml_new_string(" "),
     cst$6=caml_new_string("("),
     cst$7=caml_new_string("()"),
     cst$8=caml_new_string(")"),
     cst$10=caml_new_string("()"),
     cst$9=caml_new_string("()"),
     cst=caml_new_string("\\"),
     cst_n=caml_new_string("\\n"),
     cst$0=caml_new_string(' "'),
     cst$1=caml_new_string('"'),
     cst_Sexplib0_Sexp_Not_found_s=
      caml_new_string("Sexplib0__Sexp.Not_found_s"),
     cst_Sexplib0_Sexp_Of_sexp_error=
      caml_new_string("Sexplib0__Sexp.Of_sexp_error"),
     cst_Assert_failure=caml_new_string("Assert_failure"),
     cst_Match_failure=caml_new_string("Match_failure"),
     cst_fun_of_sexp_cannot_convert_function_values=
      caml_new_string("fun_of_sexp: cannot convert function values"),
     cst_opaque_of_sexp_cannot_convert_opaque_values=
      caml_new_string("opaque_of_sexp: cannot convert opaque values"),
     cst_hashtbl_of_sexp_tuple_list_needed=
      caml_new_string("hashtbl_of_sexp: tuple list needed"),
     cst_hashtbl_of_sexp_list_needed=
      caml_new_string("hashtbl_of_sexp: list needed"),
     cst_array_of_sexp_list_needed=
      caml_new_string("array_of_sexp: list needed"),
     cst_list_of_sexp_list_needed=caml_new_string("list_of_sexp: list needed"),
     cst_triple_of_sexp_list_needed=
      caml_new_string("triple_of_sexp: list needed"),
     cst_triple_of_sexp_list_must_contain_exactly_three_elements_only=
      caml_new_string
       ("triple_of_sexp: list must contain exactly three elements only"),
     cst_pair_of_sexp_list_needed=caml_new_string("pair_of_sexp: list needed"),
     cst_pair_of_sexp_list_must_contain_exactly_two_elements_only=
      caml_new_string
       ("pair_of_sexp: list must contain exactly two elements only"),
     cst_None=caml_new_string("None"),
     cst_none=caml_new_string("none"),
     cst_option_of_sexp_only_none_can_be_atom=
      caml_new_string("option_of_sexp: only none can be atom"),
     cst_Some=caml_new_string("Some"),
     cst_some=caml_new_string("some"),
     cst_option_of_sexp_list_must_represent_optional_value=
      caml_new_string("option_of_sexp: list must represent optional value"),
     cst_None$0=caml_new_string("None"),
     cst_none$0=caml_new_string("none"),
     cst_option_of_sexp_only_none_can_be_atom$0=
      caml_new_string("option_of_sexp: only none can be atom"),
     cst_Some$0=caml_new_string("Some"),
     cst_some$0=caml_new_string("some"),
     cst_option_of_sexp_list_must_be_some_el=
      caml_new_string("option_of_sexp: list must be (some el)"),
     cst_nativeint_of_sexp=caml_new_string("nativeint_of_sexp: "),
     cst_nativeint_of_sexp_atom_needed=
      caml_new_string("nativeint_of_sexp: atom needed"),
     cst_int64_of_sexp=caml_new_string("int64_of_sexp: "),
     cst_int64_of_sexp_atom_needed=
      caml_new_string("int64_of_sexp: atom needed"),
     cst_int32_of_sexp=caml_new_string("int32_of_sexp: "),
     cst_int32_of_sexp_atom_needed=
      caml_new_string("int32_of_sexp: atom needed"),
     cst_float_of_sexp=caml_new_string("float_of_sexp: "),
     cst_float_of_sexp_atom_needed=
      caml_new_string("float_of_sexp: atom needed"),
     cst_int_of_sexp=caml_new_string("int_of_sexp: "),
     cst_int_of_sexp_atom_needed=caml_new_string("int_of_sexp: atom needed"),
     cst_char_of_sexp_atom_string_must_contain_one_character_only=
      caml_new_string
       ("char_of_sexp: atom string must contain one character only"),
     cst_char_of_sexp_atom_needed=caml_new_string("char_of_sexp: atom needed"),
     cst_bytes_of_sexp_atom_needed=
      caml_new_string("bytes_of_sexp: atom needed"),
     cst_string_of_sexp_atom_needed=
      caml_new_string("string_of_sexp: atom needed"),
     cst_False=caml_new_string("False"),
     cst_True=caml_new_string("True"),
     cst_false=caml_new_string("false"),
     cst_true=caml_new_string("true"),
     cst_bool_of_sexp_unknown_string=
      caml_new_string("bool_of_sexp: unknown string"),
     cst_bool_of_sexp_atom_needed=caml_new_string("bool_of_sexp: atom needed"),
     cst_unit_of_sexp_empty_list_needed=
      caml_new_string("unit_of_sexp: empty list needed"),
     cst_15G=caml_new_string("%.15G"),
     cst_17G=caml_new_string("%.17G"),
     cst$13=caml_new_string(" "),
     cst_of_sexp_trying_to_convert_an_empty_type=
      caml_new_string("_of_sexp: trying to convert an empty type"),
     cst_of_sexp_trying_to_convert_a_silly_type=
      caml_new_string("_of_sexp: trying to convert a silly type"),
     cst_of_sexp_the_empty_list_is_an_invalid_polymorphic_variant=
      caml_new_string
       ("_of_sexp: the empty list is an invalid polymorphic variant"),
     cst_of_sexp_a_nested_list_is_an_invalid_polymorphic_variant=
      caml_new_string
       ("_of_sexp: a nested list is an invalid polymorphic variant"),
     cst_of_sexp_polymorphic_variant_tag_takes_an_argument=
      caml_new_string("_of_sexp: polymorphic variant tag takes an argument"),
     cst_of_sexp_polymorphic_variant_does_not_take_arguments=
      caml_new_string("_of_sexp: polymorphic variant does not take arguments"),
     cst_of_sexp_no_matching_variant_found=
      caml_new_string("_of_sexp: no matching variant found"),
     cst_of_sexp_cannot_convert_values_of_types_resulting_from_polymorphic_record_fields=
      caml_new_string
       ("_of_sexp: cannot convert values of types resulting from polymorphic record fields"),
     cst_of_sexp_list_instead_of_atom_for_record_expected=
      caml_new_string("_of_sexp: list instead of atom for record expected"),
     cst_extra_fields=caml_new_string("extra fields"),
     cst_duplicate_fields=caml_new_string("duplicate fields"),
     cst$12=caml_new_string(" "),
     cst_of_sexp_record_conversion_only_pairs_expected_their_first_element_must_be_an_atom=
      caml_new_string
       ("_of_sexp: record conversion: only pairs expected, their first element must be an atom"),
     cst_of_sexp_unexpected_sum_tag=
      caml_new_string("_of_sexp: unexpected sum tag"),
     cst_of_sexp_the_empty_list_is_an_invalid_sum=
      caml_new_string("_of_sexp: the empty list is an invalid sum"),
     cst_of_sexp_a_nested_list_is_an_invalid_sum=
      caml_new_string("_of_sexp: a nested list is an invalid sum"),
     cst_of_sexp_sum_tag_must_be_a_structured_value=
      caml_new_string("_of_sexp: sum tag must be a structured value"),
     cst_of_sexp_sum_tag_does_not_take_arguments=
      caml_new_string("_of_sexp: sum tag does not take arguments"),
     cst_Sexplib0_Sexp_conv_error_No_variant_match=
      caml_new_string("Sexplib0__Sexp_conv_error.No_variant_match"),
     StringLabels=global_data.StringLabels,
     Format=global_data.Format,
     ListLabels=global_data.ListLabels,
     Buffer=global_data.Buffer,
     Not_found=global_data.Not_found,
     BytesLabels=global_data.BytesLabels,
     Char=global_data.Char,
     Bytes=global_data.Bytes,
     Assert_failure=global_data.Assert_failure,
     Pervasives=global_data.Pervasives,
     End_of_file=global_data.End_of_file,
     Failure=global_data.Failure,
     Invalid_argument=global_data.Invalid_argument,
     Match_failure=global_data.Match_failure,
     Sys_error=global_data.Sys_error,
     Arg=global_data.Arg,
     Lazy=global_data.Lazy,
     Parsing=global_data.Parsing,
     Queue=global_data.Queue,
     Scanf=global_data.Scanf,
     Stack=global_data.Stack,
     Stream=global_data.Stream,
     Sys=global_data.Sys,
     Printf=global_data.Printf,
     MoreLabels=global_data.MoreLabels,
     Printexc=global_data.Printexc,
     Obj=global_data.Obj,
     Ephemeron=global_data.Ephemeron,
     Gc=global_data.Gc,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Nativeint=global_data.Nativeint,
     Int64=global_data.Int64,
     Int32=global_data.Int32,
     Sexplib0=[0,0,0,0];
    caml_register_global(137,Sexplib0,"Sexplib0");
    var
     _b_=[0,[15,[17,2,0]],caml_new_string("%a@?")],
     _a_=[0,0,0],
     _aC_=[0,0],
     _az_=[0,caml_new_string("sexp_conv.ml"),346,17],
     _aw_=[0,caml_new_string("Exit")],
     _ax_=[0,caml_new_string("sexp_conv.ml"),351,17],
     _as_=[0,caml_new_string("End_of_file")],
     _at_=[0,caml_new_string("sexp_conv.ml"),356,17],
     _ap_=[0,caml_new_string("Failure")],
     _aq_=[0,caml_new_string("sexp_conv.ml"),361,17],
     _am_=[0,caml_new_string("Not_found")],
     _an_=[0,caml_new_string("sexp_conv.ml"),366,17],
     _aj_=[0,caml_new_string("Invalid_argument")],
     _ak_=[0,caml_new_string("sexp_conv.ml"),371,17],
     _ah_=[0,caml_new_string("sexp_conv.ml"),376,17],
     _ae_=[0,caml_new_string("Not_found_s")],
     _af_=[0,caml_new_string("sexp_conv.ml"),381,17],
     _ab_=[0,caml_new_string("Sys_error")],
     _ac_=[0,caml_new_string("sexp_conv.ml"),386,17],
     ___=[0,caml_new_string("Arg.Help")],
     _$_=[0,caml_new_string("sexp_conv.ml"),391,17],
     _W_=[0,caml_new_string("Arg.Bad")],
     _X_=[0,caml_new_string("sexp_conv.ml"),396,17],
     _S_=[0,caml_new_string("Lazy.Undefined")],
     _T_=[0,caml_new_string("sexp_conv.ml"),401,17],
     _O_=[0,caml_new_string("Parsing.Parse_error")],
     _P_=[0,caml_new_string("sexp_conv.ml"),406,17],
     _K_=[0,caml_new_string("Queue.Empty")],
     _L_=[0,caml_new_string("sexp_conv.ml"),411,17],
     _G_=[0,caml_new_string("Scanf.Scan_failure")],
     _H_=[0,caml_new_string("sexp_conv.ml"),416,17],
     _C_=[0,caml_new_string("Stack.Empty")],
     _D_=[0,caml_new_string("sexp_conv.ml"),421,17],
     _y_=[0,caml_new_string("Stream.Failure")],
     _z_=[0,caml_new_string("sexp_conv.ml"),426,17],
     _u_=[0,caml_new_string("Stream.Error")],
     _v_=[0,caml_new_string("sexp_conv.ml"),431,17],
     _q_=[0,caml_new_string("Sys.Break")],
     _r_=[0,caml_new_string("sexp_conv.ml"),436,17],
     _m_=[0,caml_new_string("Sexplib.Conv.Of_sexp_error")],
     _n_=[0,caml_new_string("sexp_conv.ml"),442,17],
     _k_=
      [0,
       [2,0,[12,32,[2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]]]],
       caml_new_string("%s %s:%d:%d")],
     _j_=[0,2],
     _h_=[0,caml_new_string("<fun>")],
     _g_=[0,caml_new_string("<opaque>")],
     _d_=[0,caml_new_string("some")],
     _e_=[1,0],
     _f_=[0,caml_new_string("none")],
     _c_=[1,0],
     _aH_=
      [0,
       [2,
        0,
        [11,
         caml_new_string("_of_sexp: polymorphic variant tag "),
         [3,0,[11,caml_new_string(" has incorrect number of arguments"),0]]]],
       caml_new_string
        ("%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments")],
     _aG_=
      [0,
       [2,
        0,
        [11,
         caml_new_string
          ("_of_sexp: the following record elements were undefined: "),
         [2,0,0]]],
       caml_new_string
        ("%s_of_sexp: the following record elements were undefined: %s")],
     _aF_=
      [0,
       [2,
        0,
        [11,
         caml_new_string("_of_sexp: "),
         [2,0,[11,caml_new_string(": "),[2,0,0]]]]],
       caml_new_string("%s_of_sexp: %s: %s")],
     _aE_=
      [0,
       [2,
        0,
        [11,
         caml_new_string("_of_sexp: sum tag "),
         [3,0,[11,caml_new_string(" has incorrect number of arguments"),0]]]],
       caml_new_string
        ("%s_of_sexp: sum tag %S has incorrect number of arguments")],
     _aD_=
      [0,
       [2,
        0,
        [11,
         caml_new_string("_of_sexp: tuple of size "),
         [4,0,0,0,[11,caml_new_string(" expected"),0]]]],
       caml_new_string("%s_of_sexp: tuple of size %d expected")];
    function sexp_of_t(t){return t}
    function t_of_sexp(t){return t}
    function compare(a$0,match)
     {if(a$0 === match)return 0;
      if(0 === a$0[0])
       {var _b8_=a$0[1];
        if(0 === match[0])
         {var b$0=match[1];return caml_call2(StringLabels[33],_b8_,b$0)}
        return -1}
      var _b9_=a$0[1];
      if(0 === match[0])return 1;
      var b$1=match[1],a=_b9_,b=b$1;
      for(;;)
       {if(a)
         {if(b)
           {var ys=b[2],y=b[1],xs=a[2],x=a[1],res=compare(x,y);
            if(0 === res){var a=xs,b=ys;continue}
            return res}
          return 1}
        return b?-1:0}}
    function equal(a,b){return 0 === compare(a,b)?1:0}
    var
     Not_found_s=[248,cst_Sexplib0_Sexp_Not_found_s,caml_fresh_oo_id(0)],
     Of_sexp_error=[248,cst_Sexplib0_Sexp_Of_sexp_error,caml_fresh_oo_id(0)],
     default_indent=[0,1];
    function must_escape(str)
     {var len=caml_ml_string_length(str),_bY_=0 === len?1:0;
      if(_bY_)return _bY_;
      var ix$3=len - 1 | 0,ix=ix$3;
      for(;;)
       {var match=caml_string_get(str,ix);
        if(92 <= match)
         {var switcher=match - 93 | 0;
          if(33 < switcher >>> 0)
           var switch$0=0 <= switcher?2:1;
          else
           {if(31 === switcher)
             {var _bZ_=0 < ix?1:0;
              if(_bZ_)
               {var
                 ix$0=ix - 1 | 0,
                 _b0_=caml_string_get(str,ix$0),
                 _b1_=caml_call2(Char[8],_b0_,35);
                if(! _b1_){var ix=ix$0;continue}
                var _b2_=_b1_}
              else
               var _b2_=_bZ_;
              return _b2_}
            var switch$0=0}}
        else
         if(42 <= match)
          var switch$0=59 === match?1:0;
         else
          if(33 <= match)
           {var switcher$0=match - 33 | 0;
            switch(switcher$0)
             {case 2:
               var _b4_=0 < ix?1:0;
               if(_b4_)
                {var
                  ix$2=ix - 1 | 0,
                  _b5_=caml_string_get(str,ix$2),
                  _b6_=caml_call2(Char[8],_b5_,124);
                 if(! _b6_){var ix=ix$2;continue}
                 var _b7_=_b6_}
               else
                var _b7_=_b4_;
               return _b7_;
              case 1:
              case 7:
              case 8:var switch$0=1;break;
              default:var switch$0=0}}
          else
           var switch$0=2;
        switch(switch$0)
         {case 0:
           var _b3_=0 < ix?1:0;
           if(_b3_){var ix$1=ix - 1 | 0,ix=ix$1;continue}
           return _b3_;
          case 1:return 1;
          default:return 1}}}
    function escaped(s)
     {var n=[0,0],_bO_=caml_ml_string_length(s) - 1 | 0,_bN_=0;
      if(! (_bO_ < 0))
       {var i$0=_bN_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0);
          if(32 <= match)
           {var _bV_=match - 34 | 0;
            if(58 < _bV_ >>> 0)
             if(93 <= _bV_)var switch$0=0,switch$1=0;else var switch$1=1;
            else
             if(56 < (_bV_ - 1 | 0) >>> 0)
              var switch$0=1,switch$1=0;
             else
              var switch$1=1;
            if(switch$1)var _bW_=1,switch$0=2}
          else
           var switch$0=11 <= match?13 === match?1:0:8 <= match?1:0;
          switch(switch$0){case 0:var _bW_=4;break;case 1:var _bW_=2;break}
          n[1] = n[1] + _bW_ | 0;
          var _bX_=i$0 + 1 | 0;
          if(_bO_ !== i$0){var i$0=_bX_;continue}
          break}}
      if(n[1] === caml_ml_string_length(s))return s;
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _bQ_=caml_ml_string_length(s) - 1 | 0,_bP_=0;
      if(! (_bQ_ < 0))
       {var i=_bP_;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i);
          if(35 <= c)
           var switch$2=92 === c?1:127 <= c?0:2;
          else
           if(32 <= c)
            var switch$2=34 <= c?1:2;
           else
            if(14 <= c)
             var switch$2=0;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                var switch$2=3;
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                var switch$2=3;
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                var switch$2=3;
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                var switch$2=3;
                break;
               default:var switch$2=0}
          switch(switch$2)
           {case 0:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             var _bS_=caml_call1(Char[1],48 + (c / 100 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bS_);
             n[1]++;
             var _bT_=caml_call1(Char[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bT_);
             n[1]++;
             var _bU_=caml_call1(Char[1],48 + (c % 10 | 0) | 0);
             caml_bytes_unsafe_set(s$0,n[1],_bU_);
             break;
            case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 2:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _bR_=i + 1 | 0;
          if(_bQ_ !== i){var i=_bR_;continue}
          break}}
      return caml_call1(BytesLabels[42],s$0)}
    function esc_str(str)
     {var
       src=escaped(str),
       len=caml_ml_string_length(src),
       dst=caml_create_bytes(len + 2 | 0);
      caml_call5(Bytes[12],src,0,dst,1,len);
      caml_bytes_unsafe_set(dst,0,34);
      caml_bytes_unsafe_set(dst,len + 1 | 0,34);
      return caml_call1(BytesLabels[42],dst)}
    function index_of_newline(str,start)
     {try
       {var _bL_=[0,caml_call3(StringLabels[18],str,start,10)];return _bL_}
      catch(_bM_)
       {_bM_ = caml_wrap_exception(_bM_);
        if(_bM_ === Not_found)return 0;
        throw _bM_}}
    function mach_maybe_esc_str(str){return must_escape(str)?esc_str(str):str}
    function pp_hum_indent(indent,ppf,param)
     {if(0 === param[0])
       {var str=param[1];
        if(must_escape(str))
         {var match=index_of_newline(str,0);
          if(match)
           var
            index=match[1],
            _bH_=(index + 1 | 0) === caml_ml_string_length(str)?1:0;
          else
           var _bH_=1;
          if(_bH_)
           {var _bI_=esc_str(str);return caml_call2(Format[13],ppf,_bI_)}
          caml_call2(Format[1],ppf,0);
          caml_call2(Format[13],ppf,cst$0);
          var index$0=0;
          for(;;)
           {var end_pos_opt=index_of_newline(str,index$0);
            if(end_pos_opt)
             var end_pos=end_pos_opt[1],end_pos$0=end_pos;
            else
             var end_pos$0=caml_ml_string_length(str);
            var
             next_line=
              caml_call3(StringLabels[4],str,index$0,end_pos$0 - index$0 | 0),
             _bJ_=escaped(next_line);
            caml_call2(Format[13],ppf,_bJ_);
            if(end_pos_opt)
             {var newline_index=end_pos_opt[1];
              caml_call2(Format[13],ppf,cst);
              caml_call2(Format[31],ppf,0);
              caml_call2(Format[13],ppf,cst_n);
              var index$1=newline_index + 1 | 0,index$0=index$1;
              continue}
            caml_call2(Format[13],ppf,cst$1);
            return caml_call2(Format[3],ppf,0)}}
        return caml_call2(Format[13],ppf,str)}
      var _bK_=param[1];
      if(_bK_)
       {var t=_bK_[2],h=_bK_[1];
        caml_call2(Format[1],ppf,indent);
        caml_call2(Format[13],ppf,cst$2);
        pp_hum_indent(indent,ppf,h);
        var param$0=t;
        for(;;)
         {if(param$0)
           {var t$0=param$0[2],h$0=param$0[1];
            caml_call2(Format[25],ppf,0);
            pp_hum_indent(indent,ppf,h$0);
            var param$0=t$0;
            continue}
          caml_call2(Format[13],ppf,cst$4);
          return caml_call2(Format[3],ppf,0)}}
      return caml_call2(Format[13],ppf,cst$3)}
    function pp_mach_internal(may_need_space,ppf,param)
     {if(0 === param[0])
       {var
         str=param[1],
         str$0=mach_maybe_esc_str(str),
         new_may_need_space=str$0 === str?1:0,
         new_may_need_space$0=may_need_space?new_may_need_space:may_need_space;
        if(new_may_need_space$0)caml_call2(Format[13],ppf,cst$5);
        caml_call2(Format[13],ppf,str$0);
        return new_may_need_space}
      var _bG_=param[1];
      if(_bG_)
       {var t=_bG_[2],h=_bG_[1];
        caml_call2(Format[13],ppf,cst$6);
        var
         may_need_space$0=pp_mach_internal(0,ppf,h),
         may_need_space$1=may_need_space$0,
         param$0=t;
        for(;;)
         {if(param$0)
           {var
             t$0=param$0[2],
             h$0=param$0[1],
             may_need_space$2=pp_mach_internal(may_need_space$1,ppf,h$0),
             may_need_space$1=may_need_space$2,
             param$0=t$0;
            continue}
          caml_call2(Format[13],ppf,cst$8);
          return 0}}
      caml_call2(Format[13],ppf,cst$7);
      return 0}
    function pp_hum(ppf,sexp)
     {return pp_hum_indent(default_indent[1],ppf,sexp)}
    function pp(ppf,sexp){pp_mach_internal(0,ppf,sexp);return 0}
    function size_loop(acc,param)
     {var _bE_=acc[2],_bF_=acc[1];
      if(0 === param[0])
       {var str=param[1];
        return [0,_bF_ + 1 | 0,_bE_ + caml_ml_string_length(str) | 0]}
      var lst=param[1];
      return caml_call3(ListLabels[20],size_loop,acc,lst)}
    function size(sexp){return size_loop(_a_,sexp)}
    function to_buffer_hum(buf,opt,sexp)
     {if(opt)var sth=opt[1],indent=sth;else var indent=default_indent[1];
      var ppf=caml_call1(Format[98],buf);
      function _bB_(_bC_,_bD_){return pp_hum_indent(indent,_bC_,_bD_)}
      return caml_call4(Format[112],ppf,_b_,_bB_,sexp)}
    function to_buffer_mach(buf,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(Buffer[10],buf,32);
          caml_call2(Buffer[14],buf,str$0);
          return new_may_need_space}
        var _bA_=param[1];
        if(_bA_)
         {var t=_bA_[2],h=_bA_[1];
          caml_call2(Buffer[10],buf,40);
          var
           may_need_space$0=loop(0,h),
           may_need_space$1=may_need_space$0,
           param$0=t;
          for(;;)
           {if(param$0)
             {var
               t$0=param$0[2],
               h$0=param$0[1],
               may_need_space$2=loop(may_need_space$1,h$0),
               may_need_space$1=may_need_space$2,
               param$0=t$0;
              continue}
            caml_call2(Buffer[10],buf,41);
            return 0}}
        caml_call2(Buffer[14],buf,cst$9);
        return 0}
      loop(0,sexp);
      return 0}
    function to_buffer_gen(buf,add_char,add_string,sexp)
     {function loop(may_need_space,param)
       {if(0 === param[0])
         {var
           str=param[1],
           str$0=mach_maybe_esc_str(str),
           new_may_need_space=str$0 === str?1:0,
           new_may_need_space$0=
            may_need_space?new_may_need_space:may_need_space;
          if(new_may_need_space$0)caml_call2(add_char,buf,32);
          caml_call2(add_string,buf,str$0);
          return new_may_need_space}
        var _bz_=param[1];
        if(_bz_)
         {var t=_bz_[2],h=_bz_[1];
          caml_call2(add_char,buf,40);
          var
           may_need_space$0=loop(0,h),
           may_need_space$1=may_need_space$0,
           param$0=t;
          for(;;)
           {if(param$0)
             {var
               t$0=param$0[2],
               h$0=param$0[1],
               may_need_space$2=loop(may_need_space$1,h$0),
               may_need_space$1=may_need_space$2,
               param$0=t$0;
              continue}
            caml_call2(add_char,buf,41);
            return 0}}
        caml_call2(add_string,buf,cst$10);
        return 0}
      loop(0,sexp);
      return 0}
    function buffer(param){return caml_call1(Buffer[1],1024)}
    function to_string_hum(indent,sexp)
     {if(0 === sexp[0])
       {var str=sexp[1],match=index_of_newline(str,0),_by_=match?0:1;
        if(_by_)return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer_hum(buf,indent,sexp);
      return caml_call1(Buffer[2],buf)}
    function to_string(sexp)
     {if(0 === sexp[0]){var str=sexp[1];return mach_maybe_esc_str(str)}
      var buf=buffer(0);
      to_buffer_mach(buf,sexp);
      return caml_call1(Buffer[2],buf)}
    var of_float_style=[0,1009018843],of_int_style=[0,1009018843];
    function message(name,fields)
     {function conv_fields(param)
       {if(param)
         {var rest=param[2],match=param[1],fsexp=match[2],fname=match[1];
          return caml_string_notequal(fname,cst$11)
                  ?[0,[1,[0,[0,fname],[0,fsexp,0]]],conv_fields(rest)]
                  :[0,fsexp,conv_fields(rest)]}
        return 0}
      return [1,[0,[0,name],conv_fields(fields)]]}
    var
     Sexplib0_Sexp=
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp,
       pp,
       to_string_hum,
       to_string,
       to_string,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
    caml_register_global(146,Sexplib0_Sexp,"Sexplib0__Sexp");
    var
     default_string_of_float=
      [0,
       function(x)
        {var y=caml_format_float(cst_15G,x);
         return caml_float_of_string(y) == x?y:caml_format_float(cst_17G,x)}],
     read_old_option_format=[0,1],
     write_old_option_format=[0,1];
    function list_map(f,l)
     {var _bx_=caml_call2(ListLabels[19],f,l);
      return caml_call1(ListLabels[9],_bx_)}
    function sexp_of_unit(param){return _c_}
    function sexp_of_bool(b){return [0,caml_call1(Pervasives[18],b)]}
    function sexp_of_string(str){return [0,str]}
    function sexp_of_bytes(bytes){return [0,caml_call1(BytesLabels[6],bytes)]}
    function sexp_of_char(c){return [0,caml_call2(StringLabels[1],1,c)]}
    function sexp_of_int(n){return [0,caml_call1(Pervasives[21],n)]}
    function sexp_of_float(n)
     {return [0,caml_call1(default_string_of_float[1],n)]}
    function sexp_of_int32(n){return [0,caml_call1(Int32[11],n)]}
    function sexp_of_int64(n){return [0,caml_call1(Int64[11],n)]}
    function sexp_of_nativeint(n){return [0,caml_call1(Nativeint[12],n)]}
    function sexp_of_ref(sexp_of_a,rf){return caml_call1(sexp_of_a,rf[1])}
    function sexp_of_lazy_t(sexp_of_a,lv)
     {var
       _bv_=runtime.caml_obj_tag(lv),
       _bw_=
        250 === _bv_?lv[1]:246 === _bv_?caml_call1(CamlinternalLazy[2],lv):lv;
      return caml_call1(sexp_of_a,_bw_)}
    function sexp_of_option(sexp_of_a,param)
     {if(param)
       {var x=param[1];
        return write_old_option_format[1]
                ?[1,[0,caml_call1(sexp_of_a,x),0]]
                :[1,[0,_d_,[0,caml_call1(sexp_of_a,x),0]]]}
      return write_old_option_format[1]?_e_:_f_}
    function sexp_of_pair(sexp_of_a,sexp_of_b,param)
     {var b=param[2],a=param[1],_bu_=[0,caml_call1(sexp_of_b,b),0];
      return [1,[0,caml_call1(sexp_of_a,a),_bu_]]}
    function sexp_of_triple(sexp_of_a,sexp_of_b,sexp_of_c,param)
     {var
       c=param[3],
       b=param[2],
       a=param[1],
       _bs_=[0,caml_call1(sexp_of_c,c),0],
       _bt_=[0,caml_call1(sexp_of_b,b),_bs_];
      return [1,[0,caml_call1(sexp_of_a,a),_bt_]]}
    function sexp_of_list(sexp_of_a,lst)
     {var _br_=caml_call2(ListLabels[19],sexp_of_a,lst);
      return [1,caml_call1(ListLabels[9],_br_)]}
    function sexp_of_array(sexp_of_a,ar)
     {var lst_ref=[0,0],_bo_=ar.length - 1 - 1 | 0;
      if(! (_bo_ < 0))
       {var i=_bo_;
        for(;;)
         {var _bp_=lst_ref[1];
          lst_ref[1]
          =
          [0,caml_call1(sexp_of_a,caml_check_bound(ar,i)[i + 1]),_bp_];
          var _bq_=i - 1 | 0;
          if(0 !== i){var i=_bq_;continue}
          break}}
      return [1,lst_ref[1]]}
    function sexp_of_hashtbl(sexp_of_key,sexp_of_val,htbl)
     {function coll(k,v,acc)
       {var _bn_=[0,caml_call1(sexp_of_val,v),0];
        return [0,[1,[0,caml_call1(sexp_of_key,k),_bn_]],acc]}
      return [1,caml_call3(MoreLabels[1][14],coll,htbl,0)]}
    function sexp_of_opaque(param){return _g_}
    function sexp_of_fun(param){return _h_}
    var
     compare$0=runtime.caml_int_compare,
     Int=[0,compare$0],
     Exn_ids=caml_call1(MoreLabels[2][1],Int),
     exn_id_map=[0,Exn_ids[1]];
    function clean_up_handler(slot)
     {for(;;)
       {var
         id=caml_call1(Obj[23],slot),
         old_exn_id_map=exn_id_map[1],
         new_exn_id_map=caml_call2(Exn_ids[7],id,old_exn_id_map);
        if(exn_id_map[1] !== old_exn_id_map)continue;
        exn_id_map[1] = new_exn_id_map;
        return 0}}
    function add(opt,extension_constructor,sexp_of_exn)
     {if(opt)var sth=opt[1],finalise=sth;else var finalise=1;
      var id=caml_call1(Obj[23],extension_constructor);
      function loop(param)
       {for(;;)
         {var old_exn_id_map=exn_id_map[1],ephe=caml_call1(Ephemeron[1][1],0);
          caml_call2(Ephemeron[1][10],ephe,sexp_of_exn);
          caml_call2(Ephemeron[1][4],ephe,extension_constructor);
          var new_exn_id_map=caml_call3(Exn_ids[4],id,ephe,old_exn_id_map);
          if(exn_id_map[1] !== old_exn_id_map)continue;
          exn_id_map[1] = new_exn_id_map;
          if(finalise)
           try
            {var
              _bl_=
               caml_call2(Gc[3],clean_up_handler,extension_constructor);
             return _bl_}
           catch(_bm_)
            {_bm_ = caml_wrap_exception(_bm_);
             if(_bm_[1] === Invalid_argument)return 0;
             throw _bm_}
          return finalise}}
      return loop(0)}
    function add_auto(finalise,exn,sexp_of_exn)
     {return add(finalise,caml_call1(Obj[21],exn),sexp_of_exn)}
    function find_auto(exn)
     {var _bj_=caml_call1(Obj[21],exn),id=caml_call1(Obj[23],_bj_);
      try
       {var ephe=caml_call2(Exn_ids[27],id,exn_id_map[1])}
      catch(_bk_)
       {_bk_ = caml_wrap_exception(_bk_);
        if(_bk_ === Not_found)return 0;
        throw _bk_}
      var match=caml_call1(Ephemeron[1][8],ephe);
      if(match)
       {var sexp_of_exn=match[1];return [0,caml_call1(sexp_of_exn,exn)]}
      return 0}
    function size$0(param)
     {var _bg_=0,_bh_=exn_id_map[1];
      function _bi_(param,ephe,acc)
       {var match=caml_call1(Ephemeron[1][8],ephe);
        return match?acc + 1 | 0:acc}
      return caml_call3(Exn_ids[13],_bi_,_bh_,_bg_)}
    var For_unit_tests_only=[0,size$0];
    function sexp_of_exn_opt(exn){return find_auto(exn)}
    function sexp_of_exn(exn)
     {var match=sexp_of_exn_opt(exn);
      if(match){var sexp=match[1];return sexp}
      return [1,[0,[0,caml_call1(Printexc[1],exn)],0]]}
    function exn_to_string(e){return to_string_hum(0,sexp_of_exn(e))}
    function _i_(exn)
     {var match=sexp_of_exn_opt(exn);
      if(match){var sexp=match[1];return [0,to_string_hum(_j_,sexp)]}
      return 0}
    caml_call1(Printexc[8],_i_);
    var record_check_extra_fields=[0,1];
    function of_sexp_error_exn(exc,sexp){throw [0,Of_sexp_error,exc,sexp]}
    function of_sexp_error(what,sexp)
     {throw [0,Of_sexp_error,[0,Failure,what],sexp]}
    function unit_of_sexp(sexp)
     {if(1 === sexp[0])if(! sexp[1])return 0;
      return of_sexp_error(cst_unit_of_sexp_empty_list_needed,sexp)}
    function bool_of_sexp(sexp)
     {if(0 === sexp[0])
       {var _bf_=sexp[1];
        if(caml_string_notequal(_bf_,cst_False))
         {if(caml_string_notequal(_bf_,cst_True))
           if(caml_string_notequal(_bf_,cst_false))
            {if(caml_string_notequal(_bf_,cst_true))
              return of_sexp_error(cst_bool_of_sexp_unknown_string,sexp);
             var switch$0=0}
           else
            var switch$0=1;
          else
           var switch$0=0;
          if(! switch$0)return 1}
        return 0}
      return of_sexp_error(cst_bool_of_sexp_atom_needed,sexp)}
    function string_of_sexp(sexp)
     {if(0 === sexp[0]){var str=sexp[1];return str}
      return of_sexp_error(cst_string_of_sexp_atom_needed,sexp)}
    function bytes_of_sexp(sexp)
     {if(0 === sexp[0]){var str=sexp[1];return caml_call1(BytesLabels[5],str)}
      return of_sexp_error(cst_bytes_of_sexp_atom_needed,sexp)}
    function char_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        if(1 !== caml_ml_string_length(str))
         of_sexp_error
          (cst_char_of_sexp_atom_string_must_contain_one_character_only,sexp);
        return caml_string_get(str,0)}
      return of_sexp_error(cst_char_of_sexp_atom_needed,sexp)}
    function int_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        try
         {var _be_=caml_int_of_string(str);return _be_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var _bd_=exn_to_string(exc);
          return of_sexp_error
                  (caml_call2(Pervasives[16],cst_int_of_sexp,_bd_),sexp)}}
      return of_sexp_error(cst_int_of_sexp_atom_needed,sexp)}
    function float_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        try
         {var _bc_=caml_float_of_string(str);return _bc_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var _bb_=exn_to_string(exc);
          return of_sexp_error
                  (caml_call2(Pervasives[16],cst_float_of_sexp,_bb_),sexp)}}
      return of_sexp_error(cst_float_of_sexp_atom_needed,sexp)}
    function int32_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        try
         {var _ba_=caml_int_of_string(str);return _ba_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var _a$_=exn_to_string(exc);
          return of_sexp_error
                  (caml_call2(Pervasives[16],cst_int32_of_sexp,_a$_),sexp)}}
      return of_sexp_error(cst_int32_of_sexp_atom_needed,sexp)}
    function int64_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        try
         {var _a__=runtime.caml_int64_of_string(str);return _a__}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var _a9_=exn_to_string(exc);
          return of_sexp_error
                  (caml_call2(Pervasives[16],cst_int64_of_sexp,_a9_),sexp)}}
      return of_sexp_error(cst_int64_of_sexp_atom_needed,sexp)}
    function nativeint_of_sexp(sexp)
     {if(0 === sexp[0])
       {var str=sexp[1];
        try
         {var _a8_=caml_int_of_string(str);return _a8_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var _a7_=exn_to_string(exc);
          return of_sexp_error
                  (caml_call2(Pervasives[16],cst_nativeint_of_sexp,_a7_),sexp)}}
      return of_sexp_error(cst_nativeint_of_sexp_atom_needed,sexp)}
    function ref_of_sexp(a_of_sexp,sexp)
     {return [0,caml_call1(a_of_sexp,sexp)]}
    function lazy_t_of_sexp(a_of_sexp,sexp)
     {var _a6_=caml_call1(a_of_sexp,sexp);return caml_call1(Lazy[4],_a6_)}
    function option_of_sexp(a_of_sexp,sexp)
     {if(read_old_option_format[1])
       {if(0 === sexp[0])
         {var _aW_=sexp[1];
          if(caml_string_notequal(_aW_,cst_None))
           if(caml_string_notequal(_aW_,cst_none))
            return of_sexp_error
                    (cst_option_of_sexp_only_none_can_be_atom,sexp)}
        else
         {var _aX_=sexp[1];
          if(_aX_)
           {var _aY_=_aX_[1];
            if(_aX_[2])
             {if(0 === _aY_[0])
               {var _aZ_=_aY_[1];
                if(caml_string_notequal(_aZ_,cst_Some))
                 if(caml_string_notequal(_aZ_,cst_some))
                  var switch$0=0,switch$1=0;
                 else
                  var switch$1=1;
                else
                 var switch$1=1;
                if(switch$1)
                 {var _a0_=_aX_[2];
                  if(_a0_[2])var switch$0=0;else var el=_a0_[1],switch$0=1}}
              else
               var switch$0=0;
              if(! switch$0)
               return of_sexp_error
                       (cst_option_of_sexp_list_must_represent_optional_value,sexp)}
            else
             var el=_aY_;
            return [0,caml_call1(a_of_sexp,el)]}}
        return 0}
      if(0 === sexp[0])
       {var _a1_=sexp[1];
        if(caml_string_notequal(_a1_,cst_None$0))
         if(caml_string_notequal(_a1_,cst_none$0))
          return of_sexp_error
                  (cst_option_of_sexp_only_none_can_be_atom$0,sexp);
        return 0}
      var _a2_=sexp[1];
      if(_a2_)
       {var _a3_=_a2_[1];
        if(0 === _a3_[0])
         {var
           _a4_=_a3_[1],
           switch$2=
            caml_string_notequal(_a4_,cst_Some$0)
             ?caml_string_notequal(_a4_,cst_some$0)?1:0
             :0;
          if(! switch$2)
           {var _a5_=_a2_[2];
            if(_a5_)
             if(! _a5_[2])
              {var el$0=_a5_[1];return [0,caml_call1(a_of_sexp,el$0)]}}}}
      return of_sexp_error(cst_option_of_sexp_list_must_be_some_el,sexp)}
    function pair_of_sexp(a_of_sexp,b_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_pair_of_sexp_list_needed,sexp);
      var _aU_=sexp[1];
      if(_aU_)
       {var _aV_=_aU_[2];
        if(_aV_)
         if(! _aV_[2])
          {var
            b_sexp=_aV_[1],
            a_sexp=_aU_[1],
            a=caml_call1(a_of_sexp,a_sexp),
            b=caml_call1(b_of_sexp,b_sexp);
           return [0,a,b]}}
      return of_sexp_error
              (cst_pair_of_sexp_list_must_contain_exactly_two_elements_only,
               sexp)}
    function triple_of_sexp(a_of_sexp,b_of_sexp,c_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_triple_of_sexp_list_needed,sexp);
      var _aR_=sexp[1];
      if(_aR_)
       {var _aS_=_aR_[2];
        if(_aS_)
         {var _aT_=_aS_[2];
          if(_aT_)
           if(! _aT_[2])
            {var
              c_sexp=_aT_[1],
              b_sexp=_aS_[1],
              a_sexp=_aR_[1],
              a=caml_call1(a_of_sexp,a_sexp),
              b=caml_call1(b_of_sexp,b_sexp),
              c=caml_call1(c_of_sexp,c_sexp);
             return [0,a,b,c]}}}
      return of_sexp_error
              (cst_triple_of_sexp_list_must_contain_exactly_three_elements_only,
               sexp)}
    function list_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_list_of_sexp_list_needed,sexp);
      var lst=sexp[1],rev_lst=caml_call2(ListLabels[19],a_of_sexp,lst);
      return caml_call1(ListLabels[9],rev_lst)}
    function array_of_sexp(a_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_array_of_sexp_list_needed,sexp);
      var _aP_=sexp[1];
      if(_aP_)
       {var
         t=_aP_[2],
         h=_aP_[1],
         len=caml_call1(ListLabels[1],t) + 1 | 0,
         res=runtime.caml_make_vect(len,caml_call1(a_of_sexp,h)),
         i=1,
         param=t;
        for(;;)
         {if(param)
           {var t$0=param[2],h$0=param[1],_aQ_=caml_call1(a_of_sexp,h$0);
            caml_check_bound(res,i)[i + 1] = _aQ_;
            var i$0=i + 1 | 0,i=i$0,param=t$0;
            continue}
          return res}}
      return [0]}
    function hashtbl_of_sexp(key_of_sexp,val_of_sexp,sexp)
     {if(0 === sexp[0])
       return of_sexp_error(cst_hashtbl_of_sexp_list_needed,sexp);
      var lst=sexp[1],htbl=caml_call2(MoreLabels[1][1],0,0);
      function act(param)
       {if(1 === param[0])
         {var _aL_=param[1];
          if(_aL_)
           {var _aM_=_aL_[2];
            if(_aM_)
             if(! _aM_[2])
              {var
                v_sexp=_aM_[1],
                k_sexp=_aL_[1],
                _aN_=caml_call1(val_of_sexp,v_sexp),
                _aO_=caml_call1(key_of_sexp,k_sexp);
               return caml_call3(MoreLabels[1][5],htbl,_aO_,_aN_)}}}
        return of_sexp_error(cst_hashtbl_of_sexp_tuple_list_needed,sexp)}
      caml_call2(ListLabels[15],act,lst);
      return htbl}
    function opaque_of_sexp(sexp)
     {return of_sexp_error
              (cst_opaque_of_sexp_cannot_convert_opaque_values,sexp)}
    function fun_of_sexp(sexp)
     {return of_sexp_error
              (cst_fun_of_sexp_cannot_convert_function_values,sexp)}
    function get_flc_error(name,param)
     {var chr=param[3],line=param[2],file=param[1];
      return [0,caml_call5(Printf[4],_k_,name,file,line,chr)]}
    var
     _l_=0,
     _o_=
      [0,
       [0,
        Of_sexp_error,
        function(param)
         {if(param[1] === Of_sexp_error)
           {var sexp=param[3],exc=param[2];
            return [1,[0,_m_,[0,sexp_of_exn(exc),[0,sexp,0]]]]}
          throw [0,Assert_failure,_n_]}],
       _l_];
    function _p_(param)
     {if(param === Sys[44])return _q_;throw [0,Assert_failure,_r_]}
    var _s_=[0,[0,Sys[44],_p_],_o_];
    function _t_(param)
     {if(param[1] === Stream[2])
       {var arg=param[2];return [1,[0,_u_,[0,[0,arg],0]]]}
      throw [0,Assert_failure,_v_]}
    var _w_=[0,[0,Stream[2],_t_],_s_];
    function _x_(param)
     {if(param === Stream[1])return _y_;throw [0,Assert_failure,_z_]}
    var _A_=[0,[0,Stream[1],_x_],_w_];
    function _B_(param)
     {if(param === Stack[1])return _C_;throw [0,Assert_failure,_D_]}
    var _E_=[0,[0,Stack[1],_B_],_A_];
    function _F_(param)
     {if(param[1] === Scanf[2])
       {var arg=param[2];return [1,[0,_G_,[0,[0,arg],0]]]}
      throw [0,Assert_failure,_H_]}
    var _I_=[0,[0,Scanf[2],_F_],_E_];
    function _J_(param)
     {if(param === Queue[1])return _K_;throw [0,Assert_failure,_L_]}
    var _M_=[0,[0,Queue[1],_J_],_I_];
    function _N_(param)
     {if(param === Parsing[10])return _O_;throw [0,Assert_failure,_P_]}
    var _Q_=[0,[0,Parsing[10],_N_],_M_];
    function _R_(param)
     {if(param === Lazy[1])return _S_;throw [0,Assert_failure,_T_]}
    var _U_=[0,[0,Lazy[1],_R_],_Q_];
    function _V_(param)
     {if(param[1] === Arg[8])
       {var arg=param[2];return [1,[0,_W_,[0,[0,arg],0]]]}
      throw [0,Assert_failure,_X_]}
    var _Y_=[0,[0,Arg[8],_V_],_U_];
    function _Z_(param)
     {if(param[1] === Arg[7])
       {var arg=param[2];return [1,[0,___,[0,[0,arg],0]]]}
      throw [0,Assert_failure,_$_]}
    var
     _aa_=[0,[0,Arg[7],_Z_],_Y_],
     _ad_=
      [0,
       [0,
        Sys_error,
        function(param)
         {if(param[1] === Sys_error)
           {var arg=param[2];return [1,[0,_ab_,[0,[0,arg],0]]]}
          throw [0,Assert_failure,_ac_]}],
       _aa_],
     _ag_=
      [0,
       [0,
        Not_found_s,
        function(param)
         {if(param[1] === Not_found_s)
           {var arg=param[2];return [1,[0,_ae_,[0,arg,0]]]}
          throw [0,Assert_failure,_af_]}],
       _ad_],
     _ai_=
      [0,
       [0,
        Match_failure,
        function(param)
         {if(param[1] === Match_failure)
           {var arg=param[2];return get_flc_error(cst_Match_failure,arg)}
          throw [0,Assert_failure,_ah_]}],
       _ag_],
     _al_=
      [0,
       [0,
        Invalid_argument,
        function(param)
         {if(param[1] === Invalid_argument)
           {var arg=param[2];return [1,[0,_aj_,[0,[0,arg],0]]]}
          throw [0,Assert_failure,_ak_]}],
       _ai_],
     _ao_=
      [0,
       [0,
        Not_found,
        function(param)
         {if(param === Not_found)return _am_;throw [0,Assert_failure,_an_]}],
       _al_],
     _ar_=
      [0,
       [0,
        Failure,
        function(param)
         {if(param[1] === Failure)
           {var arg=param[2];return [1,[0,_ap_,[0,[0,arg],0]]]}
          throw [0,Assert_failure,_aq_]}],
       _ao_],
     _au_=
      [0,
       [0,
        End_of_file,
        function(param)
         {if(param === End_of_file)return _as_;throw [0,Assert_failure,_at_]}],
       _ar_];
    function _av_(param)
     {if(param === Pervasives[3])return _aw_;throw [0,Assert_failure,_ax_]}
    var
     _ay_=[0,[0,Pervasives[3],_av_],_au_],
     _aA_=
      [0,
       [0,
        Assert_failure,
        function(param)
         {if(param[1] === Assert_failure)
           {var arg=param[2];return get_flc_error(cst_Assert_failure,arg)}
          throw [0,Assert_failure,_az_]}],
       _ay_];
    function _aB_(param)
     {var handler=param[2],extension_constructor=param[1];
      return add(_aC_,extension_constructor,handler)}
    caml_call2(ListLabels[15],_aB_,_aA_);
    var
     Sexplib0_Sexp_conv=
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_of_exn,
       sexp_of_exn_opt,
       [0,add_auto,add,For_unit_tests_only]];
    caml_register_global(172,Sexplib0_Sexp_conv,"Sexplib0__Sexp_conv");
    function tuple_of_size_n_expected(loc,n,sexp)
     {return of_sexp_error(caml_call3(Printf[4],_aD_,loc,n),sexp)}
    function stag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_sum_tag_does_not_take_arguments),
               sexp)}
    function stag_incorrect_n_args(loc,tag,sexp)
     {var msg=caml_call3(Printf[4],_aE_,loc,tag);
      return of_sexp_error(msg,sexp)}
    function stag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_sum_tag_must_be_a_structured_value),
               sexp)}
    function nested_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_a_nested_list_is_an_invalid_sum),
               sexp)}
    function empty_list_invalid_sum(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_the_empty_list_is_an_invalid_sum),
               sexp)}
    function unexpected_stag(loc,sexp)
     {return of_sexp_error
              (caml_call2(Pervasives[16],loc,cst_of_sexp_unexpected_sum_tag),
               sexp)}
    function record_only_pairs_expected(loc,sexp)
     {var
       msg=
        caml_call2
         (Pervasives[16],
          loc,
          cst_of_sexp_record_conversion_only_pairs_expected_their_first_element_must_be_an_atom);
      return of_sexp_error(msg,sexp)}
    function record_superfluous_fields(what,loc,rev_fld_names,sexp)
     {var
       _aK_=caml_call1(ListLabels[9],rev_fld_names),
       fld_names_str=caml_call2(StringLabels[7],cst$12,_aK_),
       msg=caml_call4(Printf[4],_aF_,loc,what,fld_names_str);
      return of_sexp_error(msg,sexp)}
    function record_duplicate_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_duplicate_fields,loc,rev_fld_names,sexp)}
    function record_extra_fields(loc,rev_fld_names,sexp)
     {return record_superfluous_fields
              (cst_extra_fields,loc,rev_fld_names,sexp)}
    function record_get_undefined_loop(fields,param)
     {var fields$0=fields,param$0=param;
      for(;;)
       {if(param$0)
         {var _aI_=param$0[1];
          if(0 === _aI_[1]){var param$1=param$0[2],param$0=param$1;continue}
          var
           param$2=param$0[2],
           field=_aI_[2],
           fields$1=[0,field,fields$0],
           fields$0=fields$1,
           param$0=param$2;
          continue}
        var _aJ_=caml_call1(ListLabels[9],fields$0);
        return caml_call2(StringLabels[7],cst$13,_aJ_)}}
    function record_undefined_elements(loc,sexp,lst)
     {var
       undefined$0=record_get_undefined_loop(0,lst),
       msg=caml_call3(Printf[4],_aG_,loc,undefined$0);
      return of_sexp_error(msg,sexp)}
    function record_list_instead_atom(loc,sexp)
     {var
       msg=
        caml_call2
         (Pervasives[16],
          loc,
          cst_of_sexp_list_instead_of_atom_for_record_expected);
      return of_sexp_error(msg,sexp)}
    function record_poly_field_value(loc,sexp)
     {var
       msg=
        caml_call2
         (Pervasives[16],
          loc,
          cst_of_sexp_cannot_convert_values_of_types_resulting_from_polymorphic_record_fields);
      return of_sexp_error(msg,sexp)}
    var
     No_variant_match=
      [248,cst_Sexplib0_Sexp_conv_error_No_variant_match,caml_fresh_oo_id(0)];
    function no_variant_match(param){throw No_variant_match}
    function no_matching_variant_found(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],loc,cst_of_sexp_no_matching_variant_found),
               sexp)}
    function ptag_no_args(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_polymorphic_variant_does_not_take_arguments),
               sexp)}
    function ptag_incorrect_n_args(loc,cnstr,sexp)
     {var msg=caml_call3(Printf[4],_aH_,loc,cnstr);
      return of_sexp_error(msg,sexp)}
    function ptag_takes_args(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_polymorphic_variant_tag_takes_an_argument),
               sexp)}
    function nested_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_a_nested_list_is_an_invalid_polymorphic_variant),
               sexp)}
    function empty_list_invalid_poly_var(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_the_empty_list_is_an_invalid_polymorphic_variant),
               sexp)}
    function silly_type(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_trying_to_convert_a_silly_type),
               sexp)}
    function empty_type(loc,sexp)
     {return of_sexp_error
              (caml_call2
                (Pervasives[16],
                 loc,
                 cst_of_sexp_trying_to_convert_an_empty_type),
               sexp)}
    var
     Sexplib0_Sexp_conv_error=
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       silly_type,
       empty_type];
    caml_register_global
     (173,Sexplib0_Sexp_conv_error,"Sexplib0__Sexp_conv_error");
    return}
  (function(){return this}()));


//# 1 ".js/ppx_sexp_conv.runtime-lib/ppx_sexp_conv_lib.cma.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime,Ppx_sexp_conv_lib=[0,0,0,0];
    runtime.caml_register_global(0,Ppx_sexp_conv_lib,"Ppx_sexp_conv_lib");
    return}
  (function(){return this}()));


//# 1 ".js/str/str.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst$5=caml_new_string(""),
     cst$4=caml_new_string(""),
     cst$3=caml_new_string(""),
     cst_Str_matched_group=caml_new_string("Str.matched_group"),
     cst_Str_group_end=caml_new_string("Str.group_end"),
     cst_Str_group_beginning=caml_new_string("Str.group_beginning"),
     cst_group_not_closed_by=caml_new_string("\\( group not closed by \\)"),
     cst_class_not_closed_by=caml_new_string("[ class not closed by ]"),
     cst_spurious_in_regular_expression=
      caml_new_string("spurious \\) in regular expression"),
     cst_too_many_r_or_r_where_r_is_nullable=
      caml_new_string("too many r* or r+ where r is nullable"),
     cst$1=caml_new_string(""),
     cst$2=caml_new_string(""),
     List=global_data.List,
     String=global_data.String,
     Not_found=global_data.Not_found,
     Pervasives=global_data.Pervasives,
     Bytes=global_data.Bytes,
     Assert_failure=global_data.Assert_failure,
     Buffer=global_data.Buffer,
     Char=global_data.Char,
     Array=global_data.Array,
     Map=global_data.Map,
     _b_=[0,92],
     _c_=[0,caml_new_string("str.ml"),520,10],
     _a_=[0,caml_new_string("str.ml"),213,11];
    function string_before(s,n){return caml_call3(String[4],s,0,n)}
    function string_after(s,n)
     {return caml_call3(String[4],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(String[4],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(String[4],s,caml_ml_string_length(s) - n | 0,n)}
    var full=caml_call2(Bytes[1],32,255);
    function make_empty(param){return caml_call2(Bytes[1],32,0)}
    function add(s,i)
     {var _ao_=caml_bytes_get(s,i >>> 3 | 0) | 1 << (i & 7);
      return caml_bytes_set(s,i >>> 3 | 0,caml_call1(Char[1],_ao_))}
    function singleton(c){var s=make_empty(0);add(s,c);return s}
    function complement(s)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _am_=caml_bytes_get(s,i) ^ 255;
        caml_bytes_set(r,i,caml_call1(Char[1],_am_));
        var _an_=i + 1 | 0;
        if(31 !== i){var i=_an_;continue}
        return r}}
    function union(s1,s2)
     {var r=caml_create_bytes(32),i=0;
      for(;;)
       {var _aj_=caml_bytes_get(s2,i),_ak_=caml_bytes_get(s1,i) | _aj_;
        caml_bytes_set(r,i,caml_call1(Char[1],_ak_));
        var _al_=i + 1 | 0;
        if(31 !== i){var i=_al_;continue}
        return r}}
    function disjoint(s1,s2)
     {try
       {var i=0;
        for(;;)
         {var _ag_=caml_bytes_get(s2,i);
          if(0 !== (caml_bytes_get(s1,i) & _ag_))throw Pervasives[3];
          var _ah_=i + 1 | 0;
          if(31 !== i){var i=_ah_;continue}
          var _af_=1;
          return _af_}}
      catch(_ai_)
       {_ai_ = caml_wrap_exception(_ai_);
        if(_ai_ === Pervasives[3])return 0;
        throw _ai_}}
    function iter(fn,s)
     {var i=0;
      for(;;)
       {var c=caml_bytes_get(s,i);
        if(0 !== c)
         {var j=0;
          for(;;)
           {if(0 !== (c & 1 << j))
             caml_call1(fn,caml_call1(Char[1],(i << 3) + j | 0));
            var _ae_=j + 1 | 0;
            if(7 !== j){var j=_ae_;continue}
            break}}
        var _ad_=i + 1 | 0;
        if(31 !== i){var i=_ad_;continue}
        return 0}}
    function fold_case(s)
     {var r=make_empty(0);
      iter
       (function(c)
         {add(r,caml_call1(Char[3],c));return add(r,caml_call1(Char[4],c))},
        s);
      return r}
    var
     op_CHAR=0,
     op_CHARNORM=1,
     op_STRING=2,
     op_STRINGNORM=3,
     op_CHARCLASS=4,
     op_BOL=5,
     op_EOL=6,
     op_WORDBOUNDARY=7,
     op_BEGGROUP=8,
     op_ENDGROUP=9,
     op_REFGROUP=10,
     op_ACCEPT=11,
     op_SIMPLEOPT=12,
     op_SIMPLESTAR=13,
     op_SIMPLEPLUS=14,
     op_GOTO=15,
     op_PUSHBACK=16,
     op_SETMARK=17,
     op_CHECKPROGRESS=18;
    function instr(opc,arg){return opc | arg << 8}
    function displ(dest,from){return (dest - from | 0) - 1 | 0}
    function is_nullable(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0){case 0:return 1;case 1:return 1;default:return 1}
       else
        switch(param$0[0])
         {case 0:return 0;
          case 1:var s=param$0[1];return caml_string_equal(s,cst);
          case 2:return 0;
          case 3:var rl=param$0[1];return caml_call2(List[27],is_nullable,rl);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ac_=is_nullable(r1);
           if(_ac_)return _ac_;
           var param$0=r2;
           continue;
          case 5:return 1;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return 1;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return 1}}
    function first$0(counter,param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return full;case 1:return full;default:return full}
       else
        switch(param$0[0])
         {case 0:var c=param$0[1];return singleton(c);
          case 1:
           var s=param$0[1];
           return caml_string_equal(s,cst$0)
                   ?full
                   :singleton(caml_string_get(s,0));
          case 2:
           var cmpl=param$0[2],cl=param$0[1];return cmpl?complement(cl):cl;
          case 3:
           var rl=param$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return first_seq$0(counter$0,rl)}
           return caml_trampoline_return(first_seq$0,[0,rl]);
          case 4:
           var r2=param$0[2],r1=param$0[1],_ab_=first(r2);
           return union(first(r1),_ab_);
          case 5:return full;
          case 6:var param$1=param$0[1],param$0=param$1;continue;
          case 7:return full;
          case 8:var param$2=param$0[2],param$0=param$2;continue;
          default:return full}}
    function first_seq$0(counter,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var ___=param$0[1];
          if(typeof ___ === "number")
           {var param$1=param$0[2],param$0=param$1;continue}
          else
           switch(___[0])
            {case 5:
              var rl=param$0[2],r=___[1],_$_=first_seq(rl);
              return union(first(r),_$_);
             case 7:
              var rl$0=param$0[2],r$0=___[1],_aa_=first_seq(rl$0);
              return union(first(r$0),_aa_);
             default:
              if(counter < 50)
               {var counter$0=counter + 1 | 0;return first$0(counter$0,___)}
              return caml_trampoline_return(first$0,[0,___])}}
        return full}}
    function first(param){return caml_trampoline(first$0(0,param))}
    function first_seq(param){return caml_trampoline(first_seq$0(0,param))}
    function charclass_of_regexp(fold_case$0,re)
     {if(typeof re === "number")
       var switch$0=0;
      else
       switch(re[0])
        {case 0:var c=re[1],match=[0,singleton(c),0],switch$0=1;break;
         case 2:
          var compl$0=re[2],cl=re[1],match=[0,cl,compl$0],switch$0=1;break;
         default:var switch$0=0}
      if(switch$0)
       {var
         compl=match[2],
         cl1=match[1],
         cl2=fold_case$0?fold_case(cl1):cl1,
         _Z_=compl?complement(cl2):cl2;
        return caml_call1(Bytes[6],_Z_)}
      throw [0,Assert_failure,_a_]}
    var t=caml_create_bytes(256),i=0;
    for(;;)
     {var _d_=caml_call1(Char[1],i);
      caml_bytes_set(t,i,caml_call1(Char[3],_d_));
      var _e_=i + 1 | 0;
      if(255 !== i){var i=_e_;continue}
      var
       fold_case_table=caml_call1(Bytes[6],t),
       compare=runtime.caml_string_compare,
       StringMap=caml_call1(Map[1],[0,compare]),
       compile=
        function(fold_case$0,re)
         {var
           prog=[0,caml_make_vect(32,0)],
           progpos=[0,0],
           cpool=[0,StringMap[1]],
           cpoolpos=[0,0],
           numgroups=[0,1],
           numregs=[0,0];
          function emit_instr(opc,arg)
           {if(prog[1].length - 1 <= progpos[1])
             {var newlen=[0,prog[1].length - 1];
              for(;;)
               {if(newlen[1] <= progpos[1])
                 {newlen[1] = newlen[1] * 2 | 0;continue}
                var nprog=caml_make_vect(newlen[1],0);
                caml_call5(Array[10],prog[1],0,nprog,0,prog[1].length - 1);
                prog[1] = nprog;
                break}}
            var _X_=instr(opc,arg),_Y_=progpos[1];
            caml_check_bound(prog[1],_Y_)[_Y_ + 1] = _X_;
            progpos[1]++;
            return 0}
          function emit_hole(param)
           {var p=progpos[1];emit_instr(op_CHAR,0);return p}
          function patch_instr(pos,opc,dest)
           {var _W_=instr(opc,displ(dest,pos));
            return caml_check_bound(prog[1],pos)[pos + 1] = _W_}
          function cpool_index(s)
           {try
             {var _U_=caml_call2(StringMap[27],s,cpool[1]);return _U_}
            catch(_V_)
             {_V_ = caml_wrap_exception(_V_);
              if(_V_ === Not_found)
               {var p=cpoolpos[1];
                cpool[1] = caml_call3(StringMap[4],s,p,cpool[1]);
                cpoolpos[1]++;
                return p}
              throw _V_}}
          function allocate_register_if_nullable(r)
           {if(is_nullable(r))
             {var n=numregs[1];
              if(64 <= n)
               caml_call1
                (Pervasives[2],cst_too_many_r_or_r_where_r_is_nullable);
              numregs[1]++;
              return n}
            return -1}
          function emit_seq_code(param)
           {var param$0=param;
            for(;;)
             {if(param$0)
               {var _N_=param$0[1];
                if(typeof _N_ !== "number")
                 switch(_N_[0])
                  {case 5:
                    var _O_=_N_[1];
                    if(typeof _O_ === "number")
                     var switch$0=0;
                    else
                     switch(_O_[0])
                      {case 0:
                       case 2:
                        var rl$0=param$0[2],_P_=first_seq(rl$0);
                        if(disjoint_modulo_case(first(_O_),_P_))
                         {emit_instr
                           (op_SIMPLESTAR,
                            cpool_index(charclass_of_regexp(fold_case$0,_O_)));
                          var param$0=rl$0;
                          continue}
                        var switch$0=1;
                        break;
                       default:var switch$0=0}
                    break;
                   case 6:
                    var _Q_=_N_[1];
                    if(typeof _Q_ === "number")
                     var switch$1=0;
                    else
                     switch(_Q_[0])
                      {case 0:
                       case 2:
                        var rl$1=param$0[2],_R_=first_seq(rl$1);
                        if(disjoint_modulo_case(first(_Q_),_R_))
                         {emit_instr
                           (op_SIMPLEPLUS,
                            cpool_index(charclass_of_regexp(fold_case$0,_Q_)));
                          var param$0=rl$1;
                          continue}
                        var switch$1=1;
                        break;
                       default:var switch$1=0}
                    break;
                   case 7:
                    var _S_=_N_[1];
                    if(typeof _S_ === "number")
                     var switch$2=0;
                    else
                     switch(_S_[0])
                      {case 0:
                       case 2:
                        var rl$2=param$0[2],_T_=first_seq(rl$2);
                        if(disjoint_modulo_case(first(_S_),_T_))
                         {emit_instr
                           (op_SIMPLEOPT,
                            cpool_index(charclass_of_regexp(fold_case$0,_S_)));
                          var param$0=rl$2;
                          continue}
                        var switch$2=1;
                        break;
                       default:var switch$2=0}
                    break
                   }
                var rl=param$0[2];
                emit_code(_N_);
                var param$0=rl;
                continue}
              return 0}}
          function emit_code(param)
           {if(typeof param === "number")
             switch(param)
              {case 0:return emit_instr(op_BOL,0);
               case 1:return emit_instr(op_EOL,0);
               default:return emit_instr(op_WORDBOUNDARY,0)}
            else
             switch(param[0])
              {case 0:
                var c=param[1];
                return fold_case$0
                        ?emit_instr(op_CHARNORM,caml_call1(Char[3],c))
                        :emit_instr(op_CHAR,c);
               case 1:
                var s=param[1],match=caml_ml_string_length(s);
                if(0 === match)return 0;
                if(1 === match)
                 {if(fold_case$0)
                   {var _K_=caml_string_get(s,0);
                    return emit_instr(op_CHARNORM,caml_call1(Char[3],_K_))}
                  return emit_instr(op_CHAR,caml_string_get(s,0))}
                try
                 {var i=caml_call2(String[14],s,0);
                  emit_code([1,string_before(s,i)]);
                  emit_instr(op_CHAR,0);
                  var _L_=emit_code([1,string_after(s,i + 1 | 0)]);
                  return _L_}
                catch(_M_)
                 {_M_ = caml_wrap_exception(_M_);
                  if(_M_ === Not_found)
                   return fold_case$0
                           ?emit_instr
                             (op_STRINGNORM,cpool_index(caml_call1(String[26],s)))
                           :emit_instr(op_STRING,cpool_index(s));
                  throw _M_}
               case 2:
                var
                 compl=param[2],
                 cl=param[1],
                 cl1=fold_case$0?fold_case(cl):cl,
                 cl2=compl?complement(cl1):cl1;
                return emit_instr
                        (op_CHARCLASS,cpool_index(caml_call1(Bytes[6],cl2)));
               case 3:var rl=param[1];return emit_seq_code(rl);
               case 4:
                var r2=param[2],r1=param[1],pos_pushback=emit_hole(0);
                emit_code(r1);
                var pos_goto_end=emit_hole(0),lbl1=progpos[1];
                emit_code(r2);
                var lbl2=progpos[1];
                patch_instr(pos_pushback,op_PUSHBACK,lbl1);
                return patch_instr(pos_goto_end,op_GOTO,lbl2);
               case 5:
                var
                 r=param[1],
                 regno=allocate_register_if_nullable(r),
                 lbl1$0=emit_hole(0);
                if(0 <= regno)emit_instr(op_SETMARK,regno);
                emit_code(r);
                if(0 <= regno)emit_instr(op_CHECKPROGRESS,regno);
                emit_instr(op_GOTO,displ(lbl1$0,progpos[1]));
                var lbl2$0=progpos[1];
                return patch_instr(lbl1$0,op_PUSHBACK,lbl2$0);
               case 6:
                var
                 r$0=param[1],
                 regno$0=allocate_register_if_nullable(r$0),
                 lbl1$1=progpos[1];
                emit_code(r$0);
                if(0 <= regno$0)emit_instr(op_CHECKPROGRESS,regno$0);
                var pos_pushback$0=emit_hole(0);
                if(0 <= regno$0)emit_instr(op_SETMARK,regno$0);
                emit_instr(op_GOTO,displ(lbl1$1,progpos[1]));
                var lbl2$1=progpos[1];
                return patch_instr(pos_pushback$0,op_PUSHBACK,lbl2$1);
               case 7:
                var r$1=param[1],pos_pushback$1=emit_hole(0);
                emit_code(r$1);
                var lbl=progpos[1];
                return patch_instr(pos_pushback$1,op_PUSHBACK,lbl);
               case 8:
                var r$2=param[2],n=param[1];
                emit_instr(op_BEGGROUP,n);
                emit_code(r$2);
                emit_instr(op_ENDGROUP,n);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n + 1 | 0);
                return 0;
               default:
                var n$0=param[1];
                emit_instr(op_REFGROUP,n$0);
                numgroups[1]
                =
                caml_call2(Pervasives[5],numgroups[1],n$0 + 1 | 0);
                return 0}}
          function disjoint_modulo_case(c1,c2)
           {if(fold_case$0)
             {var _J_=fold_case(c2);return disjoint(fold_case(c1),_J_)}
            return disjoint(c1,c2)}
          emit_code(re);
          emit_instr(op_ACCEPT,0);
          var start=first(re),start$0=fold_case$0?fold_case(start):start;
          if(runtime.caml_bytes_equal(start,full))
           var start_pos=-1;
          else
           {var r=caml_call2(Bytes[1],256,0);
            iter(function(c){return caml_bytes_set(r,c,1)},start$0);
            var start_pos=cpool_index(caml_call1(Bytes[6],r))}
          var constantpool=caml_make_vect(cpoolpos[1],cst$1),_F_=cpool[1];
          function _G_(str,idx)
           {return caml_check_bound(constantpool,idx)[idx + 1] = str}
          caml_call2(StringMap[12],_G_,_F_);
          var
           _H_=numregs[1],
           _I_=numgroups[1],
           fold_case_table$0=fold_case$0?fold_case_table:cst$2;
          return [0,
                  caml_call3(Array[7],prog[1],0,progpos[1]),
                  constantpool,
                  fold_case_table$0,
                  _I_,
                  _H_,
                  start_pos]},
       flush=
        function(buf)
         {var s=caml_call1(Buffer[2],buf[1]);
          caml_call1(Buffer[8],buf[1]);
          var match=caml_ml_string_length(s);
          if(0 === match)return 0;
          if(1 === match)
           {var _E_=buf[2];buf[2] = [0,[0,caml_string_get(s,0)],_E_];return 0}
          buf[2] = [0,[1,s],buf[2]];
          return 0},
       dotclass=complement(singleton(10)),
       parse=
        function(s)
         {var len=caml_ml_string_length(s),group_counter=[0,1];
          function regexp0(i)
           {var match=regexp1(i),j=match[2],r=match[1],r1=r,i$0=j;
            for(;;)
             {if((i$0 + 2 | 0) <= len)
               if(92 === caml_string_get(s,i$0))
                if(124 === caml_string_get(s,i$0 + 1 | 0))
                 {var
                   match$0=regexp1(i$0 + 2 | 0),
                   i$1=match$0[2],
                   r2=match$0[1],
                   r1$0=[4,r1,r2],
                   r1=r1$0,
                   i$0=i$1;
                  continue}
              return [0,r1,i$0]}}
          function regexp1(i)
           {var sb=[0,caml_call1(Buffer[1],16),0],i$0=i;
            a:
            for(;;)
             {if(! (len <= i$0))
               {if((i$0 + 2 | 0) <= len)
                 if(92 === caml_string_get(s,i$0))
                  var
                   c$0=caml_string_get(s,i$0 + 1 | 0),
                   _B_=124 === c$0?1:0,
                   _C_=_B_ || (41 === c$0?1:0),
                   switch$0=_C_?0:1;
                 else
                  var switch$0=1;
                else
                 var switch$0=1;
                if(switch$0)
                 {var c$1=caml_string_get(s,i$0);
                  if(36 === c$1)
                   var match=[0,1,i$0 + 1 | 0];
                  else
                   {if(91 <= c$1)
                     if(95 <= c$1)
                      var switch$1=0;
                     else
                      {var switcher$0=c$1 - 91 | 0;
                       switch(switcher$0)
                        {case 0:
                          var i$4=i$0 + 1 | 0;
                          if(i$4 < len)
                           if(94 === caml_string_get(s,i$4))
                            var
                             match$3=regexpclass1(i$4 + 1 | 0),
                             j$3=match$3[2],
                             c$4=match$3[1],
                             match$1=[0,c$4,1,j$3],
                             switch$2=1;
                           else
                            var switch$2=0;
                          else
                           var switch$2=0;
                          if(! switch$2)
                           var
                            match$4=regexpclass1(i$4),
                            j$4=match$4[2],
                            c$5=match$4[1],
                            match$1=[0,c$5,0,j$4];
                          var
                           j$1=match$1[3],
                           compl=match$1[2],
                           c$2=match$1[1],
                           match=[0,[2,c$2,compl],j$1],
                           switch$1=1;
                          break;
                         case 1:
                          var i$5=i$0 + 1 | 0;
                          if(len <= i$5)
                           var _D_=[0,_b_,i$5];
                          else
                           {var c$3=caml_string_get(s,i$5);
                            if(58 <= c$3)
                             if(98 === c$3)
                              var _D_=[0,2,i$5 + 1 | 0],switch$3=2;
                             else
                              var switch$3=124 === c$3?1:0;
                            else
                             {var switcher$1=c$3 - 40 | 0;
                              if(1 < switcher$1 >>> 0)
                               if(9 <= switcher$1)
                                var _D_=[0,[9,c$3 - 48 | 0],i$5 + 1 | 0],switch$3=2;
                               else
                                var switch$3=0;
                              else
                               if(0 === switcher$1)
                                {var group_no=group_counter[1];
                                 group_counter[1]++;
                                 var
                                  match$2=regexp0(i$5 + 1 | 0),
                                  j$2=match$2[2],
                                  r$4=match$2[1];
                                 if((j$2 + 1 | 0) < len)
                                  if(92 === caml_string_get(s,j$2))
                                   if(41 === caml_string_get(s,j$2 + 1 | 0))
                                    var
                                     _D_=[0,[8,group_no,r$4],j$2 + 2 | 0],
                                     switch$3=2,
                                     switch$4=0;
                                   else
                                    var switch$4=1;
                                  else
                                   var switch$4=1;
                                 else
                                  var switch$4=1;
                                 if(switch$4)
                                  var
                                   _D_=caml_call1(Pervasives[2],cst_group_not_closed_by),
                                   switch$3=2}
                               else
                                var switch$3=1}
                            switch(switch$3)
                             {case 0:var _D_=[0,[0,c$3],i$5 + 1 | 0];break;
                              case 1:throw [0,Assert_failure,_c_]
                              }}
                          var match=_D_,switch$1=1;
                          break;
                         case 2:var switch$1=0;break;
                         default:var match=[0,0,i$0 + 1 | 0],switch$1=1}}
                    else
                     if(46 === c$1)
                      var match=[0,[2,dotclass,0],i$0 + 1 | 0],switch$1=1;
                     else
                      var switch$1=0;
                    if(! switch$1)var match=[0,[0,c$1],i$0 + 1 | 0]}
                  var j=match[2],r=match[1],r$0=r,j$0=j;
                  for(;;)
                   {if(! (len <= j$0))
                     {var
                       match$0=caml_string_get(s,j$0),
                       switcher=match$0 - 42 | 0;
                      if(! (1 < switcher >>> 0))
                       {if(0 === switcher)
                         {var i$2=j$0 + 1 | 0,r$2=[5,r$0],r$0=r$2,j$0=i$2;continue}
                        var i$3=j$0 + 1 | 0,r$3=[6,r$0],r$0=r$3,j$0=i$3;
                        continue}
                      if(21 === switcher)
                       {var i$1=j$0 + 1 | 0,r$1=[7,r$0],r$0=r$1,j$0=i$1;continue}}
                    if(typeof r$0 === "number")
                     var switch$5=0;
                    else
                     if(0 === r$0[0])
                      {var c=r$0[1];caml_call2(Buffer[10],sb[1],c);var switch$5=1}
                     else
                      var switch$5=0;
                    if(! switch$5){flush(sb);sb[2] = [0,r$0,sb[2]]}
                    var i$0=j$0;
                    continue a}}}
              flush(sb);
              return [0,[3,caml_call1(List[9],sb[2])],i$0]}}
          function regexpclass1(start)
           {var c=make_empty(0),i$0=start;
            for(;;)
             {if(len <= i$0)caml_call1(Pervasives[2],cst_class_not_closed_by);
              if(93 === caml_string_get(s,i$0))
               if(start < i$0){var j=i$0 + 1 | 0;return [0,c,j]}
              var c1=caml_string_get(s,i$0);
              if((i$0 + 2 | 0) < len)
               if(45 === caml_string_get(s,i$0 + 1 | 0))
                if(93 !== caml_string_get(s,i$0 + 2 | 0))
                 {var c2=caml_string_get(s,i$0 + 2 | 0);
                  if(! (c2 < c1))
                   {var i=c1;
                    for(;;)
                     {add(c,caml_call1(Char[1],i));
                      var _A_=i + 1 | 0;
                      if(c2 !== i){var i=_A_;continue}
                      break}}
                  var i$2=i$0 + 3 | 0,i$0=i$2;
                  continue}
              add(c,c1);
              var i$1=i$0 + 1 | 0,i$0=i$1;
              continue}}
          var match=regexp0(0),j=match[2],r=match[1];
          return j === len
                  ?r
                  :caml_call1
                    (Pervasives[2],cst_spurious_in_regular_expression)},
       regexp=function(e){return compile(0,parse(e))},
       regexp_case_fold=function(e){return compile(1,parse(e))},
       quote=
        function(s)
         {var
           len=caml_ml_string_length(s),
           buf=caml_create_bytes(2 * len | 0),
           pos=[0,0],
           _w_=len - 1 | 0,
           _v_=0;
          if(! (_w_ < 0))
           {var i=_v_;
            for(;;)
             {var c=caml_string_get(s,i),_x_=c - 63 | 0;
              if(31 < _x_ >>> 0)
               {var _y_=_x_ + 27 | 0;
                if(10 < _y_ >>> 0)
                 var switch$0=0;
                else
                 switch(_y_)
                  {case 0:
                   case 6:
                   case 7:
                   case 10:var switch$0=1;break;
                   default:var switch$0=0}}
              else
               var switch$0=26 < (_x_ - 1 | 0) >>> 0?1:0;
              if(switch$0)
               {caml_bytes_set(buf,pos[1],92);
                caml_bytes_set(buf,pos[1] + 1 | 0,c);
                pos[1] = pos[1] + 2 | 0}
              else
               {caml_bytes_set(buf,pos[1],c);pos[1] = pos[1] + 1 | 0}
              var _z_=i + 1 | 0;
              if(_w_ !== i){var i=_z_;continue}
              break}}
          return caml_call3(Bytes[8],buf,0,pos[1])},
       regexp_string=function(s){return compile(0,[1,s])},
       regexp_string_case_fold=function(s){return compile(1,[1,s])},
       last_search_result=[0,[0]],
       string_match=
        function(re,s,pos)
         {var res=runtime.re_string_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       string_partial_match=
        function(re,s,pos)
         {var res=runtime.re_partial_match(re,s,pos);
          last_search_result[1] = res;
          return 0 < res.length - 1?1:0},
       search_forward=
        function(re,s,pos)
         {var res=runtime.re_search_forward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       search_backward=
        function(re,s,pos)
         {var res=runtime.re_search_backward(re,s,pos);
          last_search_result[1] = res;
          if(0 === res.length - 1)throw Not_found;
          return caml_check_bound(res,0)[1]},
       group_beginning=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var pos=caml_check_bound(last_search_result[1],n2)[n2 + 1];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_beginning)},
       group_end=
        function(n)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              _u_=n2 + 1 | 0,
              pos=caml_check_bound(last_search_result[1],_u_)[_u_ + 1];
             if(-1 === pos)throw Not_found;
             return pos}
          return caml_call1(Pervasives[1],cst_Str_group_end)},
       matched_group=
        function(n,txt)
         {var n2=n + n | 0;
          if(0 <= n)
           if(! (last_search_result[1].length - 1 <= n2))
            {var
              b=caml_check_bound(last_search_result[1],n2)[n2 + 1],
              _t_=n2 + 1 | 0,
              e=caml_check_bound(last_search_result[1],_t_)[_t_ + 1];
             if(-1 === b)throw Not_found;
             return caml_call3(String[4],txt,b,e - b | 0)}
          return caml_call1(Pervasives[1],cst_Str_matched_group)},
       match_beginning=function(param){return group_beginning(0)},
       match_end=function(param){return group_end(0)},
       matched_string=function(txt){return matched_group(0,txt)},
       replace_matched=
        function(repl,matched)
         {return runtime.re_replacement_text
                  (repl,last_search_result[1],matched)},
       substitute_first=
        function(expr,repl_fun,text)
         {try
           {var
             pos=search_forward(expr,text,0),
             _o_=[0,string_after(text,match_end(0)),0],
             _p_=[0,caml_call1(repl_fun,text),_o_],
             _q_=[0,string_before(text,pos),_p_],
             _r_=caml_call2(String[7],cst$3,_q_);
            return _r_}
          catch(_s_)
           {_s_ = caml_wrap_exception(_s_);
            if(_s_ === Not_found)return text;
            throw _s_}},
       opt_search_forward=
        function(re,s,pos)
         {try
           {var _m_=[0,search_forward(re,s,pos)];return _m_}
          catch(_n_)
           {_n_ = caml_wrap_exception(_n_);
            if(_n_ === Not_found)return 0;
            throw _n_}},
       global_substitute=
        function(expr,repl_fun,text)
         {var accu=0,start=0,last_was_empty=0;
          for(;;)
           {var startpos=last_was_empty?start + 1 | 0:start;
            if(caml_ml_string_length(text) < startpos)
             var _k_=[0,string_after(text,start),accu];
            else
             {var match=opt_search_forward(expr,text,startpos);
              if(match)
               {var
                 pos=match[1],
                 start$0=match_end(0),
                 repl_text=caml_call1(repl_fun,text),
                 last_was_empty$0=start$0 === pos?1:0,
                 accu$0=
                  [0,
                   repl_text,
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu]],
                 accu=accu$0,
                 start=start$0,
                 last_was_empty=last_was_empty$0;
                continue}
              var _k_=[0,string_after(text,start),accu]}
            var _l_=caml_call1(List[9],_k_);
            return caml_call2(String[7],cst$4,_l_)}},
       global_replace=
        function(expr,repl,text)
         {return global_substitute
                  (expr,function(_j_){return replace_matched(repl,_j_)},text)},
       replace_first=
        function(expr,repl,text)
         {return substitute_first
                  (expr,function(_i_){return replace_matched(repl,_i_)},text)},
       opt_search_forward_progress=
        function(expr,text,start)
         {var match=opt_search_forward(expr,text,start);
          if(match)
           {var pos=match[1];
            return start < match_end(0)
                    ?[0,pos]
                    :start < caml_ml_string_length(text)
                      ?opt_search_forward(expr,text,start + 1 | 0)
                      :0}
          return 0},
       bounded_split=
        function(expr,text,num)
         {var
           start=string_match(expr,text,0)?match_end(0):0,
           accu=0,
           start$0=start,
           n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start$0)
             var _h_=accu;
            else
             if(1 === n)
              var _h_=[0,string_after(text,start$0),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start$0);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$1=match_end(0),
                  accu$0=
                   [0,
                    caml_call3(String[4],text,start$0,pos - start$0 | 0),
                    accu],
                  accu=accu$0,
                  start$0=start$1,
                  n=n$0;
                 continue}
               var _h_=[0,string_after(text,start$0),accu]}
            return caml_call1(List[9],_h_)}},
       split=function(expr,text){return bounded_split(expr,text,0)},
       bounded_split_delim=
        function(expr,text,num)
         {if(caml_string_equal(text,cst$5))return 0;
          var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) < start)
             var _g_=accu;
            else
             if(1 === n)
              var _g_=[0,string_after(text,start),accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var
                  pos=match[1],
                  n$0=n - 1 | 0,
                  start$0=match_end(0),
                  accu$0=
                   [0,caml_call3(String[4],text,start,pos - start | 0),accu],
                  accu=accu$0,
                  start=start$0,
                  n=n$0;
                 continue}
               var _g_=[0,string_after(text,start),accu]}
            return caml_call1(List[9],_g_)}},
       split_delim=
        function(expr,text){return bounded_split_delim(expr,text,0)},
       bounded_full_split=
        function(expr,text,num)
         {var accu=0,start=0,n=num;
          for(;;)
           {if(caml_ml_string_length(text) <= start)
             var _f_=accu;
            else
             if(1 === n)
              var _f_=[0,[0,string_after(text,start)],accu];
             else
              {var match=opt_search_forward_progress(expr,text,start);
               if(match)
                {var pos=match[1],s=matched_string(text);
                 if(start < pos)
                  {var
                    n$0=n - 1 | 0,
                    start$0=match_end(0),
                    accu$0=
                     [0,
                      [1,s],
                      [0,
                       [0,caml_call3(String[4],text,start,pos - start | 0)],
                       accu]],
                    accu=accu$0,
                    start=start$0,
                    n=n$0;
                   continue}
                 var
                  n$1=n - 1 | 0,
                  start$1=match_end(0),
                  accu$1=[0,[1,s],accu],
                  accu=accu$1,
                  start=start$1,
                  n=n$1;
                 continue}
               var _f_=[0,[0,string_after(text,start)],accu]}
            return caml_call1(List[9],_f_)}},
       full_split=function(expr,text){return bounded_full_split(expr,text,0)},
       Str=
        [0,
         regexp,
         regexp_case_fold,
         quote,
         regexp_string,
         regexp_string_case_fold,
         string_match,
         search_forward,
         search_backward,
         string_partial_match,
         matched_string,
         match_beginning,
         match_end,
         matched_group,
         group_beginning,
         group_end,
         global_replace,
         replace_first,
         global_substitute,
         substitute_first,
         replace_matched,
         split,
         bounded_split,
         split_delim,
         bounded_split_delim,
         full_split,
         bounded_full_split,
         string_before,
         string_after,
         first_chars,
         last_chars];
      runtime.caml_register_global(27,Str,"Str");
      return}}
  (function(){return this}()));


//# 1 ".js/containers.monomorphic/containers_monomorphic.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Pervasives=global_data.Pervasives,
     min=Pervasives[4],
     max=Pervasives[5];
    function _a_(_L_,_K_){return _L_ == _K_?1:0}
    function _b_(_J_,_I_){return _J_ != _I_?1:0}
    function _c_(_H_,_G_){return _H_ < _G_?1:0}
    function _d_(_F_,_E_){return _E_ < _F_?1:0}
    function _e_(_D_,_C_){return _D_ <= _C_?1:0}
    function _f_(_B_,_A_){return _A_ <= _B_?1:0}
    var _g_=996202947,_h_=996202947,_i_=runtime.caml_int_compare;
    function _j_(_z_,_y_){return _y_ <= _z_?1:0}
    function _k_(_x_,_w_){return _x_ <= _w_?1:0}
    function _l_(_v_,_u_){return _u_ < _v_?1:0}
    function _m_(_t_,_s_){return _t_ < _s_?1:0}
    function _n_(_r_,_q_){return _r_ !== _q_?1:0}
    var
     CCMonomorphic=
      [0,
       function(_p_,_o_){return _p_ === _o_?1:0},
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       min,
       max,
       _a_,
       _b_,
       _c_,
       _d_,
       _e_,
       _f_,
       _g_,
       _h_];
    runtime.caml_register_global(1,CCMonomorphic,"CCMonomorphic");
    return}
  (function(){return this}()));


//# 1 ".js/result/result.cma.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime,Result=[0];
    runtime.caml_register_global(0,Result,"Result");
    return}
  (function(){return this}()));


//# 1 ".js/containers/containers.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_classify_float=runtime.caml_classify_float,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_int64_of_float=runtime.caml_int64_of_float,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_to_int32=runtime.caml_int64_to_int32,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_notequal=runtime.caml_notequal,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_sys_file_exists=runtime.caml_sys_file_exists,
     caml_sys_is_directory=runtime.caml_sys_is_directory,
     caml_sys_read_directory=runtime.caml_sys_read_directory,
     caml_sys_remove=runtime.caml_sys_remove,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call12(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
     {return f.length == 12
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11])}
    function caml_call16
     (f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
     {return f.length == 16
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_new_string(", "),
     cst=caml_new_string(", "),
     cst_fold2=caml_new_string("fold2"),
     cst_iter2=caml_new_string("iter2"),
     cst_map2=caml_new_string("map2"),
     cst$2=caml_new_string(", "),
     cst$1=caml_new_string(", "),
     cst_CCArray_slice_fold2=caml_new_string("CCArray_slice_fold2"),
     cst_CCArray_slice_iter2=caml_new_string("CCArray_slice_iter2"),
     cst_CCArray_slice_blit=caml_new_string("CCArray_slice.blit"),
     cst_CCArray_slice_set=caml_new_string("CCArray_slice.set"),
     cst_CCArray_slice_get=caml_new_string("CCArray_slice.get"),
     cst_CCArray_slice_make=caml_new_string("CCArray_slice.make"),
     cst_sign_exn=caml_new_string("sign_exn"),
     cst_CCFloat_TrapNaN=caml_new_string("CCFloat.TrapNaN"),
     cst$15=caml_new_string(")"),
     cst$16=caml_new_string("("),
     cst$13=caml_new_string(")"),
     cst$14=caml_new_string("("),
     cst$11=caml_new_string(")"),
     cst$12=caml_new_string("("),
     cst_None=caml_new_string("None"),
     cst$9=caml_new_string("|]"),
     cst$10=caml_new_string("[|"),
     cst$7=caml_new_string("]"),
     cst$8=caml_new_string("["),
     cst$6=caml_new_string(""),
     cst$5=caml_new_string(""),
     cst_blue=caml_new_string("blue"),
     cst_Black=caml_new_string("Black"),
     cst_Blue=caml_new_string("Blue"),
     cst_Cyan=caml_new_string("Cyan"),
     cst_Green=caml_new_string("Green"),
     cst_Magenta=caml_new_string("Magenta"),
     cst_Red=caml_new_string("Red"),
     cst_White=caml_new_string("White"),
     cst_Yellow=caml_new_string("Yellow"),
     cst_black=caml_new_string("black"),
     cst_bold=caml_new_string("bold"),
     cst_cyan=caml_new_string("cyan"),
     cst_green=caml_new_string("green"),
     cst_magenta=caml_new_string("magenta"),
     cst_red=caml_new_string("red"),
     cst_reset=caml_new_string("reset"),
     cst_white=caml_new_string("white"),
     cst_yellow=caml_new_string("yellow"),
     cst$4=caml_new_string("\x1b["),
     cst_m=caml_new_string("m"),
     cst_0m=caml_new_string("\x1b[0m"),
     cst_none=caml_new_string("none"),
     cst$3=caml_new_string("()"),
     cst_CCFormat_No_such_style=caml_new_string("CCFormat.No_such_style"),
     cst_CCFun_iterate=caml_new_string("CCFun.iterate"),
     cst_CCList_range_by=caml_new_string("CCList.range_by"),
     cst_pow_can_t_raise_int_to_negative_power=
      caml_new_string("pow: can't raise int to negative power"),
     cst_pow_undefined_value_0_0=caml_new_string("pow: undefined value 0^0"),
     cst$20=caml_new_string(", "),
     cst$19=caml_new_string(" -> "),
     cst$18=caml_new_string(", "),
     cst$17=caml_new_string(" -> "),
     cst$21=caml_new_string(","),
     cst_CCHeap_Make_E_Empty=caml_new_string("CCHeap.Make(E).Empty"),
     cst_file=caml_new_string("file:"),
     cst_dir=caml_new_string("dir:"),
     cst$22=caml_new_string(""),
     cst$25=caml_new_string(""),
     cst$24=caml_new_string(""),
     cst$23=caml_new_string(", "),
     cst_CCList_Ref_pop_exn=caml_new_string("CCList.Ref.pop_exn"),
     cst_CCList_range_by$0=caml_new_string("CCList.range_by"),
     cst_foldi2=caml_new_string("foldi2"),
     cst_iteri2=caml_new_string("iteri2"),
     cst_sublists_of_len_n_must_be_0=
      caml_new_string("sublists_of_len: n must be > 0"),
     cst_sublists_of_len_offset_must_be_0=
      caml_new_string("sublists_of_len: offset must be > 0"),
     cst_hd_tl=caml_new_string("hd_tl"),
     cst_CCList_combine=caml_new_string("CCList.combine"),
     cst_CCList_combine$0=caml_new_string("CCList.combine"),
     cst_init=caml_new_string("init"),
     cst_fold_map2=caml_new_string("fold_map2"),
     cst$29=caml_new_string(""),
     cst$28=caml_new_string(""),
     cst$27=caml_new_string("->"),
     cst$26=caml_new_string(", "),
     cst_None$0=caml_new_string("None"),
     cst_CCOpt_get_exn=caml_new_string("CCOpt.get_exn"),
     cst_CCOpt_ExitChoice=caml_new_string("CCOpt.ExitChoice"),
     cst$30=caml_new_string(", "),
     cst$31=caml_new_string(""),
     cst$32=caml_new_string(""),
     cst$42=caml_new_string("("),
     cst$41=caml_new_string(")"),
     cst$40=caml_new_string(","),
     cst$39=caml_new_string("("),
     cst$38=caml_new_string(")"),
     cst$37=caml_new_string(","),
     cst_expected_an_int=caml_new_string("expected an int"),
     cst$36=caml_new_string("["),
     cst$35=caml_new_string("]"),
     cst$34=caml_new_string(";"),
     cst_expected_end_of_line=caml_new_string("expected end-of-line"),
     cst$33=caml_new_string(""),
     cst_unexpected_sequence_of_chars=
      caml_new_string("unexpected sequence of chars"),
     cst_expected_EOI=caml_new_string("expected EOI"),
     cst_unexpected_end_of_input=caml_new_string("unexpected end of input"),
     cst_CCParse_ParseError=caml_new_string("CCParse.ParseError"),
     cst_Random_split_list=caml_new_string("Random.split_list"),
     cst_sample_without_replacement=
      caml_new_string("sample_without_replacement"),
     cst_CCRandom_choose_array=caml_new_string("CCRandom.choose_array"),
     cst_CCRandom_Pick_from_empty=caml_new_string("CCRandom.Pick_from_empty"),
     cst_CCRandom_Backtrack=caml_new_string("CCRandom.Backtrack"),
     cst_context=caml_new_string("\ncontext:"),
     cst_CCResult_Get_error=caml_new_string("CCResult.Get_error"),
     cst_CCResult_LocalExit=caml_new_string("CCResult.LocalExit"),
     cst$45=caml_new_string(""),
     cst$44=caml_new_string(""),
     cst$43=caml_new_string(", "),
     cst_CCString_Sub_blit=caml_new_string("CCString.Sub.blit"),
     cst_CCString_Sub_get=caml_new_string("CCString.Sub.get"),
     cst_CCString_Sub_sub=caml_new_string("CCString.Sub.sub"),
     cst_CCString_Sub_make=caml_new_string("CCString.Sub.make"),
     cst_CCString_fold2=caml_new_string("CCString.fold2"),
     cst_CCString_iteri2=caml_new_string("CCString.iteri2"),
     cst_CCString_iter2=caml_new_string("CCString.iter2"),
     cst_CCString_map2=caml_new_string("CCString.map2"),
     cst_CCString_set=caml_new_string("CCString.set"),
     cst$52=caml_new_string("\n"),
     cst$51=caml_new_string("\n"),
     cst$50=caml_new_string("\n"),
     cst$49=caml_new_string(""),
     cst$47=caml_new_string("."),
     cst$48=caml_new_string("."),
     state$0=[0,0],
     state=[0,0],
     cst_CCString_replace=caml_new_string("CCString.replace"),
     cst_CCString_is_sub=caml_new_string("CCString.is_sub"),
     cst$46=caml_new_string(""),
     no_drop=[0,0,0],
     cst_CCString_MyExit=caml_new_string("CCString.MyExit"),
     cst_CCUtf8_string_of_string_exn=
      caml_new_string("CCUtf8_string.of_string_exn"),
     cst_CCUtf8_string_Malformed=caml_new_string("CCUtf8_string.Malformed"),
     cst_CCUtf8_string_Stop=caml_new_string("CCUtf8_string.Stop"),
     cst$55=caml_new_string(""),
     cst$54=caml_new_string(""),
     cst$53=caml_new_string(", "),
     cst_CCVector_remove=caml_new_string("CCVector.remove"),
     cst_CCVector_set=caml_new_string("CCVector.set"),
     cst_CCVector_get=caml_new_string("CCVector.get"),
     cst_vec_ensure_size_too_big=caml_new_string("vec.ensure: size too big"),
     cst_vec_can_t_grow_any_further=
      caml_new_string("vec: can't grow any further"),
     cst_CCVector_Empty=caml_new_string("CCVector.Empty"),
     CCMonomorphic=global_data.CCMonomorphic,
     Not_found=global_data.Not_found,
     include=global_data.Random,
     Format=global_data.Format,
     Array=global_data.Array,
     Pervasives=global_data.Pervasives,
     Assert_failure=global_data.Assert_failure,
     Invalid_argument=global_data.Invalid_argument,
     List=global_data.List,
     Char=global_data.Char,
     Buffer=global_data.Buffer,
     Hashtbl=global_data.Hashtbl,
     Stack=global_data.Stack,
     include$1=global_data.String,
     Printf=global_data.Printf,
     Lazy=global_data.Lazy,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Filename=global_data.Filename,
     Sys_error=global_data.Sys_error,
     Printexc=global_data.Printexc,
     Bytes=global_data.Bytes,
     End_of_file=global_data.End_of_file,
     Failure=global_data.Failure,
     Int32=global_data.Int32,
     Int64=global_data.Int64,
     Map=global_data.Map,
     Nativeint=global_data.Nativeint,
     Set=global_data.Set,
     Uchar=global_data.Uchar,
     Sys=global_data.Sys,
     make_float=Array[1],
     init=Array[2],
     make_matrix=Array[3],
     create_matrix=Array[4],
     append=Array[5],
     concat=Array[6],
     sub=Array[7],
     copy=Array[8],
     fill=Array[9],
     to_list=Array[11],
     of_list=Array[12],
     mapi=Array[16],
     fold_left=Array[17],
     fold_right=Array[18],
     mem=Array[23],
     memq=Array[24],
     sort=Array[25],
     stable_sort=Array[26],
     fast_sort=Array[27],
     Floatarray=Array[28],
     empty=[0],
     map=Array[15],
     _f_=[0,caml_new_string("src/core/CCArray_slice.ml"),70,8],
     _an_=
      [0,
       [12,
        40,
        [18,
         [1,[0,0,caml_new_string("")]],
         [11,caml_new_string("Ok "),[15,[17,0,[12,41,0]]]]]],
       caml_new_string("(@[Ok %a@])")],
     _ao_=
      [0,
       [12,
        40,
        [18,
         [1,[0,0,caml_new_string("")]],
         [11,caml_new_string("Error "),[15,[17,0,[12,41,0]]]]]],
       caml_new_string("(@[Error %a@])")],
     _am_=[0,[11,caml_new_string("Some "),[15,0]],caml_new_string("Some %a")],
     _al_=
      [0,[12,59,[17,[0,caml_new_string("@,"),0,0],0]],caml_new_string(";@,")],
     _ak_=
      [0,[12,59,[17,[0,caml_new_string("@,"),0,0],0]],caml_new_string(";@,")],
     _aj_=[0,-101336657,0],
     _aa_=[0,[0,15681,-937474657],0],
     _ab_=[0,[0,15681,82908052],[0,737455525,0]],
     _ac_=[0,[0,15681,-588596599],[0,737455525,0]],
     _ad_=[0,[0,15681,4100401],[0,737455525,0]],
     _ae_=[0,[0,15681,-605101559],[0,737455525,0]],
     _af_=[0,[0,15681,756711075],[0,737455525,0]],
     _ag_=[0,[0,15681,749039939],[0,737455525,0]],
     _ah_=[0,[0,15681,737308346],[0,737455525,0]],
     _ai_=[0,[0,15681,-937474657],[0,737455525,0]],
     _T_=[0,[0,15681,82908052],0],
     _U_=[0,[0,15681,-588596599],0],
     _V_=[0,-101336657,0],
     _W_=[0,[0,15681,4100401],0],
     _X_=[0,[0,15681,-605101559],0],
     _Y_=[0,[0,15681,756711075],0],
     _Z_=[0,[0,15681,749039939],0],
     ___=[0,737455525,0],
     _$_=[0,[0,15681,737308346],0],
     _R_=
      [0,
       [11,caml_new_string("\x1b["),[4,0,0,0,[12,59,[4,0,0,0,[12,109,0]]]]],
       caml_new_string("\x1b[%d;%dm")],
     _S_=
      [0,
       [11,caml_new_string("\x1b["),[4,0,0,0,[12,109,0]]],
       caml_new_string("\x1b[%dm")],
     _Q_=[0,[11,caml_new_string("<lazy>"),0],caml_new_string("<lazy>")],
     _P_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _O_=
      [0,
       [15,[15,[15,[15,[15,[15,[15,0]]]]]]],
       caml_new_string("%a%a%a%a%a%a%a")],
     _N_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _M_=[0,[15,[15,[15,[15,[15,0]]]]],caml_new_string("%a%a%a%a%a")],
     _L_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _K_=[0,[15,[15,[15,0]]],caml_new_string("%a%a%a")],
     _J_=[0,[11,caml_new_string("some "),[15,0]],caml_new_string("some %a")],
     _I_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _H_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _G_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _F_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _E_=[0,[12,34,[2,0,[12,34,0]]],caml_new_string('"%s"')],
     _D_=[0,[6,0,0,0,0],caml_new_string("%nd")],
     _C_=[0,[7,0,0,0,0],caml_new_string("%Ld")],
     _B_=[0,[5,0,0,0,0],caml_new_string("%ld")],
     _A_=[0,[8,0,0,[0,3],0],caml_new_string("%.3f")],
     _z_=[0,[14,0,0,0],caml_new_string("%(%)")],
     _a5_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<hov2>"),0],caml_new_string("<hov2>")]],
        [11,caml_new_string("tbl {"),[17,[0,caml_new_string("@,"),0,0],0]]],
       caml_new_string("@[<hov2>tbl {@,")],
     _a6_=[0,[12,125,[17,0,0]],caml_new_string("}@]")],
     _a3_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<hov2>"),0],caml_new_string("<hov2>")]],
        [11,caml_new_string("tbl {"),[17,[0,caml_new_string("@,"),0,0],0]]],
       caml_new_string("@[<hov2>tbl {@,")],
     _a4_=[0,[12,125,[17,0,0]],caml_new_string("}@]")],
     _a8_=
      [0,[2,0,[17,[0,caml_new_string("@,"),0,0],0]],caml_new_string("%s@,")],
     _a7_=[0,0,0],
     _bb_=[0,[0,2,[0,3,[0,7,0]]]],
     _ba_=[0,3,0],
     _a$_=[0,3,[0,4,[0,7,0]]],
     _a__=[0,caml_new_string("src/core/CCIO.ml"),118,8],
     _a9_=[0,7,0],
     _bF_=[0,caml_new_string("src/core/CCList.ml"),1145,12],
     _bE_=[0,caml_new_string("src/core/CCList.ml"),1016,16],
     _bD_=[0,0,0],
     _bA_=[0,0,0],
     _bG_=[0,caml_new_string("src/core/CCMap.ml"),179,25],
     _bY_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [11,caml_new_string("Some "),[15,[17,0,0]]]],
       caml_new_string("@[Some %a@]")],
     _b2_=
      [0,
       [15,[2,0,[17,[0,caml_new_string("@,"),0,0],[15,0]]]],
       caml_new_string("%a%s@,%a")],
     _b3_=
      [0,
       [11,
        caml_new_string("while parsing "),
        [2,0,[11,caml_new_string(", "),0]]],
       caml_new_string("while parsing %s, ")],
     _b4_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [15,
         [11,
          caml_new_string("at line "),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", col "),
            [4,0,0,0,[17,0,[17,[0,caml_new_string("@,"),0,0],[2,0,0]]]]]]]]],
       caml_new_string("@[%aat line %d, col %d@]@,%s")],
     _b5_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [15,
         [11,
          caml_new_string("at line "),
          [4,0,0,0,[11,caml_new_string(", col "),[4,0,0,0,[17,0,0]]]]]]],
       caml_new_string("@[%aat line %d, col %d@]")],
     _cj_=[0,caml_new_string("src/core/CCParse.ml"),431,14],
     _ci_=[0,caml_new_string("src/core/CCParse.ml"),402,18],
     _ch_=
      [0,
       [11,caml_new_string('expected "'),[2,0,[12,34,0]]],
       caml_new_string('expected "%s"')],
     _ce_=
      [0,
       [11,caml_new_string("unexpected char '"),[0,[12,39,0]]],
       caml_new_string("unexpected char '%c'")],
     _cd_=
      [0,
       [11,caml_new_string("expected '"),[0,[12,39,0]]],
       caml_new_string("expected '%c'")],
     _cc_=[0,caml_new_string("src/core/CCParse.ml"),227,49],
     _b8_=[0,caml_new_string("src/core/CCParse.ml"),199,2],
     _b7_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<v>"),0],caml_new_string("<v>")]],
        [2,0,[17,[0,caml_new_string("@ "),1,0],[2,0,[17,0,0]]]]],
       caml_new_string("@[<v>%s@ %s@]")],
     _cO_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [11,
         caml_new_string("ok("),
         [17,[0,caml_new_string("@,"),0,0],[15,[12,41,[17,0,0]]]]]],
       caml_new_string("@[ok(@,%a)@]")],
     _cP_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [11,
         caml_new_string("error("),
         [17,[0,caml_new_string("@,"),0,0],[15,[12,41,[17,0,0]]]]]],
       caml_new_string("@[error(@,%a)@]")],
     _cM_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [11,
         caml_new_string("ok("),
         [17,[0,caml_new_string("@,"),0,0],[15,[12,41,[17,0,0]]]]]],
       caml_new_string("@[ok(@,%a)@]")],
     _cN_=
      [0,
       [18,
        [1,[0,0,caml_new_string("")]],
        [11,
         caml_new_string("error("),
         [17,[0,caml_new_string("@,"),0,0],[2,0,[12,41,[17,0,0]]]]]],
       caml_new_string("@[error(@,%s)@]")],
     _cL_=[1,caml_new_string("of_opt")],
     _cK_=[0,caml_new_string("src/core/CCResult.ml"),225,55],
     _cJ_=[0,caml_new_string("src/core/CCResult.ml"),211,26],
     _cF_=[0,[2,0,[12,10,[2,0,0]]],caml_new_string("%s\n%s")],
     _c2_=[0,[12,34,[2,0,[12,34,0]]],caml_new_string('"%s"')],
     _c1_=[0,[12,34,[2,0,[12,34,0]]],caml_new_string('"%s"')],
     _c0_=[0,caml_new_string("src/core/CCString.ml"),895,6],
     _cZ_=[0,[0,0,1]],
     _cY_=[0,[0,0,1]],
     _cX_=[0,caml_new_string("src/core/CCString.ml"),688,2],
     _cW_=[0,caml_new_string("src/core/CCString.ml"),690,2],
     _cV_=[0,0],
     _cU_=[0,0],
     _cT_=[0,0],
     _cS_=[0,caml_new_string("src/core/CCString.ml"),227,10],
     _cR_=[0,caml_new_string("src/core/CCString.ml"),192,10],
     _cQ_=[0,caml_new_string("src/core/CCString.ml"),163,16],
     _c9_=[0,caml_new_string("src/core/CCUtf8_string.ml"),151,2],
     _c3_=[0,caml_new_string("src/core/CCUtf8_string.ml"),70,4],
     _c4_=[0,16],
     _c5_=[0,32],
     _dd_=[0,caml_new_string("src/core/CCVector.ml"),794,4],
     _de_=[0,caml_new_string("src/core/CCVector.ml"),792,2],
     _da_=[0,caml_new_string("src/core/CCVector.ml"),160,4],
     _c$_=[0,caml_new_string("src/core/CCVector.ml"),76,2],
     _c__=[0,caml_new_string("src/core/CCVector.ml"),77,2];
    function map2(f,a,b)
     {if(caml_call2(CCMonomorphic[2],a.length - 1,b.length - 1))
       caml_call1(Pervasives[1],cst_map2);
      function _z8_(i){return caml_call2(f,a[i + 1],b[i + 1])}
      return caml_call2(Array[2],a.length - 1,_z8_)}
    function length(_z7_){return _z7_.length - 1}
    function get(_z6_,_z5_){return caml_check_bound(_z6_,_z5_)[_z5_ + 1]}
    function get_safe(a,i)
     {if(caml_call2(CCMonomorphic[6],i,0))
       if(caml_call2(CCMonomorphic[3],i,a.length - 1))return [0,a[i + 1]];
      return 0}
    function set(_z4_,_z3_,_z2_)
     {return caml_check_bound(_z4_,_z3_)[_z3_ + 1] = _z2_}
    var fold=Array[17];
    function foldi(f,acc,a)
     {var acc$0=acc,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,a.length - 1))return acc$0;
        var
         i$0=i + 1 | 0,
         acc$1=caml_call3(f,acc$0,i,caml_check_bound(a,i)[i + 1]),
         acc$0=acc$1,
         i=i$0;
        continue}}
    function fold_while(f,acc,a)
     {var acc$0=acc,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i,a.length - 1))
         {var
           match=caml_call2(f,acc$0,caml_check_bound(a,i)[i + 1]),
           cont=match[2],
           acc$1=match[1];
          if(926227490 <= cont)return acc$1;
          var i$0=i + 1 | 0,acc$0=acc$1,i=i$0;
          continue}
        return acc$0}}
    function fold_map(f,acc,a)
     {var n=a.length - 1;
      if(caml_call2(CCMonomorphic[1],n,0))return [0,acc,[0]];
      var
       match=caml_call2(f,acc,caml_check_bound(a,0)[1]),
       b0=match[2],
       acc$0=match[1],
       res=caml_make_vect(n,b0),
       acc$1=[0,acc$0],
       _zZ_=n - 1 | 0,
       _zY_=1;
      if(! (_zZ_ < 1))
       {var i=_zY_;
        for(;;)
         {var
           _z0_=caml_check_bound(a,i)[i + 1],
           match$0=caml_call2(f,acc$1[1],_z0_),
           b=match$0[2],
           new_acc=match$0[1];
          acc$1[1] = new_acc;
          caml_check_bound(res,i)[i + 1] = b;
          var _z1_=i + 1 | 0;
          if(_zZ_ !== i){var i=_z1_;continue}
          break}}
      return [0,acc$1[1],res]}
    function scan_left(f,acc,a)
     {var n=a.length - 1,res=caml_make_vect(n + 1 | 0,acc);
      function _zW_(i,x)
       {var
         new_acc=caml_call2(f,caml_check_bound(res,i)[i + 1],x),
         _zX_=i + 1 | 0;
        return caml_check_bound(res,_zX_)[_zX_ + 1] = new_acc}
      caml_call2(Array[14],_zW_,a);
      return res}
    var iter=Array[13],iteri=Array[14],blit=Array[10];
    function reverse_in_place(a)
     {var len=a.length - 1,_zO_=caml_call2(CCMonomorphic[4],len,0);
      if(_zO_)
       {var _zQ_=(len - 1 | 0) / 2 | 0,_zP_=0;
        if(! (_zQ_ < 0))
         {var k=_zP_;
          for(;;)
           {var
             t=caml_check_bound(a,k)[k + 1],
             _zS_=(len - 1 | 0) - k | 0,
             _zT_=caml_check_bound(a,_zS_)[_zS_ + 1];
            caml_check_bound(a,k)[k + 1] = _zT_;
            var _zU_=(len - 1 | 0) - k | 0;
            caml_check_bound(a,_zU_)[_zU_ + 1] = t;
            var _zV_=k + 1 | 0;
            if(_zQ_ !== k){var k=_zV_;continue}
            break}}
        var _zR_=0}
      else
       var _zR_=_zO_;
      return _zR_}
    function sorted(cmp,a)
     {var b=caml_call1(Array[8],a);caml_call2(Array[25],cmp,b);return b}
    function sort_indices(cmp,a)
     {var len=a.length - 1;
      function _zL_(k){return k}
      var b=caml_call2(Array[2],len,_zL_);
      function _zM_(k1,k2)
       {var _zN_=caml_check_bound(a,k2)[k2 + 1];
        return caml_call2(cmp,caml_check_bound(a,k1)[k1 + 1],_zN_)}
      caml_call2(Array[25],_zM_,b);
      return b}
    function sort_ranking(cmp,a)
     {var _zK_=sort_indices(cmp,a);return sort_indices(CCMonomorphic[7],_zK_)}
    function rev(a){var b=caml_call1(Array[8],a);reverse_in_place(b);return b}
    function find_aux(f,a,i)
     {var i$0=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,a.length - 1))return 0;
        var res=caml_call2(f,i$0,caml_check_bound(a,i$0)[i$0 + 1]);
        if(res)return res;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function find(f,a)
     {var _zJ_=0;return find_aux(function(param){return f},a,_zJ_)}
    function findi(f,a){return find_aux(f,a,0)}
    function find_idx(p,a)
     {var _zI_=0;
      return find_aux
              (function(i,x){return caml_call1(p,x)?[0,[0,i,x]]:0},a,_zI_)}
    function filter_map(f,a)
     {var acc=0,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,a.length - 1))
         {var a$0=caml_call1(Array[12],acc);reverse_in_place(a$0);return a$0}
        var match=caml_call1(f,caml_check_bound(a,i)[i + 1]);
        if(match)
         {var x=match[1],i$0=i + 1 | 0,acc$0=[0,x,acc],acc=acc$0,i=i$0;
          continue}
        var i$1=i + 1 | 0,i=i$1;
        continue}}
    function filter(p,a)
     {return filter_map(function(x){return caml_call1(p,x)?[0,x]:0},a)}
    function flat_map(f,a)
     {var acc$1=0,i$1=0;
      a:
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$1,a.length - 1))
         {var a$0=caml_call1(Array[12],acc$1);
          reverse_in_place(a$0);
          return a$0}
        var
         a$1=caml_call1(f,caml_check_bound(a,i$1)[i$1 + 1]),
         i$2=i$1 + 1 | 0,
         acc=acc$1,
         i=0;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i,a$1.length - 1))
           {var acc$1=acc,i$1=i$2;continue a}
          var
           i$0=i + 1 | 0,
           acc$0=[0,caml_check_bound(a$1,i)[i + 1],acc],
           acc=acc$0,
           i=i$0;
          continue}}}
    function lookup_exn(cmp,k,a,i$1,j$1)
     {if(caml_call2(CCMonomorphic[4],i$1,j$1))throw Not_found;
      var n$0=caml_call2(cmp,k,caml_check_bound(a,i$1)[i$1 + 1]);
      if(0 === n$0)return i$1;
      if(caml_call2(CCMonomorphic[3],n$0,0))throw Not_found;
      if(caml_call2(CCMonomorphic[1],i$1,j$1))throw Not_found;
      var n$1=caml_call2(cmp,k,caml_check_bound(a,j$1)[j$1 + 1]);
      if(0 === n$1)return j$1;
      if(caml_call2(CCMonomorphic[3],n$1,0))
       {var j$2=j$1 - 1 | 0,i$2=i$1 + 1 | 0,i=i$2,j=j$2;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],i,j))throw Not_found;
          if(caml_call2(CCMonomorphic[1],i,j))
           {var _zH_=caml_call2(cmp,k,caml_check_bound(a,i)[i + 1]);
            if(caml_call2(CCMonomorphic[1],_zH_,0))return i;
            throw Not_found}
          var
           middle=(j + i | 0) / 2 | 0,
           n=caml_call2(cmp,k,caml_check_bound(a,middle)[middle + 1]);
          if(0 === n)return middle;
          if(caml_call2(CCMonomorphic[3],n,0))
           {var j$0=middle - 1 | 0,j=j$0;continue}
          var i$0=middle + 1 | 0,i=i$0;
          continue}}
      throw Not_found}
    function lookup_exn$0(cmp,k,a)
     {return lookup_exn(cmp,k,a,0,a.length - 1 - 1 | 0)}
    function lookup(cmp,k,a)
     {try
       {var _zF_=[0,lookup_exn(cmp,k,a,0,a.length - 1 - 1 | 0)];return _zF_}
      catch(_zG_)
       {_zG_ = caml_wrap_exception(_zG_);
        if(_zG_ === Not_found)return 0;
        throw _zG_}}
    function bsearch(cmp,k,a)
     {var n$0=a.length - 1;
      if(caml_call2(CCMonomorphic[1],n$0,0))return 50834029;
      var
       c=caml_call2(cmp,caml_check_bound(a,0)[1],k),
       _zE_=n$0 - 1 | 0,
       c$0=caml_call2(cmp,caml_check_bound(a,_zE_)[_zE_ + 1],k);
      if(caml_call2(CCMonomorphic[4],c,0))return -923815278;
      if(caml_call2(CCMonomorphic[3],c$0,0))return 814295299;
      var j$1=n$0 - 1 | 0,i=0,j=j$1;
      for(;;)
       {if(caml_call2(CCMonomorphic[4],i,j))return [0,550003881,j];
        var
         middle=i + ((j - i | 0) / 2 | 0) | 0,
         n=caml_call2(cmp,k,caml_check_bound(a,middle)[middle + 1]);
        if(0 === n)return [0,14611,middle];
        if(caml_call2(CCMonomorphic[3],n,0))
         {var j$0=middle - 1 | 0,j=j$0;continue}
        var i$0=middle + 1 | 0,i=i$0;
        continue}}
    function _a_(a,f){return flat_map(f,a)}
    function _b_(a,f){return caml_call2(map,f,a)}
    function _c_(a,f){return caml_call2(map,f,a)}
    function for_all(p,a)
     {var i=0;
      for(;;)
       {var _zB_=caml_call2(CCMonomorphic[1],i,a.length - 1);
        if(_zB_)
         var _zC_=_zB_;
        else
         {var _zD_=caml_call1(p,caml_check_bound(a,i)[i + 1]);
          if(_zD_){var i$0=i + 1 | 0,i=i$0;continue}
          var _zC_=_zD_}
        return _zC_}}
    function exists(p,a)
     {var i=0;
      for(;;)
       {var _zy_=caml_call2(CCMonomorphic[2],i,a.length - 1);
        if(_zy_)
         {var _zz_=caml_call1(p,caml_check_bound(a,i)[i + 1]);
          if(! _zz_){var i$0=i + 1 | 0,i=i$0;continue}
          var _zA_=_zz_}
        else
         var _zA_=_zy_;
        return _zA_}}
    function for_all2(p,a,b)
     {var _zx_=caml_call2(CCMonomorphic[1],a.length - 1,b.length - 1);
      if(_zx_)
       {var len$1=a.length - 1,i1=0,i2=0,len=len$1;
        for(;;)
         {var _zt_=caml_call2(CCMonomorphic[1],len,0);
          if(_zt_)
           var _zu_=_zt_;
          else
           {var
             _zv_=caml_check_bound(b,i2)[i2 + 1],
             _zw_=caml_call2(p,caml_check_bound(a,i1)[i1 + 1],_zv_);
            if(_zw_)
             {var
               len$0=len - 1 | 0,
               i2$0=i2 + 1 | 0,
               i1$0=i1 + 1 | 0,
               i1=i1$0,
               i2=i2$0,
               len=len$0;
              continue}
            var _zu_=_zw_}
          return _zu_}}
      return _zx_}
    function exists2(p,a,b)
     {var
       len$1=caml_call2(CCMonomorphic[8],a.length - 1,b.length - 1),
       i1=0,
       i2=0,
       len=len$1;
      for(;;)
       {var _zp_=caml_call2(CCMonomorphic[4],len,0);
        if(_zp_)
         {var
           _zq_=caml_check_bound(b,i2)[i2 + 1],
           _zr_=caml_call2(p,caml_check_bound(a,i1)[i1 + 1],_zq_);
          if(! _zr_)
           {var
             len$0=len - 1 | 0,
             i2$0=i2 + 1 | 0,
             i1$0=i1 + 1 | 0,
             i1=i1$0,
             i2=i2$0,
             len=len$0;
            continue}
          var _zs_=_zr_}
        else
         var _zs_=_zp_;
        return _zs_}}
    function iter2(f,a,b)
     {if(caml_call2(CCMonomorphic[2],a.length - 1,b.length - 1))
       caml_call1(Pervasives[1],cst_iter2);
      var len=a.length - 1,_zk_=len - 1 | 0,_zj_=0;
      if(! (_zk_ < 0))
       {var o=_zj_;
        for(;;)
         {var _zl_=o | 0,_zn_=o | 0,_zm_=caml_check_bound(b,_zl_)[_zl_ + 1];
          caml_call2(f,caml_check_bound(a,_zn_)[_zn_ + 1],_zm_);
          var _zo_=o + 1 | 0;
          if(_zk_ !== o){var o=_zo_;continue}
          break}}
      return 0}
    function fold2(f,acc$1,a,b)
     {if(caml_call2(CCMonomorphic[2],a.length - 1,b.length - 1))
       caml_call1(Pervasives[1],cst_fold2);
      var len=a.length - 1,acc=acc$1,o=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],o,len))return acc;
        var
         _zg_=o | 0,
         _zi_=o | 0,
         _zh_=caml_check_bound(b,_zg_)[_zg_ + 1],
         acc$0=caml_call3(f,acc,caml_check_bound(a,_zi_)[_zi_ + 1],_zh_),
         o$0=o + 1 | 0,
         acc=acc$0,
         o=o$0;
        continue}}
    function _d_(i,j)
     {if(caml_call2(CCMonomorphic[5],i,j))
       {var _ze_=function(k){return i + k | 0};
        return caml_call2(Array[2],(j - i | 0) + 1 | 0,_ze_)}
      function _zf_(k){return i - k | 0}
      return caml_call2(Array[2],(i - j | 0) + 1 | 0,_zf_)}
    function _e_(i,j)
     {if(caml_call2(CCMonomorphic[1],i,j))return [0];
      if(caml_call2(CCMonomorphic[4],i,j))
       {var _zc_=function(k){return i - k | 0};
        return caml_call2(Array[2],i - j | 0,_zc_)}
      function _zd_(k){return i + k | 0}
      return caml_call2(Array[2],j - i | 0,_zd_)}
    function except_idx(a,i)
     {var _zb_=0;
      return foldi
              (function(acc,j,elt)
                {return caml_call2(CCMonomorphic[1],i,j)?acc:[0,elt,acc]},
               _zb_,
               a)}
    function equal(eq,a,b)
     {var _za_=caml_call2(CCMonomorphic[1],a.length - 1,b.length - 1);
      if(_za_)
       {var i=0;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i,a.length - 1))return 1;
          var
           _y__=caml_check_bound(b,i)[i + 1],
           _y$_=caml_call2(eq,caml_check_bound(a,i)[i + 1],_y__);
          if(_y$_){var i$0=i + 1 | 0,i=i$0;continue}
          return _y$_}}
      return _za_}
    function compare(cmp,a,b)
     {var i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,a.length - 1))
         return caml_call2(CCMonomorphic[1],i,b.length - 1)?0:-1;
        if(caml_call2(CCMonomorphic[1],i,b.length - 1))return 1;
        var
         _y9_=caml_check_bound(b,i)[i + 1],
         c=caml_call2(cmp,caml_check_bound(a,i)[i + 1],_y9_);
        if(caml_call2(CCMonomorphic[1],c,0)){var i$0=i + 1 | 0,i=i$0;continue}
        return c}}
    function swap(a,i,j)
     {var _y6_=caml_call2(CCMonomorphic[2],i,j);
      if(_y6_)
       {var
         tmp=caml_check_bound(a,i)[i + 1],
         _y7_=caml_check_bound(a,j)[j + 1];
        caml_check_bound(a,i)[i + 1] = _y7_;
        var _y8_=caml_check_bound(a,j)[j + 1] = tmp}
      else
       var _y8_=_y6_;
      return _y8_}
    function shuffle(rand_int,a,i,j)
     {var _y2_=j - 1 | 0,_y3_=i + 1 | 0;
      if(! (_y2_ < _y3_))
       {var k=_y2_;
        for(;;)
         {var
           l=caml_call1(rand_int,k + 1 | 0),
           tmp=caml_check_bound(a,l)[l + 1],
           _y4_=caml_check_bound(a,k)[k + 1];
          caml_check_bound(a,l)[l + 1] = _y4_;
          caml_check_bound(a,k)[k + 1] = tmp;
          var _y5_=k - 1 | 0;
          if(_y3_ !== k){var k=_y5_;continue}
          break}}
      return 0}
    function shuffle$0(a){return shuffle(include[5],a,0,a.length - 1)}
    function shuffle_with(st,a)
     {return shuffle(caml_call1(include[11][5],st),a,0,a.length - 1)}
    function to_klist(a,i,j,param)
     {if(caml_call2(CCMonomorphic[1],i,j))return 3902385;
      var _yZ_=i + 1 | 0;
      function _y0_(_y1_){return to_klist(a,_yZ_,j,_y1_)}
      return [0,748545553,[0,caml_check_bound(a,i)[i + 1],_y0_]]}
    function random_choose(a,st)
     {var n=a.length - 1;
      if(caml_call2(CCMonomorphic[1],n,0))throw Not_found;
      var _yY_=caml_call2(include[11][5],st,n);
      return caml_check_bound(a,_yY_)[_yY_ + 1]}
    function random_len(n,g,st)
     {function _yX_(param){return caml_call1(g,st)}
      return caml_call2(Array[2],n,_yX_)}
    function random(g,st)
     {var n=caml_call2(include[11][5],st,1e3);return random_len(n,g,st)}
    function random_non_empty(g,st)
     {var n=1 + caml_call2(include[11][5],st,1e3) | 0;
      return random_len(n,g,st)}
    function pp(opt,pp_item,out,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst;
      var _yV_=a.length - 1 - 1 | 0,_yU_=0;
      if(! (_yV_ < 0))
       {var k=_yU_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],k,0))
           {caml_call2(Format[13],out,sep);caml_call2(Format[27],out,0)}
          caml_call2(pp_item,out,caml_check_bound(a,k)[k + 1]);
          var _yW_=k + 1 | 0;
          if(_yV_ !== k){var k=_yW_;continue}
          break}}
      return 0}
    function pp_i(opt,pp_item,out,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$0;
      var _yS_=a.length - 1 - 1 | 0,_yR_=0;
      if(! (_yS_ < 0))
       {var k=_yR_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],k,0))
           {caml_call2(Format[13],out,sep);caml_call2(Format[27],out,0)}
          caml_call3(pp_item,k,out,caml_check_bound(a,k)[k + 1]);
          var _yT_=k + 1 | 0;
          if(_yS_ !== k){var k=_yT_;continue}
          break}}
      return 0}
    function to_seq(a,k){return caml_call2(iter,k,a)}
    function to_gen(a)
     {var k=[0,0];
      return function(param)
       {if(caml_call2(CCMonomorphic[3],k[1],a.length - 1))
         {var _yQ_=k[1],x=caml_check_bound(a,_yQ_)[_yQ_ + 1];
          k[1]++;
          return [0,x]}
        return 0}}
    function to_klist$0(a)
     {var _yN_=a.length - 1,_yO_=0;
      return function(_yP_){return to_klist(a,_yO_,_yN_,_yP_)}}
    function sort_generic(A,cmp,a)
     {var seed=[0,123456];
      function rand_idx(rand,i,j)
       {return i + caml_call2(include[11][5],rand,j - i | 0) | 0}
      function swap(a,i,j)
       {if(caml_call2(CCMonomorphic[1],i,j))return 0;
        var tmp=caml_call2(A[2],a,i),_yM_=caml_call2(A[2],a,j);
        caml_call3(A[3],a,i,_yM_);
        return caml_call3(A[3],a,j,tmp)}
      var rand=caml_call1(include[11][1],seed);
      function sort_slice(st,a,i,j)
       {var i$0=i;
        a:
        for(;;)
         {if(caml_call2(CCMonomorphic[4],j - i$0 | 0,10))
           {st[1] = i$0;
            st[2] = j - 1 | 0;
            st[3] = i$0;
            var
             _yC_=rand_idx(rand,i$0,j),
             p=caml_call2(A[2],a,_yC_),
             _yD_=rand_idx(rand,i$0,j),
             q=caml_call2(A[2],a,_yD_),
             _yE_=caml_call2(cmp,p,q);
            if(caml_call2(CCMonomorphic[4],_yE_,0))
             var p$0=q,q$0=p;
            else
             var p$0=p,q$0=q;
            for(;;)
             {if(caml_call2(CCMonomorphic[5],st[3],st[2]))
               {var cur=caml_call2(A[2],a,st[3]),_yF_=caml_call2(cmp,cur,p$0);
                if(caml_call2(CCMonomorphic[3],_yF_,0))
                 {if(caml_call2(CCMonomorphic[2],st[3],st[1]))
                   swap(a,st[3],st[1]);
                  st[1] = st[1] + 1 | 0}
                else
                 {var _yG_=caml_call2(cmp,cur,q$0);
                  if(caml_call2(CCMonomorphic[4],_yG_,0))
                   for(;;)
                    {if(caml_call2(CCMonomorphic[3],st[3],st[2]))
                      {var _yH_=caml_call2(cmp,caml_call2(A[2],a,st[2]),q$0);
                       if(caml_call2(CCMonomorphic[4],_yH_,0))
                        {st[2] = st[2] - 1 | 0;continue}}
                     swap(a,st[3],st[2]);
                     st[2] = st[2] - 1 | 0;
                     var _yI_=caml_call2(cmp,caml_call2(A[2],a,st[3]),p$0);
                     if(caml_call2(CCMonomorphic[3],_yI_,0))
                      {if(caml_call2(CCMonomorphic[2],st[3],st[1]))
                        swap(a,st[3],st[1]);
                       st[1] = st[1] + 1 | 0}
                     break}}
                st[3] = st[3] + 1 | 0;
                continue}
              var
               _yJ_=st[1],
               _yK_=st[2],
               _yL_=caml_call2(cmp,p$0,q$0),
               sort_middle=caml_call2(CCMonomorphic[3],_yL_,0);
              sort_slice(st,a,i$0,_yJ_);
              if(sort_middle)sort_slice(st,a,_yJ_,_yK_ + 1 | 0);
              var i$1=_yK_ + 1 | 0,i$0=i$1;
              continue a}}
          var _yB_=caml_call2(CCMonomorphic[4],j - i$0 | 0,1);
          if(_yB_)
           {var k$4=i$0 + 1 | 0,k$1=k$4;
            b:
            for(;;)
             {var _yA_=caml_call2(CCMonomorphic[3],k$1,j);
              if(_yA_)
               {var k$2=k$1 - 1 | 0,k=k$2;
                for(;;)
                 {if(! caml_call2(CCMonomorphic[3],k,i$0))
                   {var
                     _yy_=caml_call2(A[2],a,k + 1 | 0),
                     _yz_=caml_call2(cmp,caml_call2(A[2],a,k),_yy_);
                    if(caml_call2(CCMonomorphic[4],_yz_,0))
                     {swap(a,k,k + 1 | 0);var k$0=k - 1 | 0,k=k$0;continue}}
                  var k$3=k$1 + 1 | 0,k$1=k$3;
                  continue b}}
              return _yA_}}
          return _yB_}}
      var _yw_=caml_call1(A[1],a),_yx_=caml_call2(CCMonomorphic[4],_yw_,0);
      if(_yx_)
       {var st=[0,0,caml_call1(A[1],a),0];
        return sort_slice(st,a,0,caml_call1(A[1],a))}
      return _yx_}
    var
     include$0=
      [0,
       make_float,
       init,
       make_matrix,
       create_matrix,
       append,
       concat,
       sub,
       copy,
       fill,
       to_list,
       of_list,
       mapi,
       fold_left,
       fold_right,
       mem,
       memq,
       sort,
       stable_sort,
       fast_sort,
       Floatarray,
       empty,
       equal,
       compare,
       swap,
       get,
       get_safe,
       set,
       length,
       fold,
       foldi,
       fold_while,
       fold_map,
       scan_left,
       iter,
       iteri,
       blit,
       reverse_in_place,
       sorted,
       sort_indices,
       sort_ranking,
       find,
       find,
       findi,
       findi,
       find_idx,
       lookup,
       lookup_exn$0,
       bsearch,
       for_all,
       for_all2,
       exists,
       exists2,
       fold2,
       iter2,
       shuffle$0,
       shuffle_with,
       random_choose,
       to_seq,
       to_gen,
       to_klist$0,
       pp,
       pp_i,
       map,
       map2,
       rev,
       filter,
       filter_map,
       flat_map,
       _a_,
       _b_,
       _c_,
       except_idx,
       _d_,
       _e_,
       random,
       random_non_empty,
       random_len,
       sort_generic];
    caml_register_global(276,include$0,"CCArray");
    var
     CCArrayLabels=
      [0,
       init,
       make_matrix,
       create_matrix,
       append,
       concat,
       sub,
       copy,
       fill,
       to_list,
       of_list,
       mapi,
       fold_left,
       fold_right,
       mem,
       memq,
       make_float,
       sort,
       stable_sort,
       fast_sort,
       Floatarray,
       empty,
       equal,
       compare,
       swap,
       get,
       get_safe,
       set,
       length,
       fold,
       foldi,
       fold_while,
       fold_map,
       scan_left,
       iter,
       iteri,
       blit,
       reverse_in_place,
       sorted,
       sort_indices,
       sort_ranking,
       find,
       find,
       findi,
       findi,
       find_idx,
       lookup,
       lookup_exn$0,
       bsearch,
       for_all,
       for_all2,
       exists,
       exists2,
       fold2,
       iter2,
       shuffle$0,
       shuffle_with,
       random_choose,
       to_seq,
       to_gen,
       to_klist$0,
       pp,
       pp_i,
       map,
       map2,
       rev,
       filter,
       filter_map,
       flat_map,
       _a_,
       _b_,
       _c_,
       except_idx,
       _d_,
       _e_,
       random,
       random_non_empty,
       random_len,
       sort_generic];
    caml_register_global(277,CCArrayLabels,"CCArrayLabels");
    var empty$0=[0,[0],0,0];
    function make(arr,i,len)
     {var
       _yu_=caml_call2(CCMonomorphic[3],i,0),
       _yv_=_yu_ || caml_call2(CCMonomorphic[4],i + len | 0,arr.length - 1);
      if(_yv_)caml_call1(Pervasives[1],cst_CCArray_slice_make);
      return [0,arr,i,i + len | 0]}
    function of_slice(param)
     {var len=param[3],i=param[2],arr=param[1];return make(arr,i,len)}
    function to_slice(a){return [0,a[1],a[2],a[3] - a[2] | 0]}
    function full(arr){return [0,arr,0,arr.length - 1]}
    function underlying(a){return a[1]}
    function length$0(a){return a[3] - a[2] | 0}
    function copy$0(a)
     {var _yt_=length$0(a);return caml_call3(Array[7],a[1],a[2],_yt_)}
    function sub$0(a,i,len){return make(a[1],a[2] + i | 0,len)}
    function equal$0(eq,a,b)
     {var
       _ym_=length$0(b),
       _yn_=length$0(a),
       _yo_=caml_call2(CCMonomorphic[1],_yn_,_ym_);
      if(_yo_)
       {var _yr_=a[3],i1=a[2],i2=b[2],_yp_=b[3],_yq_=b[1],_ys_=a[1];
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i1,_yr_))
           {if(caml_call2(CCMonomorphic[1],i1,_yr_))
             if(caml_call2(CCMonomorphic[1],i2,_yp_))return 1;
            throw [0,Assert_failure,_f_]}
          var
           _yk_=caml_check_bound(_yq_,i2)[i2 + 1],
           _yl_=caml_call2(eq,caml_check_bound(_ys_,i1)[i1 + 1],_yk_);
          if(_yl_)
           {var i2$0=i2 + 1 | 0,i1$0=i1 + 1 | 0,i1=i1$0,i2=i2$0;continue}
          return _yl_}}
      return _yo_}
    var cmp=caml_int_compare;
    function compare$0(cmp,a,b)
     {var _yg_=b[3],i1=a[2],i2=b[2],_yh_=b[1],_yi_=a[3],_yj_=a[1];
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i1,_yi_))
         return caml_call2(CCMonomorphic[1],i2,_yg_)?0:-1;
        if(caml_call2(CCMonomorphic[1],i2,_yg_))return 1;
        var
         _yf_=caml_check_bound(_yh_,i2)[i2 + 1],
         c=caml_call2(cmp,caml_check_bound(_yj_,i1)[i1 + 1],_yf_);
        if(caml_call2(CCMonomorphic[1],c,0))
         {var i2$0=i2 + 1 | 0,i1$0=i1 + 1 | 0,i1=i1$0,i2=i2$0;continue}
        return c}}
    function fold$0(f,acc,a)
     {var acc$0=acc,i=a[2],_ye_=a[3];
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,_ye_))return acc$0;
        var
         i$0=i + 1 | 0,
         acc$1=caml_call2(f,acc$0,caml_check_bound(a[1],i)[i + 1]),
         acc$0=acc$1,
         i=i$0;
        continue}}
    function to_list$0(a)
     {var _yd_=0,l=fold$0(function(l,x){return [0,x,l]},_yd_,a);
      return caml_call1(List[9],l)}
    function foldi$0(f,acc$1,a)
     {var acc=acc$1,i=a[2],_yb_=a[3],_yc_=a[1];
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,_yb_))return acc;
        var
         i$0=i + 1 | 0,
         acc$0=caml_call3(f,acc,i,caml_check_bound(_yc_,i)[i + 1]),
         acc=acc$0,
         i=i$0;
        continue}}
    function fold_while$0(f,acc,a)
     {var acc$0=acc,i=a[2];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i,a[1].length - 1))
         if(caml_call2(CCMonomorphic[3],i,a[3]))
          {var
            match=caml_call2(f,acc$0,caml_check_bound(a[1],i)[i + 1]),
            cont=match[2],
            acc$1=match[1];
           if(926227490 <= cont)return acc$1;
           var i$0=i + 1 | 0,acc$0=acc$1,i=i$0;
           continue}
        return acc$0}}
    function get$0(a,i)
     {var
       j=a[2] + i | 0,
       _x$_=caml_call2(CCMonomorphic[3],i,0),
       _ya_=_x$_ || caml_call2(CCMonomorphic[6],j,a[3]);
      if(_ya_)caml_call1(Pervasives[1],cst_CCArray_slice_get);
      return caml_check_bound(a[1],j)[j + 1]}
    function get_safe$0(a,i)
     {try
       {var _x9_=[0,get$0(a,i)];return _x9_}
      catch(_x__)
       {_x__ = caml_wrap_exception(_x__);
        if(_x__[1] === Invalid_argument)return 0;
        throw _x__}}
    function set$0(a,i,x)
     {var
       j=a[2] + i | 0,
       _x7_=caml_call2(CCMonomorphic[3],i,0),
       _x8_=_x7_ || caml_call2(CCMonomorphic[6],j,a[3]);
      if(_x8_)caml_call1(Pervasives[1],cst_CCArray_slice_set);
      return caml_check_bound(a[1],j)[j + 1] = x}
    function iter$0(f,a)
     {var _x4_=a[2],_x5_=a[3] - 1 | 0;
      if(! (_x5_ < _x4_))
       {var k=_x4_;
        for(;;)
         {caml_call1(f,caml_check_bound(a[1],k)[k + 1]);
          var _x6_=k + 1 | 0;
          if(_x5_ !== k){var k=_x6_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _x1_=length$0(a) - 1 | 0,_x0_=0;
      if(! (_x1_ < 0))
       {var k=_x0_;
        for(;;)
         {var _x2_=a[2] + k | 0;
          caml_call2(f,k,caml_check_bound(a[1],_x2_)[_x2_ + 1]);
          var _x3_=k + 1 | 0;
          if(_x1_ !== k){var k=_x3_;continue}
          break}}
      return 0}
    function blit$0(a,i,b,j,len)
     {var _xW_=length$0(a),_xX_=caml_call2(CCMonomorphic[4],i + len | 0,_xW_);
      if(_xX_)
       var _xY_=_xX_;
      else
       var
        _xZ_=length$0(b),
        _xY_=caml_call2(CCMonomorphic[4],j + len | 0,_xZ_);
      if(_xY_)caml_call1(Pervasives[1],cst_CCArray_slice_blit);
      return caml_call5(Array[10],a[1],a[2] + i | 0,b[1],b[2] + j | 0,len)}
    function find$0(f,a,i,j)
     {var i$0=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,j))return 0;
        var res=caml_call2(f,i$0,caml_check_bound(a,i$0)[i$0 + 1]);
        if(res)return res;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function lookup_exn$1(cmp,k,a,i$1,j$1)
     {if(caml_call2(CCMonomorphic[4],i$1,j$1))throw Not_found;
      var n$0=caml_call2(cmp,k,caml_check_bound(a,i$1)[i$1 + 1]);
      if(0 === n$0)return i$1;
      if(caml_call2(CCMonomorphic[3],n$0,0))throw Not_found;
      if(caml_call2(CCMonomorphic[1],i$1,j$1))throw Not_found;
      var n$1=caml_call2(cmp,k,caml_check_bound(a,j$1)[j$1 + 1]);
      if(0 === n$1)return j$1;
      if(caml_call2(CCMonomorphic[3],n$1,0))
       {var j$2=j$1 - 1 | 0,i$2=i$1 + 1 | 0,i=i$2,j=j$2;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],i,j))throw Not_found;
          if(caml_call2(CCMonomorphic[1],i,j))
           {var _xV_=caml_call2(cmp,k,caml_check_bound(a,i)[i + 1]);
            if(caml_call2(CCMonomorphic[1],_xV_,0))return i;
            throw Not_found}
          var
           middle=(j + i | 0) / 2 | 0,
           n=caml_call2(cmp,k,caml_check_bound(a,middle)[middle + 1]);
          if(0 === n)return middle;
          if(caml_call2(CCMonomorphic[3],n,0))
           {var j$0=middle - 1 | 0,j=j$0;continue}
          var i$0=middle + 1 | 0,i=i$0;
          continue}}
      throw Not_found}
    function shuffle$1(rand_int,a,i,j)
     {var _xR_=j - 1 | 0,_xS_=i + 1 | 0;
      if(! (_xR_ < _xS_))
       {var k=_xR_;
        for(;;)
         {var
           l=caml_call1(rand_int,k + 1 | 0),
           tmp=caml_check_bound(a,l)[l + 1],
           _xT_=caml_check_bound(a,k)[k + 1];
          caml_check_bound(a,l)[l + 1] = _xT_;
          caml_check_bound(a,k)[k + 1] = tmp;
          var _xU_=k - 1 | 0;
          if(_xS_ !== k){var k=_xU_;continue}
          break}}
      return 0}
    function sort_indices$0(cmp,a,i,j)
     {var len=j - i | 0;
      function _xM_(k){return k}
      var b=caml_call2(Array[2],len,_xM_);
      function _xN_(k1,k2)
       {var
         _xO_=k2 + i | 0,
         _xQ_=k1 + i | 0,
         _xP_=caml_check_bound(a,_xO_)[_xO_ + 1];
        return caml_call2(cmp,caml_check_bound(a,_xQ_)[_xQ_ + 1],_xP_)}
      caml_call2(Array[25],_xN_,b);
      return b}
    function to_klist$1(a,i,j,param)
     {if(caml_call2(CCMonomorphic[1],i,j))return 3902385;
      var _xJ_=i + 1 | 0;
      function _xK_(_xL_){return to_klist$1(a,_xJ_,j,_xL_)}
      return [0,748545553,[0,caml_check_bound(a,i)[i + 1],_xK_]]}
    function reverse_in_place$0(a)
     {var len=length$0(a),_xH_=a[2],_xI_=a[1];
      if(caml_call2(CCMonomorphic[1],len,0))return 0;
      var _xA_=(len - 1 | 0) / 2 | 0,_xz_=0;
      if(! (_xA_ < 0))
       {var k=_xz_;
        for(;;)
         {var
           _xB_=_xH_ + k | 0,
           t=caml_check_bound(_xI_,_xB_)[_xB_ + 1],
           _xC_=((_xH_ + len | 0) - 1 | 0) - k | 0,
           _xE_=_xH_ + k | 0,
           _xD_=caml_check_bound(_xI_,_xC_)[_xC_ + 1];
          caml_check_bound(_xI_,_xE_)[_xE_ + 1] = _xD_;
          var _xF_=((_xH_ + len | 0) - 1 | 0) - k | 0;
          caml_check_bound(_xI_,_xF_)[_xF_ + 1] = t;
          var _xG_=k + 1 | 0;
          if(_xA_ !== k){var k=_xG_;continue}
          break}}
      return 0}
    function sorted$0(cmp,a)
     {var _xy_=a[2],len=a[3] - _xy_ | 0,b=caml_call3(Array[7],a[1],_xy_,len);
      caml_call2(Array[25],cmp,b);
      return b}
    function sort_ranking$0(cmp$0,a)
     {var a$0=sort_indices$0(cmp$0,a[1],a[2],a[3]);
      return sort_indices$0(cmp,a$0,0,a$0.length - 1)}
    function sort_indices$1(cmp,a){return sort_indices$0(cmp,a[1],a[2],a[3])}
    function find$1(f,a)
     {var _xv_=a[3],_xw_=a[2],_xx_=a[1];
      return find$0(function(param){return f},_xx_,_xw_,_xv_)}
    function findi$0(f,a)
     {var _xs_=a[3],_xt_=a[2],_xu_=a[1];
      return find$0
              (function(i){return caml_call1(f,i - a[2] | 0)},_xu_,_xt_,_xs_)}
    function find_idx$0(p,a)
     {var _xp_=a[3],_xq_=a[2],_xr_=a[1];
      return find$0
              (function(i,x){return caml_call1(p,x)?[0,[0,i - a[2] | 0,x]]:0},
               _xr_,
               _xq_,
               _xp_)}
    function lookup_exn$2(cmp,k,a)
     {var _xo_=a[2];
      return lookup_exn$1(cmp,k,a[1],a[2],a[3] - 1 | 0) - _xo_ | 0}
    function lookup$0(cmp,k,a)
     {try
       {var
         _xl_=a[2],
         _xm_=[0,lookup_exn$1(cmp,k,a[1],a[2],a[3] - 1 | 0) - _xl_ | 0];
        return _xm_}
      catch(_xn_)
       {_xn_ = caml_wrap_exception(_xn_);
        if(_xn_ === Not_found)return 0;
        throw _xn_}}
    function bsearch$0(cmp,k,a)
     {var j$1=a[3] - 1 | 0,_xi_=a[2],_xj_=a[1];
      if(caml_call2(CCMonomorphic[6],_xi_,j$1))
       var res=50834029;
      else
       {var
         n$0=caml_call2(cmp,caml_check_bound(_xj_,_xi_)[_xi_ + 1],k),
         n$1=caml_call2(cmp,caml_check_bound(_xj_,j$1)[j$1 + 1],k);
        if(caml_call2(CCMonomorphic[4],n$0,0))
         var res=-923815278;
        else
         if(caml_call2(CCMonomorphic[3],n$1,0))
          var res=814295299;
         else
          {var i=_xi_,j=j$1;
           for(;;)
            {if(caml_call2(CCMonomorphic[4],i,j))
              var res=[0,550003881,j];
             else
              {var
                middle=i + ((j - i | 0) / 2 | 0) | 0,
                n=caml_call2(cmp,k,caml_check_bound(_xj_,middle)[middle + 1]);
               if(0 !== n)
                {if(caml_call2(CCMonomorphic[3],n,0))
                  {var j$0=middle - 1 | 0,j=j$0;continue}
                 var i$0=middle + 1 | 0,i=i$0;
                 continue}
               var res=[0,14611,middle]}
             break}}}
      if(typeof res !== "number")
       {var _xk_=res[1];
        if(14611 === _xk_){var m=res[2];return [0,14611,m - a[2] | 0]}
        if(550003881 === _xk_)
         {var m$0=res[2];return [0,550003881,m$0 - a[2] | 0]}}
      return res}
    function for_all$0(p,a)
     {var i=a[2],_xg_=a[3],_xh_=a[1];
      for(;;)
       {var _xd_=caml_call2(CCMonomorphic[1],i,_xg_);
        if(_xd_)
         var _xe_=_xd_;
        else
         {var _xf_=caml_call1(p,caml_check_bound(_xh_,i)[i + 1]);
          if(_xf_){var i$0=i + 1 | 0,i=i$0;continue}
          var _xe_=_xf_}
        return _xe_}}
    function exists$0(p,a)
     {var i=a[2],_xb_=a[3],_xc_=a[1];
      for(;;)
       {var _w__=caml_call2(CCMonomorphic[2],i,_xb_);
        if(_w__)
         {var _w$_=caml_call1(p,caml_check_bound(_xc_,i)[i + 1]);
          if(! _w$_){var i$0=i + 1 | 0,i=i$0;continue}
          var _xa_=_w$_}
        else
         var _xa_=_w__;
        return _xa_}}
    function for_all2$0(p,a,b)
     {var
       _w5_=length$0(b),
       _w6_=length$0(a),
       _w7_=caml_call2(CCMonomorphic[1],_w6_,_w5_);
      if(_w7_)
       {var len$1=length$0(a),i1=a[2],i2=b[2],len=len$1,_w8_=b[1],_w9_=a[1];
        for(;;)
         {var _w1_=caml_call2(CCMonomorphic[1],len,0);
          if(_w1_)
           var _w2_=_w1_;
          else
           {var
             _w3_=caml_check_bound(_w8_,i2)[i2 + 1],
             _w4_=caml_call2(p,caml_check_bound(_w9_,i1)[i1 + 1],_w3_);
            if(_w4_)
             {var
               len$0=len - 1 | 0,
               i2$0=i2 + 1 | 0,
               i1$0=i1 + 1 | 0,
               i1=i1$0,
               i2=i2$0,
               len=len$0;
              continue}
            var _w2_=_w4_}
          return _w2_}}
      return _w7_}
    function exists2$0(p,a,b)
     {var
       _wX_=length$0(b),
       _wY_=length$0(a),
       len$1=caml_call2(CCMonomorphic[8],_wY_,_wX_),
       i1=a[2],
       i2=b[2],
       len=len$1,
       _wZ_=b[1],
       _w0_=a[1];
      for(;;)
       {var _wT_=caml_call2(CCMonomorphic[4],len,0);
        if(_wT_)
         {var
           _wU_=caml_check_bound(_wZ_,i2)[i2 + 1],
           _wV_=caml_call2(p,caml_check_bound(_w0_,i1)[i1 + 1],_wU_);
          if(! _wV_)
           {var
             len$0=len - 1 | 0,
             i2$0=i2 + 1 | 0,
             i1$0=i1 + 1 | 0,
             i1=i1$0,
             i2=i2$0,
             len=len$0;
            continue}
          var _wW_=_wV_}
        else
         var _wW_=_wT_;
        return _wW_}}
    function iter2$0(f,a,b)
     {var _wN_=length$0(b),_wO_=length$0(a);
      if(caml_call2(CCMonomorphic[2],_wO_,_wN_))
       caml_call1(Pervasives[1],cst_CCArray_slice_iter2);
      var
       len=length$0(a),
       _wI_=len - 1 | 0,
       _wP_=b[2],
       _wQ_=a[2],
       _wR_=b[1],
       _wS_=a[1],
       _wH_=0;
      if(! (_wI_ < 0))
       {var o=_wH_;
        for(;;)
         {var
           _wJ_=_wP_ + o | 0,
           _wL_=_wQ_ + o | 0,
           _wK_=caml_check_bound(_wR_,_wJ_)[_wJ_ + 1];
          caml_call2(f,caml_check_bound(_wS_,_wL_)[_wL_ + 1],_wK_);
          var _wM_=o + 1 | 0;
          if(_wI_ !== o){var o=_wM_;continue}
          break}}
      return 0}
    function fold2$0(f,acc$1,a,b)
     {var _wB_=length$0(b),_wC_=length$0(a);
      if(caml_call2(CCMonomorphic[2],_wC_,_wB_))
       caml_call1(Pervasives[1],cst_CCArray_slice_fold2);
      var
       len=length$0(a),
       acc=acc$1,
       o=0,
       _wD_=b[2],
       _wE_=a[2],
       _wF_=b[1],
       _wG_=a[1];
      for(;;)
       {if(caml_call2(CCMonomorphic[1],o,len))return acc;
        var
         _wy_=_wD_ + o | 0,
         _wA_=_wE_ + o | 0,
         _wz_=caml_check_bound(_wF_,_wy_)[_wy_ + 1],
         acc$0=caml_call3(f,acc,caml_check_bound(_wG_,_wA_)[_wA_ + 1],_wz_),
         o$0=o + 1 | 0,
         acc=acc$0,
         o=o$0;
        continue}}
    function shuffle$2(a){return shuffle$1(include[5],a[1],a[2],a[3])}
    function shuffle_with$0(st,a)
     {var _wv_=a[3],_ww_=a[2],_wx_=a[1];
      return shuffle$1(caml_call1(include[11][5],st),_wx_,_ww_,_wv_)}
    function random_choose$0(a,st)
     {var _ws_=a[3],_wt_=a[2],_wu_=a[1];
      if(caml_call2(CCMonomorphic[6],_wt_,_ws_))throw Not_found;
      var _wr_=_wt_ + caml_call2(include[11][5],st,_ws_ - _wt_ | 0) | 0;
      return caml_check_bound(_wu_,_wr_)[_wr_ + 1]}
    function pp$0(opt,pp_item,buf,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$1;
      var _wp_=a[2],_wn_=a[3] - 1 | 0,_wq_=a[1];
      if(! (_wn_ < _wp_))
       {var k=_wp_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],k,_wp_))
           {caml_call2(Format[13],buf,sep);caml_call2(Format[27],buf,0)}
          caml_call2(pp_item,buf,caml_check_bound(_wq_,k)[k + 1]);
          var _wo_=k + 1 | 0;
          if(_wn_ !== k){var k=_wo_;continue}
          break}}
      return 0}
    function pp_i$0(opt,pp_item,out,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$2;
      var _wl_=a[2],_wj_=a[3] - 1 | 0,_wm_=a[1];
      if(! (_wj_ < _wl_))
       {var k=_wl_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],k,_wl_))
           {caml_call2(Format[13],out,sep);caml_call2(Format[27],out,0)}
          var x=caml_check_bound(_wm_,k)[k + 1];
          caml_call3(pp_item,k - a[2] | 0,out,x);
          var _wk_=k + 1 | 0;
          if(_wj_ !== k){var k=_wk_;continue}
          break}}
      return 0}
    function to_seq$0(a,k){return iter$0(k,a)}
    function to_gen$0(a)
     {var k=[0,a[2]],_wg_=a[3],_wh_=a[1];
      return function(param)
       {if(caml_call2(CCMonomorphic[3],k[1],_wg_))
         {var _wi_=k[1],x=caml_check_bound(_wh_,_wi_)[_wi_ + 1];
          k[1]++;
          return [0,x]}
        return 0}}
    function to_klist$2(a)
     {var _wc_=a[3],_wd_=a[2],_we_=a[1];
      return function(_wf_){return to_klist$1(_we_,_wd_,_wc_,_wf_)}}
    var
     CCArray_slice=
      [0,
       empty$0,
       equal$0,
       compare$0,
       get$0,
       get_safe$0,
       make,
       of_slice,
       to_slice,
       to_list$0,
       full,
       underlying,
       copy$0,
       sub$0,
       set$0,
       length$0,
       fold$0,
       foldi$0,
       fold_while$0,
       iter$0,
       iteri$0,
       blit$0,
       reverse_in_place$0,
       sorted$0,
       sort_indices$1,
       sort_ranking$0,
       find$1,
       findi$0,
       find_idx$0,
       lookup$0,
       lookup_exn$2,
       bsearch$0,
       for_all$0,
       for_all2$0,
       exists$0,
       exists2$0,
       fold2$0,
       iter2$0,
       shuffle$2,
       shuffle_with$0,
       random_choose$0,
       to_seq$0,
       to_gen$0,
       to_klist$2,
       pp$0,
       pp_i$0];
    caml_register_global(281,CCArray_slice,"CCArray_slice");
    function equal$1(a,b){return a === b?1:0}
    var compare$1=caml_int_compare;
    function negate(_wb_){return 1 - _wb_}
    var pp$1=Format[23],CCBool=[0,compare$1,equal$1,negate,pp$1];
    caml_register_global(282,CCBool,"CCBool");
    var
     chr=Char[1],
     escaped=Char[2],
     lowercase=Char[3],
     uppercase=Char[4],
     compare$2=Char[7];
    function equal$2(a,b){return a === b?1:0}
    var pp_buf=Buffer[10],pp$2=Format[21],of_int_exn=Char[1];
    function of_int(c)
     {try
       {var _v$_=[0,caml_call1(of_int_exn,c)];return _v$_}
      catch(_wa_){return 0}}
    function to_int(_v__){return _v__}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    var
     CCChar=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       equal$2,
       compare$2,
       lowercase_ascii,
       uppercase_ascii,
       of_int_exn,
       of_int,
       to_int,
       pp_buf,
       pp$2];
    caml_register_global(285,CCChar,"CCChar");
    var poly=caml_equal;
    function physical(_v9_,_v8_){return _v9_ === _v8_?1:0}
    var int$0=CCMonomorphic[1],string=caml_string_equal;
    function bool(_v7_,_v6_){return _v7_ === _v6_?1:0}
    function float$0(_v5_,_v4_){return _v5_ == _v4_?1:0}
    function unit(param,_v3_){return 1}
    function list(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             _v2_=caml_call2(f,x1,x2);
            if(_v2_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _v2_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function array(eq,a,b)
     {var _v1_=caml_call2(CCMonomorphic[1],a.length - 1,b.length - 1);
      if(_v1_)
       {var i=0;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i,a.length - 1))return 1;
          var
           _vZ_=caml_check_bound(b,i)[i + 1],
           _v0_=caml_call2(eq,caml_check_bound(a,i)[i + 1],_vZ_);
          if(_v0_){var i$0=i + 1 | 0,i=i$0;continue}
          return _v0_}}
      return _v1_}
    function option(f,o1,o2)
     {if(o1)
       {if(o2){var y=o2[1],x=o1[1];return caml_call2(f,x,y)}}
      else
       if(! o2)return 1;
      return 0}
    function pair(f,g,param,_vX_)
     {var
       y2=_vX_[2],
       x2=_vX_[1],
       y1=param[2],
       x1=param[1],
       _vY_=caml_call2(f,x1,x2);
      return _vY_?caml_call2(g,y1,y2):_vY_}
    function triple(f,g,h,param,_vT_)
     {var
       z2=_vT_[3],
       y2=_vT_[2],
       x2=_vT_[1],
       z1=param[3],
       y1=param[2],
       x1=param[1],
       _vU_=caml_call2(f,x1,x2);
      if(_vU_)
       {var _vV_=caml_call2(g,y1,y2);
        if(_vV_)return caml_call2(h,z1,z2);
        var _vW_=_vV_}
      else
       var _vW_=_vU_;
      return _vW_}
    function map$0(f,eq,x,y)
     {var _vS_=caml_call1(f,y);return caml_call2(eq,caml_call1(f,x),_vS_)}
    var
     Infix=
      [0,
       function(x,f){return function(_vQ_,_vR_){return map$0(f,x,_vQ_,_vR_)}}],
     CCEqual=
      [0,
       poly,
       physical,
       int$0,
       string,
       bool,
       float$0,
       unit,
       list,
       array,
       option,
       pair,
       triple,
       map$0,
       Infix,
       Infix[1]];
    caml_register_global(286,CCEqual,"CCEqual");
    var
     _g_=caml_equal,
     _h_=caml_notequal,
     _i_=caml_lessthan,
     _j_=caml_greaterthan,
     _k_=caml_lessequal,
     _l_=caml_greaterequal;
    function _m_(_vP_){return - _vP_}
    function _n_(_vO_,_vN_){return _vO_ + _vN_}
    function _o_(_vM_,_vL_){return _vM_ - _vL_}
    function _p_(_vK_,_vJ_){return _vK_ * _vJ_}
    function _q_(_vI_,_vH_){return _vI_ / _vH_}
    var
     _r_=Pervasives[12],
     _s_=Pervasives[10],
     _t_=Pervasives[11],
     _u_=Pervasives[13],
     _v_=Pervasives[15];
    function is_nan(x){return caml_equal(caml_classify_float(x),4)}
    function add(_vG_,_vF_){return _vG_ + _vF_}
    function sub$1(_vE_,_vD_){return _vE_ - _vD_}
    function neg(_vC_){return - _vC_}
    function abs(_vB_){return Math.abs(_vB_)}
    function scale(_vA_,_vz_){return _vA_ * _vz_}
    function min(x,y)
     {var match=caml_classify_float(x),match$0=caml_classify_float(y);
      return 4 <= match?y:4 <= match$0?x:caml_lessthan(x,y)?x:y}
    function max(x,y)
     {var match=caml_classify_float(x),match$0=caml_classify_float(y);
      return 4 <= match?y:4 <= match$0?x:caml_greaterthan(x,y)?x:y}
    var
     equal$3=caml_equal,
     compare$3=caml_float_compare,
     _w_=Hashtbl[21],
     _x_=Format[19];
    function fsign(a)
     {return is_nan(a)?_r_:caml_equal(a,0)?a:runtime.caml_copysign_float(1,a)}
    var TrapNaN=[248,cst_CCFloat_TrapNaN,caml_fresh_oo_id(0)];
    function sign_exn(a)
     {if(is_nan(a))throw [0,TrapNaN,cst_sign_exn];
      return caml_float_compare(a,0)}
    function round(x)
     {var low=Math.floor(x),high=Math.ceil(x);
      return caml_greaterthan(x - low,high - x)?high:low}
    function to_int$0(a){return a | 0}
    function of_int$0(a){return a}
    function to_string(a){return caml_call1(Pervasives[23],a)}
    var of_string_exn=caml_float_of_string,of_string=caml_float_of_string;
    function random$0(n,st){return caml_call2(include[11][9],st,n)}
    var _y_=100;
    function random_small(_vy_){return random$0(_y_,_vy_)}
    function random_range(i,j,st){return i + random$0(j - i,st)}
    function equal_precision(epsilon,a,b)
     {return caml_lessthan(Math.abs(a - b),epsilon)}
    var
     classify=caml_classify_float,
     CCFloat=
      [0,
       _r_,
       _s_,
       _t_,
       _u_,
       _v_,
       is_nan,
       add,
       sub$1,
       neg,
       abs,
       scale,
       min,
       max,
       equal$3,
       compare$3,
       _x_,
       _w_,
       random$0,
       random_small,
       random_range,
       fsign,
       round,
       TrapNaN,
       sign_exn,
       to_int$0,
       of_int$0,
       to_string,
       of_string_exn,
       of_string,
       equal_precision,
       classify,
       [0,_g_,_h_,_i_,_j_,_k_,_l_,_n_,_o_,_m_,_p_,_q_],
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _n_,
       _o_,
       _m_,
       _p_,
       _q_];
    caml_register_global(288,CCFloat,"CCFloat");
    var
     pp_open_box=Format[1],
     open_box=Format[2],
     pp_close_box=Format[3],
     close_box=Format[4],
     pp_open_hbox=Format[5],
     open_hbox=Format[6],
     pp_open_vbox=Format[7],
     open_vbox=Format[8],
     pp_open_hvbox=Format[9],
     open_hvbox=Format[10],
     pp_open_hovbox=Format[11],
     open_hovbox=Format[12],
     pp_print_string=Format[13],
     print_string=Format[14],
     pp_print_as=Format[15],
     print_as=Format[16],
     pp_print_int=Format[17],
     print_int=Format[18],
     pp_print_float=Format[19],
     print_float=Format[20],
     pp_print_char=Format[21],
     print_char=Format[22],
     pp_print_bool=Format[23],
     print_bool=Format[24],
     pp_print_space=Format[25],
     print_space=Format[26],
     pp_print_cut=Format[27],
     print_cut=Format[28],
     pp_print_break=Format[29],
     print_break=Format[30],
     pp_force_newline=Format[31],
     force_newline=Format[32],
     pp_print_if_newline=Format[33],
     print_if_newline=Format[34],
     pp_print_flush=Format[35],
     print_flush=Format[36],
     pp_print_newline=Format[37],
     print_newline=Format[38],
     pp_set_margin=Format[39],
     set_margin=Format[40],
     pp_get_margin=Format[41],
     get_margin=Format[42],
     pp_set_max_indent=Format[43],
     set_max_indent=Format[44],
     pp_get_max_indent=Format[45],
     get_max_indent=Format[46],
     pp_set_max_boxes=Format[47],
     set_max_boxes=Format[48],
     pp_get_max_boxes=Format[49],
     get_max_boxes=Format[50],
     pp_over_max_boxes=Format[51],
     over_max_boxes=Format[52],
     pp_open_tbox=Format[53],
     open_tbox=Format[54],
     pp_close_tbox=Format[55],
     close_tbox=Format[56],
     pp_set_tab=Format[57],
     set_tab=Format[58],
     pp_print_tab=Format[59],
     print_tab=Format[60],
     pp_print_tbreak=Format[61],
     print_tbreak=Format[62],
     pp_set_ellipsis_text=Format[63],
     set_ellipsis_text=Format[64],
     pp_get_ellipsis_text=Format[65],
     get_ellipsis_text=Format[66],
     pp_open_tag=Format[67],
     open_tag=Format[68],
     pp_close_tag=Format[69],
     close_tag=Format[70],
     pp_set_tags=Format[71],
     set_tags=Format[72],
     pp_set_print_tags=Format[73],
     set_print_tags=Format[74],
     pp_set_mark_tags=Format[75],
     set_mark_tags=Format[76],
     pp_get_print_tags=Format[77],
     get_print_tags=Format[78],
     pp_get_mark_tags=Format[79],
     get_mark_tags=Format[80],
     pp_set_formatter_out_channel=Format[81],
     set_formatter_out_channel=Format[82],
     pp_set_formatter_output_functions=Format[83],
     set_formatter_output_functions=Format[84],
     pp_get_formatter_output_functions=Format[85],
     get_formatter_output_functions=Format[86],
     pp_set_formatter_out_functions=Format[87],
     set_formatter_out_functions=Format[88],
     pp_get_formatter_out_functions=Format[89],
     get_formatter_out_functions=Format[90],
     pp_set_formatter_tag_functions=Format[91],
     set_formatter_tag_functions=Format[92],
     pp_get_formatter_tag_functions=Format[93],
     get_formatter_tag_functions=Format[94],
     formatter_of_out_channel=Format[95],
     std_formatter=Format[96],
     err_formatter=Format[97],
     formatter_of_buffer=Format[98],
     stdbuf=Format[99],
     str_formatter=Format[100],
     flush_str_formatter=Format[101],
     make_formatter=Format[102],
     formatter_of_out_functions=Format[103],
     make_symbolic_output_buffer=Format[104],
     clear_symbolic_output_buffer=Format[105],
     get_symbolic_output_buffer=Format[106],
     flush_symbolic_output_buffer=Format[107],
     add_symbolic_output_item=Format[108],
     formatter_of_symbolic_output_buffer=Format[109],
     pp_print_list=Format[110],
     pp_print_text=Format[111],
     printf=Format[113],
     eprintf=Format[114],
     asprintf=Format[116],
     ifprintf=Format[117],
     kfprintf=Format[118],
     ikfprintf=Format[119],
     kasprintf=Format[121],
     bprintf=Format[122],
     kprintf=Format[123],
     set_all_formatter_output_functions=Format[124],
     get_all_formatter_output_functions=Format[125],
     pp_set_all_formatter_output_functions=Format[126],
     pp_get_all_formatter_output_functions=Format[127];
    function silent(fmt,param){return 0}
    function return$0(fmt_str,out,param)
     {return caml_call3(Format[112],out,_z_,fmt_str)}
    function unit$0(fmt,param){return caml_call2(Format[13],fmt,cst$3)}
    function int$1(fmt,i)
     {var _vx_=caml_call1(Pervasives[21],i);
      return caml_call2(Format[13],fmt,_vx_)}
    var string$0=Format[13],bool$0=Format[23];
    function float3(fmt,f){return caml_call3(Format[112],fmt,_A_,f)}
    function float$1(fmt,f)
     {var _vw_=caml_call1(Pervasives[23],f);
      return caml_call2(Format[13],fmt,_vw_)}
    var char$0=Format[21];
    function int32(fmt,n){return caml_call3(Format[112],fmt,_B_,n)}
    function int64(fmt,n){return caml_call3(Format[112],fmt,_C_,n)}
    function nativeint(fmt,n){return caml_call3(Format[112],fmt,_D_,n)}
    function string_quoted(fmt,s){return caml_call3(Format[112],fmt,_E_,s)}
    var flush=Format[35],newline=Format[31];
    function substring(out,param)
     {var len=param[3],i=param[2],s=param[1];
      return caml_call2(string$0,out,caml_call3(include$1[4],s,i,len))}
    var text=Format[111];
    function list$0(opt,pp,fmt,l)
     {if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_vu_,_vv_){return return$0(_F_,_vu_,_vv_)};
      var l$0=l;
      for(;;)
       {if(l$0)
         {var _vs_=l$0[2],_vt_=l$0[1];
          if(_vs_)
           {caml_call2(pp,fmt,_vt_);
            caml_call2(sep,fmt,0);
            var l$0=_vs_;
            continue}
          return caml_call2(pp,fmt,_vt_)}
        return 0}}
    function array$0(opt,pp,fmt,a)
     {if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_vq_,_vr_){return return$0(_G_,_vq_,_vr_)};
      var _vo_=a.length - 1 - 1 | 0,_vn_=0;
      if(! (_vo_ < 0))
       {var i=_vn_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],i,0))caml_call2(sep,fmt,0);
          caml_call2(pp,fmt,caml_check_bound(a,i)[i + 1]);
          var _vp_=i + 1 | 0;
          if(_vo_ !== i){var i=_vp_;continue}
          break}}
      return 0}
    function arrayi(opt,pp,fmt,a)
     {if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_vl_,_vm_){return return$0(_H_,_vl_,_vm_)};
      var _vj_=a.length - 1 - 1 | 0,_vi_=0;
      if(! (_vj_ < 0))
       {var i=_vi_;
        for(;;)
         {if(caml_call2(CCMonomorphic[4],i,0))caml_call2(sep,fmt,0);
          caml_call2(pp,fmt,[0,i,caml_check_bound(a,i)[i + 1]]);
          var _vk_=i + 1 | 0;
          if(_vj_ !== i){var i=_vk_;continue}
          break}}
      return 0}
    function seq(opt,pp,fmt,seq)
     {if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_vg_,_vh_){return return$0(_I_,_vg_,_vh_)};
      var first=[0,1];
      return caml_call1
              (seq,
               function(x)
                {if(first[1])first[1] = 0;else caml_call2(sep,fmt,0);
                 return caml_call2(pp,fmt,x)})}
    function opt(pp,fmt,x)
     {if(x){var x$0=x[1];return caml_call4(Format[112],fmt,_J_,pp,x$0)}
      return caml_call2(Format[13],fmt,cst_none)}
    function pair$0(opt,ppa,ppb,fmt,param)
     {var b=param[2],a=param[1];
      if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_ve_,_vf_){return return$0(_L_,_ve_,_vf_)};
      return caml_call8(Format[112],fmt,_K_,ppa,a,sep,0,ppb,b)}
    function triple$0(opt,ppa,ppb,ppc,fmt,param)
     {var c=param[3],b=param[2],a=param[1];
      if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_vc_,_vd_){return return$0(_N_,_vc_,_vd_)};
      return caml_call12(Format[112],fmt,_M_,ppa,a,sep,0,ppb,b,sep,0,ppc,c)}
    function quad(opt,ppa,ppb,ppc,ppd,fmt,param)
     {var d=param[4],c=param[3],b=param[2],a=param[1];
      if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(_va_,_vb_){return return$0(_P_,_va_,_vb_)};
      return caml_call16
              (Format[112],fmt,_O_,ppa,a,sep,0,ppb,b,sep,0,ppc,c,sep,0,ppd,d)}
    function within(a,b,p,out,x)
     {caml_call2(string$0,out,a);
      caml_call2(p,out,x);
      return caml_call2(string$0,out,b)}
    function map$1(f,pp,fmt,x){caml_call2(pp,fmt,caml_call1(f,x));return 0}
    function vbox(opt,pp,out,x)
     {if(opt)var sth=opt[1],i=sth;else var i=0;
      caml_call2(Format[7],out,i);
      caml_call2(pp,out,x);
      return caml_call2(Format[3],out,0)}
    function hovbox(opt,pp,out,x)
     {if(opt)var sth=opt[1],i=sth;else var i=0;
      caml_call2(Format[11],out,i);
      caml_call2(pp,out,x);
      return caml_call2(Format[3],out,0)}
    function hvbox(opt,pp,out,x)
     {if(opt)var sth=opt[1],i=sth;else var i=0;
      caml_call2(Format[9],out,i);
      caml_call2(pp,out,x);
      return caml_call2(Format[3],out,0)}
    function hbox(pp,out,x)
     {caml_call2(Format[5],out,0);
      caml_call2(pp,out,x);
      return caml_call2(Format[3],out,0)}
    function of_to_string(f,out,x)
     {var _u$_=caml_call1(f,x);return caml_call2(Format[13],out,_u$_)}
    function const$0(pp,x,out,param){return caml_call2(pp,out,x)}
    function some(pp,out,param)
     {if(param){var x=param[1];return caml_call2(pp,out,x)}return 0}
    function lazy_force(pp,out,param)
     {var
       _u__=caml_obj_tag(param),
       x=
        250 === _u__
         ?param[1]
         :246 === _u__?caml_call1(CamlinternalLazy[2],param):param;
      return caml_call2(pp,out,x)}
    function lazy_or(opt,pp,out,x)
     {if(opt)
       var sth=opt[1],default$0=sth;
      else
       var default$0=function(_u8_,_u9_){return return$0(_Q_,_u8_,_u9_)};
      if(caml_call1(Lazy[5],x))
       {var
         _u6_=caml_obj_tag(x),
         _u7_=
          250 === _u6_?x[1]:246 === _u6_?caml_call1(CamlinternalLazy[2],x):x;
        return caml_call2(pp,out,_u7_)}
      return caml_call2(default$0,out,0)}
    function output(fmt,pp,x){return caml_call2(pp,fmt,x)}
    function to_string$0(pp,x)
     {var buf=caml_call1(Buffer[1],64),fmt=caml_call1(Format[98],buf);
      caml_call2(pp,fmt,x);
      caml_call2(Format[35],fmt,0);
      return caml_call1(Buffer[2],buf)}
    var
     fprintf=Format[112],
     stdout=Format[96],
     stderr=Format[97],
     of_chan=Format[95];
    function with_out_chan(oc,f)
     {var fmt=caml_call1(of_chan,oc);
      try
       {var x=caml_call1(f,fmt);caml_call2(Format[35],fmt,0);return x}
      catch(e)
       {e = caml_wrap_exception(e);caml_call2(Format[35],fmt,0);throw e}}
    function tee(a,b)
     {var fa=caml_call2(Format[89],a,0),fb=caml_call2(Format[89],b,0);
      function _u4_(param){caml_call1(fa[2],0);return caml_call1(fb[2],0)}
      function _u5_(str,i,len)
       {caml_call3(fa[1],str,i,len);return caml_call3(fb[1],str,i,len)}
      return caml_call2(Format[102],_u5_,_u4_)}
    function to_file(filename,format)
     {var
       oc=caml_call1(Pervasives[48],filename),
       fmt=caml_call1(Format[95],oc);
      function _u3_(fmt)
       {caml_call2(Format[35],fmt,0);return caml_call1(Pervasives[65],oc)}
      return caml_call3(Format[118],_u3_,fmt,format)}
    function int_of_color(param)
     {return 82908052 <= param
              ?749039939 <= param
                ?756711075 <= param?2:6
                :737308346 <= param?4:3
              :-588596599 <= param
                ?4100401 <= param?1:7
                :-605101559 <= param?5:0}
    function code_of_style(param)
     {if(typeof param === "number")return 737455525 <= param?1:0;
      if(15681 <= param[1]){var c=param[2];return 30 + int_of_color(c) | 0}
      var c$0=param[2];
      return 40 + int_of_color(c$0) | 0}
    function ansi_l_to_str(l)
     {if(l)
       {var _uV_=l[2],_uW_=l[1];
        if(_uV_)
         {if(_uV_[2])
           {var buf=caml_call1(Buffer[1],16);
            caml_call2(Buffer[14],buf,cst$4);
            var
             _uX_=
              function(i,c)
               {if(caml_call2(CCMonomorphic[4],i,0))
                 caml_call2(Buffer[10],buf,59);
                var
                 _u1_=code_of_style(c),
                 _u2_=caml_call1(Pervasives[21],_u1_);
                return caml_call2(Buffer[14],buf,_u2_)};
            caml_call2(List[16],_uX_,l);
            caml_call2(Buffer[14],buf,cst_m);
            return caml_call1(Buffer[2],buf)}
          var b=_uV_[1],_uY_=code_of_style(b),_uZ_=code_of_style(_uW_);
          return caml_call3(Printf[4],_R_,_uZ_,_uY_)}
        var _u0_=code_of_style(_uW_);
        return caml_call2(Printf[4],_S_,_u0_)}
      return cst_0m}
    var No_such_style=[248,cst_CCFormat_No_such_style,caml_fresh_oo_id(0)];
    function style_of_tag(s)
     {var
       match=caml_call1(include$1[12],s),
       switch$0=caml_string_compare(match,cst_blue);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return _$_;
        if(! caml_string_notequal(match,cst_bold))return ___;
        if(! caml_string_notequal(match,cst_cyan))return _Z_;
        if(! caml_string_notequal(match,cst_green))return _Y_;
        if(! caml_string_notequal(match,cst_magenta))return _X_;
        if(! caml_string_notequal(match,cst_red))return _W_;
        if(! caml_string_notequal(match,cst_reset))return _V_;
        if(! caml_string_notequal(match,cst_white))return _U_;
        if(! caml_string_notequal(match,cst_yellow))return _T_}
      else
       {if(! caml_string_notequal(match,cst_Black))return _ai_;
        if(! caml_string_notequal(match,cst_Blue))return _ah_;
        if(! caml_string_notequal(match,cst_Cyan))return _ag_;
        if(! caml_string_notequal(match,cst_Green))return _af_;
        if(! caml_string_notequal(match,cst_Magenta))return _ae_;
        if(! caml_string_notequal(match,cst_Red))return _ad_;
        if(! caml_string_notequal(match,cst_White))return _ac_;
        if(! caml_string_notequal(match,cst_Yellow))return _ab_;
        if(! caml_string_notequal(match,cst_black))return _aa_}
      throw No_such_style}
    var color_enabled=[0,0];
    function mark_open_tag(st,or_else,s)
     {try
       {var style=style_of_tag(s);
        caml_call2(Stack[3],style,st);
        var _uT_=color_enabled[1]?ansi_l_to_str(style):cst$5;
        return _uT_}
      catch(_uU_)
       {_uU_ = caml_wrap_exception(_uU_);
        if(_uU_ === No_such_style)return caml_call1(or_else,s);
        throw _uU_}}
    function mark_close_tag(st,or_else,s)
     {try
       {style_of_tag(s)}
      catch(_uS_)
       {_uS_ = caml_wrap_exception(_uS_);
        if(_uS_ === No_such_style)return caml_call1(or_else,s);
        throw _uS_}
      try
       {caml_call1(Stack[4],st);var _uQ_=caml_call1(Stack[5],st),style=_uQ_}
      catch(_uR_)
       {_uR_ = caml_wrap_exception(_uR_);
        if(_uR_ !== Stack[1])throw _uR_;
        var style=_aj_}
      return color_enabled[1]?ansi_l_to_str(style):cst$6}
    function set_color_tag_handling(ppf)
     {var
       functions=caml_call2(Format[93],ppf,0),
       st=caml_call1(Stack[2],0),
       _uJ_=functions[4],
       _uK_=functions[3],
       _uL_=functions[2];
      function _uM_(_uP_){return mark_close_tag(st,_uL_,_uP_)}
      var
       _uN_=functions[1],
       functions$0=
        [0,function(_uO_){return mark_open_tag(st,_uN_,_uO_)},_uM_,_uK_,_uJ_];
      caml_call2(Format[75],ppf,1);
      return caml_call2(Format[91],ppf,functions$0)}
    var first=[0,1];
    function set_color_default(b)
     {if(b)
       if(! color_enabled[1])
        {color_enabled[1] = 1;
         var _uI_=first[1];
         return _uI_
                 ?(first[1]
                   =
                   0,
                   set_color_tag_handling(stdout),
                   set_color_tag_handling(stderr))
                 :_uI_}
      var
       _uF_=1 - b,
       _uG_=_uF_?color_enabled[1]:_uF_,
       _uH_=_uG_?(color_enabled[1] = 0,0):_uG_;
      return _uH_}
    function with_color(s,pp,out,x)
     {caml_call2(Format[67],out,s);
      caml_call2(pp,out,x);
      return caml_call2(Format[69],out,0)}
    function with_colorf(s,out,fmt)
     {caml_call2(Format[67],out,s);
      function _uE_(out){return caml_call2(Format[69],out,0)}
      return caml_call3(Format[118],_uE_,out,fmt)}
    function sprintf(c,format)
     {var
       buf=caml_call1(Buffer[1],64),
       fmt=caml_call1(Format[98],buf),
       _uC_=c?color_enabled[1]:c;
      if(_uC_)set_color_tag_handling(fmt);
      function _uD_(fmt$0)
       {caml_call2(Format[35],fmt,0);return caml_call1(Buffer[2],buf)}
      return caml_call3(Format[118],_uD_,fmt,format)}
    function with_color_ksf(f,s,fmt)
     {var buf=caml_call1(Buffer[1],64),out=caml_call1(Format[98],buf);
      if(color_enabled[1])set_color_tag_handling(out);
      caml_call2(Format[67],out,s);
      function _uB_(out)
       {caml_call2(Format[69],out,0);
        caml_call2(Format[35],out,0);
        return caml_call1(f,caml_call1(Buffer[2],buf))}
      return caml_call3(Format[118],_uB_,out,fmt)}
    function with_color_sf(s,fmt)
     {return with_color_ksf(function(s){return s},s,fmt)}
    function sprintf$0(fmt){return sprintf(1,fmt)}
    function sprintf_no_color(fmt){return sprintf(0,fmt)}
    function sprintf_dyn_color(colors,fmt){return sprintf(colors,fmt)}
    function fprintf_dyn_color(colors,out,fmt)
     {var old_tags=caml_call2(Format[79],out,0);
      caml_call2(Format[75],out,colors);
      function _uA_(out){return caml_call2(Format[75],out,old_tags)}
      return caml_call3(Format[118],_uA_,out,fmt)}
    function ksprintf(margin,f,fmt)
     {var buf=caml_call1(Buffer[1],32),out=caml_call1(Format[98],buf);
      if(color_enabled[1])set_color_tag_handling(out);
      if(margin){var m=margin[1];caml_call2(pp_set_margin,out,m)}
      function _uz_(param)
       {caml_call2(Format[35],out,0);
        return caml_call1(f,caml_call1(Buffer[2],buf))}
      return caml_call3(Format[118],_uz_,out,fmt)}
    function list$1(pp)
     {var _un_=[0,function(_ux_,_uy_){return return$0(_ak_,_ux_,_uy_)}];
      function _uo_(_uv_,_uw_){return list$0(_un_,pp,_uv_,_uw_)}
      var _up_=0;
      function _uq_(_ut_,_uu_){return hovbox(_up_,_uo_,_ut_,_uu_)}
      return function(_ur_,_us_){return within(cst$8,cst$7,_uq_,_ur_,_us_)}}
    function array$1(pp)
     {var _ub_=[0,function(_ul_,_um_){return return$0(_al_,_ul_,_um_)}];
      function _uc_(_uj_,_uk_){return array$0(_ub_,pp,_uj_,_uk_)}
      var _ud_=0;
      function _ue_(_uh_,_ui_){return hovbox(_ud_,_uc_,_uh_,_ui_)}
      return function(_uf_,_ug_){return within(cst$10,cst$9,_ue_,_uf_,_ug_)}}
    function option$0(pp,out,x)
     {if(x){var x$0=x[1];return caml_call4(Format[112],out,_am_,pp,x$0)}
      return caml_call2(Format[13],out,cst_None)}
    function pair$1(p1,p2)
     {var _t3_=0;
      function _t4_(_t$_,_ua_){return pair$0(_t3_,p1,p2,_t$_,_ua_)}
      var _t5_=0;
      function _t6_(_t9_,_t__){return hovbox(_t5_,_t4_,_t9_,_t__)}
      return function(_t7_,_t8_){return within(cst$12,cst$11,_t6_,_t7_,_t8_)}}
    function triple$1(p1,p2,p3)
     {var _tT_=0;
      function _tU_(_t1_,_t2_){return triple$0(_tT_,p1,p2,p3,_t1_,_t2_)}
      var _tV_=0;
      function _tW_(_tZ_,_t0_){return hovbox(_tV_,_tU_,_tZ_,_t0_)}
      return function(_tX_,_tY_){return within(cst$14,cst$13,_tW_,_tX_,_tY_)}}
    function quad$0(p1,p2,p3,p4)
     {var _tJ_=0;
      function _tK_(_tR_,_tS_){return quad(_tJ_,p1,p2,p3,p4,_tR_,_tS_)}
      var _tL_=0;
      function _tM_(_tP_,_tQ_){return hovbox(_tL_,_tK_,_tP_,_tQ_)}
      return function(_tN_,_tO_){return within(cst$16,cst$15,_tM_,_tN_,_tO_)}}
    function result(pok,perror,out,param)
     {if(0 === param[0])
       {var x=param[1];return caml_call4(Format[112],out,_an_,pok,x)}
      var e=param[1];
      return caml_call4(Format[112],out,_ao_,perror,e)}
    function result$0(pok)
     {return function(_tH_,_tI_){return result(pok,string_quoted,_tH_,_tI_)}}
    var
     CCFormat=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functions,
       set_formatter_output_functions,
       pp_get_formatter_output_functions,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_buffer,
       pp_print_list,
       pp_print_text,
       printf,
       eprintf,
       asprintf,
       ifprintf,
       kfprintf,
       ikfprintf,
       kasprintf,
       bprintf,
       kprintf,
       set_all_formatter_output_functions,
       get_all_formatter_output_functions,
       pp_set_all_formatter_output_functions,
       pp_get_all_formatter_output_functions,
       silent,
       unit$0,
       int$1,
       string$0,
       bool$0,
       float3,
       float$1,
       newline,
       substring,
       text,
       char$0,
       int32,
       int64,
       nativeint,
       flush,
       string_quoted,
       list$0,
       array$0,
       arrayi,
       seq,
       opt,
       pair$0,
       triple$0,
       quad,
       within,
       map$1,
       vbox,
       hvbox,
       hovbox,
       hbox,
       return$0,
       of_to_string,
       const$0,
       some,
       lazy_force,
       lazy_or,
       set_color_tag_handling,
       set_color_default,
       with_color,
       with_colorf,
       with_color_sf,
       with_color_ksf,
       output,
       to_string$0,
       of_chan,
       with_out_chan,
       stdout,
       stderr,
       tee,
       sprintf$0,
       sprintf_no_color,
       sprintf_dyn_color,
       fprintf,
       fprintf_dyn_color,
       ksprintf,
       to_file,
       [0,
        unit$0,
        int$1,
        string_quoted,
        bool$0,
        float$1,
        char$0,
        int32,
        int64,
        nativeint,
        list$1,
        array$1,
        option$0,
        pair$1,
        triple$1,
        quad$0,
        result$0,
        result,
        to_string$0]];
    caml_register_global(294,CCFormat,"CCFormat");
    var invalid_arg=Pervasives[1];
    function compose(f,g,x){return caml_call1(g,caml_call1(f,x))}
    function compose_binop(f,g,x,y)
     {var _tG_=caml_call1(f,y);return caml_call2(g,caml_call1(f,x),_tG_)}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function curry(f,x,y){return caml_call1(f,[0,x,y])}
    function id(x){return x}
    function const$1(x,param){return x}
    function uncurry(f,param)
     {var y=param[2],x=param[1];return caml_call2(f,x,y)}
    function tap(f,x){caml_call1(f,x);return x}
    function _ap_(f,g,x){return caml_call1(f,caml_call1(g,x))}
    function lexicographic(f1,f2,x,y)
     {var c=caml_call2(f1,x,y);return 0 === c?caml_call2(f2,x,y):c}
    function finally$0(h,f)
     {try
       {var x=caml_call1(f,0);caml_call1(h,0);return x}
      catch(e){e = caml_wrap_exception(e);caml_call1(h,0);throw e}}
    function finally1(h,f,x)
     {try
       {var res=caml_call1(f,x);caml_call1(h,0);return res}
      catch(e){e = caml_wrap_exception(e);caml_call1(h,0);throw e}}
    function finally2(h,f,x,y)
     {try
       {var res=caml_call2(f,x,y);caml_call1(h,0);return res}
      catch(e){e = caml_wrap_exception(e);caml_call1(h,0);throw e}}
    function iterate(n,f,x)
     {var n$0=n,x$0=x;
      for(;;)
       {if(0 <= n$0)
         {if(0 === n$0)return x$0;
          var x$1=caml_call1(f,x$0),n$1=n$0 - 1 | 0,n$0=n$1,x$0=x$1;
          continue}
        return caml_call1(invalid_arg,cst_CCFun_iterate)}}
    function Monad(X)
     {function return$0(x,param){return x}
      function _tF_(f,g,x){return caml_call1(g,caml_call1(f,x))}
      return [0,
              return$0,
              _tF_,
              function(f,g,x){return caml_call2(g,caml_call1(f,x),x)}]}
    function _aq_(_tE_){return _tE_}
    function _ar_(_tD_,_tC_){return caml_call1(_tD_,_tC_)}
    var
     CCFun=
      [0,
       function(_tB_,_tA_){return caml_call1(_tA_,_tB_)},
       compose,
       compose_binop,
       compose,
       _ar_,
       id,
       const$1,
       flip,
       curry,
       uncurry,
       tap,
       _ap_,
       lexicographic,
       finally$0,
       finally1,
       finally2,
       _aq_,
       iterate,
       Monad];
    caml_register_global(295,CCFun,"CCFun");
    function equal$4(a,b){return a === b?1:0}
    function hash(i){return i & Pervasives[7]}
    function range(i,j,yield$0)
     {if(caml_call2(CCMonomorphic[5],i,j))
       {var i$0=i;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i$0,j))
           return caml_call1(yield$0,i$0);
          caml_call1(yield$0,i$0);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      var i$2=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$2,j))return caml_call1(yield$0,i$2);
        caml_call1(yield$0,i$2);
        var i$3=i$2 - 1 | 0,i$2=i$3;
        continue}}
    function range$0(i,j,yield$0)
     {return caml_call2(CCMonomorphic[3],i,j)
              ?range(i,j - 1 | 0,yield$0)
              :caml_call2(CCMonomorphic[1],i,j)?0:range(i,j + 1 | 0,yield$0)}
    var
     min$0=Pervasives[4],
     max$0=Pervasives[5],
     lnot=Pervasives[9],
     string_of_int=Pervasives[21];
    function sign(i){return 0 <= i?0 < i?1:0:-1}
    function neg$0(i){return - i | 0}
    function pow(a,b)
     {function aux(acc,n)
       {var acc$0=acc,n$0=n;
        for(;;)
         {if(1 === n$0)return acc$0;
          if(0 === (n$0 % 2 | 0))
           {var
             n$1=n$0 / 2 | 0,
             acc$1=caml_mul(acc$0,acc$0),
             acc$0=acc$1,
             n$0=n$1;
            continue}
          return caml_mul(acc$0,aux(caml_mul(acc$0,acc$0),n$0 / 2 | 0))}}
      if(0 === b)
       {if(0 === a)throw [0,Invalid_argument,cst_pow_undefined_value_0_0];
        return 1}
      if(0 <= b)return aux(a,b);
      throw [0,Invalid_argument,cst_pow_can_t_raise_int_to_negative_power]}
    function floor_div(a,n)
     {if(! (0 <= a))if(0 <= n)return caml_div(a + 1 | 0,n) - 1 | 0;
      if(0 < a)if(! (0 <= n))return caml_div(a - 1 | 0,n) - 1 | 0;
      return caml_div(a,n)}
    function rem(a,n)
     {var y=caml_mod(a,n);
      if((y < 0?1:0) !== (n < 0?1:0))if(0 !== y)return y + n | 0;
      return y}
    function random$1(n,st){return caml_call2(include[11][5],st,n)}
    var _as_=100;
    function random_small$0(_tz_){return random$1(_as_,_tz_)}
    function random_range$0(i,j,st){return i + random$1(j - i | 0,st) | 0}
    function pp$3(fmt){return caml_call1(Format[17],fmt)}
    var bit=-2147483648;
    function of_string$0(s)
     {try
       {var _tx_=[0,caml_int_of_string(s)];return _tx_}
      catch(_ty_){return 0}}
    function to_binary_gen(out,n)
     {var n$0=0 <= n?n:(caml_call1(out,45),- n | 0);
      caml_call1(out,48);
      caml_call1(out,98);
      var started=0,bit$0=bit;
      for(;;)
       {if(0 === bit$0)
         {var _tw_=1 - started;return _tw_?caml_call1(out,48):_tw_}
        var b=n$0 & bit$0;
        if(0 === b)
         {if(started)caml_call1(out,48);
          var bit$1=bit$0 >>> 1 | 0,bit$0=bit$1;
          continue}
        caml_call1(out,49);
        var bit$2=bit$0 >>> 1 | 0,started=1,bit$0=bit$2;
        continue}}
    function pp_binary(out,n)
     {return to_binary_gen(caml_call1(Format[21],out),n)}
    function to_string_binary(n)
     {var buf=caml_call1(Buffer[1],16);
      to_binary_gen(caml_call1(Buffer[10],buf),n);
      return caml_call1(Buffer[2],buf)}
    function range_by(step,i,j,yield$0)
     {if(0 === step)throw [0,Invalid_argument,cst_CCList_range_by];
      var _tv_=0 < step?j < i?1:0:i < j?1:0;
      if(_tv_)return 0;
      var j$0=caml_mul(caml_div(j - i | 0,step),step) + i | 0,i$0=i;
      for(;;)
       {if(i$0 === j$0)return caml_call1(yield$0,i$0);
        caml_call1(yield$0,i$0);
        var i$1=i$0 + step | 0,i$0=i$1;
        continue}}
    function _at_(_tu_,_tt_){return _tu_ >> _tt_}
    function _au_(_ts_,_tr_){return _ts_ >>> _tr_ | 0}
    function _av_(_tq_,_tp_){return _tq_ << _tp_}
    function _aw_(_to_,_tn_){return _to_ ^ _tn_}
    function _ax_(_tm_,_tl_){return _tm_ | _tl_}
    function _ay_(_tk_,_tj_){return _tk_ & _tj_}
    var _az_=caml_mod,_aA_=caml_div;
    function _aB_(_ti_,_th_){return caml_mul(_ti_,_th_)}
    function _aC_(_tg_){return - _tg_ | 0}
    function _aD_(_tf_,_te_){return _tf_ - _te_ | 0}
    function _aE_(_td_,_tc_){return _td_ + _tc_ | 0}
    function _aF_(_tb_,_ta_){return _ta_ <= _tb_?1:0}
    function _aG_(_s$_,_s__){return _s$_ <= _s__?1:0}
    function _aH_(_s9_,_s8_){return _s8_ < _s9_?1:0}
    function _aI_(_s7_,_s6_){return _s7_ < _s6_?1:0}
    function _aJ_(_s5_,_s4_){return _s5_ !== _s4_?1:0}
    function _aK_(_s3_,_s2_){return _s3_ === _s2_?1:0}
    function _aL_(_s1_,_s0_){return _s1_ >> _s0_}
    function _aM_(_sZ_,_sY_){return _sZ_ >>> _sY_ | 0}
    function _aN_(_sX_,_sW_){return _sX_ << _sW_}
    function _aO_(_sV_,_sU_){return _sV_ ^ _sU_}
    function _aP_(_sT_,_sS_){return _sT_ | _sS_}
    function _aQ_(_sR_,_sQ_){return _sR_ & _sQ_}
    var _aR_=caml_mod,_aS_=caml_div;
    function _aT_(_sP_,_sO_){return caml_mul(_sP_,_sO_)}
    function _aU_(_sN_){return - _sN_ | 0}
    function _aV_(_sM_,_sL_){return _sM_ - _sL_ | 0}
    function _aW_(_sK_,_sJ_){return _sK_ + _sJ_ | 0}
    function _aX_(_sI_,_sH_){return _sH_ <= _sI_?1:0}
    function _aY_(_sG_,_sF_){return _sG_ <= _sF_?1:0}
    function _aZ_(_sE_,_sD_){return _sD_ < _sE_?1:0}
    function _a0_(_sC_,_sB_){return _sC_ < _sB_?1:0}
    function _a1_(_sA_,_sz_){return _sA_ !== _sz_?1:0}
    var
     _a2_=caml_int_compare,
     CCInt=
      [0,
       _a2_,
       equal$4,
       hash,
       sign,
       neg$0,
       pow,
       floor_div,
       rem,
       random$1,
       random_small$0,
       random_range$0,
       pp$3,
       string_of_int,
       of_string$0,
       pp_binary,
       to_string_binary,
       min$0,
       max$0,
       range_by,
       range,
       range$0,
       [0,
        function(_sy_,_sx_){return _sy_ === _sx_?1:0},
        _a1_,
        _a0_,
        _aZ_,
        _aY_,
        _aX_,
        range,
        range$0,
        _aW_,
        _aV_,
        _aU_,
        _aT_,
        _aS_,
        _aR_,
        _aQ_,
        _aP_,
        _aO_,
        lnot,
        _aN_,
        _aM_,
        _aL_],
       _aK_,
       _aJ_,
       _aI_,
       _aH_,
       _aG_,
       _aF_,
       range,
       range$0,
       _aE_,
       _aD_,
       _aC_,
       _aB_,
       _aA_,
       _az_,
       _ay_,
       _ax_,
       _aw_,
       lnot,
       _av_,
       _au_,
       _at_];
    caml_register_global(296,CCInt,"CCInt");
    function combine(f,s,x)
     {var _sw_=caml_call1(f,x);return caml_call2(Hashtbl[22],s,_sw_)}
    function combine2(a,b){return caml_call2(Hashtbl[22],a,b)}
    function combine3(a,b,c){return combine2(combine2(a,b),c)}
    function combine4(a,b,c,d)
     {var _sv_=combine2(c,d);return combine2(combine2(a,b),_sv_)}
    function combine5(a,b,c,d,e)
     {var _su_=combine2(combine2(c,d),e);return combine2(combine2(a,b),_su_)}
    function combine6(a,b,c,d,e,f)
     {var _ss_=combine2(e,f),_st_=combine2(combine2(c,d),_ss_);
      return combine2(combine2(a,b),_st_)}
    function const$2(h,param){return h}
    function const0(param){return 0}
    function int$2(i){return i & Pervasives[7]}
    function bool$1(b){return b?1:2}
    function char$1(x){return x}
    function int32$0(x){return caml_call1(Hashtbl[21],x)}
    function int64$0(x){return caml_call1(Hashtbl[21],x)}
    function nativeint$0(x){return caml_call1(Hashtbl[21],x)}
    function string$1(x){return caml_call1(Hashtbl[21],x)}
    function slice(x,i,len)
     {var j=i + len | 0,i$0=i,s=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,j))return s;
        var
         s$0=combine2(caml_string_get(x,i$0),s),
         i$1=i$0 + 1 | 0,
         i$0=i$1,
         s=s$0;
        continue}}
    function opt$0(f,param)
     {if(param){var x=param[1];return combine2(43,caml_call1(f,x))}return 42}
    function list$2(f,l)
     {var _so_=66;
      function _sp_(_sq_,_sr_){return combine(f,_sq_,_sr_)}
      return caml_call3(List[20],_sp_,_so_,l)}
    function array$2(f,l)
     {var _sk_=66;
      function _sl_(_sm_,_sn_){return combine(f,_sm_,_sn_)}
      return caml_call3(Array[17],_sl_,_sk_,l)}
    function pair$2(f,g,param)
     {var y=param[2],x=param[1],_sj_=caml_call1(g,y);
      return combine2(caml_call1(f,x),_sj_)}
    function triple$2(f,g,h,param)
     {var
       z=param[3],
       y=param[2],
       x=param[1],
       _sh_=caml_call1(h,z),
       _si_=caml_call1(g,y);
      return combine2(combine2(caml_call1(f,x),_si_),_sh_)}
    function quad$1(f,g,h,i,param)
     {var
       w=param[4],
       z=param[3],
       y=param[2],
       x=param[1],
       _se_=caml_call1(i,w),
       _sf_=combine2(caml_call1(h,z),_se_),
       _sg_=caml_call1(g,y);
      return combine2(combine2(caml_call1(f,x),_sg_),_sf_)}
    function if$0(b,then,else$0,h)
     {return b?caml_call1(then,h):caml_call1(else$0,h)}
    function poly$0(x){return caml_call1(Hashtbl[21],x)}
    function array_comm(f,a)
     {function _sd_(i){return caml_call1(f,caml_check_bound(a,i)[i + 1])}
      var arr=caml_call2(Array[2],a.length - 1,_sd_);
      caml_call2(Array[25],_a2_,arr);
      return array$2(function(h){return h},arr)}
    function list_comm(f,l)
     {var a=caml_call1(Array[12],l);return array_comm(f,a)}
    function seq$0(f,seq)
     {var h=[0,67];
      caml_call1(seq,function(x){h[1] = combine(f,h[1],x);return 0});
      return h[1]}
    function gen(f,g)
     {var s=66;
      for(;;)
       {var match=caml_call1(g,0);
        if(match)
         {var x=match[1],s$0=combine2(s,caml_call1(f,x)),s=s$0;continue}
        return s}}
    function klist(f,l)
     {var l$0=l,s=66;
      for(;;)
       {var match=caml_call1(l$0,0);
        if(typeof match === "number")return s;
        var
         match$0=match[2],
         tail=match$0[2],
         x=match$0[1],
         s$0=combine2(s,caml_call1(f,x)),
         l$0=tail,
         s=s$0;
        continue}}
    var
     CCHash=
      [0,
       const$2,
       const0,
       int$2,
       bool$1,
       char$1,
       int32$0,
       int64$0,
       nativeint$0,
       slice,
       string$1,
       list$2,
       array$2,
       opt$0,
       pair$2,
       triple$2,
       quad$1,
       if$0,
       poly$0,
       list_comm,
       array_comm,
       combine,
       combine2,
       combine3,
       combine4,
       combine5,
       combine6,
       seq$0,
       gen,
       klist];
    caml_register_global(297,CCHash,"CCHash");
    function get$1(tbl,x)
     {try
       {var _sb_=[0,caml_call2(Hashtbl[6],tbl,x)];return _sb_}
      catch(_sc_)
       {_sc_ = caml_wrap_exception(_sc_);
        if(_sc_ === Not_found)return 0;
        throw _sc_}}
    function get_or(tbl,x,default$0)
     {try
       {var _r$_=caml_call2(Hashtbl[6],tbl,x);return _r$_}
      catch(_sa_)
       {_sa_ = caml_wrap_exception(_sa_);
        if(_sa_ === Not_found)return default$0;
        throw _sa_}}
    function keys(tbl,k)
     {function _r__(key,param){return caml_call1(k,key)}
      return caml_call2(Hashtbl[12],_r__,tbl)}
    function values(tbl,k)
     {function _r9_(param,v){return caml_call1(k,v)}
      return caml_call2(Hashtbl[12],_r9_,tbl)}
    function keys_list(tbl)
     {var _r7_=0;
      function _r8_(k,param,a){return [0,k,a]}
      return caml_call3(Hashtbl[14],_r8_,tbl,_r7_)}
    function values_list(tbl)
     {var _r5_=0;
      function _r6_(param,v,a){return [0,v,a]}
      return caml_call3(Hashtbl[14],_r6_,tbl,_r5_)}
    function add_list(tbl,k,v)
     {try
       {var _r3_=caml_call2(Hashtbl[6],tbl,k),l=_r3_}
      catch(_r4_)
       {_r4_ = caml_wrap_exception(_r4_);
        if(_r4_ !== Not_found)throw _r4_;
        var l=0}
      return caml_call3(Hashtbl[11],tbl,k,[0,v,l])}
    function incr(opt,tbl,x)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      var n=get_or(tbl,x,0);
      return caml_call2(CCMonomorphic[5],n + by | 0,0)
              ?caml_call2(Hashtbl[10],tbl,x)
              :caml_call3(Hashtbl[11],tbl,x,n + by | 0)}
    function decr(opt,tbl,x)
     {if(opt)var sth=opt[1],by=sth;else var by=1;
      try
       {var
         n=caml_call2(Hashtbl[6],tbl,x),
         _r1_=
          caml_call2(CCMonomorphic[5],n - by | 0,0)
           ?caml_call2(Hashtbl[10],tbl,x)
           :caml_call3(Hashtbl[11],tbl,x,n - by | 0);
        return _r1_}
      catch(_r2_)
       {_r2_ = caml_wrap_exception(_r2_);
        if(_r2_ === Not_found)return 0;
        throw _r2_}}
    function map_list(f,h)
     {var _rZ_=0;
      function _r0_(x,y,acc){return [0,caml_call2(f,x,y),acc]}
      return caml_call3(Hashtbl[14],_r0_,h,_rZ_)}
    function to_seq$1(tbl,k)
     {function _rY_(key,v){return caml_call1(k,[0,key,v])}
      return caml_call2(Hashtbl[12],_rY_,tbl)}
    function add_seq(tbl,seq)
     {return caml_call1
              (seq,
               function(param)
                {var v=param[2],k=param[1];
                 return caml_call3(Hashtbl[5],tbl,k,v)})}
    function of_seq(seq)
     {var tbl=caml_call2(Hashtbl[1],0,32);add_seq(tbl,seq);return tbl}
    function add_seq_count(tbl,seq)
     {return caml_call1(seq,function(k){return incr(0,tbl,k)})}
    function of_seq_count(seq)
     {var tbl=caml_call2(Hashtbl[1],0,32);add_seq_count(tbl,seq);return tbl}
    function to_list$1(tbl)
     {var _rW_=0;
      function _rX_(k,v,l){return [0,[0,k,v],l]}
      return caml_call3(Hashtbl[14],_rX_,tbl,_rW_)}
    function of_list$0(l)
     {var tbl=caml_call2(Hashtbl[1],0,32);
      function _rV_(param)
       {var v=param[2],k=param[1];return caml_call3(Hashtbl[5],tbl,k,v)}
      caml_call2(List[15],_rV_,l);
      return tbl}
    function update(tbl,f,k)
     {var v=get$1(tbl,k),match=caml_call2(f,k,v);
      if(v)
       {if(match){var v$0=match[1];return caml_call3(Hashtbl[11],tbl,k,v$0)}
        return caml_call2(Hashtbl[10],tbl,k)}
      if(match){var v$1=match[1];return caml_call3(Hashtbl[5],tbl,k,v$1)}
      return 0}
    function get_or_add(tbl,f,k)
     {try
       {var _rT_=caml_call2(Hashtbl[6],tbl,k);return _rT_}
      catch(_rU_)
       {_rU_ = caml_wrap_exception(_rU_);
        if(_rU_ === Not_found)
         {var v=caml_call1(f,k);caml_call3(Hashtbl[5],tbl,k,v);return v}
        throw _rU_}}
    function pp$4(pp_k,pp_v,fmt,m)
     {caml_call2(Format[112],fmt,_a3_);
      var first=[0,1];
      function _rS_(k,v)
       {if(first[1])first[1] = 0;else caml_call2(Format[13],fmt,cst$18);
        caml_call2(pp_k,fmt,k);
        caml_call2(Format[13],fmt,cst$17);
        caml_call2(pp_v,fmt,v);
        return caml_call2(Format[27],fmt,0)}
      caml_call2(Hashtbl[12],_rS_,m);
      return caml_call2(Format[112],fmt,_a4_)}
    function Make(X)
     {var
       include=caml_call1(Hashtbl[19],X),
       create=include[1],
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16];
      function get(tbl,x)
       {try
         {var _rQ_=[0,caml_call2(find,tbl,x)];return _rQ_}
        catch(_rR_)
         {_rR_ = caml_wrap_exception(_rR_);
          if(_rR_ === Not_found)return 0;
          throw _rR_}}
      function get_or(tbl,x,default$0)
       {try
         {var _rO_=caml_call2(find,tbl,x);return _rO_}
        catch(_rP_)
         {_rP_ = caml_wrap_exception(_rP_);
          if(_rP_ === Not_found)return default$0;
          throw _rP_}}
      function incr(opt,tbl,x)
       {if(opt)var sth=opt[1],by=sth;else var by=1;
        var n=get_or(tbl,x,0);
        return caml_call2(CCMonomorphic[5],n + by | 0,0)
                ?caml_call2(remove,tbl,x)
                :caml_call3(replace,tbl,x,n + by | 0)}
      function add_list(tbl,k,v)
       {try
         {var _rM_=caml_call2(find,tbl,k),l=_rM_}
        catch(_rN_)
         {_rN_ = caml_wrap_exception(_rN_);
          if(_rN_ !== Not_found)throw _rN_;
          var l=0}
        return caml_call3(replace,tbl,k,[0,v,l])}
      function decr(opt,tbl,x)
       {if(opt)var sth=opt[1],by=sth;else var by=1;
        try
         {var
           n=caml_call2(find,tbl,x),
           _rK_=
            caml_call2(CCMonomorphic[5],n - by | 0,0)
             ?caml_call2(remove,tbl,x)
             :caml_call3(replace,tbl,x,n - by | 0);
          return _rK_}
        catch(_rL_)
         {_rL_ = caml_wrap_exception(_rL_);
          if(_rL_ === Not_found)return 0;
          throw _rL_}}
      function keys(tbl,k)
       {return caml_call2
                (iter,function(key,param){return caml_call1(k,key)},tbl)}
      function values(tbl,k)
       {return caml_call2(iter,function(param,v){return caml_call1(k,v)},tbl)}
      function keys_list(tbl)
       {var _rJ_=0;
        return caml_call3(fold,function(k,param,a){return [0,k,a]},tbl,_rJ_)}
      function values_list(tbl)
       {var _rI_=0;
        return caml_call3(fold,function(param,v,a){return [0,v,a]},tbl,_rI_)}
      function map_list(f,h)
       {var _rH_=0;
        return caml_call3
                (fold,
                 function(x,y,acc){return [0,caml_call2(f,x,y),acc]},
                 h,
                 _rH_)}
      function update(tbl,f,k)
       {var v=get(tbl,k),match=caml_call2(f,k,v);
        if(v)
         {if(match){var v$0=match[1];return caml_call3(replace,tbl,k,v$0)}
          return caml_call2(remove,tbl,k)}
        if(match){var v$1=match[1];return caml_call3(add,tbl,k,v$1)}
        return 0}
      function get_or_add(tbl,f,k)
       {try
         {var _rF_=caml_call2(find,tbl,k);return _rF_}
        catch(_rG_)
         {_rG_ = caml_wrap_exception(_rG_);
          if(_rG_ === Not_found)
           {var v=caml_call1(f,k);caml_call3(add,tbl,k,v);return v}
          throw _rG_}}
      function to_seq(tbl,k)
       {return caml_call2
                (iter,function(key,v){return caml_call1(k,[0,key,v])},tbl)}
      function add_seq(tbl,seq)
       {return caml_call1
                (seq,
                 function(param)
                  {var v=param[2],k=param[1];return caml_call3(add,tbl,k,v)})}
      function of_seq(seq)
       {var tbl=caml_call1(create,32);add_seq(tbl,seq);return tbl}
      function add_seq_count(tbl,seq)
       {return caml_call1(seq,function(k){return incr(0,tbl,k)})}
      function of_seq_count(seq)
       {var tbl=caml_call1(create,32);add_seq_count(tbl,seq);return tbl}
      function to_list(tbl)
       {var _rE_=0;
        return caml_call3(fold,function(k,v,l){return [0,[0,k,v],l]},tbl,_rE_)}
      function of_list(l)
       {var tbl=caml_call1(create,32);
        function _rD_(param)
         {var v=param[2],k=param[1];return caml_call3(add,tbl,k,v)}
        caml_call2(List[15],_rD_,l);
        return tbl}
      function pp(pp_k,pp_v,fmt,m)
       {caml_call2(Format[112],fmt,_a5_);
        var first=[0,1];
        caml_call2
         (iter,
          function(k,v)
           {if(first[1])first[1] = 0;else caml_call2(Format[13],fmt,cst$20);
            caml_call2(pp_k,fmt,k);
            caml_call2(Format[13],fmt,cst$19);
            caml_call2(pp_v,fmt,v);
            return caml_call2(Format[27],fmt,0)},
          m);
        return caml_call2(Format[112],fmt,_a6_)}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              get,
              get_or,
              add_list,
              incr,
              decr,
              keys,
              values,
              keys_list,
              values_list,
              map_list,
              to_seq,
              of_seq,
              add_seq,
              add_seq_count,
              of_seq_count,
              to_list,
              of_list,
              update,
              get_or_add,
              pp]}
    var
     include$2=
      [0,
       get$1,
       get_or,
       keys,
       values,
       keys_list,
       values_list,
       map_list,
       incr,
       decr,
       to_seq$1,
       add_list,
       add_seq,
       of_seq,
       add_seq_count,
       of_seq_count,
       to_list$1,
       of_list$0,
       update,
       get_or_add,
       pp$4],
     CCHashtbl=
      [0,
       include$2,
       get$1,
       get_or,
       keys,
       values,
       keys_list,
       values_list,
       map_list,
       incr,
       decr,
       to_seq$1,
       add_list,
       add_seq,
       of_seq,
       add_seq_count,
       of_seq_count,
       to_list$1,
       of_list$0,
       update,
       get_or_add,
       pp$4,
       Make];
    caml_register_global(298,CCHashtbl,"CCHashtbl");
    function Make$0(E)
     {var empty=0;
      function is_empty(param){return param?0:1}
      var Empty=[248,cst_CCHeap_Make_E_Empty,caml_fresh_oo_id(0)];
      function rank(param){if(param){var r=param[1];return r}return 0}
      function make_node(x,a,b)
       {var _rB_=rank(b),_rC_=rank(a);
        return caml_call2(CCMonomorphic[6],_rC_,_rB_)
                ?[0,rank(b) + 1 | 0,x,a,b]
                :[0,rank(a) + 1 | 0,x,b,a]}
      function merge(t,match)
       {if(match)
         {if(t)
           {var b2=match[4],a2=match[3],y=match[2],b1=t[4],a1=t[3],x=t[2];
            return caml_call2(E[1],x,y)
                    ?make_node(x,a1,merge(b1,match))
                    :make_node(y,a2,merge(t,b2))}
          return match}
        return t}
      function insert(x,h){return merge([0,1,x,0,0],h)}
      function add(h,x){return insert(x,h)}
      function filter(p,h)
       {if(h)
         {var r=h[4],l=h[3],x=h[2];
          if(caml_call1(p,x))
           {var _rz_=filter(p,r);return make_node(x,filter(p,l),_rz_)}
          var _rA_=filter(p,r);
          return merge(filter(p,l),_rA_)}
        return 0}
      function find_min_exn(param)
       {if(param){var x=param[2];return x}throw Empty}
      function find_min(param){if(param){var x=param[2];return [0,x]}return 0}
      function take(param)
       {if(param)
         {var r=param[4],l=param[3],x=param[2];return [0,[0,merge(l,r),x]]}
        return 0}
      function take_exn(param)
       {if(param)
         {var r=param[4],l=param[3],x=param[2];return [0,merge(l,r),x]}
        throw Empty}
      function delete_one(eq,x,h)
       {function aux(h)
         {if(h)
           {var r=h[4],l=h[3],y=h[2];
            if(caml_call2(eq,x,y))return [0,1,merge(l,r)];
            if(caml_call2(E[1],y,x))
             {var match=aux(l),l1=match[2],found_left=match[1];
              if(found_left)
               var found=1,r1=r;
              else
               var _ry_=aux(r),found=_ry_[1],r1=_ry_[2];
              return found?[0,1,make_node(y,l1,r1)]:[0,0,h]}
            return [0,0,h]}
          return _a7_}
        return aux(h)[2]}
      function delete_all(eq,x,h)
       {if(h)
         {var r=h[4],l=h[3],y=h[2];
          if(caml_call2(eq,x,y))
           {var _rw_=delete_all(eq,x,r);return merge(delete_all(eq,x,l),_rw_)}
          if(caml_call2(E[1],y,x))
           {var _rx_=delete_all(eq,x,r);
            return make_node(y,delete_all(eq,x,l),_rx_)}
          return h}
        return 0}
      function iter(f,h)
       {var h$0=h;
        for(;;)
         {if(h$0)
           {var r=h$0[4],l=h$0[3],x=h$0[2];
            caml_call1(f,x);
            iter(f,l);
            var h$0=r;
            continue}
          return 0}}
      function fold(f,acc,h)
       {var acc$0=acc,h$0=h;
        for(;;)
         {if(h$0)
           {var
             b=h$0[4],
             a=h$0[3],
             x=h$0[2],
             acc$1=caml_call2(f,acc$0,x),
             acc$2=fold(f,acc$1,a),
             acc$0=acc$2,
             h$0=b;
            continue}
          return acc$0}}
      function size(param)
       {if(param)
         {var r=param[4],l=param[3],_rv_=size(r);
          return (1 + size(l) | 0) + _rv_ | 0}
        return 0}
      function to_list(h)
       {function aux(acc,h)
         {if(h){var r=h[4],l=h[3],x=h[2];return [0,x,aux(aux(acc,l),r)]}
          return acc}
        return aux(0,h)}
      function to_list_sorted(h)
       {var acc=0,h$0=h;
        for(;;)
         {var match=take(h$0);
          if(match)
           {var
             match$0=match[1],
             x=match$0[2],
             h$1=match$0[1],
             acc$0=[0,x,acc],
             acc=acc$0,
             h$0=h$1;
            continue}
          return caml_call1(List[9],acc)}}
      function add_list(h,l){return caml_call3(List[20],add,h,l)}
      function of_list(l){return add_list(empty,l)}
      function add_seq(h,seq)
       {var h$0=[0,h];
        caml_call1(seq,function(x){h$0[1] = insert(x,h$0[1]);return 0});
        return h$0[1]}
      function of_seq(seq){return add_seq(empty,seq)}
      function to_seq(h,k){return iter(k,h)}
      function to_seq_sorted(h)
       {return function(k)
         {var h$0=h;
          for(;;)
           {var match=take(h$0);
            if(match)
             {var match$0=match[1],x=match$0[2],h$1=match$0[1];
              caml_call1(k,x);
              var h$0=h$1;
              continue}
            return 0}}}
      function add_klist(h,l)
       {var h$0=h,l$0=l;
        for(;;)
         {var match=caml_call1(l$0,0);
          if(typeof match === "number")return h$0;
          var
           match$0=match[2],
           l$1=match$0[2],
           x=match$0[1],
           h$1=add(h$0,x),
           h$0=h$1,
           l$0=l$1;
          continue}}
      function of_klist(l){return add_klist(empty,l)}
      function to_klist(h)
       {function next(stack,param)
         {var stack$0=stack;
          for(;;)
           {if(stack$0)
             {var _rs_=stack$0[1];
              if(_rs_)
               {var
                 stack$1=stack$0[2],
                 b=_rs_[4],
                 a=_rs_[3],
                 x=_rs_[2],
                 _rt_=[0,a,[0,b,stack$1]];
                return [0,
                        748545553,
                        [0,x,function(_ru_){return next(_rt_,_ru_)}]]}
              var stack$2=stack$0[2],stack$0=stack$2;
              continue}
            return 3902385}}
        var _rq_=[0,h,0];
        return function(_rr_){return next(_rq_,_rr_)}}
      function add_gen(h,g)
       {var h$0=h;
        for(;;)
         {var match=caml_call1(g,0);
          if(match){var x=match[1],h$1=add(h$0,x),h$0=h$1;continue}
          return h$0}}
      function of_gen(g){return add_gen(empty,g)}
      function to_gen(h)
       {var stack=caml_call1(Stack[2],0);
        caml_call2(Stack[3],h,stack);
        function next(param)
         {for(;;)
           {if(caml_call1(Stack[8],stack))return 0;
            var match=caml_call1(Stack[4],stack);
            if(match)
             {var b=match[4],a=match[3],x=match[2];
              caml_call2(Stack[3],a,stack);
              caml_call2(Stack[3],b,stack);
              return [0,x]}
            continue}}
        return next}
      function to_tree(h,param)
       {if(h)
         {var
           r=h[4],
           l=h[3],
           x=h[2],
           _rm_=0,
           _rn_=[0,function(_rp_){return to_tree(r,_rp_)},_rm_];
          return [0,
                  870528546,
                  [0,x,[0,function(_ro_){return to_tree(l,_ro_)},_rn_]]]}
        return 3902385}
      function pp(opt,pp_elt,out,h)
       {if(opt)var sth=opt[1],sep=sth;else var sep=cst$21;
        var first=[0,1];
        return iter
                (function(x)
                  {if(first[1])
                    first[1] = 0;
                   else
                    caml_call3(Format[112],out,_a8_,sep);
                   return caml_call2(pp_elt,out,x)},
                 h)}
      return [0,
              empty,
              is_empty,
              Empty,
              merge,
              insert,
              add,
              filter,
              find_min,
              find_min_exn,
              take,
              take_exn,
              delete_one,
              delete_all,
              iter,
              fold,
              size,
              to_list,
              to_list_sorted,
              add_list,
              of_list,
              add_seq,
              of_seq,
              to_seq,
              to_seq_sorted,
              add_klist,
              of_klist,
              to_klist,
              add_gen,
              of_gen,
              to_gen,
              to_tree,
              pp]}
    function Make_from_compare(E)
     {function leq(a,b)
       {var _rl_=caml_call2(E[1],a,b);
        return caml_call2(CCMonomorphic[5],_rl_,0)}
      return Make$0([0,leq])}
    var CCHeap=[0,Make$0,Make_from_compare];
    caml_register_global(299,CCHeap,"CCHeap");
    function gen_empty(param){return 0}
    function gen_singleton(x)
     {var done=[0,0];
      return function(param){return done[1]?0:(done[1] = 1,[0,x])}}
    function gen_of_array(arr)
     {var r=[0,0];
      return function(param)
       {if(caml_call2(CCMonomorphic[1],r[1],arr.length - 1))return 0;
        var _rk_=r[1],x=caml_check_bound(arr,_rk_)[_rk_ + 1];
        r[1]++;
        return [0,x]}}
    function gen_flat_map(f,next_elem)
     {var state=[0,815032112];
      function get_next_gen(param)
       {var match=caml_call1(next_elem,0);
        if(match)
         {var x=match[1];
          try
           {state[1] = [0,4103979,caml_call1(f,x)];
            var _rj_=next(0);
            return _rj_}
          catch(e){e = caml_wrap_exception(e);state[1] = 926227490;throw e}}
        state[1] = 926227490;
        return 0}
      function next(param)
       {var _ri_=state[1];
        if(typeof _ri_ === "number")
         return 926227490 <= _ri_?0:get_next_gen(0);
        var gen=_ri_[2],x=caml_call1(gen,0);
        return x?x:get_next_gen(0)}
      return next}
    function finally$1(f,x,h)
     {try
       {var res=caml_call1(f,x);caml_call1(h,x);return res}
      catch(e){e = caml_wrap_exception(e);caml_call1(h,x);throw e}}
    function with_in(opt,_rh_,filename,f)
     {if(opt)var sth=opt[1],mode=sth;else var mode=420;
      if(_rh_)var sth$0=_rh_[1],flags=sth$0;else var flags=_a9_;
      var ic=caml_call3(Pervasives[69],[0,0,flags],mode,filename);
      return finally$1(f,ic,Pervasives[81])}
    function read_chunks(opt,ic)
     {if(opt)var sth=opt[1],size=sth;else var size=1024;
      var buf=caml_create_bytes(size);
      function next(param)
       {var n=caml_call4(Pervasives[72],ic,buf,0,size);
        return caml_call2(CCMonomorphic[1],n,0)
                ?0
                :[0,caml_call3(Bytes[8],buf,0,n)]}
      return next}
    function read_line(ic)
     {try
       {var _rf_=[0,caml_call1(Pervasives[71],ic)];return _rf_}
      catch(_rg_)
       {_rg_ = caml_wrap_exception(_rg_);
        if(_rg_ === End_of_file)return 0;
        throw _rg_}}
    function read_lines(ic)
     {var stop=[0,0];
      return function(param)
       {if(stop[1])return 0;
        try
         {var _rd_=[0,caml_call1(Pervasives[71],ic)];return _rd_}
        catch(_re_)
         {_re_ = caml_wrap_exception(_re_);
          if(_re_ === End_of_file){stop[1] = 1;return 0}
          throw _re_}}}
    function read_lines_l(ic)
     {var l=[0,0];
      try
       {for(;;)
         {var _rb_=l[1];
          l[1] = [0,caml_call1(Pervasives[71],ic),_rb_];
          continue}}
      catch(_rc_)
       {_rc_ = caml_wrap_exception(_rc_);
        if(_rc_ === End_of_file)return caml_call1(List[9],l[1]);
        throw _rc_}}
    function read_all(op,size,ic)
     {var buf=[0,caml_create_bytes(size)],len=[0,0];
      try
       {for(;;)
         {if(caml_call2(CCMonomorphic[1],len[1],caml_ml_bytes_length(buf[1])))
           buf[1] = caml_call3(Bytes[9],buf[1],0,len[1]);
          if(caml_call2(CCMonomorphic[4],caml_ml_bytes_length(buf[1]),len[1]))
           {var
             n=
              caml_call4
               (Pervasives[72],
                ic,
                buf[1],
                len[1],
                caml_ml_bytes_length(buf[1]) - len[1] | 0);
            len[1] = len[1] + n | 0;
            if(caml_call2(CCMonomorphic[1],n,0))throw Pervasives[3];
            continue}
          throw [0,Assert_failure,_a__]}}
      catch(_ra_)
       {_ra_ = caml_wrap_exception(_ra_);
        if(_ra_ === Pervasives[3])
         return 0 === op
                 ?caml_call3(Bytes[8],buf[1],0,len[1])
                 :caml_call3(Bytes[7],buf[1],0,len[1]);
        throw _ra_}}
    function read_all_bytes(opt,ic)
     {if(opt)var sth=opt[1],size=sth;else var size=1024;
      return read_all(1,size,ic)}
    function read_all$0(opt,ic)
     {if(opt)var sth=opt[1],size=sth;else var size=1024;
      return read_all(0,size,ic)}
    function with_out(opt,_q$_,filename,f)
     {if(opt)var sth=opt[1],mode=sth;else var mode=420;
      if(_q$_)var sth$0=_q$_[1],flags=sth$0;else var flags=_a$_;
      var oc=caml_call3(Pervasives[50],[0,1,flags],mode,filename);
      return finally$1(f,oc,Pervasives[64])}
    function with_out_a(mode,opt,filename,f)
     {if(opt)var sth=opt[1],flags=sth;else var flags=0;
      return with_out(mode,[0,[0,1,[0,3,[0,2,flags]]]],filename,f)}
    function write_line(oc,s)
     {caml_call2(Pervasives[54],oc,s);return caml_call2(Pervasives[53],oc,10)}
    function write_gen(opt,oc,g)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$22;
      var match$0=caml_call1(g,0);
      if(match$0)
       {var s$0=match$0[1];
        caml_call2(Pervasives[54],oc,s$0);
        for(;;)
         {var match=caml_call1(g,0);
          if(match)
           {var s=match[1];
            caml_call2(Pervasives[54],oc,sep);
            caml_call2(Pervasives[54],oc,s);
            continue}
          return 0}}
      return 0}
    function write_lines(oc,g)
     {for(;;)
       {var match=caml_call1(g,0);
        if(match){var l=match[1];write_line(oc,l);continue}
        return 0}}
    function write_lines_l(oc,l)
     {function _q9_(_q__){return write_line(oc,_q__)}
      return caml_call2(List[15],_q9_,l)}
    function with_in_out(opt,_q8_,filename,f)
     {if(opt)var sth=opt[1],mode=sth;else var mode=420;
      if(_q8_)var sth$0=_q8_[1],flags=sth$0;else var flags=_ba_;
      var
       ic=caml_call3(Pervasives[69],[0,0,flags],mode,filename),
       oc=caml_call3(Pervasives[50],[0,1,flags],mode,filename);
      try
       {var x=caml_call2(f,ic,oc);
        caml_call1(Pervasives[64],oc);
        caml_call1(Pervasives[81],ic);
        return x}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[65],oc);
        caml_call1(Pervasives[82],ic);
        throw e}}
    function tee$0(funs,g,param)
     {var res=caml_call1(g,0);
      if(res)
       {var
         x=res[1],
         _q5_=
          function(f)
           {try {var _q6_=caml_call1(f,x);return _q6_}catch(_q7_){return 0}};
        caml_call2(List[15],_q5_,funs);
        return res}
      return 0}
    function to_string$1(f){return f}
    function make$0(f)
     {if(caml_call1(Filename[5],f))
       {var _q4_=runtime.caml_sys_getcwd(0);
        return caml_call2(Filename[4],_q4_,f)}
      return f}
    var
     exists$1=caml_sys_file_exists,
     is_directory=caml_sys_is_directory,
     remove_exn=caml_sys_remove;
    function remove(f)
     {try
       {var _q3_=[0,caml_sys_remove(f)];return _q3_}
      catch(exn)
       {exn = caml_wrap_exception(exn);return [1,caml_call1(Printexc[1],exn)]}}
    function read_exn(f)
     {var _q0_=4096,_q1_=0;
      return with_in(0,0,f,function(_q2_){return read_all(_q1_,_q0_,_q2_)})}
    function read(f)
     {try
       {var _qZ_=[0,read_exn(f)];return _qZ_}
      catch(e)
       {e = caml_wrap_exception(e);return [1,caml_call1(Printexc[1],e)]}}
    function append_exn(f,x)
     {return with_out
              (0,
               _bb_,
               f,
               function(oc)
                {caml_call2(Pervasives[54],oc,x);
                 return caml_call1(Pervasives[51],oc)})}
    function append$0(f,x)
     {try
       {var _qY_=[0,append_exn(f,x)];return _qY_}
      catch(e)
       {e = caml_wrap_exception(e);return [1,caml_call1(Printexc[1],e)]}}
    function write_exn(f,x)
     {return with_out
              (0,
               0,
               f,
               function(oc)
                {caml_call2(Pervasives[54],oc,x);
                 return caml_call1(Pervasives[51],oc)})}
    function write(f,x)
     {try
       {var _qX_=[0,write_exn(f,x)];return _qX_}
      catch(e)
       {e = caml_wrap_exception(e);return [1,caml_call1(Printexc[1],e)]}}
    function remove_noerr(f)
     {try {var _qV_=caml_sys_remove(f);return _qV_}catch(_qW_){return 0}}
    function cons(x,tl)
     {var first=[0,1];
      return function(param)
       {return first[1]?(first[1] = 0,[0,x]):caml_call1(tl,0)}}
    function walk(d)
     {if(caml_sys_file_exists(d))
       {if(caml_sys_is_directory(d))
         {try
           {var _qT_=caml_sys_read_directory(d),arr=_qT_}
          catch(_qU_)
           {_qU_ = caml_wrap_exception(_qU_);
            if(_qU_[1] !== Sys_error)throw _qU_;
            var arr=[0]}
          var
           tail=gen_of_array(arr),
           tail$0=
            gen_flat_map
             (function(s){return walk(caml_call2(Filename[4],d,s))},tail);
          return cons([0,3405101,d],tail$0)}
        return gen_singleton([0,781515420,d])}
      return gen_empty}
    function walk_l(d)
     {var l=[0,0],g=walk(d);
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1];l[1] = [0,x,l[1]];continue}
        return l[1]}}
    function read_dir(opt,d)
     {if(opt)var sth=opt[1],recurse=sth;else var recurse=0;
      if(recurse)
       {var
         gen=walk(d),
         next=
          function(param)
           {for(;;)
             {var match=caml_call1(gen,0);
              if(match)
               {var x=match[1];
                if(781515420 <= x[1])var f=x[2],res=[0,f];else var res=0;
                if(res)return res;
                continue}
              return 0}};
        return next}
      if(caml_sys_is_directory(d))
       {var arr=caml_sys_read_directory(d);return gen_of_array(arr)}
      return function(param){return 0}}
    function show_walk_item(param)
     {var f=param[2],i=param[1],_qS_=781515420 <= i?cst_file:cst_dir;
      return caml_call2(Pervasives[16],_qS_,f)}
    function with_temp(temp_dir,prefix,suffix,f)
     {var name=caml_call3(Filename[14],temp_dir,prefix,suffix);
      return finally$1(f,name,remove_noerr)}
    var
     CCIO=
      [0,
       with_in,
       read_chunks,
       read_line,
       read_lines,
       read_lines_l,
       read_all$0,
       read_all_bytes,
       with_out,
       with_out_a,
       write_line,
       write_gen,
       write_lines,
       write_lines_l,
       with_in_out,
       tee$0,
       [0,
        to_string$1,
        make$0,
        exists$1,
        is_directory,
        remove_exn,
        remove,
        remove_noerr,
        read_dir,
        read_exn,
        read,
        append_exn,
        append$0,
        write_exn,
        write,
        walk,
        walk_l,
        show_walk_item,
        with_temp]];
    caml_register_global(305,CCIO,"CCIO");
    var
     zero=Int32[1],
     one=Int32[2],
     minus_one=Int32[3],
     succ=Int32[4],
     pred=Int32[5],
     abs$0=Int32[6],
     max_int=Int32[7],
     min_int=Int32[8],
     lnot$0=Int32[9],
     to_string$2=Int32[11],
     compare$4=Int32[12],
     equal$5=caml_equal;
    function _bc_(_qR_,_qQ_){return _qR_ + _qQ_ | 0}
    function _bd_(_qP_,_qO_){return _qP_ - _qO_ | 0}
    function _be_(_qN_){return - _qN_ | 0}
    function _bf_(_qM_,_qL_){return caml_mul(_qM_,_qL_)}
    var _bg_=caml_div,mod=caml_mod;
    function land(_qK_,_qJ_){return _qK_ & _qJ_}
    function lor(_qI_,_qH_){return _qI_ | _qH_}
    function lxor(_qG_,_qF_){return _qG_ ^ _qF_}
    function lsl(_qE_,_qD_){return _qE_ << _qD_}
    function lsr(_qC_,_qB_){return _qC_ >>> _qB_ | 0}
    function asr(_qA_,_qz_){return _qA_ >> _qz_}
    var
     _bh_=caml_notequal,
     _bi_=caml_lessthan,
     _bj_=caml_lessequal,
     _bk_=caml_greaterthan,
     _bl_=caml_greaterequal;
    function hash$0(x){return caml_call1(Pervasives[6],x)}
    var of_string_exn$0=caml_int_of_string;
    function of_string$1(x)
     {try
       {var _qx_=[0,caml_int_of_string(x)];return _qx_}
      catch(_qy_)
       {_qy_ = caml_wrap_exception(_qy_);
        if(_qy_[1] === Failure)return 0;
        throw _qy_}}
    function _bm_(_qw_){return _qw_ | 0}
    function _bn_(_qv_){return _qv_}
    function _bo_(_qu_){return _qu_}
    var
     CCInt32=
      [0,
       zero,
       one,
       minus_one,
       succ,
       pred,
       abs$0,
       max_int,
       min_int,
       lnot$0,
       compare$4,
       [0,
        _bc_,
        _bd_,
        _be_,
        _bf_,
        _bg_,
        mod,
        land,
        lor,
        lxor,
        lnot$0,
        lsl,
        lsr,
        asr,
        equal$5,
        _bh_,
        _bk_,
        _bl_,
        _bj_,
        _bi_],
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       mod,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       lsr,
       asr,
       equal$5,
       _bh_,
       _bk_,
       _bl_,
       _bj_,
       _bi_,
       equal$5,
       hash$0,
       function(_qt_){return _qt_},
       _bo_,
       _bn_,
       _bm_,
       to_string$2,
       of_string_exn$0,
       of_string$1,
       of_string$1];
    caml_register_global(308,CCInt32,"CCInt32");
    var
     zero$0=Int64[1],
     one$0=Int64[2],
     minus_one$0=Int64[3],
     succ$0=Int64[4],
     pred$0=Int64[5],
     abs$1=Int64[6],
     max_int$0=Int64[7],
     min_int$0=Int64[8],
     lnot$1=Int64[9],
     to_string$3=Int64[11],
     compare$5=Int64[12],
     equal$6=caml_equal,
     _bp_=runtime.caml_int64_add,
     _bq_=runtime.caml_int64_sub,
     _br_=runtime.caml_int64_neg,
     _bs_=runtime.caml_int64_mul,
     _bt_=runtime.caml_int64_div,
     mod$0=runtime.caml_int64_mod,
     land$0=runtime.caml_int64_and,
     lor$0=runtime.caml_int64_or,
     lxor$0=runtime.caml_int64_xor,
     lsl$0=runtime.caml_int64_shift_left,
     lsr$0=runtime.caml_int64_shift_right_unsigned,
     asr$0=runtime.caml_int64_shift_right,
     _bu_=caml_notequal,
     _bv_=caml_lessthan,
     _bw_=caml_lessequal,
     _bx_=caml_greaterthan,
     _by_=caml_greaterequal;
    function hash$1(x)
     {return caml_call1(Pervasives[6],caml_int64_to_int32(x))}
    var
     of_int_exn$0=caml_int64_of_int32,
     of_nativeint_exn=caml_int64_of_int32,
     of_int32_exn=caml_int64_of_int32,
     of_float_exn=caml_int64_of_float,
     of_string_exn$1=caml_int64_of_string;
    function of_string$2(x)
     {try
       {var _qr_=[0,caml_int64_of_string(x)];return _qr_}
      catch(_qs_)
       {_qs_ = caml_wrap_exception(_qs_);
        if(_qs_[1] === Failure)return 0;
        throw _qs_}}
    var
     CCInt64=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       succ$0,
       pred$0,
       lnot$1,
       abs$1,
       max_int$0,
       min_int$0,
       [0,
        _bp_,
        _bq_,
        _br_,
        _bs_,
        _bt_,
        mod$0,
        land$0,
        lor$0,
        lxor$0,
        lnot$1,
        lsl$0,
        lsr$0,
        asr$0,
        equal$6,
        _bu_,
        _bx_,
        _by_,
        _bw_,
        _bv_],
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       mod$0,
       land$0,
       lor$0,
       lxor$0,
       lnot$1,
       lsl$0,
       lsr$0,
       asr$0,
       equal$6,
       _bu_,
       _bx_,
       _by_,
       _bw_,
       _bv_,
       equal$6,
       compare$5,
       hash$1,
       caml_int64_to_int32,
       caml_int64_of_int32,
       of_int_exn$0,
       caml_int64_to_int32,
       caml_int64_of_int32,
       of_int32_exn,
       caml_int64_to_int32,
       caml_int64_of_int32,
       of_nativeint_exn,
       runtime.caml_int64_to_float,
       caml_int64_of_float,
       of_float_exn,
       to_string$3,
       of_string$2,
       of_string$2,
       of_string_exn$1];
    caml_register_global(310,CCInt64,"CCInt64");
    var
     length$1=List[1],
     compare_lengths=List[2],
     compare_length_with=List[3],
     hd=List[5],
     tl=List[6],
     nth=List[7],
     nth_opt=List[8],
     rev$0=List[9],
     rev_append=List[12],
     concat$0=List[13],
     iter$1=List[15],
     rev_map=List[19],
     fold_left$0=List[20],
     iter2$1=List[22],
     map2$0=List[23],
     rev_map2=List[24],
     fold_left2=List[25],
     fold_right2=List[26],
     for_all$1=List[27],
     exists$2=List[28],
     for_all2$1=List[29],
     exists2$1=List[30],
     memq$0=List[32],
     find$2=List[33],
     find_opt=List[34],
     find_all=List[36],
     partition=List[37],
     assq=List[40],
     assq_opt=List[41],
     mem_assq=List[43],
     remove_assq=List[45],
     sort$0=List[48],
     stable_sort$0=List[49],
     fast_sort$0=List[50],
     merge=List[52],
     empty$1=0;
    function is_empty(param){return param?0:1}
    var direct_depth_default=1e3;
    function map$2(f,l)
     {function direct(f,i,l)
       {if(l)
         {var _ql_=l[2],_qm_=l[1];
          if(_ql_)
           {var _qn_=_ql_[2],_qo_=_ql_[1];
            if(_qn_)
             {if(_qn_[2])
               {if(caml_call2(CCMonomorphic[1],i,0))
                 {var tuple_acc=0,xs=l;
                  for(;;)
                   {if(xs)
                     {var _qd_=xs[2];
                      if(_qd_)
                       {var _qe_=_qd_[2];
                        if(_qe_)
                         {var _qf_=_qe_[2];
                          if(_qf_)
                           {var _qg_=_qf_[2];
                            if(_qg_)
                             {var _qh_=_qg_[2];
                              if(_qh_)
                               {var _qi_=_qh_[2];
                                if(_qi_)
                                 {var _qj_=_qi_[2];
                                  if(_qj_)
                                   {var _qk_=_qj_[2];
                                    if(_qk_)
                                     {var
                                       xs$0=_qk_[2],
                                       x8=_qk_[1],
                                       x7=_qj_[1],
                                       x6=_qi_[1],
                                       x5=_qh_[1],
                                       x4=_qg_[1],
                                       x3=_qf_[1],
                                       x2=_qe_[1],
                                       x1=_qd_[1],
                                       x0=xs[1],
                                       y0$0=caml_call1(f,x0),
                                       y1$0=caml_call1(f,x1),
                                       y2$0=caml_call1(f,x2),
                                       y3$0=caml_call1(f,x3),
                                       y4$0=caml_call1(f,x4),
                                       y5$0=caml_call1(f,x5),
                                       y6$0=caml_call1(f,x6),
                                       y7$0=caml_call1(f,x7),
                                       y8$0=caml_call1(f,x8),
                                       tuple_acc$0=
                                        [0,
                                         [0,y0$0,y1$0,y2$0,y3$0,y4$0,y5$0,y6$0,y7$0,y8$0],
                                         tuple_acc],
                                       tuple_acc=tuple_acc$0,
                                       xs=xs$0;
                                      continue}}}}}}}}}
                    var
                     tail_acc$1=caml_call2(List[17],f,xs),
                     tail_acc=tail_acc$1,
                     param=tuple_acc;
                    for(;;)
                     {if(param)
                       {var
                         param$0=param[2],
                         match=param[1],
                         y8=match[9],
                         y7=match[8],
                         y6=match[7],
                         y5=match[6],
                         y4=match[5],
                         y3=match[4],
                         y2=match[3],
                         y1=match[2],
                         y0=match[1],
                         tail_acc$0=
                          [0,
                           y0,
                           [0,
                            y1,
                            [0,y2,[0,y3,[0,y4,[0,y5,[0,y6,[0,y7,[0,y8,tail_acc]]]]]]]]],
                         tail_acc=tail_acc$0,
                         param=param$0;
                        continue}
                      return tail_acc}}}
                var
                 _qp_=l[2],
                 _qq_=_qp_[2],
                 match$0=_qq_[2],
                 l$0=match$0[2],
                 x4$0=match$0[1],
                 x3$0=_qq_[1],
                 x2$0=_qp_[1],
                 x1$0=l[1],
                 y1$1=caml_call1(f,x1$0),
                 y2$1=caml_call1(f,x2$0),
                 y3$1=caml_call1(f,x3$0),
                 y4$1=caml_call1(f,x4$0);
                return [0,
                        y1$1,
                        [0,y2$1,[0,y3$1,[0,y4$1,direct(f,i - 1 | 0,l$0)]]]]}
              var
               x3$1=_qn_[1],
               y1$2=caml_call1(f,_qm_),
               y2$2=caml_call1(f,_qo_);
              return [0,y1$2,[0,y2$2,[0,caml_call1(f,x3$1),0]]]}
            var y1$3=caml_call1(f,_qm_);
            return [0,y1$3,[0,caml_call1(f,_qo_),0]]}
          return [0,caml_call1(f,_qm_),0]}
        return 0}
      return direct(f,direct_depth_default,l)}
    function _bz_(l,f){return map$2(f,l)}
    var direct_depth_append=1e4;
    function cons$0(x,l){return [0,x,l]}
    function append$1(l1,l2)
     {function direct(i,l1,l2)
       {if(l1)
         {if(caml_call2(CCMonomorphic[1],i,0))
           {var _qc_=caml_call1(List[9],l1);
            return caml_call2(List[12],_qc_,l2)}
          var l1$0=l1[2],x=l1[1];
          return [0,x,direct(i - 1 | 0,l1$0,l2)]}
        return l2}
      if(l1)
       {var _qa_=l1[2],_qb_=l1[1];
        if(_qa_)
         {if(_qa_[2])return direct(direct_depth_append,l1,l2);
          var y=_qa_[1];
          return [0,_qb_,[0,y,l2]]}
        return [0,_qb_,l2]}
      return l2}
    function cons_maybe(o,l){if(o){var x=o[1];return [0,x,l]}return l}
    var direct_depth_filter=1e4;
    function filter$0(p,l)
     {function direct(i,p,l)
       {var l$0=l;
        for(;;)
         {if(l$0)
           {if(caml_call2(CCMonomorphic[1],i,0))
             {var l$2=l$0,acc=0;
              for(;;)
               {if(l$2)
                 {var l$3=l$2[2],x$0=l$2[1];
                  if(caml_call1(p,x$0))
                   {var acc$0=[0,x$0,acc],l$2=l$3,acc=acc$0;continue}
                  var l$2=l$3;
                  continue}
                return caml_call1(List[9],acc)}}
            var l$1=l$0[2],x=l$0[1];
            if(caml_call1(p,x))return [0,x,direct(i - 1 | 0,p,l$1)];
            var l$0=l$1;
            continue}
          return 0}}
      return direct(direct_depth_filter,p,l)}
    function fold_right$0(f,l,acc)
     {function direct(i,f,l,acc)
       {if(l)
         {if(caml_call2(CCMonomorphic[1],i,0))
           {var l$0=caml_call1(List[9],l),l$2=l$0,acc$1=acc;
            for(;;)
             {if(l$2)
               {var
                 l$3=l$2[2],
                 x$0=l$2[1],
                 acc$2=caml_call2(f,x$0,acc$1),
                 l$2=l$3,
                 acc$1=acc$2;
                continue}
              return acc$1}}
          var l$1=l[2],x=l[1],acc$0=direct(i - 1 | 0,f,l$1,acc);
          return caml_call2(f,x,acc$0)}
        return acc}
      return direct(direct_depth_default,f,l,acc)}
    function fold_while$1(f,acc,param)
     {var acc$0=acc,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           e=param$0[1],
           match=caml_call2(f,acc$0,e),
           cont=match[2],
           acc$1=match[1];
          if(926227490 <= cont)return acc$1;
          var acc$0=acc$1,param$0=l;
          continue}
        return acc$0}}
    function fold_map$0(f,acc,l)
     {var acc$0=acc,map_acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1],
           map_acc$0=[0,y,map_acc],
           acc$0=acc$1,
           map_acc=map_acc$0,
           l$0=l$1;
          continue}
        return [0,acc$0,caml_call1(List[9],map_acc)]}}
    function scan_left$0(f,acc,l)
     {var l_acc$1=[0,acc,0],acc$0=acc,l_acc=l_acc$1,l$0=l;
      for(;;)
       {if(l$0)
         {var
           tail=l$0[2],
           x=l$0[1],
           acc$1=caml_call2(f,acc$0,x),
           l_acc$0=[0,acc$1,l_acc],
           acc$0=acc$1,
           l_acc=l_acc$0,
           l$0=tail;
          continue}
        return caml_call1(List[9],l_acc)}}
    function fold_map2(f,acc,l1,l2)
     {var acc$0=acc,map_acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             match=caml_call3(f,acc$0,x1,x2),
             y=match[2],
             acc$1=match[1],
             map_acc$0=[0,y,map_acc],
             acc$0=acc$1,
             map_acc=map_acc$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return [0,acc$0,caml_call1(List[9],map_acc)];
        return caml_call1(Pervasives[1],cst_fold_map2)}}
    function fold_filter_map(f,acc,l)
     {var acc$0=acc,map_acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1],
           map_acc$0=cons_maybe(y,map_acc),
           acc$0=acc$1,
           map_acc=map_acc$0,
           l$0=l$1;
          continue}
        return [0,acc$0,caml_call1(List[9],map_acc)]}}
    function fold_flat_map(f,acc,l)
     {var acc$0=acc,map_acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           match=caml_call2(f,acc$0,x),
           y=match[2],
           acc$1=match[1],
           map_acc$0=caml_call2(List[12],y,map_acc),
           acc$0=acc$1,
           map_acc=map_acc$0,
           l$0=l$1;
          continue}
        return [0,acc$0,caml_call1(List[9],map_acc)]}}
    function init$0(len,f)
     {if(caml_call2(CCMonomorphic[3],len,0))
       return caml_call1(Pervasives[1],cst_init);
      if(caml_call2(CCMonomorphic[1],len,0))return 0;
      var i$1=len - 1 | 0,acc=0,i=i$1;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,0))return [0,caml_call1(f,i),acc];
        var i$0=i - 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
        continue}}
    function compare$6(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             c=caml_call2(f,x1,x2);
            if(caml_call2(CCMonomorphic[2],c,0))return c;
            var l1$0=l1$1,l2$0=l2$1;
            continue}
          return 1}
        return l2$0?-1:0}}
    function equal$7(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             _p$_=caml_call2(f,x1,x2);
            if(_p$_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _p$_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function flat_map$0(f,l)
     {function kont$1(l){return l}
      var l$0=l,kont=kont$1;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           l$2=caml_call1(f,x),
           kont$2=
            function(kont,l)
             {function kont$0(tail)
               {if(l)
                 {var _p9_=l[2],_p__=l[1];
                  if(_p9_)
                   {if(_p9_[2])return kont(append$1(l,tail));
                    var y=_p9_[1];
                    return kont([0,_p__,[0,y,tail]])}
                  return kont([0,_p__,tail])}
                return kont(tail)}
              return kont$0},
           kont$0=kont$2(kont,l$2),
           l$0=l$1,
           kont=kont$0;
          continue}
        return kont(0)}}
    function flatten(l){return fold_right$0(append$1,l,0)}
    function count(f,l)
     {var _p8_=0;
      return caml_call3
              (fold_left$0,
               function(n,x){return caml_call1(f,x)?n + 1 | 0:n},
               _p8_,
               l)}
    function product(f,l1,l2)
     {return flat_map$0
              (function(x)
                {return map$2(function(y){return caml_call2(f,x,y)},l2)},
               l1)}
    function fold_product(f,acc,l1,l2)
     {function _p6_(acc,x1)
       {function _p7_(acc,x2){return caml_call3(f,acc,x1,x2)}
        return caml_call3(List[20],_p7_,acc,l2)}
      return caml_call3(List[20],_p6_,acc,l1)}
    function diagonal(l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           _p5_=function(x){return function(acc,y){return [0,[0,x,y],acc]}}(x),
           acc$0=caml_call3(List[20],_p5_,acc,l$1),
           acc=acc$0,
           l$0=l$1;
          continue}
        return acc}}
    function partition_map(f,l)
     {var l1=0,l2=0,l$0=l;
      for(;;)
       {if(l$0)
         {var tl=l$0[2],x=l$0[1],match=caml_call1(f,x);
          if(typeof match === "number"){var l$0=tl;continue}
          if(847852583 <= match[1])
           {var y=match[2],l1$0=[0,y,l1],l1=l1$0,l$0=tl;continue}
          var y$0=match[2],l2$0=[0,y$0,l2],l2=l2$0,l$0=tl;
          continue}
        var _p4_=caml_call1(List[9],l2);
        return [0,caml_call1(List[9],l1),_p4_]}}
    function combine$0(l1,l2)
     {function direct(i,l1,l2)
       {if(! l1)if(! l2)return 0;
        if(caml_call2(CCMonomorphic[1],i,0))
         {var l1$1=l1,l2$1=l2,acc=0;
          for(;;)
           {if(l1$1)
             {if(l2$1)
               {var
                 l2$2=l2$1[2],
                 x2$0=l2$1[1],
                 l1$2=l1$1[2],
                 x1$0=l1$1[1],
                 acc$0=[0,[0,x1$0,x2$0],acc],
                 l1$1=l1$2,
                 l2$1=l2$2,
                 acc=acc$0;
                continue}}
            else
             if(! l2$1)return caml_call1(List[9],acc);
            return caml_call1(Pervasives[1],cst_CCList_combine$0)}}
        if(l1)
         if(l2)
          {var l2$0=l2[2],x2=l2[1],l1$0=l1[2],x1=l1[1];
           return [0,[0,x1,x2],direct(i - 1 | 0,l1$0,l2$0)]}
        return caml_call1(Pervasives[1],cst_CCList_combine)}
      return direct(direct_depth_default,l1,l2)}
    function combine_gen(l1,l2)
     {var l1$0=[0,l1],l2$0=[0,l2];
      return function(param)
       {var _p2_=l1$0[1],_p3_=l2$0[1];
        if(_p2_)
         if(_p3_)
          {var tail2=_p3_[2],x2=_p3_[1],tail1=_p2_[2],x1=_p2_[1];
           l1$0[1] = tail1;
           l2$0[1] = tail2;
           return [0,[0,x1,x2]]}
        return 0}}
    function split(l)
     {function direct(i,l)
       {if(l)
         {var _pH_=l[2],_pI_=l[1],_pJ_=_pI_[2],_pK_=_pI_[1];
          if(_pH_)
           {var _pL_=_pH_[2],_pM_=_pH_[1],_pN_=_pM_[2],_pO_=_pM_[1];
            if(_pL_)
             {var _pP_=_pL_[2],_pQ_=_pL_[1],_pR_=_pQ_[2],_pS_=_pQ_[1];
              if(_pP_)
               {if(_pP_[2])
                 {if(caml_call2(CCMonomorphic[1],i,0))
                   {var acc1=0,acc2=0,l$1=l;
                    for(;;)
                     {if(l$1)
                       {var
                         l$2=l$1[2],
                         match$2=l$1[1],
                         x2$0=match$2[2],
                         x1$0=match$2[1],
                         acc1$0=[0,x1$0,acc1],
                         acc2$0=[0,x2$0,acc2],
                         acc1=acc1$0,
                         acc2=acc2$0,
                         l$1=l$2;
                        continue}
                      var _p1_=caml_call1(List[9],acc2);
                      return [0,caml_call1(List[9],acc1),_p1_]}}
                  var
                   _pT_=l[2],
                   _pU_=_pT_[2],
                   _pV_=_pU_[2],
                   _pW_=_pV_[2],
                   l$0=_pW_[2],
                   _pX_=_pW_[1],
                   y5=_pX_[2],
                   x5=_pX_[1],
                   _pY_=_pV_[1],
                   y4=_pY_[2],
                   x4=_pY_[1],
                   _pZ_=_pU_[1],
                   y3=_pZ_[2],
                   x3=_pZ_[1],
                   _p0_=_pT_[1],
                   y2=_p0_[2],
                   x2=_p0_[1],
                   match=l[1],
                   y1=match[2],
                   x1=match[1],
                   match$0=direct(i - 1 | 0,l$0),
                   ry=match$0[2],
                   rx=match$0[1];
                  return [0,
                          [0,x1,[0,x2,[0,x3,[0,x4,[0,x5,rx]]]]],
                          [0,y1,[0,y2,[0,y3,[0,y4,[0,y5,ry]]]]]]}
                var match$1=_pP_[1],y4$0=match$1[2],x4$0=match$1[1];
                return [0,
                        [0,_pK_,[0,_pO_,[0,_pS_,[0,x4$0,0]]]],
                        [0,_pJ_,[0,_pN_,[0,_pR_,[0,y4$0,0]]]]]}
              return [0,
                      [0,_pK_,[0,_pO_,[0,_pS_,0]]],
                      [0,_pJ_,[0,_pN_,[0,_pR_,0]]]]}
            return [0,[0,_pK_,[0,_pO_,0]],[0,_pJ_,[0,_pN_,0]]]}
          return [0,[0,_pK_,0],[0,_pJ_,0]]}
        return _bA_}
      return direct(direct_depth_default,l)}
    function return$1(x){return [0,x,0]}
    function _bB_(l,f){return flat_map$0(f,l)}
    function _bC_(funs,l)
     {return product(function(f,x){return caml_call1(f,x)},funs,l)}
    function cartesian_product(l)
     {function prod_rec(left,right,k,acc)
       {if(right)
         {var
           tail=right[2],
           l1=right[1],
           _pG_=function(acc,x){return prod_rec([0,x,left],tail,k,acc)};
          return caml_call3(List[20],_pG_,acc,l1)}
        return caml_call2(k,acc,caml_call1(List[9],left))}
      var _pF_=0;
      return prod_rec(0,l,function(acc,l){return [0,l,acc]},_pF_)}
    function map_product_l(f,l)
     {var l$0=caml_call2(List[17],f,l);return cartesian_product(l$0)}
    function sorted_merge(cmp,l1,l2)
     {var acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             c=caml_call2(cmp,x1,x2);
            if(caml_call2(CCMonomorphic[3],c,0))
             {var acc$0=[0,x1,acc],acc=acc$0,l1$0=l1$1;continue}
            if(caml_call2(CCMonomorphic[4],c,0))
             {var acc$1=[0,x2,acc],acc=acc$1,l2$0=l2$1;continue}
            var acc$2=[0,x1,[0,x2,acc]],acc=acc$2,l1$0=l1$1,l2$0=l2$1;
            continue}
          return caml_call2(List[12],acc,l1$0)}
        return caml_call2(List[12],acc,l2$0)}}
    function sort_uniq(cmp,l){return caml_call2(List[51],cmp,l)}
    function is_sorted(cmp,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _pC_=param$0[2];
          if(_pC_)
           {var
             y=_pC_[1],
             x=param$0[1],
             _pD_=caml_call2(cmp,x,y),
             _pE_=caml_call2(CCMonomorphic[5],_pD_,0);
            if(_pE_){var param$0=_pC_;continue}
            return _pE_}}
        return 1}}
    function sorted_insert(cmp,opt,x,l)
     {if(opt)var sth=opt[1],uniq=sth;else var uniq=0;
      var left=0,l$0=l;
      for(;;)
       {if(l$0)
         {var tail=l$0[2],y=l$0[1],n=caml_call2(cmp,x,y);
          if(0 === n)
           {var l$1=uniq?l$0:[0,x,l$0];return caml_call2(List[12],left,l$1)}
          if(caml_call2(CCMonomorphic[3],n,0))
           return caml_call2(List[12],left,[0,x,l$0]);
          var left$0=[0,y,left],left=left$0,l$0=tail;
          continue}
        return caml_call2(List[12],left,[0,x,0])}}
    function uniq_succ(eq,l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var _pA_=l$0[2],_pB_=l$0[1];
          if(_pA_)
           {var y=_pA_[1];
            if(caml_call2(eq,_pB_,y)){var l$0=_pA_;continue}
            var acc$0=[0,_pB_,acc],acc=acc$0,l$0=_pA_;
            continue}
          return caml_call1(List[9],[0,_pB_,acc])}
        return caml_call1(List[9],acc)}}
    function group_succ(eq,l)
     {var acc=0,cur=0,l$0=l;
      for(;;)
       {if(cur)
         {var _py_=cur[1];
          if(l$0)
           {var tl=l$0[2],x=l$0[1];
            if(caml_call2(eq,x,_py_))
             {var cur$0=[0,x,cur],cur=cur$0,l$0=tl;continue}
            var
             tl$0=l$0[2],
             x$0=l$0[1],
             cur$1=[0,x$0,0],
             acc$0=[0,caml_call1(List[9],cur),acc],
             acc=acc$0,
             cur=cur$1,
             l$0=tl$0;
            continue}
          var _pz_=[0,caml_call1(List[9],cur),acc];
          return caml_call1(List[9],_pz_)}
        if(l$0)
         {var l$1=l$0[2],x$1=l$0[1],cur$2=[0,x$1,0],cur=cur$2,l$0=l$1;
          continue}
        return caml_call1(List[9],acc)}}
    function sorted_merge_uniq(cmp,l1,l2)
     {function push(cmp,acc,x)
       {if(acc)
         {var y=acc[1],_px_=caml_call2(cmp,x,y);
          return caml_call2(CCMonomorphic[4],_px_,0)?[0,x,acc]:acc}
        return [0,x,0]}
      var acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             c=caml_call2(cmp,x1,x2);
            if(caml_call2(CCMonomorphic[3],c,0))
             {var acc$0=push(cmp,acc,x1),acc=acc$0,l1$0=l1$1;continue}
            if(caml_call2(CCMonomorphic[4],c,0))
             {var acc$1=push(cmp,acc,x2),acc=acc$1,l2$0=l2$1;continue}
            var l2$0=l2$1;
            continue}
          var l=l1$0}
        else
         var l=l2$0;
        var
         _pu_=function(_pv_,_pw_){return push(cmp,_pv_,_pw_)},
         acc$2=caml_call3(List[20],_pu_,acc,l);
        return caml_call1(List[9],acc$2)}}
    function take(n,l)
     {function direct(i,n,l)
       {if(l)
         {if(caml_call2(CCMonomorphic[1],i,0))
           {var n$0=n,acc=0,l$1=l;
            for(;;)
             {if(l$1)
               {if(caml_call2(CCMonomorphic[1],n$0,0))
                 return caml_call1(List[9],acc);
                var
                 l$2=l$1[2],
                 x$0=l$1[1],
                 acc$0=[0,x$0,acc],
                 n$1=n$0 - 1 | 0,
                 n$0=n$1,
                 acc=acc$0,
                 l$1=l$2;
                continue}
              return caml_call1(List[9],acc)}}
          var l$0=l[2],x=l[1];
          return caml_call2(CCMonomorphic[4],n,0)
                  ?[0,x,direct(i - 1 | 0,n - 1 | 0,l$0)]
                  :0}
        return 0}
      return direct(direct_depth_default,n,l)}
    function drop(n,l)
     {var n$0=n,l$0=l;
      for(;;)
       {if(l$0)
         {if(caml_call2(CCMonomorphic[1],n$0,0))return l$0;
          var l$1=l$0[2],n$1=n$0 - 1 | 0,n$0=n$1,l$0=l$1;
          continue}
        return 0}}
    function hd_tl(param)
     {if(param){var l=param[2],x=param[1];return [0,x,l]}
      return caml_call1(Pervasives[2],cst_hd_tl)}
    function take_drop(n,l){var _pt_=drop(n,l);return [0,take(n,l),_pt_]}
    function sublists_of_len(opt,offset,n,l)
     {if(opt)var sth=opt[1],last=sth;else var last=function(param){return 0};
      if(caml_call2(CCMonomorphic[3],n,1))
       caml_call1(Pervasives[1],cst_sublists_of_len_n_must_be_0);
      if(offset)
       var
        o=offset[1],
        _pq_=
         caml_call2(CCMonomorphic[3],o,1)
          ?caml_call1(Pervasives[1],cst_sublists_of_len_offset_must_be_0)
          :o,
        offset$0=_pq_;
      else
       var offset$0=n;
      var acc=0,l$0=l;
      for(;;)
       {var group=take(n,l$0);
        if(is_empty(group))
         var _ps_=acc;
        else
         {var _pr_=caml_call1(List[1],group);
          if(! caml_call2(CCMonomorphic[3],_pr_,n))
           {var l$1=drop(offset$0,l$0),acc$0=[0,group,acc],acc=acc$0,l$0=l$1;
            continue}
          var match=caml_call1(last,group);
          if(match)var group$0=match[1],_ps_=[0,group$0,acc];else var _ps_=acc}
        return caml_call1(List[9],_ps_)}}
    function intersperse(x,l)
     {function aux_direct(i,x,l)
       {if(l)
         {if(l[2])
           {if(caml_call2(CCMonomorphic[1],i,0))
             {var acc=0,l$0=l;
              for(;;)
               {if(l$0)
                 {var _po_=l$0[2],_pp_=l$0[1];
                  if(_po_)
                   {var acc$0=[0,x,[0,_pp_,acc]],acc=acc$0,l$0=_po_;continue}
                  return caml_call1(List[9],[0,_pp_,acc])}
                return caml_call1(List[9],acc)}}
            var tail=l[2],y=l[1];
            return [0,y,[0,x,aux_direct(i - 1 | 0,x,tail)]]}
          return l}
        return 0}
      return aux_direct(1e3,x,l)}
    function interleave(l1,l2)
     {var acc=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             acc$0=[0,x2,[0,x1,acc]],
             acc=acc$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}
          var _pm_=caml_call2(List[12],l1$0,acc);
          return caml_call1(List[9],_pm_)}
        if(l2$0)
         {var _pn_=caml_call2(List[12],l2$0,acc);
          return caml_call1(List[9],_pn_)}
        return caml_call1(List[9],acc)}}
    function take_while(p,l)
     {function direct(i,p,l)
       {if(l)
         {if(caml_call2(CCMonomorphic[1],i,0))
           {var acc=0,l$1=l;
            for(;;)
             {if(l$1)
               {var l$2=l$1[2],x$0=l$1[1];
                if(caml_call1(p,x$0))
                 {var acc$0=[0,x$0,acc],acc=acc$0,l$1=l$2;continue}
                return caml_call1(List[9],acc)}
              return caml_call1(List[9],acc)}}
          var l$0=l[2],x=l[1];
          return caml_call1(p,x)?[0,x,direct(i - 1 | 0,p,l$0)]:0}
        return 0}
      return direct(direct_depth_default,p,l)}
    function drop_while(p,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],x=l$0[1];
          if(caml_call1(p,x)){var l$0=l$1;continue}
          return l$0}
        return 0}}
    function take_drop_while(p,l)
     {function direct(i,p,l)
       {if(l)
         {if(caml_call2(CCMonomorphic[1],i,0))
           {var acc=0,l$0=l;
            for(;;)
             {if(l$0)
               {var tail$0=l$0[2],x$0=l$0[1];
                if(caml_call1(p,x$0))
                 {var acc$0=[0,x$0,acc],acc=acc$0,l$0=tail$0;continue}
                return [0,caml_call1(List[9],acc),l$0]}
              return [0,caml_call1(List[9],acc),0]}}
          var tail=l[2],x=l[1];
          if(caml_call1(p,x))
           {var match=direct(i - 1 | 0,p,tail),l2=match[2],l1=match[1];
            return [0,[0,x,l1],l2]}
          return [0,0,l]}
        return _bD_}
      return direct(direct_depth_default,p,l)}
    function last(n,l)
     {var len=caml_call1(List[1],l);
      return caml_call2(CCMonomorphic[3],len,n)?l:drop(len - n | 0,l)}
    function head_opt(param){if(param){var x=param[1];return [0,x]}return 0}
    function tail_opt(param)
     {if(param){var tail=param[2];return [0,tail]}return 0}
    function last_opt(param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _pk_=param$0[2],_pl_=param$0[1];
          if(_pk_){var param$0=_pk_;continue}
          return [0,_pl_]}
        return 0}}
    function find_pred_exn(p,l)
     {var match=caml_call2(find_opt,p,l);
      if(match){var x=match[1];return x}
      throw Not_found}
    function find_mapi(f,param)
     {var i=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],res=caml_call2(f,i,x);
          if(res)return res;
          var i$0=i + 1 | 0,i=i$0,param$0=l;
          continue}
        return 0}}
    function find_map(f,l){return find_mapi(function(param){return f},l)}
    function find_idx$1(p,l)
     {return find_mapi(function(i,x){return caml_call1(p,x)?[0,[0,i,x]]:0},l)}
    function remove$0(eq,x,l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var tail=l$0[2],y=l$0[1];
          if(caml_call2(eq,x,y)){var l$0=tail;continue}
          var acc$0=[0,y,acc],acc=acc$0,l$0=tail;
          continue}
        return caml_call1(List[9],acc)}}
    function filter_map$0(f,l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],x=l$0[1],match=caml_call1(f,x);
          if(match)var y=match[1],acc$0=[0,y,acc];else var acc$0=acc;
          var acc=acc$0,l$0=l$1;
          continue}
        return caml_call1(List[9],acc)}}
    function keep_some(l){return filter_map$0(function(x){return x},l)}
    function keep_ok(l)
     {return filter_map$0
              (function(param)
                {if(0 === param[0]){var x=param[1];return [0,x]}return 0},
               l)}
    function all_some(l)
     {try
       {var
         _pi_=
          [0,
           map$2
            (function(param)
              {if(param){var x=param[1];return x}throw Pervasives[3]},
             l)];
        return _pi_}
      catch(_pj_)
       {_pj_ = caml_wrap_exception(_pj_);
        if(_pj_ === Pervasives[3])return 0;
        throw _pj_}}
    function all_ok(l)
     {var err=[0,0];
      try
       {var
         _pg_=
          [0,
           map$2
            (function(param)
              {if(0 === param[0]){var x=param[1];return x}
               var e=param[1];
               err[1] = [0,e];
               throw Pervasives[3]},
             l)];
        return _pg_}
      catch(_ph_)
       {_ph_ = caml_wrap_exception(_ph_);
        if(_ph_ === Pervasives[3])
         {var _pf_=err[1];
          if(_pf_){var e=_pf_[1];return [1,e]}
          throw [0,Assert_failure,_bE_]}
        throw _ph_}}
    function group_by(opt,_o$_,l)
     {if(opt)var sth=opt[1],hash=sth;else var hash=Hashtbl[21];
      if(_o$_)var sth$0=_o$_[1],eq=sth$0;else var eq=caml_equal;
      var Tbl=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(Tbl[1],32);
      function _pa_(x)
       {try
         {var _pd_=caml_call2(Tbl[7],tbl,x),l=_pd_}
        catch(_pe_)
         {_pe_ = caml_wrap_exception(_pe_);
          if(_pe_ !== Not_found)throw _pe_;
          var l=0}
        return caml_call3(Tbl[10],tbl,x,[0,x,l])}
      caml_call2(List[15],_pa_,l);
      var _pb_=0;
      function _pc_(param,x,acc){return [0,x,acc]}
      return caml_call3(Tbl[14],_pc_,tbl,_pb_)}
    function join(join_row,s1,s2)
     {return flat_map$0
              (function(a){return filter_map$0(caml_call1(join_row,a),s2)},s1)}
    function join_by(opt,_o7_,f1,f2,merge,c1,c2)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(_o7_)var sth$0=_o7_[1],hash=sth$0;else var hash=Hashtbl[21];
      var Tbl=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(Tbl[1],32);
      function _o8_(x)
       {var key=caml_call1(f1,x);return caml_call3(Tbl[5],tbl,key,x)}
      caml_call2(List[15],_o8_,c1);
      var res=[0,0];
      function _o9_(y)
       {var key=caml_call1(f2,y),xs=caml_call2(Tbl[9],tbl,key);
        function _o__(x)
         {var match=caml_call3(merge,key,x,y);
          if(match){var z=match[1];res[1] = [0,z,res[1]];return 0}
          return 0}
        return caml_call2(List[15],_o__,xs)}
      caml_call2(List[15],_o9_,c2);
      return res[1]}
    function join_all_by(opt,_oY_,f1,f2,merge,c1,c2)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(_oY_)var sth$0=_oY_[1],hash=sth$0;else var hash=Hashtbl[21];
      var Tbl=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(Tbl[1],32);
      function _oZ_(x)
       {var key=caml_call1(f1,x);
        try
         {var c=caml_call2(Tbl[7],tbl,key);
          c[1] = [0,x,c[1]];
          var _o5_=0;
          return _o5_}
        catch(_o6_)
         {_o6_ = caml_wrap_exception(_o6_);
          if(_o6_ === Not_found)
           return caml_call3(Tbl[5],tbl,key,[0,[0,x,0],0]);
          throw _o6_}}
      caml_call2(List[15],_oZ_,c1);
      function _o0_(y)
       {var key=caml_call1(f2,y);
        try
         {var c=caml_call2(Tbl[7],tbl,key);
          c[2] = [0,y,c[2]];
          var _o3_=0;
          return _o3_}
        catch(_o4_)
         {_o4_ = caml_wrap_exception(_o4_);
          if(_o4_ === Not_found)
           return caml_call3(Tbl[5],tbl,key,[0,0,[0,y,0]]);
          throw _o4_}}
      caml_call2(List[15],_o0_,c2);
      var _o1_=0;
      function _o2_(key,cell,res)
       {var match=caml_call3(merge,key,cell[1],cell[2]);
        if(match){var z=match[1];return [0,z,res]}
        return res}
      return caml_call3(Tbl[14],_o2_,tbl,_o1_)}
    function group_join_by(opt,_oR_,f,c1,c2)
     {if(opt)var sth=opt[1],eq=sth;else var eq=caml_equal;
      if(_oR_)var sth$0=_oR_[1],hash=sth$0;else var hash=Hashtbl[21];
      var Tbl=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(Tbl[1],32);
      function _oS_(x){return caml_call3(Tbl[10],tbl,x,0)}
      caml_call2(List[15],_oS_,c1);
      function _oT_(y)
       {var key=caml_call1(f,y);
        try
         {var
           l=caml_call2(Tbl[7],tbl,key),
           _oW_=caml_call3(Tbl[10],tbl,key,[0,y,l]);
          return _oW_}
        catch(_oX_)
         {_oX_ = caml_wrap_exception(_oX_);
          if(_oX_ === Not_found)return 0;
          throw _oX_}}
      caml_call2(List[15],_oT_,c2);
      var _oU_=0;
      function _oV_(k,v,l){return [0,[0,k,v],l]}
      return caml_call3(Tbl[14],_oV_,tbl,_oU_)}
    function mem$0(eq,x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],y=l$0[1],_oQ_=caml_call2(eq,x,y);
          if(_oQ_)return _oQ_;
          var l$0=l$1;
          continue}
        return 0}}
    function add_nodup(eq,x,l){return mem$0(eq,x,l)?l:[0,x,l]}
    function remove_one(eq,x,l)
     {if(mem$0(eq,x,l))
       {var acc=0,l$0=l;
        for(;;)
         {if(l$0)
           {var tl=l$0[2],y=l$0[1];
            if(caml_call2(eq,x,y))return caml_call2(List[12],acc,tl);
            var acc$0=[0,y,acc],acc=acc$0,l$0=tl;
            continue}
          throw [0,Assert_failure,_bF_]}}
      return l}
    function subset(eq,l1,l2)
     {function _oP_(t){return mem$0(eq,t,l2)}
      return caml_call2(List[27],_oP_,l1)}
    function uniq(eq,l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var xs=l$0[2],x=l$0[1],_oO_=caml_call1(eq,x);
          if(caml_call2(List[28],_oO_,xs)){var l$0=xs;continue}
          var acc$0=[0,x,acc],acc=acc$0,l$0=xs;
          continue}
        return caml_call1(List[9],acc)}}
    function union(eq,l1,l2)
     {var acc=0,l1$0=l1;
      for(;;)
       {if(l1$0)
         {var xs=l1$0[2],x=l1$0[1];
          if(mem$0(eq,x,l2)){var l1$0=xs;continue}
          var acc$0=[0,x,acc],acc=acc$0,l1$0=xs;
          continue}
        return caml_call2(List[12],acc,l2)}}
    function inter(eq,l1,l2)
     {var acc=0,l1$0=l1;
      for(;;)
       {if(l1$0)
         {var xs=l1$0[2],x=l1$0[1];
          if(mem$0(eq,x,l2)){var acc$0=[0,x,acc],acc=acc$0,l1$0=xs;continue}
          var l1$0=xs;
          continue}
        return caml_call1(List[9],acc)}}
    function mapi$0(f,l)
     {var r=[0,0];
      return map$2(function(x){var y=caml_call2(f,r[1],x);r[1]++;return y},l)}
    function iteri$1(f,l)
     {var i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],x=l$0[1];
          caml_call2(f,i,x);
          var i$0=i + 1 | 0,i=i$0,l$0=l$1;
          continue}
        return 0}}
    function iteri2(f,l1,l2)
     {var i=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],x2=l2$0[1],l1$1=l1$0[2],x1=l1$0[1];
            caml_call3(f,i,x1,x2);
            var i$0=i + 1 | 0,i=i$0,l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return caml_call1(Pervasives[1],cst_iteri2)}}
    function foldi$1(f,acc,l)
     {var acc$0=acc,i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           x=l$0[1],
           acc$1=caml_call3(f,acc$0,i,x),
           i$0=i + 1 | 0,
           acc$0=acc$1,
           i=i$0,
           l$0=l$1;
          continue}
        return acc$0}}
    function foldi2(f,acc,l1,l2)
     {var acc$0=acc,i=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             acc$1=caml_call4(f,acc$0,i,x1,x2),
             i$0=i + 1 | 0,
             acc$0=acc$1,
             i=i$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return acc$0;
        return caml_call1(Pervasives[1],cst_foldi2)}}
    function get_at_idx_exn(i$1,l$1)
     {var
       i$2=
        caml_call2(CCMonomorphic[3],i$1,0)
         ?caml_call1(length$1,l$1) + i$1 | 0
         :i$1,
       i=i$2,
       l=l$1;
      for(;;)
       {if(l)
         {var l$0=l[2],x=l[1];
          if(caml_call2(CCMonomorphic[1],i,0))return x;
          var i$0=i - 1 | 0,i=i$0,l=l$0;
          continue}
        throw Not_found}}
    function get_at_idx(i,l)
     {try
       {var _oM_=[0,get_at_idx_exn(i,l)];return _oM_}
      catch(_oN_)
       {_oN_ = caml_wrap_exception(_oN_);
        if(_oN_ === Not_found)return 0;
        throw _oN_}}
    function set_at_idx(i,x,l0)
     {var
       i$2=caml_call2(CCMonomorphic[3],i,0)?caml_call1(length$1,l0) + i | 0:i,
       l=l0,
       acc=0,
       i$0=i$2;
      for(;;)
       {if(l)
         {var l$0=l[2],y=l[1];
          if(caml_call2(CCMonomorphic[1],i$0,0))
           return caml_call2(List[12],acc,[0,x,l$0]);
          var i$1=i$0 - 1 | 0,acc$0=[0,y,acc],l=l$0,acc=acc$0,i$0=i$1;
          continue}
        return l0}}
    function insert_at_idx(i,x,l)
     {var
       i$2=caml_call2(CCMonomorphic[3],i,0)?caml_call1(length$1,l) + i | 0:i,
       l$0=l,
       acc=0,
       i$0=i$2;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],y=l$0[1];
          if(caml_call2(CCMonomorphic[1],i$0,0))
           return caml_call2(List[12],acc,[0,x,[0,y,l$1]]);
          var i$1=i$0 - 1 | 0,acc$0=[0,y,acc],l$0=l$1,acc=acc$0,i$0=i$1;
          continue}
        return caml_call2(List[12],acc,[0,x,0])}}
    function remove_at_idx(i,l0)
     {var
       i$2=caml_call2(CCMonomorphic[3],i,0)?caml_call1(length$1,l0) + i | 0:i,
       l=l0,
       acc=0,
       i$0=i$2;
      for(;;)
       {if(l)
         {var l$0=l[2],y=l[1];
          if(caml_call2(CCMonomorphic[1],i$0,0))
           return caml_call2(List[12],acc,l$0);
          var i$1=i$0 - 1 | 0,acc$0=[0,y,acc],l=l$0,acc=acc$0,i$0=i$1;
          continue}
        return l0}}
    function range_by$0(step,i,j)
     {if(caml_call2(CCMonomorphic[1],step,0))
       throw [0,Invalid_argument,cst_CCList_range_by$0];
      var
       _oL_=
        caml_call2(CCMonomorphic[4],step,0)
         ?caml_call2(CCMonomorphic[4],i,j)
         :caml_call2(CCMonomorphic[3],i,j);
      if(_oL_)return 0;
      var j$2=caml_mul(caml_div(j - i | 0,step),step) + i | 0,j$0=j$2,acc=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,j$0))return [0,i,acc];
        var acc$0=[0,j$0,acc],j$1=j$0 - step | 0,j$0=j$1,acc=acc$0;
        continue}}
    function range$1(i,j)
     {if(caml_call2(CCMonomorphic[5],i,j))
       {var j$0=j,acc=0;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i,j$0))return [0,i,acc];
          var acc$0=[0,j$0,acc],j$1=j$0 - 1 | 0,j$0=j$1,acc=acc$0;
          continue}}
      var j$2=j,acc$1=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,j$2))return [0,i,acc$1];
        var acc$2=[0,j$2,acc$1],j$3=j$2 + 1 | 0,j$2=j$3,acc$1=acc$2;
        continue}}
    function range$2(i,j)
     {return caml_call2(CCMonomorphic[3],i,j)
              ?range$1(i,j - 1 | 0)
              :caml_call2(CCMonomorphic[1],i,j)?0:range$1(i,j + 1 | 0)}
    function replicate(i,x)
     {var acc=0,i$0=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,0))return acc;
        var i$1=i$0 - 1 | 0,acc$0=[0,x,acc],acc=acc$0,i$0=i$1;
        continue}}
    function repeat(i,l)
     {var acc=0,i$0=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,0))return caml_call1(List[9],acc);
        var
         i$1=i$0 - 1 | 0,
         acc$0=caml_call2(List[12],l,acc),
         acc=acc$0,
         i$0=i$1;
        continue}}
    function search_exn(eq,l,x)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],match=l$0[1],z=match[2],y=match[1];
          if(caml_call2(eq,x,y))return z;
          var l$0=l$1;
          continue}
        throw Not_found}}
    function assoc(eq,x,l){return search_exn(eq,l,x)}
    function assoc_opt(eq,x,l)
     {try
       {var _oJ_=[0,search_exn(eq,l,x)];return _oJ_}
      catch(_oK_)
       {_oK_ = caml_wrap_exception(_oK_);
        if(_oK_ === Not_found)return 0;
        throw _oK_}}
    function search_set(eq,acc,l,x,f)
     {var acc$0=acc,l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],match=l$0[1],y=match[2],x$0=match[1];
          if(caml_call2(eq,x,x$0))
           return caml_call3(f,x,[0,y],caml_call2(List[12],acc$0,l$1));
          var acc$1=[0,[0,x$0,y],acc$0],acc$0=acc$1,l$0=l$1;
          continue}
        return caml_call3(f,x,0,acc$0)}}
    function set$1(eq,x,y,l)
     {return search_set(eq,0,l,x,function(x,param,l){return [0,[0,x,y],l]})}
    function mem_assoc(eq,x,l)
     {try
       {search_exn(eq,l,x);var _oH_=1;return _oH_}
      catch(_oI_)
       {_oI_ = caml_wrap_exception(_oI_);
        if(_oI_ === Not_found)return 0;
        throw _oI_}}
    function update$0(eq,f,x,l)
     {return search_set
              (eq,
               0,
               l,
               x,
               function(x,opt_y,rest)
                {var match=caml_call1(f,opt_y);
                 if(match){var y=match[1];return [0,[0,x,y],rest]}
                 return rest})}
    function remove_assoc(eq,x,l)
     {return search_set
              (eq,0,l,x,function(param,opt_y,rest){return opt_y?rest:l})}
    function push(l,x){l[1] = [0,x,l[1]];return 0}
    function pop(l)
     {var _oG_=l[1];
      if(_oG_){var tail=_oG_[2],x=_oG_[1];l[1] = tail;return [0,x]}
      return 0}
    function pop_exn(l)
     {var _oF_=l[1];
      if(_oF_){var tail=_oF_[2],x=_oF_[1];l[1] = tail;return x}
      return caml_call1(Pervasives[2],cst_CCList_Ref_pop_exn)}
    function create(param){return [0,0]}
    function clear(l){l[1] = 0;return 0}
    function lift(f,l){return caml_call1(f,l[1])}
    function push_list(r,l){r[1] = caml_call2(List[12],l,r[1]);return 0}
    var Ref=[0,push,pop,pop_exn,create,clear,lift,push_list];
    function random_len$0(len,g,st)
     {return init$0(len,function(param){return caml_call1(g,st)})}
    function random$2(g,st)
     {var len=caml_call2(include[11][5],st,1e3);return random_len$0(len,g,st)}
    function random_non_empty$0(g,st)
     {var len=1 + caml_call2(include[11][5],st,1e3) | 0;
      return random_len$0(len,g,st)}
    function random_choose$1(l)
     {if(l)
       {var len=caml_call1(List[1],l);
        return function(st)
         {var i=caml_call2(include[11][5],st,len);
          return caml_call2(List[7],l,i)}}
      throw Not_found}
    function random_sequence(l,st)
     {return map$2(function(g){return caml_call1(g,st)},l)}
    function to_seq$2(l,k){return caml_call2(List[15],k,l)}
    function of_seq$0(seq)
     {var l=[0,0];
      caml_call1(seq,function(x){l[1] = [0,x,l[1]];return 0});
      return caml_call1(List[9],l[1])}
    function to_gen$1(l)
     {var l$0=[0,l];
      return function(param)
       {var _oE_=l$0[1];
        if(_oE_){var l=_oE_[2],x=_oE_[1];l$0[1] = l;return [0,x]}
        return 0}}
    function of_gen(g)
     {function direct(i,g)
       {if(caml_call2(CCMonomorphic[1],i,0))
         {var acc=0;
          for(;;)
           {var match$0=caml_call1(g,0);
            if(match$0)
             {var x$0=match$0[1],acc$0=[0,x$0,acc],acc=acc$0;continue}
            return caml_call1(List[9],acc)}}
        var match=caml_call1(g,0);
        if(match){var x=match[1];return [0,x,direct(i - 1 | 0,g)]}
        return 0}
      return direct(direct_depth_default,g)}
    function to_klist$3(l)
     {function make(l,param)
       {if(l)
         {var l$0=l[2],x=l[1];
          return [0,748545553,[0,x,function(_oD_){return make(l$0,_oD_)}]]}
        return 3902385}
      return function(_oC_){return make(l,_oC_)}}
    function of_klist(l)
     {function direct(i,l$0)
       {if(caml_call2(CCMonomorphic[1],i,0))
         {var acc=0,l$2=l$0;
          for(;;)
           {var match$1=caml_call1(l$2,0);
            if(typeof match$1 === "number")return caml_call1(List[9],acc);
            var
             match$2=match$1[2],
             l$3=match$2[2],
             x$0=match$2[1],
             acc$0=[0,x$0,acc],
             acc=acc$0,
             l$2=l$3;
            continue}}
        var match=caml_call1(l,0);
        if(typeof match === "number")return 0;
        var match$0=match[2],l$1=match$0[2],x=match$0[1];
        return [0,x,direct(i - 1 | 0,l$1)]}
      return direct(direct_depth_default,l)}
    var Infix$0=[0,_bz_,append$1,_bC_,map$2,_bB_,range$1,range$2];
    function pp$5(opt,_oz_,_oy_,pp_item,fmt,l)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$25;
      if(_oz_)var sth$0=_oz_[1],stop=sth$0;else var stop=cst$24;
      if(_oy_)var sth$1=_oy_[1],sep=sth$1;else var sep=cst$23;
      caml_call2(Format[13],fmt,start);
      var l$0=l;
      for(;;)
       {if(l$0)
         {var _oA_=l$0[2],_oB_=l$0[1];
          if(_oA_)
           {caml_call2(pp_item,fmt,_oB_);
            caml_call2(Format[13],fmt,sep);
            caml_call2(Format[27],fmt,0);
            var l$0=_oA_;
            continue}
          caml_call2(pp_item,fmt,_oB_)}
        return caml_call2(Format[13],fmt,stop)}}
    function Traverse(M)
     {function map_m(f,l)
       {function aux(f,acc,l)
         {if(l)
           {var
             tail=l[2],
             x=l[1],
             _ov_=function(x){return aux(f,[0,x,acc],tail)},
             _ow_=caml_call1(f,x);
            return caml_call2(M[2],_ow_,_ov_)}
          var _ox_=caml_call1(List[9],acc);
          return caml_call1(M[1],_ox_)}
        return aux(f,0,l)}
      function map_m_par(f,l)
       {if(l)
         {var
           tl=l[2],
           x=l[1],
           x$0=caml_call1(f,x),
           tl$0=map_m_par(f,tl),
           _ot_=
            function(x)
             {function _ou_(tl){return caml_call1(M[1],[0,x,tl])}
              return caml_call2(M[2],tl$0,_ou_)};
          return caml_call2(M[2],x$0,_ot_)}
        return caml_call1(M[1],0)}
      function sequence_m(l){return map_m(function(x){return x},l)}
      function fold_m(f,acc,l)
       {if(l)
         {var
           l$0=l[2],
           x=l[1],
           _or_=function(acc){return fold_m(f,acc,l$0)},
           _os_=caml_call2(f,acc,x);
          return caml_call2(M[2],_os_,_or_)}
        return caml_call1(M[1],acc)}
      return [0,sequence_m,fold_m,map_m,map_m_par]}
    var
     Assoc=[0,assoc_opt,assoc,set$1,mem_assoc,update$0,remove_assoc],
     include$3=
      [0,
       length$1,
       hd,
       tl,
       nth,
       rev$0,
       rev_append,
       concat$0,
       iter$1,
       rev_map,
       fold_left$0,
       iter2$1,
       map2$0,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all$1,
       exists$2,
       for_all2$1,
       exists2$1,
       memq$0,
       find$2,
       find_all,
       partition,
       assq,
       mem_assq,
       remove_assq,
       sort$0,
       stable_sort$0,
       fast_sort$0,
       merge,
       empty$1,
       is_empty,
       map$2,
       _bz_,
       cons$0,
       append$1,
       cons_maybe,
       append$1,
       filter$0,
       fold_right$0,
       fold_while$1,
       fold_map$0,
       scan_left$0,
       fold_map2,
       fold_filter_map,
       fold_flat_map,
       count,
       init$0,
       combine$0,
       combine_gen,
       split,
       compare$6,
       compare_lengths,
       compare_length_with,
       equal$7,
       flat_map$0,
       flatten,
       product,
       fold_product,
       cartesian_product,
       map_product_l,
       diagonal,
       partition_map,
       group_by,
       join,
       join_by,
       join_all_by,
       group_join_by,
       sublists_of_len,
       intersperse,
       interleave,
       return$1,
       _bC_,
       map$2,
       return$1,
       _bB_,
       take,
       drop,
       hd_tl,
       take_drop,
       take_while,
       drop_while,
       take_drop_while,
       last,
       head_opt,
       tail_opt,
       last_opt,
       find_opt,
       find_opt,
       find_pred_exn,
       find_map,
       find_mapi,
       find_idx$1,
       remove$0,
       filter_map$0,
       keep_some,
       keep_ok,
       all_some,
       all_ok,
       sorted_merge,
       sort_uniq,
       sorted_merge_uniq,
       is_sorted,
       sorted_insert,
       uniq_succ,
       group_succ,
       mapi$0,
       iteri$1,
       iteri2,
       foldi$1,
       foldi2,
       get_at_idx,
       nth_opt,
       get_at_idx_exn,
       set_at_idx,
       insert_at_idx,
       remove_at_idx,
       add_nodup,
       remove_one,
       mem$0,
       subset,
       uniq,
       union,
       inter,
       range_by$0,
       range$1,
       range$2,
       range$1,
       range$2,
       replicate,
       repeat,
       Assoc,
       assoc,
       assoc_opt,
       assq_opt,
       mem_assoc,
       remove_assoc,
       Ref,
       Traverse,
       random$2,
       random_non_empty$0,
       random_len$0,
       random_choose$1,
       random_sequence,
       to_seq$2,
       of_seq$0,
       to_gen$1,
       of_gen,
       to_klist$3,
       of_klist,
       Infix$0,
       pp$5];
    caml_register_global(311,include$3,"CCList");
    var
     CCListLabels=
      [0,
       length$1,
       hd,
       tl,
       nth,
       rev$0,
       rev_append,
       concat$0,
       iter$1,
       rev_map,
       fold_left$0,
       iter2$1,
       map2$0,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all$1,
       exists$2,
       for_all2$1,
       exists2$1,
       memq$0,
       find$2,
       find_all,
       partition,
       assq,
       mem_assq,
       remove_assq,
       sort$0,
       stable_sort$0,
       fast_sort$0,
       merge,
       empty$1,
       is_empty,
       map$2,
       _bz_,
       cons$0,
       append$1,
       cons_maybe,
       append$1,
       filter$0,
       fold_right$0,
       fold_while$1,
       fold_map$0,
       scan_left$0,
       fold_map2,
       fold_filter_map,
       fold_flat_map,
       count,
       init$0,
       combine$0,
       combine_gen,
       split,
       compare$6,
       compare_lengths,
       compare_length_with,
       equal$7,
       flat_map$0,
       flatten,
       product,
       fold_product,
       cartesian_product,
       map_product_l,
       diagonal,
       partition_map,
       group_by,
       join,
       join_by,
       join_all_by,
       group_join_by,
       sublists_of_len,
       intersperse,
       interleave,
       return$1,
       _bC_,
       map$2,
       return$1,
       _bB_,
       take,
       drop,
       hd_tl,
       take_drop,
       take_while,
       drop_while,
       take_drop_while,
       last,
       head_opt,
       tail_opt,
       last_opt,
       find_opt,
       find_opt,
       find_pred_exn,
       find_map,
       find_mapi,
       find_idx$1,
       remove$0,
       filter_map$0,
       keep_some,
       keep_ok,
       all_some,
       all_ok,
       sorted_merge,
       sort_uniq,
       sorted_merge_uniq,
       is_sorted,
       sorted_insert,
       uniq_succ,
       group_succ,
       mapi$0,
       iteri$1,
       iteri2,
       foldi$1,
       foldi2,
       get_at_idx,
       nth_opt,
       get_at_idx_exn,
       set_at_idx,
       insert_at_idx,
       remove_at_idx,
       add_nodup,
       remove_one,
       mem$0,
       subset,
       uniq,
       union,
       inter,
       range_by$0,
       range$1,
       range$2,
       range$1,
       range$2,
       replicate,
       repeat,
       Assoc,
       assoc,
       assoc_opt,
       assq_opt,
       mem_assoc,
       remove_assoc,
       Ref,
       Traverse,
       random$2,
       random_non_empty$0,
       random_len$0,
       random_choose$1,
       random_sequence,
       to_seq$2,
       of_seq$0,
       to_gen$1,
       of_gen,
       to_klist$3,
       of_klist,
       Infix$0,
       pp$5];
    caml_register_global(312,CCListLabels,"CCListLabels");
    var
     CCMap=
      [0,
       function(O)
        {var M=caml_call1(Map[1],O);
         caml_fresh_oo_id(0);
         var
          empty=M[1],
          is_empty=M[2],
          mem=M[3],
          add=M[4],
          singleton=M[6],
          remove=M[7],
          merge=M[8],
          union=M[9],
          compare=M[10],
          equal=M[11],
          iter=M[12],
          fold=M[13],
          for_all=M[14],
          exists=M[15],
          filter=M[16],
          partition=M[17],
          cardinal=M[18],
          bindings=M[19],
          min_binding=M[20],
          min_binding_opt=M[21],
          max_binding=M[22],
          max_binding_opt=M[23],
          choose=M[24],
          choose_opt=M[25],
          split=M[26],
          find=M[27],
          find_opt=M[28],
          find_first=M[29],
          find_first_opt=M[30],
          find_last=M[31],
          find_last_opt=M[32],
          map=M[33],
          mapi=M[34];
         function get_or(k,m,default$0)
          {try
            {var _op_=caml_call2(find,k,m);return _op_}
           catch(_oq_)
            {_oq_ = caml_wrap_exception(_oq_);
             if(_oq_ === Not_found)return default$0;
             throw _oq_}}
         function update(k,f,m)
          {try
            {var _on_=caml_call1(f,[0,caml_call2(find,k,m)]),x=_on_}
           catch(_oo_)
            {_oo_ = caml_wrap_exception(_oo_);
             if(_oo_ !== Not_found)throw _oo_;
             var x=caml_call1(f,0)}
           if(x){var v=x[1];return caml_call3(add,k,v,m)}
           return caml_call2(remove,k,m)}
         function merge_safe(f,a,b)
          {return caml_call3
                   (merge,
                    function(k,v1,match)
                     {if(v1)
                       {var _om_=v1[1];
                        if(match)
                         {var v2=match[1];
                          return caml_call2(f,k,[0,737457313,[0,_om_,v2]])}
                        return caml_call2(f,k,[0,847852583,_om_])}
                      if(match)
                       {var v2$0=match[1];
                        return caml_call2(f,k,[0,-57574468,v2$0])}
                      throw [0,Assert_failure,_bG_]},
                    a,
                    b)}
         function add_seq(m,s)
          {var m$0=[0,m];
           caml_call1
            (s,
             function(param)
              {var v=param[2],k=param[1];
               m$0[1] = caml_call3(add,k,v,m$0[1]);
               return 0});
           return m$0[1]}
         function of_seq(s){return add_seq(empty,s)}
         function to_seq(m,yield$0)
          {return caml_call2
                   (iter,function(k,v){return caml_call1(yield$0,[0,k,v])},m)}
         function keys(m,yield$0)
          {return caml_call2
                   (iter,function(k,param){return caml_call1(yield$0,k)},m)}
         function values(m,yield$0)
          {return caml_call2
                   (iter,function(param,v){return caml_call1(yield$0,v)},m)}
         function add_list(m,l)
          {function _ol_(m,param)
            {var v=param[2],k=param[1];return caml_call3(add,k,v,m)}
           return caml_call3(List[20],_ol_,m,l)}
         function of_list(l){return add_list(empty,l)}
         function to_list(m)
          {var _ok_=0;
           return caml_call3
                   (fold,function(k,v,acc){return [0,[0,k,v],acc]},m,_ok_)}
         function pp(opt,_oj_,_oi_,_oh_,pp_k,pp_v,fmt,m)
          {if(opt)var sth=opt[1],start=sth;else var start=cst$29;
           if(_oj_)var sth$0=_oj_[1],stop=sth$0;else var stop=cst$28;
           if(_oi_)var sth$1=_oi_[1],arrow=sth$1;else var arrow=cst$27;
           if(_oh_)var sth$2=_oh_[1],sep=sth$2;else var sep=cst$26;
           caml_call2(Format[13],fmt,start);
           var first=[0,1];
           caml_call2
            (iter,
             function(k,v)
              {if(first[1])
                first[1] = 0;
               else
                {caml_call2(Format[13],fmt,sep);caml_call2(Format[27],fmt,0)}
               caml_call2(pp_k,fmt,k);
               caml_call2(Format[13],fmt,arrow);
               return caml_call2(pp_v,fmt,v)},
             m);
           return caml_call2(Format[13],fmt,stop)}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 merge,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 max_binding,
                 choose,
                 split,
                 find,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 find_opt,
                 get_or,
                 update,
                 choose_opt,
                 min_binding_opt,
                 max_binding_opt,
                 find_opt,
                 find_first,
                 find_first_opt,
                 merge_safe,
                 union,
                 of_seq,
                 add_seq,
                 to_seq,
                 of_list,
                 add_list,
                 keys,
                 values,
                 to_list,
                 pp]}];
    caml_register_global(314,CCMap,"CCMap");
    var
     zero$1=Nativeint[1],
     one$1=Nativeint[2],
     minus_one$1=Nativeint[3],
     succ$1=Nativeint[4],
     pred$1=Nativeint[5],
     abs$2=Nativeint[6],
     size=Nativeint[7],
     max_int$1=Nativeint[8],
     min_int$1=Nativeint[9],
     lnot$2=Nativeint[10],
     to_string$4=Nativeint[12],
     compare$7=Nativeint[13],
     equal$8=caml_equal;
    function _bH_(_og_,_of_){return _og_ + _of_ | 0}
    function _bI_(_oe_,_od_){return _oe_ - _od_ | 0}
    function _bJ_(_oc_){return - _oc_ | 0}
    function _bK_(_ob_,_oa_){return caml_mul(_ob_,_oa_)}
    var _bL_=caml_div,mod$1=caml_mod;
    function land$1(_n$_,_n__){return _n$_ & _n__}
    function lor$1(_n9_,_n8_){return _n9_ | _n8_}
    function lxor$1(_n7_,_n6_){return _n7_ ^ _n6_}
    function lsl$1(_n5_,_n4_){return _n5_ << _n4_}
    function lsr$1(_n3_,_n2_){return _n3_ >>> _n2_ | 0}
    function asr$1(_n1_,_n0_){return _n1_ >> _n0_}
    var
     _bM_=caml_notequal,
     _bN_=caml_lessthan,
     _bO_=caml_lessequal,
     _bP_=caml_greaterthan,
     _bQ_=caml_greaterequal;
    function hash$2(x){return caml_call1(Pervasives[6],x)}
    var of_string_exn$2=caml_int_of_string;
    function of_string$3(x)
     {try
       {var _nY_=[0,caml_int_of_string(x)];return _nY_}
      catch(_nZ_)
       {_nZ_ = caml_wrap_exception(_nZ_);
        if(_nZ_[1] === Failure)return 0;
        throw _nZ_}}
    function _bR_(_nX_){return _nX_ | 0}
    function _bS_(_nW_){return _nW_}
    function _bT_(_nV_){return _nV_}
    var
     CCNativeint=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       succ$1,
       pred$1,
       abs$2,
       size,
       max_int$1,
       min_int$1,
       lnot$2,
       compare$7,
       _bH_,
       _bI_,
       _bJ_,
       _bK_,
       _bL_,
       mod$1,
       land$1,
       lor$1,
       lxor$1,
       lnot$2,
       lsl$1,
       lsr$1,
       asr$1,
       [0,
        _bH_,
        _bI_,
        _bJ_,
        _bK_,
        _bL_,
        mod$1,
        land$1,
        lor$1,
        lxor$1,
        lnot$2,
        lsl$1,
        lsr$1,
        asr$1,
        equal$8,
        _bM_,
        _bP_,
        _bQ_,
        _bO_,
        _bN_],
       equal$8,
       hash$2,
       function(_nU_){return _nU_},
       _bT_,
       _bS_,
       _bR_,
       to_string$4,
       of_string_exn$2,
       of_string$3,
       of_string$3];
    caml_register_global(316,CCNativeint,"CCNativeint");
    function map$3(f,param)
     {if(param){var x=param[1];return [0,caml_call1(f,x)]}return 0}
    function map_or(default$0,f,param)
     {if(param){var x=param[1];return caml_call1(f,x)}return default$0}
    function map_lazy(default_fn,f,param)
     {if(param){var x=param[1];return caml_call1(f,x)}
      return caml_call1(default_fn,0)}
    function is_some(param){return param?1:0}
    function is_none(param){return param?0:1}
    function compare$8(f,o1,o2)
     {if(o1)
       {var _nT_=o1[1];
        if(o2){var y=o2[1];return caml_call2(f,_nT_,y)}
        return 1}
      return o2?-1:0}
    function equal$9(f,o1,o2)
     {if(o1)
       {if(o2){var y=o2[1],x=o1[1];return caml_call2(f,x,y)}}
      else
       if(! o2)return 1;
      return 0}
    function return$2(x){return [0,x]}
    function _bU_(x,f){return map$3(f,x)}
    function _bV_(o,f){if(o){var x=o[1];return caml_call1(f,x)}return 0}
    function flat_map$1(f,o){if(o){var x=o[1];return caml_call1(f,x)}return 0}
    function pure(x){return [0,x]}
    function _bW_(f,match)
     {if(f)if(match){var x=match[1],f$0=f[1];return [0,caml_call1(f$0,x)]}
      return 0}
    function or(else$0,a){return a?a:else$0}
    function or_lazy(else$0,a){return a?a:caml_call1(else$0,0)}
    function _bX_(a,b){return or(b,a)}
    function choice(l){return caml_call3(List[20],_bX_,0,l)}
    function map2$1(f,o1,match)
     {if(o1)if(match){var y=match[1],x=o1[1];return [0,caml_call2(f,x,y)]}
      return 0}
    function filter$1(p,o)
     {if(o){var x=o[1];if(caml_call1(p,x))return o}return 0}
    function if$1(p,x){return caml_call1(p,x)?[0,x]:0}
    function exists$3(p,param)
     {if(param){var x=param[1];return caml_call1(p,x)}return 0}
    function for_all$2(p,param)
     {if(param){var x=param[1];return caml_call1(p,x)}return 1}
    function iter$2(f,o){if(o){var x=o[1];return caml_call1(f,x)}return 0}
    function fold$1(f,acc,o)
     {if(o){var x=o[1];return caml_call2(f,acc,x)}return acc}
    function get_or$0(default$0,x){if(x){var y=x[1];return y}return default$0}
    function get_exn(param)
     {if(param){var x=param[1];return x}
      return caml_call1(Pervasives[1],cst_CCOpt_get_exn)}
    function get_lazy(default_fn,x)
     {if(x){var y=x[1];return y}return caml_call1(default_fn,0)}
    function sequence_l(l)
     {function aux(acc,l)
       {var acc$0=acc,l$0=l;
        for(;;)
         {if(l$0)
           {var _nS_=l$0[1];
            if(_nS_)
             {var l$1=l$0[2],x=_nS_[1],acc$1=[0,x,acc$0],acc$0=acc$1,l$0=l$1;
              continue}
            throw Pervasives[3]}
          return [0,caml_call1(List[9],acc$0)]}}
      try
       {var _nQ_=aux(0,l);return _nQ_}
      catch(_nR_)
       {_nR_ = caml_wrap_exception(_nR_);
        if(_nR_ === Pervasives[3])return 0;
        throw _nR_}}
    function wrap(opt,f,x)
     {if(opt)
       var sth=opt[1],handler=sth;
      else
       var handler=function(param){return 1};
      try
       {var _nP_=[0,caml_call1(f,x)];return _nP_}
      catch(e)
       {e = caml_wrap_exception(e);if(caml_call1(handler,e))return 0;throw e}}
    function wrap2(opt,f,x,y)
     {if(opt)
       var sth=opt[1],handler=sth;
      else
       var handler=function(param){return 1};
      try
       {var _nO_=[0,caml_call2(f,x,y)];return _nO_}
      catch(e)
       {e = caml_wrap_exception(e);if(caml_call1(handler,e))return 0;throw e}}
    function to_list$2(o){if(o){var x=o[1];return [0,x,0]}return 0}
    function of_list$1(param){if(param){var x=param[1];return [0,x]}return 0}
    function to_result(err,param)
     {if(param){var x=param[1];return [0,x]}return [1,err]}
    function to_result_lazy(err_fn,param)
     {if(param){var x=param[1];return [0,x]}return [1,caml_call1(err_fn,0)]}
    function of_result(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}return 0}
    var Infix$1=[0,_bU_,_bV_,_bW_,map$3,_bX_];
    function random$3(g,st)
     {return caml_call1(include[11][10],st)?[0,caml_call1(g,st)]:0}
    var ExitChoice=[248,cst_CCOpt_ExitChoice,caml_fresh_oo_id(0)];
    function choice_seq(s)
     {var r=[0,0];
      try
       {caml_call1(s,function(o){if(o){r[1] = o;throw ExitChoice}return 0})}
      catch(_nN_)
       {_nN_ = caml_wrap_exception(_nN_);if(_nN_ !== ExitChoice)throw _nN_}
      return r[1]}
    function to_gen$2(o)
     {if(o)
       {var first=[0,1];
        return function(param){return first[1]?(first[1] = 0,o):0}}
      return function(param){return 0}}
    function to_seq$3(o,k){if(o){var x=o[1];return caml_call1(k,x)}return 0}
    function pp$6(ppx,out,param)
     {if(param){var x=param[1];return caml_call4(Format[112],out,_bY_,ppx,x)}
      return caml_call2(Format[13],out,cst_None$0)}
    function flatten$0(param){if(param){var x=param[1];return x}return 0}
    function return_if(b,x){return b?[0,x]:0}
    var
     CCOpt=
      [0,
       map$3,
       map_or,
       map_lazy,
       is_some,
       is_none,
       compare$8,
       equal$9,
       return$2,
       _bU_,
       _bV_,
       flat_map$1,
       map2$1,
       iter$2,
       fold$1,
       filter$1,
       if$1,
       exists$3,
       for_all$2,
       get_or$0,
       get_exn,
       get_lazy,
       sequence_l,
       wrap,
       wrap2,
       pure,
       _bW_,
       map$3,
       or,
       or_lazy,
       _bX_,
       choice,
       flatten$0,
       return_if,
       Infix$1,
       to_list$2,
       of_list$1,
       to_result,
       to_result_lazy,
       of_result,
       random$3,
       choice_seq,
       to_gen$2,
       to_seq$3,
       pp$6];
    caml_register_global(317,CCOpt,"CCOpt");
    var compare$9=runtime.caml_compare;
    function opp(f,x,y){return - caml_call2(f,x,y) | 0}
    function equiv(i,j)
     {return caml_call2(CCMonomorphic[3],i,0)
              ?caml_call2(CCMonomorphic[3],j,0)
              :caml_call2(CCMonomorphic[4],i,0)
                ?caml_call2(CCMonomorphic[4],j,0)
                :caml_call2(CCMonomorphic[1],j,0)}
    var
     int$3=caml_int_compare,
     string$2=caml_string_compare,
     bool$2=caml_int_compare,
     float$2=caml_float_compare;
    function _bZ_(c,param)
     {var y=param[3],x=param[2],ord=param[1];
      return caml_call2(CCMonomorphic[1],c,0)?caml_call2(ord,x,y):c}
    function option$1(c,o1,o2)
     {if(o1)
       {var _nM_=o1[1];
        if(o2){var x2=o2[1];return caml_call2(c,_nM_,x2)}
        return 1}
      return o2?-1:0}
    function pair$3(o_x,o_y,param,_nL_)
     {var
       y2=_nL_[2],
       x2=_nL_[1],
       y1=param[2],
       x1=param[1],
       c=caml_call2(o_x,x1,x2);
      return caml_call2(CCMonomorphic[1],c,0)?caml_call2(o_y,y1,y2):c}
    function triple$3(o_x,o_y,o_z,param,_nK_)
     {var
       z2=_nK_[3],
       y2=_nK_[2],
       x2=_nK_[1],
       z1=param[3],
       y1=param[2],
       x1=param[1],
       c=caml_call2(o_x,x1,x2);
      if(caml_call2(CCMonomorphic[1],c,0))
       {var c$0=caml_call2(o_y,y1,y2);
        return caml_call2(CCMonomorphic[1],c$0,0)?caml_call2(o_z,z1,z2):c$0}
      return c}
    function list$3(ord,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             x2=l2$0[1],
             l1$1=l1$0[2],
             x1=l1$0[1],
             c=caml_call2(ord,x1,x2);
            if(caml_call2(CCMonomorphic[1],c,0))
             {var l1$0=l1$1,l2$0=l2$1;continue}
            return c}
          return 1}
        return l2$0?-1:0}}
    function array$3(ord,a1,a2)
     {var i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,a1.length - 1))
         return caml_call2(CCMonomorphic[1],a1.length - 1,a2.length - 1)?0:-1;
        if(caml_call2(CCMonomorphic[1],i,a2.length - 1))return 1;
        var
         _nJ_=caml_check_bound(a2,i)[i + 1],
         c=caml_call2(ord,caml_check_bound(a1,i)[i + 1],_nJ_);
        if(caml_call2(CCMonomorphic[1],c,0)){var i$0=i + 1 | 0,i=i$0;continue}
        return c}}
    function map$4(f,ord,a,b)
     {var _nI_=caml_call1(f,b);return caml_call2(ord,caml_call1(f,a),_nI_)}
    function _b0_(x,f)
     {return function(_nG_,_nH_){return map$4(f,x,_nG_,_nH_)}}
    var
     CCOrd=
      [0,
       compare$9,
       opp,
       equiv,
       int$3,
       string$2,
       bool$2,
       float$2,
       _bZ_,
       option$1,
       pair$3,
       triple$3,
       list$3,
       array$3,
       map$4,
       _b0_,
       [0,_bZ_,_b0_]];
    caml_register_global(318,CCOrd,"CCOrd");
    function make$1(x,y){return [0,x,y]}
    function map1(f,param)
     {var y=param[2],x=param[1];return [0,caml_call1(f,x),y]}
    function map2$2(f,param)
     {var y=param[2],x=param[1];return [0,x,caml_call1(f,y)]}
    function map$5(f,g,param)
     {var y=param[2],x=param[1],_nF_=caml_call1(g,y);
      return [0,caml_call1(f,x),_nF_]}
    function map_same(f,param)
     {var y=param[2],x=param[1],_nE_=caml_call1(f,y);
      return [0,caml_call1(f,x),_nE_]}
    function map_fst(f,param){var x=param[1];return caml_call1(f,x)}
    function map_snd(f,param){var x=param[2];return caml_call1(f,x)}
    function iter$3(f,param)
     {var y=param[2],x=param[1];return caml_call2(f,x,y)}
    function swap$0(param){var y=param[2],x=param[1];return [0,y,x]}
    function _b1_(f,g,x)
     {var _nD_=caml_call1(g,x);return [0,caml_call1(f,x),_nD_]}
    function merge$0(f,param)
     {var y=param[2],x=param[1];return caml_call2(f,x,y)}
    function dup(x){return [0,x,x]}
    function dup_map(f,x){return [0,x,caml_call1(f,x)]}
    function equal$10(f,g,param,_nB_)
     {var
       y2=_nB_[2],
       x2=_nB_[1],
       y1=param[2],
       x1=param[1],
       _nC_=caml_call2(f,x1,x2);
      return _nC_?caml_call2(g,y1,y2):_nC_}
    function compare$10(f,g,param,_nA_)
     {var y2=_nA_[2],x2=_nA_[1],y1=param[2],x1=param[1],c=caml_call2(f,x1,x2);
      return caml_call2(CCMonomorphic[2],c,0)?c:caml_call2(g,y1,y2)}
    function pp$7(opt,pa,pb,out,param)
     {var y=param[2],x=param[1];
      if(opt)var sth=opt[1],sep=sth;else var sep=cst$30;
      return caml_call7(Format[112],out,_b2_,pa,x,sep,pb,y)}
    var
     CCPair=
      [0,
       make$1,
       map1,
       map2$2,
       map$5,
       map_same,
       map_fst,
       map_snd,
       iter$3,
       swap$0,
       map1,
       map2$2,
       map$5,
       _b1_,
       merge$0,
       merge$0,
       dup,
       dup_map,
       equal$10,
       compare$10,
       pp$7];
    caml_register_global(319,CCPair,"CCPair");
    function equal$11(param,_ny_)
     {var
       d=_ny_[2],
       c=_ny_[1],
       b=param[2],
       a=param[1],
       _nz_=caml_call2(CCMonomorphic[1],a,c);
      return _nz_?caml_call2(CCMonomorphic[1],b,d):_nz_}
    var
     hash$3=Hashtbl[21],
     H=caml_call1(Hashtbl[19],[0,equal$11,hash$3]),
     id$0=[0,0],
     ParseError=[248,cst_CCParse_ParseError,caml_fresh_oo_id(0)];
    function string_of_branch(l)
     {function pp_s(param,_nx_)
       {if(_nx_){var s=_nx_[1];return caml_call2(Format[115],_b3_,s)}
        return cst$31}
      if(l)
       {var _nr_=l[2],_ns_=l[1],_nt_=_ns_[3],_nu_=_ns_[2],_nv_=_ns_[1];
        if(_nr_)
         {var _nw_=string_of_branch(_nr_);
          return caml_call6(Format[115],_b4_,pp_s,_nt_,_nv_,_nu_,_nw_)}
        return caml_call5(Format[115],_b5_,pp_s,_nt_,_nv_,_nu_)}
      return cst$32}
    function _b6_(param)
     {if(param[1] === ParseError)
       {var
         msg=param[3],
         b=param[2],
         _np_=string_of_branch(b),
         _nq_=caml_call1(msg,0);
        return [0,caml_call3(Format[115],_b7_,_nq_,_np_)]}
      return 0}
    caml_call1(Printexc[8],_b6_);
    function state_of_string(str)
     {var
       n=32,
       s=[0,str,0,1,1,0,[246,function(_no_){return caml_call1(H[1],n)}]];
      return s}
    function is_done(st)
     {return caml_call2(CCMonomorphic[1],st[2],caml_ml_string_length(st[1]))}
    function cur(st){return caml_string_get(st[1],st[2])}
    function fail(err,st,msg)
     {var b=[0,[0,st[3],st[4],0],st[5]];
      return caml_call1(err,[0,ParseError,b,msg])}
    function next(st,ok,err)
     {if(caml_call2(CCMonomorphic[1],st[2],caml_ml_string_length(st[1])))
       return fail(err,st,function(_nn_){return cst_unexpected_end_of_input});
      var c=caml_string_get(st[1],st[2]);
      st[2] = st[2] + 1 | 0;
      if(c === 10){st[3] = st[3] + 1 | 0;st[4] = 1}else st[4] = st[4] + 1 | 0;
      return caml_call1(ok,c)}
    function pos(st){return [0,st[2],st[3],st[4]]}
    function backtrack(st,param)
     {var c=param[3],l=param[2],i=param[1];
      if(caml_call2(CCMonomorphic[5],0,i))
       if(caml_call2(CCMonomorphic[5],i,st[2]))
        {st[2] = i;st[3] = l;st[4] = c;return 0}
      throw [0,Assert_failure,_b8_]}
    function return$3(x,st,ok,param){return caml_call1(ok,x)}
    function _b9_(p,f,st,ok,err)
     {return caml_call3
              (p,st,function(x){return caml_call1(ok,caml_call1(f,x))},err)}
    function _b__(p,f,st,ok,err)
     {return caml_call3
              (p,st,function(x){return caml_call4(f,x,st,ok,err)},err)}
    function _b$_(f,x,st,ok,err)
     {return caml_call3
              (f,
               st,
               function(f)
                {return caml_call3
                         (x,
                          st,
                          function(x){return caml_call1(ok,caml_call1(f,x))},
                          err)},
               err)}
    function _ca_(x,y,st,ok,err)
     {return caml_call3
              (x,
               st,
               function(res)
                {return caml_call3
                         (y,st,function(param){return caml_call1(ok,res)},err)},
               err)}
    function _cb_(x,y,st,ok,err)
     {return caml_call3
              (x,st,function(param){return caml_call3(y,st,ok,err)},err)}
    function map$6(f,x)
     {return function(_nk_,_nl_,_nm_){return _b9_(x,f,_nk_,_nl_,_nm_)}}
    function map2$3(f,x,y)
     {function _m$_(_nh_,_ni_,_nj_){return return$3(f,_nh_,_ni_,_nj_)}
      function _na_(_ne_,_nf_,_ng_){return _b$_(_m$_,x,_ne_,_nf_,_ng_)}
      return function(_nb_,_nc_,_nd_){return _b$_(_na_,y,_nb_,_nc_,_nd_)}}
    function map3(f,x,y,z)
     {function _mW_(_m8_,_m9_,_m__){return return$3(f,_m8_,_m9_,_m__)}
      function _mX_(_m5_,_m6_,_m7_){return _b$_(_mW_,x,_m5_,_m6_,_m7_)}
      function _mY_(_m2_,_m3_,_m4_){return _b$_(_mX_,y,_m2_,_m3_,_m4_)}
      return function(_mZ_,_m0_,_m1_){return _b$_(_mY_,z,_mZ_,_m0_,_m1_)}}
    function junk(st)
     {function _mU_(param){throw [0,Assert_failure,_cc_]}
      return next(st,function(_mV_){return 0},_mU_)}
    function eoi(st,ok,err)
     {return is_done(st)
              ?caml_call1(ok,0)
              :fail(err,st,function(_mT_){return cst_expected_EOI})}
    function fail$0(msg,st,param,err)
     {return fail(err,st,function(_mS_){return msg})}
    function failf(msg){return caml_call2(Printf[9],fail$0,msg)}
    function parsing(s,p,st,ok,err)
     {st[5] = [0,[0,st[3],st[4],[0,s]],st[5]];
      function _mR_(e)
       {st[5] = caml_call1(List[6],st[5]);return caml_call1(err,e)}
      return caml_call3
              (p,
               st,
               function(x)
                {st[5] = caml_call1(List[6],st[5]);return caml_call1(ok,x)},
               _mR_)}
    function nop(param,ok,_mQ_){return caml_call1(ok,0)}
    function char$2(c)
     {var msg=caml_call2(Printf[4],_cd_,c);
      return function(st,ok,err)
       {return next
                (st,
                 function(c$0)
                  {return c === c$0
                           ?caml_call1(ok,c)
                           :fail(err,st,function(_mP_){return msg})},
                 err)}}
    function char_if(p,st,ok,err)
     {return next
              (st,
               function(c)
                {return caml_call1(p,c)
                         ?caml_call1(ok,c)
                         :fail
                           (err,
                            st,
                            function(param){return caml_call2(Printf[4],_ce_,c)})},
               err)}
    function chars_if(p,st,ok,param)
     {var i=st[2],len=[0,0];
      for(;;)
       {if(! is_done(st))if(caml_call1(p,cur(st))){junk(st);len[1]++;continue}
        return caml_call1(ok,caml_call3(include$1[4],st[1],i,len[1]))}}
    function chars1_if(p,st,ok,err)
     {return chars_if
              (p,
               st,
               function(s)
                {return caml_string_equal(s,cst$33)
                         ?fail
                           (err,
                            st,
                            function(_mO_){return cst_unexpected_sequence_of_chars})
                         :caml_call1(ok,s)},
               err)}
    function skip_chars(p,st,ok,err)
     {for(;;)
       {if(! is_done(st))if(caml_call1(p,cur(st))){junk(st);continue}
        return caml_call1(ok,0)}}
    function is_alpha(param)
     {var
       switch$0=
        91 <= param?25 < (param - 97 | 0) >>> 0?0:1:65 <= param?1:0;
      return switch$0?1:0}
    function is_num(param)
     {var switcher=param - 48 | 0;return 9 < switcher >>> 0?0:1}
    function is_alpha_num(param)
     {var
       _mN_=param - 48 | 0,
       switch$0=
        42 < _mN_ >>> 0
         ?25 < (_mN_ - 49 | 0) >>> 0?0:1
         :6 < (_mN_ - 10 | 0) >>> 0?1:0;
      return switch$0?1:0}
    function is_space(param){if(9 !== param)if(32 !== param)return 0;return 1}
    function is_white(param)
     {var switch$0=11 <= param?32 === param?1:0:9 <= param?1:0;
      return switch$0?1:0}
    function space(_mK_,_mL_,_mM_){return char_if(is_space,_mK_,_mL_,_mM_)}
    function white(_mH_,_mI_,_mJ_){return char_if(is_white,_mH_,_mI_,_mJ_)}
    function endline(st,ok,err)
     {return next
              (st,
               function(c)
                {return 10 === c
                         ?caml_call1(ok,c)
                         :fail
                           (err,st,function(_mG_){return cst_expected_end_of_line})},
               err)}
    function skip_space(_mD_,_mE_,_mF_)
     {return skip_chars(is_space,_mD_,_mE_,_mF_)}
    function skip_white(_mA_,_mB_,_mC_)
     {return skip_chars(is_white,_mA_,_mB_,_mC_)}
    function _cf_(x,y,st,ok,err)
     {var i=st[2];
      return caml_call3
              (x,
               st,
               ok,
               function(e)
                {var j=st[2];
                 return caml_call2(CCMonomorphic[1],i,j)
                         ?caml_call3(y,st,ok,err)
                         :caml_call1(err,e)})}
    function try$0(p,st,ok,err)
     {var i=pos(st);
      return caml_call3
              (p,st,ok,function(e){backtrack(st,i);return caml_call1(err,e)})}
    function suspend(f,st,ok,err){return caml_call4(f,0,st,ok,err)}
    function _cg_(x,msg,st,ok,err)
     {var i=st[2];
      return caml_call3
              (x,
               st,
               ok,
               function(e)
                {return caml_call2(CCMonomorphic[1],st[2],i)
                         ?fail(err,st,function(param){return msg})
                         :caml_call1(err,e)})}
    function string$3(s,st,ok,err)
     {function check(i)
       {return caml_call2(CCMonomorphic[1],i,caml_ml_string_length(s))
                ?caml_call1(ok,s)
                :next
                  (st,
                   function(c)
                    {return c === caml_string_get(s,i)
                             ?check(i + 1 | 0)
                             :fail
                               (err,
                                st,
                                function(param){return caml_call2(Printf[4],_ch_,s)})},
                   err)}
      return check(0)}
    function many_rec(p,acc,st,ok,err)
     {return is_done(st)
              ?caml_call1(ok,caml_call1(List[9],acc))
              :caml_call3
                (p,
                 st,
                 function(x)
                  {var i=pos(st);
                   return many_rec
                           (p,
                            [0,x,acc],
                            st,
                            ok,
                            function(param)
                             {backtrack(st,i);
                              return caml_call1(ok,caml_call1(List[9],acc))})},
                 err)}
    function many(p,st,ok,err){return many_rec(p,0,st,ok,err)}
    function many1(p,st,ok,err)
     {return caml_call3
              (p,st,function(x){return many_rec(p,[0,x,0],st,ok,err)},err)}
    function skip(p,st,ok,err)
     {var i=pos(st);
      function _mz_(param){backtrack(st,i);return caml_call1(ok,0)}
      return caml_call3(p,st,function(param){return skip(p,st,ok,err)},_mz_)}
    function sep_rec(by,p)
     {var _mr_=sep1(by,p);
      function _ms_(_mw_,_mx_,_my_){return try$0(by,_mw_,_mx_,_my_)}
      return function(_mt_,_mu_,_mv_){return _cb_(_ms_,_mr_,_mt_,_mu_,_mv_)}}
    function sep1(by,p)
     {function _l$_(x)
       {var _md_=[0,x,0];
        function _me_(_mo_,_mp_,_mq_){return return$3(_md_,_mo_,_mp_,_mq_)}
        function _mf_(tl){return [0,x,tl]}
        var _mg_=sep_rec(by,p);
        function _mh_(_ml_,_mm_,_mn_){return _b9_(_mg_,_mf_,_ml_,_mm_,_mn_)}
        return function(_mi_,_mj_,_mk_){return _cf_(_mh_,_me_,_mi_,_mj_,_mk_)}}
      return function(_ma_,_mb_,_mc_){return _b__(p,_l$_,_ma_,_mb_,_mc_)}}
    function sep(by,p)
     {var _lG_=0;
      function _lH_(_l8_,_l9_,_l__){return return$3(_lG_,_l8_,_l9_,_l__)}
      function _lI_(x)
       {var _lU_=[0,x,0];
        function _lV_(_l5_,_l6_,_l7_){return return$3(_lU_,_l5_,_l6_,_l7_)}
        function _lW_(tl){return [0,x,tl]}
        var _lX_=sep_rec(by,p);
        function _lY_(_l2_,_l3_,_l4_){return _b9_(_lX_,_lW_,_l2_,_l3_,_l4_)}
        return function(_lZ_,_l0_,_l1_){return _cf_(_lY_,_lV_,_lZ_,_l0_,_l1_)}}
      function _lJ_(_lR_,_lS_,_lT_){return try$0(p,_lR_,_lS_,_lT_)}
      function _lK_(_lO_,_lP_,_lQ_){return _b__(_lJ_,_lI_,_lO_,_lP_,_lQ_)}
      return function(_lL_,_lM_,_lN_){return _cf_(_lK_,_lH_,_lL_,_lM_,_lN_)}}
    function fix(f)
     {function p(st,ok,err){return caml_call4(f,p,st,ok,err)}return p}
    function memo(p)
     {var id=id$0[1];
      id$0[1]++;
      var r=[0,0];
      return function(st,ok,err)
       {var
         i=st[2],
         _lx_=st[6],
         _ly_=caml_obj_tag(_lx_),
         tbl=
          250 === _ly_
           ?_lx_[1]
           :246 === _ly_?caml_call1(CamlinternalLazy[2],_lx_):_lx_;
        try
         {var f=caml_call2(H[7],tbl,[0,i,id]);
          r[1] = 0;
          caml_call1(f,0);
          var _lA_=r[1];
          if(_lA_)
           {var _lB_=_lA_[1];
            if(0 === _lB_[0])
             var e=_lB_[1],_lC_=caml_call1(err,e);
            else
             var x=_lB_[1],_lC_=caml_call1(ok,x);
            return _lC_}
          throw [0,Assert_failure,_ci_]}
        catch(_lD_)
         {_lD_ = caml_wrap_exception(_lD_);
          if(_lD_ === Not_found)
           {var
             _lz_=
              function(e)
               {function _lF_(param){r[1] = [0,[0,e]];return 0}
                caml_call3(H[10],tbl,[0,i,id],_lF_);
                return caml_call1(err,e)};
            return caml_call3
                    (p,
                     st,
                     function(x)
                      {function _lE_(param){r[1] = [0,[1,x]];return 0}
                       caml_call3(H[10],tbl,[0,i,id],_lE_);
                       return caml_call1(ok,x)},
                     _lz_)}
          throw _lD_}}}
    function fix_memo(f)
     {var
       p=function _lw_(_lt_,_lu_,_lv_){return _lw_.fun(_lt_,_lu_,_lv_)},
       p$0=[246,function(_ls_){return memo(p)}];
      runtime.caml_update_dummy
       (p,
        function(st,ok,err)
         {var
           _lq_=caml_obj_tag(p$0),
           _lr_=
            250 === _lq_
             ?p$0[1]
             :246 === _lq_?caml_call1(CamlinternalLazy[2],p$0):p$0;
          return caml_call4(f,_lr_,st,ok,err)});
      return p}
    function get_lnum(st,ok,param){return caml_call1(ok,st[3])}
    function get_cnum(st,ok,param){return caml_call1(ok,st[4])}
    function get_pos(st,ok,param){return caml_call1(ok,[0,st[3],st[4]])}
    function parse_exn(p,st)
     {var res=[0,0];
      function _lo_(e){throw e}
      caml_call3(p,st,function(x){res[1] = [0,x];return 0},_lo_);
      var _lp_=res[1];
      if(_lp_){var x=_lp_[1];return x}
      throw [0,Assert_failure,_cj_]}
    function exn_to_err(e){return [1,caml_call1(Printexc[1],e)]}
    function parse(p,st)
     {try
       {var _ln_=[0,parse_exn(p,st)];return _ln_}
      catch(e){e = caml_wrap_exception(e);return exn_to_err(e)}}
    function parse_string_exn(p,s){return parse_exn(p,state_of_string(s))}
    function parse_string(p,s){return parse(p,state_of_string(s))}
    function parse_file_exn(p,file)
     {var ic=caml_call1(Pervasives[67],file),buf=caml_call1(Buffer[1],1024);
      try
       {for(;;)
         {var line=caml_call1(Pervasives[71],ic);
          caml_call2(Buffer[14],buf,line);
          caml_call2(Buffer[10],buf,10);
          continue}}
      catch(_lm_)
       {_lm_ = caml_wrap_exception(_lm_);
        if(_lm_ === End_of_file)
         {var st=state_of_string(caml_call1(Buffer[2],buf));
          try
           {var res=parse_exn(p,st);caml_call1(Pervasives[81],ic);return res}
          catch(e)
           {e = caml_wrap_exception(e);caml_call1(Pervasives[82],ic);throw e}}
        throw _lm_}}
    function parse_file(p,file)
     {try
       {var _ll_=[0,parse_file_exn(p,file)];return _ll_}
      catch(e){e = caml_wrap_exception(e);return exn_to_err(e)}}
    var Infix$2=[0,_b9_,_b__,_b$_,_ca_,_cb_,_cf_,_cg_];
    function list$4(opt,_kN_,_kM_,p)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$36;
      if(_kN_)var sth$0=_kN_[1],stop=sth$0;else var stop=cst$35;
      if(_kM_)var sth$1=_kM_[1],sep$0=sth$1;else var sep$0=cst$34;
      function _kO_(_li_,_lj_,_lk_){return string$3(stop,_li_,_lj_,_lk_)}
      function _kP_(_lf_,_lg_,_lh_){return string$3(sep$0,_lf_,_lg_,_lh_)}
      function _kQ_(_lc_,_ld_,_le_)
       {return _cb_(skip_white,_kP_,_lc_,_ld_,_le_)}
      var
       _kR_=
        sep
         (function(_k$_,_la_,_lb_)
           {return _cb_(_kQ_,skip_white,_k$_,_la_,_lb_)},
          p);
      function _kS_(_k8_,_k9_,_k__){return string$3(start,_k8_,_k9_,_k__)}
      function _kT_(_k5_,_k6_,_k7_)
       {return _cb_(_kS_,skip_white,_k5_,_k6_,_k7_)}
      function _kU_(_k2_,_k3_,_k4_){return _cb_(_kT_,_kR_,_k2_,_k3_,_k4_)}
      function _kV_(_kZ_,_k0_,_k1_)
       {return _ca_(_kU_,skip_white,_kZ_,_k0_,_k1_)}
      return function(_kW_,_kX_,_kY_){return _ca_(_kV_,_kO_,_kW_,_kX_,_kY_)}}
    function _ck_(s)
     {try
       {var
         _kD_=caml_int_of_string(s),
         _kE_=function(_kJ_,_kK_,_kL_){return return$3(_kD_,_kJ_,_kK_,_kL_)};
        return _kE_}
      catch(_kF_)
       {_kF_ = caml_wrap_exception(_kF_);
        if(_kF_[1] === Failure)
         return function(_kG_,_kH_,_kI_)
          {return fail$0(cst_expected_an_int,_kG_,_kH_,_kI_)};
        throw _kF_}}
    function _cl_(c){var _kC_=is_num(c);return _kC_?_kC_:c === 45?1:0}
    function _cm_(_kz_,_kA_,_kB_){return chars1_if(_cl_,_kz_,_kA_,_kB_)}
    function int$4(_kw_,_kx_,_ky_){return _b__(_cm_,_ck_,_kw_,_kx_,_ky_)}
    function prepend_str(c,s)
     {var _kv_=caml_call2(include$1[1],1,c);
      return caml_call2(Pervasives[16],_kv_,s)}
    function _cn_(_ks_,_kt_,_ku_)
     {return chars_if(is_alpha_num,_ks_,_kt_,_ku_)}
    var
     word=
      map2$3
       (prepend_str,
        function(_kp_,_kq_,_kr_){return char_if(is_alpha,_kp_,_kq_,_kr_)},
        _cn_);
    function pair$4(opt,_jE_,_jD_,p1,p2)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$39;
      if(_jE_)var sth$0=_jE_[1],stop=sth$0;else var stop=cst$38;
      if(_jD_)var sth$1=_jD_[1],sep=sth$1;else var sep=cst$37;
      function _jF_(x1)
       {function _jV_(x2)
         {var _kd_=[0,x1,x2];
          function _ke_(_km_,_kn_,_ko_){return return$3(_kd_,_km_,_kn_,_ko_)}
          function _kf_(_kj_,_kk_,_kl_){return string$3(stop,_kj_,_kk_,_kl_)}
          return function(_kg_,_kh_,_ki_)
           {return _cb_(_kf_,_ke_,_kg_,_kh_,_ki_)}}
        function _jW_(_ka_,_kb_,_kc_){return string$3(sep,_ka_,_kb_,_kc_)}
        function _jX_(_j9_,_j__,_j$_)
         {return _cb_(skip_white,_jW_,_j9_,_j__,_j$_)}
        function _jY_(_j6_,_j7_,_j8_)
         {return _cb_(_jX_,skip_white,_j6_,_j7_,_j8_)}
        function _jZ_(_j3_,_j4_,_j5_){return _cb_(_jY_,p2,_j3_,_j4_,_j5_)}
        return function(_j0_,_j1_,_j2_){return _b__(_jZ_,_jV_,_j0_,_j1_,_j2_)}}
      function _jG_(_jS_,_jT_,_jU_){return string$3(start,_jS_,_jT_,_jU_)}
      function _jH_(_jP_,_jQ_,_jR_)
       {return _cb_(_jG_,skip_white,_jP_,_jQ_,_jR_)}
      function _jI_(_jM_,_jN_,_jO_){return _cb_(_jH_,p1,_jM_,_jN_,_jO_)}
      return function(_jJ_,_jK_,_jL_){return _b__(_jI_,_jF_,_jJ_,_jK_,_jL_)}}
    function triple$4(opt,_iy_,_ix_,p1,p2,p3)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$42;
      if(_iy_)var sth$0=_iy_[1],stop=sth$0;else var stop=cst$41;
      if(_ix_)var sth$1=_ix_[1],sep=sth$1;else var sep=cst$40;
      function _iz_(x1)
       {function _iP_(x2)
         {function _i9_(x3)
           {var _jr_=[0,x1,x2,x3];
            function _js_(_jA_,_jB_,_jC_)
             {return return$3(_jr_,_jA_,_jB_,_jC_)}
            function _jt_(_jx_,_jy_,_jz_)
             {return string$3(stop,_jx_,_jy_,_jz_)}
            return function(_ju_,_jv_,_jw_)
             {return _cb_(_jt_,_js_,_ju_,_jv_,_jw_)}}
          function _i__(_jo_,_jp_,_jq_){return string$3(sep,_jo_,_jp_,_jq_)}
          function _i$_(_jl_,_jm_,_jn_)
           {return _cb_(skip_white,_i__,_jl_,_jm_,_jn_)}
          function _ja_(_ji_,_jj_,_jk_)
           {return _cb_(_i$_,skip_white,_ji_,_jj_,_jk_)}
          function _jb_(_jf_,_jg_,_jh_){return _cb_(_ja_,p3,_jf_,_jg_,_jh_)}
          return function(_jc_,_jd_,_je_)
           {return _b__(_jb_,_i9_,_jc_,_jd_,_je_)}}
        function _iQ_(_i6_,_i7_,_i8_){return string$3(sep,_i6_,_i7_,_i8_)}
        function _iR_(_i3_,_i4_,_i5_)
         {return _cb_(skip_white,_iQ_,_i3_,_i4_,_i5_)}
        function _iS_(_i0_,_i1_,_i2_)
         {return _cb_(_iR_,skip_white,_i0_,_i1_,_i2_)}
        function _iT_(_iX_,_iY_,_iZ_){return _cb_(_iS_,p2,_iX_,_iY_,_iZ_)}
        return function(_iU_,_iV_,_iW_){return _b__(_iT_,_iP_,_iU_,_iV_,_iW_)}}
      function _iA_(_iM_,_iN_,_iO_){return string$3(start,_iM_,_iN_,_iO_)}
      function _iB_(_iJ_,_iK_,_iL_)
       {return _cb_(_iA_,skip_white,_iJ_,_iK_,_iL_)}
      function _iC_(_iG_,_iH_,_iI_){return _cb_(_iB_,p1,_iG_,_iH_,_iI_)}
      return function(_iD_,_iE_,_iF_){return _b__(_iC_,_iz_,_iD_,_iE_,_iF_)}}
    var
     CCParse=
      [0,
       string_of_branch,
       ParseError,
       state_of_string,
       return$3,
       return$3,
       _b9_,
       map$6,
       map2$3,
       map3,
       _b__,
       _b$_,
       _ca_,
       _cb_,
       fail$0,
       failf,
       parsing,
       eoi,
       nop,
       char$2,
       char_if,
       chars_if,
       chars1_if,
       endline,
       space,
       white,
       skip_chars,
       skip_space,
       skip_white,
       is_alpha,
       is_num,
       is_alpha_num,
       is_space,
       is_white,
       _cf_,
       _cg_,
       try$0,
       suspend,
       string$3,
       many,
       many1,
       skip,
       sep,
       sep1,
       fix,
       memo,
       fix_memo,
       get_lnum,
       get_cnum,
       get_pos,
       parse,
       parse_exn,
       parse_string,
       parse_string_exn,
       parse_file,
       parse_file_exn,
       Infix$2,
       [0,list$4,int$4,word,pair$4,triple$4]];
    caml_register_global(320,CCParse,"CCParse");
    var
     _co_=include[1],
     _cp_=include[2],
     _cq_=include[3],
     _cr_=include[4],
     _cs_=include[6],
     _ct_=include[7],
     _cu_=include[8],
     _cv_=include[10],
     _cw_=include[11],
     _cx_=include[12],
     _cy_=include[13];
    function return$4(x,st){return x}
    function flat_map$2(f,g,st){return caml_call2(f,caml_call1(g,st),st)}
    function _cz_(g,f,st){return flat_map$2(f,g,st)}
    function map$7(f,g,st){return caml_call1(f,caml_call1(g,st))}
    function _cA_(g,f,st){return map$7(f,g,st)}
    function delay(f,st){return caml_call2(f,0,st)}
    function choose_array(a,st)
     {if(caml_call2(CCMonomorphic[1],a.length - 1,0))
       caml_call1(Pervasives[1],cst_CCRandom_choose_array);
      var _iw_=caml_call2(include[11][5],st,a.length - 1);
      return caml_check_bound(a,_iw_)[_iw_ + 1]}
    function choose_array$0(a,st)
     {try
       {var _iu_=[0,caml_call1(choose_array(a,st),st)];return _iu_}
      catch(_iv_)
       {_iv_ = caml_wrap_exception(_iv_);
        if(_iv_[1] === Invalid_argument)return 0;
        throw _iv_}}
    function choose(l)
     {var a=caml_call1(Array[12],l);
      return function(_it_){return choose_array$0(a,_it_)}}
    function choose_exn(l)
     {var a=caml_call1(Array[12],l);
      return function(st){return caml_call1(choose_array(a,st),st)}}
    function choose_return(l)
     {var _ir_=caml_call1(Array[12],l);
      return function(_is_){return choose_array(_ir_,_is_)}}
    var
     Pick_from_empty=
      [248,cst_CCRandom_Pick_from_empty,caml_fresh_oo_id(0)];
    function pick_list(l)
     {var n=caml_call1(List[1],l);
      if(caml_call2(CCMonomorphic[1],n,0))throw Pick_from_empty;
      return function(st)
       {var _iq_=caml_call2(include[11][5],st,n);
        return caml_call2(List[7],l,_iq_)}}
    function pick_array(a)
     {var n=a.length - 1;
      if(caml_call2(CCMonomorphic[1],n,0))throw Pick_from_empty;
      return function(st)
       {var _ip_=caml_call2(include[11][5],st,n);
        return caml_check_bound(a,_ip_)[_ip_ + 1]}}
    function int$5(i,st){return caml_call2(include[11][5],st,i)}
    var _cB_=100;
    function small_int(_io_){return int$5(_cB_,_io_)}
    function int_range(i,j,st)
     {return i + caml_call2(include[11][5],st,(j - i | 0) + 1 | 0) | 0}
    function float$3(f,st){return caml_call2(include[11][9],st,f)}
    var _cC_=100;
    function small_float(_in_){return float$3(_cC_,_in_)}
    function float_range(i,j,st)
     {return i + caml_call2(include[11][9],st,j - i)}
    function replicate$0(n,g,st)
     {var acc=0,n$0=n;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],n$0,0))return acc;
        var n$1=n$0 - 1 | 0,acc$0=[0,caml_call1(g,st),acc],acc=acc$0,n$0=n$1;
        continue}}
    function sample_without_replacement(compare,k,rng,st)
     {var S=caml_call1(Set[1],[0,compare]);
      if(caml_call2(CCMonomorphic[5],k,0))
       caml_call1(Pervasives[1],cst_sample_without_replacement);
      var s=S[1],k$0=k;
      for(;;)
       {if(caml_call2(CCMonomorphic[5],k$0,0))return caml_call1(S[21],s);
        var x=caml_call1(rng,st);
        if(caml_call2(S[3],x,s))continue;
        var k$1=k$0 - 1 | 0,s$0=caml_call2(S[4],x,s),s=s$0,k$0=k$1;
        continue}}
    function list_seq(l,st)
     {function _im_(f){return caml_call1(f,st)}
      return caml_call2(List[17],_im_,l)}
    function split$0(i,st)
     {if(caml_call2(CCMonomorphic[3],i,2))return 0;
      var j=1 + caml_call2(include[11][5],st,i - 1 | 0) | 0;
      return [0,[0,j,i - j | 0]]}
    function split_list(i,len,st)
     {if(caml_call2(CCMonomorphic[5],len,1))
       caml_call1(Pervasives[1],cst_Random_split_list);
      if(caml_call2(CCMonomorphic[6],i,len))
       {var
         _ii_=i - 1 | 0,
         _ij_=1,
         _ik_=function(_il_){return int_range(_ij_,_ii_,_il_)},
         xs=sample_without_replacement(CCMonomorphic[7],len - 1 | 0,_ik_,st),
         param$0=[0,0,xs],
         acc=0,
         param=param$0;
        for(;;)
         {if(param)
           {var _ig_=param[2],_ih_=param[1];
            if(_ig_)
             {var b=_ig_[1],acc$0=[0,b - _ih_ | 0,acc],acc=acc$0,param=_ig_;
              continue}
            return [0,[0,i - _ih_ | 0,acc]]}
          return 0}}
      return 0}
    function retry(opt,g,st)
     {if(opt)var sth=opt[1],max=sth;else var max=10;
      var n=max;
      for(;;)
       {var res=caml_call1(g,st);
        if(res)return res;
        if(caml_call2(CCMonomorphic[1],n,0))return 0;
        var n$0=n - 1 | 0,n=n$0;
        continue}}
    function try_successively(l,st)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],g=l$0[1],res=caml_call1(g,st);
          if(res)return res;
          var l$0=l$1;
          continue}
        return 0}}
    function _cD_(a,b)
     {var _ie_=[0,a,[0,b,0]];
      return function(_if_){return try_successively(_ie_,_if_)}}
    var Backtrack=[248,cst_CCRandom_Backtrack,caml_fresh_oo_id(0)];
    function choose_array_call(a,f,st)
     {try
       {var _ic_=caml_call1(f,choose_array(a,st));return _ic_}
      catch(_id_)
       {_id_ = caml_wrap_exception(_id_);
        if(_id_[1] === Invalid_argument)throw Backtrack;
        throw _id_}}
    function fix$0(opt,_hX_,_hW_,base,fuel,st)
     {if(opt)var sth=opt[1],sub1=sth;else var sub1=0;
      if(_hX_)var sth$0=_hX_[1],sub2=sth$0;else var sub2=0;
      if(_hW_)var sth$1=_hW_[1],subn=sth$1;else var subn=0;
      var
       sub1$0=caml_call1(Array[12],sub1),
       sub2$0=caml_call1(Array[12],sub2),
       subn$0=caml_call1(Array[12],subn);
      function try_otherwise(i,a)
       {var i$0=i;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],i$0,a.length - 1))throw Backtrack;
          try
           {var _ia_=caml_call1(caml_check_bound(a,i$0)[i$0 + 1],st);
            return _ia_}
          catch(_ib_)
           {_ib_ = caml_wrap_exception(_ib_);
            if(_ib_ === Backtrack){var i$1=i$0 + 1 | 0,i$0=i$1;continue}
            throw _ib_}}}
      function make(fuel,st)
       {if(caml_call2(CCMonomorphic[1],fuel,0))throw Backtrack;
        if(caml_call2(CCMonomorphic[1],fuel,1))return caml_call1(base,st);
        function _hY_(param)
         {var
           f=param[2],
           len=param[1],
           len$0=caml_call1(len,st),
           match=split_list(fuel,len$0,st);
          if(match)
           {var l=match[1];
            return caml_call2
                    (f,
                     function(st)
                      {function _h$_(x){return make(x,st)}
                       return caml_call2(List[17],_h$_,l)},
                     st)}
          throw Backtrack}
        function _hZ_(_h__){return choose_array_call(subn$0,_hY_,_h__)}
        function _h0_(f)
         {var match=split$0(fuel,st);
          if(match)
           {var
             match$0=match[1],
             j=match$0[2],
             i=match$0[1],
             _h7_=function(_h9_){return make(j,_h9_)};
            return caml_call3(f,function(_h8_){return make(i,_h8_)},_h7_,st)}
          throw Backtrack}
        function _h1_(_h6_){return choose_array_call(sub2$0,_h0_,_h6_)}
        function _h2_(f)
         {var _h4_=fuel - 1 | 0;
          return caml_call2(f,function(_h5_){return make(_h4_,_h5_)},st)}
        return try_otherwise
                (0,
                 [0,
                  function(_h3_){return choose_array_call(sub1$0,_h2_,_h3_)},
                  _h1_,
                  _hZ_,
                  base])}
      return make(caml_call1(fuel,st),st)}
    function pure$0(x,st){return x}
    function _cE_(f,g,st){return caml_call2(f,st,caml_call1(g,st))}
    var default_state=caml_call1(include[11][2],0);
    function run(opt,g)
     {if(opt)var sth=opt[1],st=sth;else var st=default_state;
      return caml_call1(g,st)}
    function uniformity_test(opt,k,rng,st)
     {if(opt)var sth=opt[1],size_hint=sth;else var size_hint=10;
      var histogram=caml_call2(Hashtbl[1],0,size_hint);
      function add(x)
       {try
         {var _hU_=caml_call2(Hashtbl[6],histogram,x),n=_hU_}
        catch(_hV_)
         {_hV_ = caml_wrap_exception(_hV_);
          if(_hV_ !== Not_found)throw _hV_;
          var n=0}
        return caml_call3(Hashtbl[11],histogram,x,n + 1 | 0)}
      var _hS_=k - 1 | 0,_hR_=0;
      if(! (_hS_ < 0))
       {var i=_hR_;
        for(;;)
         {add(caml_call1(rng,st));
          var _hT_=i + 1 | 0;
          if(_hS_ !== i){var i=_hT_;continue}
          break}}
      var
       cardinal=caml_call1(Hashtbl[15],histogram),
       average=k / cardinal,
       p=1 / cardinal,
       variance=p * (1 - p),
       std=4 * Math.sqrt(k * variance);
      function predicate(key,n,acc)
       {return acc?Math.abs(average - n) < std?1:0:acc}
      return caml_call3(Hashtbl[14],predicate,histogram,1)}
    var
     CCRandom=
      [0,
       _co_,
       _cp_,
       _cq_,
       _cr_,
       _cs_,
       _ct_,
       _cu_,
       _cv_,
       _cw_,
       _cx_,
       _cy_,
       return$4,
       flat_map$2,
       _cz_,
       map$7,
       _cA_,
       delay,
       choose,
       choose_exn,
       choose_array$0,
       choose_return,
       replicate$0,
       sample_without_replacement,
       list_seq,
       Pick_from_empty,
       pick_list,
       pick_array,
       small_int,
       int$5,
       int_range,
       small_float,
       float$3,
       float_range,
       split$0,
       split_list,
       retry,
       try_successively,
       _cD_,
       fix$0,
       pure$0,
       _cE_,
       run,
       uniformity_test];
    caml_register_global(322,CCRandom,"CCRandom");
    function create$0(x){return [0,x]}
    function map$8(f,r){return [0,caml_call1(f,r[1])]}
    function iter$4(f,r){return caml_call1(f,r[1])}
    function update$1(f,r){r[1] = caml_call1(f,r[1]);return 0}
    function incr_then_get(r){r[1]++;return r[1]}
    function get_then_incr(r){var x=r[1];r[1]++;return x}
    function compare$11(f,r1,r2){return caml_call2(f,r1[1],r2[1])}
    function equal$12(f,r1,r2){return caml_call2(f,r1[1],r2[1])}
    function swap$1(a,b){var x=a[1];a[1] = b[1];b[1] = x;return 0}
    function to_list$3(r){return [0,r[1],0]}
    function to_seq$4(r,yield$0){return caml_call1(yield$0,r[1])}
    function pp$8(pp_x,out,r){return caml_call2(pp_x,out,r[1])}
    var
     CCRef=
      [0,
       map$8,
       create$0,
       iter$4,
       update$1,
       incr_then_get,
       get_then_incr,
       swap$1,
       compare$11,
       equal$12,
       to_list$3,
       to_seq$4,
       pp$8];
    caml_register_global(323,CCRef,"CCRef");
    function return$5(x){return [0,x]}
    function fail$1(s){return [1,s]}
    function fail_printf(format)
     {var buf=caml_call1(Buffer[1],64);
      function _hQ_(buf){return [1,caml_call1(Buffer[2],buf)]}
      return caml_call3(Printf[10],_hQ_,buf,format)}
    function fail_fprintf(format)
     {var buf=caml_call1(Buffer[1],64),out=caml_call1(Format[98],buf);
      function _hP_(out)
       {caml_call2(Format[35],out,0);return [1,caml_call1(Buffer[2],buf)]}
      return caml_call3(Format[118],_hP_,out,format)}
    function add_ctx(msg,x)
     {if(0 === x[0]){var x$0=x[1];return [0,x$0]}
      var e=x[1],_hO_=caml_call2(Pervasives[16],cst_context,msg);
      return [1,caml_call2(Pervasives[16],e,_hO_)]}
    function add_ctxf(msg)
     {var buf=caml_call1(Buffer[1],64),out=caml_call1(Format[98],buf);
      function _hN_(out,e)
       {caml_call2(Format[35],out,0);
        return add_ctx(caml_call1(Buffer[2],buf),e)}
      return caml_call3(Format[118],_hN_,out,msg)}
    function of_exn(e){var msg=caml_call1(Printexc[1],e);return [1,msg]}
    function of_exn_trace(e)
     {var
       _hL_=caml_call1(Printexc[5],0),
       _hM_=caml_call1(Printexc[1],e),
       res=caml_call3(Printf[4],_cF_,_hM_,_hL_);
      return [1,res]}
    function map$9(f,e)
     {if(0 === e[0]){var x=e[1];return [0,caml_call1(f,x)]}
      var s=e[1];
      return [1,s]}
    function map_err(f,e)
     {if(0 === e[0])return e;var y=e[1];return [1,caml_call1(f,y)]}
    function map2$4(f,g,e)
     {if(0 === e[0]){var x=e[1];return [0,caml_call1(f,x)]}
      var s=e[1];
      return [1,caml_call1(g,s)]}
    function iter$5(f,e)
     {if(0 === e[0]){var x=e[1];return caml_call1(f,x)}return 0}
    var Get_error=[248,cst_CCResult_Get_error,caml_fresh_oo_id(0)];
    function get_exn$0(param)
     {if(0 === param[0]){var x=param[1];return x}throw Get_error}
    function get_or$1(e,default$0)
     {if(0 === e[0]){var x=e[1];return x}return default$0}
    function map_or$0(f,e,default$0)
     {if(0 === e[0]){var x=e[1];return caml_call1(f,x)}return default$0}
    function catch$0(e,ok,err)
     {if(0 === e[0]){var x=e[1];return caml_call1(ok,x)}
      var y=e[1];
      return caml_call1(err,y)}
    function flat_map$3(f,e)
     {if(0 === e[0]){var x=e[1];return caml_call1(f,x)}
      var s=e[1];
      return [1,s]}
    function _cG_(e,f){return map$9(f,e)}
    function _cH_(e,f){return flat_map$3(f,e)}
    function equal$13(err,eq,a,match)
     {if(0 === a[0])
       {var _hJ_=a[1];
        if(0 === match[0]){var y=match[1];return caml_call2(eq,_hJ_,y)}}
      else
       {var _hK_=a[1];
        if(0 !== match[0]){var s=match[1];return caml_call2(err,_hK_,s)}}
      return 0}
    function compare$12(err,cmp,a,match)
     {if(0 === a[0])
       {var _hH_=a[1];
        if(0 === match[0]){var y=match[1];return caml_call2(cmp,_hH_,y)}
        return 1}
      var _hI_=a[1];
      if(0 === match[0])return -1;
      var s=match[1];
      return caml_call2(err,_hI_,s)}
    function fold$2(ok,error,x)
     {if(0 === x[0]){var x$0=x[1];return caml_call1(ok,x$0)}
      var s=x[1];
      return caml_call1(error,s)}
    function fold_ok(f,acc,r)
     {if(0 === r[0]){var x=r[1];return caml_call2(f,acc,x)}return acc}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function guard(f)
     {try
       {var _hG_=[0,caml_call1(f,0)];return _hG_}
      catch(e){e = caml_wrap_exception(e);return [1,e]}}
    function guard_str(f)
     {try
       {var _hF_=[0,caml_call1(f,0)];return _hF_}
      catch(e){e = caml_wrap_exception(e);return of_exn(e)}}
    function guard_str_trace(f)
     {try
       {var _hE_=[0,caml_call1(f,0)];return _hE_}
      catch(e){e = caml_wrap_exception(e);return of_exn_trace(e)}}
    function wrap1(f,x)
     {try
       {var _hD_=[0,caml_call1(f,x)];return _hD_}
      catch(e){e = caml_wrap_exception(e);return [1,e]}}
    function wrap2$0(f,x,y)
     {try
       {var _hC_=[0,caml_call2(f,x,y)];return _hC_}
      catch(e){e = caml_wrap_exception(e);return [1,e]}}
    function wrap3(f,x,y,z)
     {try
       {var _hB_=[0,caml_call3(f,x,y,z)];return _hB_}
      catch(e){e = caml_wrap_exception(e);return [1,e]}}
    function _cI_(f,x)
     {if(0 === f[0]){var f$0=f[1];return map$9(f$0,x)}var s=f[1];return [1,s]}
    function join$0(t)
     {if(0 === t[0])
       {var _hA_=t[1];
        if(0 === _hA_[0]){var o=_hA_[1];return [0,o]}
        var e=_hA_[1];
        return [1,e]}
      return t}
    function both(x,match)
     {if(0 === x[0])
       {var _hz_=x[1];
        if(0 === match[0]){var o=match[1];return [0,[0,_hz_,o]]}
        var e=match[1];
        return [1,e]}
      var e$0=x[1];
      return [1,e$0]}
    function map_l(f,l)
     {var acc=0,l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2],x=l$0[1],match=caml_call1(f,x);
          if(0 === match[0])
           {var y=match[1],acc$0=[0,y,acc],acc=acc$0,l$0=l$1;continue}
          var s=match[1];
          return [1,s]}
        return [0,caml_call1(List[9],acc)]}}
    var LocalExit=[248,cst_CCResult_LocalExit,caml_fresh_oo_id(0)];
    function fold_seq(f,acc,seq)
     {var err=[0,0];
      try
       {var acc$0=[0,acc];
        caml_call1
         (seq,
          function(x)
           {var match=caml_call2(f,acc$0[1],x);
            if(0 === match[0]){var y=match[1];acc$0[1] = y;return 0}
            var s=match[1];
            err[1] = [0,s];
            throw LocalExit});
        var _hx_=[0,acc$0[1]];
        return _hx_}
      catch(_hy_)
       {_hy_ = caml_wrap_exception(_hy_);
        if(_hy_ === LocalExit)
         {var _hw_=err[1];
          if(_hw_){var s=_hw_[1];return [1,s]}
          throw [0,Assert_failure,_cJ_]}
        throw _hy_}}
    function fold_l(f,acc,l)
     {return fold_seq(f,acc,function(k){return caml_call2(List[15],k,l)})}
    function choose$0(l)
     {function find(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var _hv_=param$0[1];
            if(0 === _hv_[0])return _hv_;
            var param$1=param$0[2],param$0=param$1;
            continue}
          throw Not_found}}
      try
       {var _ht_=find(l);return _ht_}
      catch(_hu_)
       {_hu_ = caml_wrap_exception(_hu_);
        if(_hu_ === Not_found)
         {var
           _hs_=
            function(param)
             {if(0 === param[0])throw [0,Assert_failure,_cK_];
              var s=param[1];
              return s},
           l$0=caml_call2(List[17],_hs_,l);
          return [1,l$0]}
        throw _hu_}}
    function retry$0(n,f)
     {var n$0=n,acc=0;
      for(;;)
       {if(0 === n$0)return [1,caml_call1(List[9],acc)];
        var res=caml_call1(f,0);
        if(0 === res[0])return res;
        var e=res[1],acc$0=[0,e,acc],n$1=n$0 - 1 | 0,n$0=n$1,acc=acc$0;
        continue}}
    function to_opt(param)
     {if(0 === param[0]){var x=param[1];return [0,x]}return 0}
    function of_opt(param){if(param){var x=param[1];return [0,x]}return _cL_}
    function to_seq$5(e,k)
     {if(0 === e[0]){var x=e[1];return caml_call1(k,x)}return 0}
    function of_err(param)
     {if(106380200 <= param[1]){var y=param[2];return [1,y]}
      var x=param[2];
      return [0,x]}
    function to_err(param)
     {if(0 === param[0]){var x=param[1];return [0,17724,x]}
      var y=param[1];
      return [0,106380200,y]}
    function pp$9(pp_x,fmt,e)
     {if(0 === e[0])
       {var x=e[1];return caml_call4(Format[112],fmt,_cM_,pp_x,x)}
      var s=e[1];
      return caml_call3(Format[112],fmt,_cN_,s)}
    function pp$10(pp_x,pp_e,fmt,e)
     {if(0 === e[0])
       {var x=e[1];return caml_call4(Format[112],fmt,_cO_,pp_x,x)}
      var s=e[1];
      return caml_call4(Format[112],fmt,_cP_,pp_e,s)}
    var
     CCResult=
      [0,
       return$5,
       fail$1,
       of_exn,
       of_exn_trace,
       fail_printf,
       fail_fprintf,
       add_ctx,
       add_ctxf,
       map$9,
       map_err,
       map2$4,
       iter$5,
       Get_error,
       get_exn$0,
       get_or$1,
       map_or$0,
       catch$0,
       flat_map$3,
       _cG_,
       _cH_,
       equal$13,
       compare$12,
       fold$2,
       fold_ok,
       is_ok,
       is_error,
       guard,
       guard_str,
       guard_str_trace,
       wrap1,
       wrap2$0,
       wrap3,
       return$5,
       _cI_,
       join$0,
       both,
       [0,_cG_,_cH_,_cI_],
       map_l,
       fold_l,
       fold_seq,
       choose$0,
       retry$0,
       function(M)
        {var _hn_=M[2];
         function map_m(f,e)
          {if(0 === e[0])
            {var x=e[1],_hr_=function(y){return caml_call1(M[1],[0,y])};
             return caml_call2(_hn_,caml_call1(f,x),_hr_)}
           var s=e[1];
           return caml_call1(M[1],[1,s])}
         function sequence_m(m){return map_m(function(x){return x},m)}
         function fold_m(f,acc,e)
          {if(0 === e[0])
            {var x=e[1],_hq_=function(y){return caml_call1(M[1],y)};
             return caml_call2(_hn_,caml_call2(f,acc,x),_hq_)}
           return caml_call1(M[1],acc)}
         function retry_m(n,f)
          {function retry(n,acc)
            {if(0 === n)
              {var _ho_=[1,caml_call1(List[9],acc)];
               return caml_call1(M[1],_ho_)}
             function _hp_(param)
              {if(0 === param[0])
                {var x=param[1];return caml_call1(M[1],[0,x])}
               var e=param[1];
               return retry(n - 1 | 0,[0,e,acc])}
             return caml_call2(_hn_,caml_call1(f,0),_hp_)}
           return retry(n,0)}
         return [0,sequence_m,fold_m,map_m,retry_m]},
       to_opt,
       of_opt,
       to_seq$5,
       of_err,
       to_err,
       pp$9,
       pp$10];
    caml_register_global(324,CCResult,"CCResult");
    var
     CCSet=
      [0,
       function(_hk_)
        {var include=caml_call1(Set[1],_hk_);
         caml_fresh_oo_id(0);
         var
          _gN_=include[1],
          _gQ_=include[4],
          _gZ_=include[13],
          _g7_=include[21],
          _gO_=include[2],
          _gP_=include[3],
          _gR_=include[5],
          _gS_=include[6],
          _gT_=include[7],
          _gU_=include[8],
          _gV_=include[9],
          _gW_=include[10],
          _gX_=include[11],
          _gY_=include[12],
          _g0_=include[14],
          _g1_=include[15],
          _g2_=include[16],
          _g3_=include[17],
          _g4_=include[18],
          _g5_=include[19],
          _g6_=include[20],
          _g8_=include[22],
          _g9_=include[23],
          _g__=include[24],
          _g$_=include[25],
          _ha_=include[26],
          _hb_=include[27],
          _hc_=include[28],
          _hd_=include[29],
          _he_=include[30],
          _hf_=include[31],
          _hg_=include[32],
          _hh_=include[33],
          _hi_=include[34];
         function add_seq(set,seq)
          {var set$0=[0,set];
           caml_call1
            (seq,function(x){set$0[1] = caml_call2(_gQ_,x,set$0[1]);return 0});
           return set$0[1]}
         function of_seq(s){return add_seq(_gN_,s)}
         function to_seq(s,yield$0){return caml_call2(_gZ_,yield$0,s)}
         function _hj_(set,x){return caml_call2(_gQ_,x,set)}
         var add_list=caml_call1(List[20],_hj_);
         function of_list(l){return caml_call2(add_list,_gN_,l)}
         function pp(opt,_hm_,_hl_,pp_x,fmt,m)
          {if(opt)var sth=opt[1],start=sth;else var start=cst$45;
           if(_hm_)var sth$0=_hm_[1],stop=sth$0;else var stop=cst$44;
           if(_hl_)var sth$1=_hl_[1],sep=sth$1;else var sep=cst$43;
           caml_call2(Format[13],fmt,start);
           var first=[0,1];
           caml_call2
            (_gZ_,
             function(x)
              {if(first[1])
                first[1] = 0;
               else
                {caml_call2(Format[13],fmt,sep);caml_call2(Format[27],fmt,0)}
               return caml_call2(pp_x,fmt,x)},
             m);
           return caml_call2(Format[13],fmt,stop)}
         return [0,
                 _gN_,
                 _gO_,
                 _gP_,
                 _gQ_,
                 _gR_,
                 _gS_,
                 _gT_,
                 _gU_,
                 _gV_,
                 _gW_,
                 _gX_,
                 _gY_,
                 _gZ_,
                 _g0_,
                 _g1_,
                 _g2_,
                 _g3_,
                 _g4_,
                 _g5_,
                 _g6_,
                 _g7_,
                 _g8_,
                 _g__,
                 _ha_,
                 _hc_,
                 _hd_,
                 _g9_,
                 _g$_,
                 _hb_,
                 _he_,
                 _hf_,
                 _hg_,
                 _hh_,
                 _hi_,
                 of_seq,
                 add_seq,
                 to_seq,
                 of_list,
                 add_list,
                 _g7_,
                 pp]}];
    caml_register_global(325,CCSet,"CCSet");
    caml_call1(include$1[10],uppercase_ascii);
    caml_call1(include$1[10],lowercase_ascii);
    var
     make$2=include$1[1],
     init$1=include$1[2],
     copy$1=include$1[3],
     sub$2=include$1[4],
     fill$0=include$1[5],
     concat$1=include$1[7],
     iteri$2=include$1[9],
     map$10=include$1[10],
     mapi$1=include$1[11],
     trim=include$1[12],
     escaped$0=include$1[13],
     index=include$1[14],
     index_opt=include$1[15],
     rindex=include$1[16],
     rindex_opt=include$1[17],
     index_from=include$1[18],
     index_from_opt=include$1[19],
     rindex_from=include$1[20],
     rindex_from_opt=include$1[21],
     contains=include$1[22],
     contains_from=include$1[23],
     rcontains_from=include$1[24],
     uppercase$0=include$1[25],
     lowercase$0=include$1[26],
     capitalize=include$1[27],
     uncapitalize=include$1[28],
     uppercase_ascii$0=include$1[29],
     lowercase_ascii$0=include$1[30],
     capitalize_ascii=include$1[31],
     uncapitalize_ascii=include$1[32],
     equal$14=caml_string_equal,
     compare$13=include$1[33];
    function hash$4(s){return caml_call1(Hashtbl[21],s)}
    var length$2=caml_ml_string_length;
    function is_empty$0(s){return caml_string_equal(s,cst$46)}
    function rev$1(s)
     {var n=caml_ml_string_length(s);
      return caml_call2
              (init$1,
               n,
               function(i){return caml_string_get(s,(n - i | 0) - 1 | 0)})}
    function to_list$4(s,acc,i,len)
     {var acc$0=acc,i$0=i,len$0=len;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],len$0,0))
         return caml_call1(List[9],acc$0);
        var
         len$1=len$0 - 1 | 0,
         i$1=i$0 + 1 | 0,
         acc$1=[0,caml_string_get(s,i$0),acc$0],
         acc$0=acc$1,
         i$0=i$1,
         len$0=len$1;
        continue}}
    function is_sub(sub,i,s,j,len)
     {if(caml_call2(CCMonomorphic[4],i + len | 0,caml_ml_string_length(sub)))
       caml_call1(Pervasives[1],cst_CCString_is_sub);
      var
       _gM_=
        caml_call2(CCMonomorphic[5],j + len | 0,caml_ml_string_length(s));
      if(_gM_)
       {var k=0;
        for(;;)
         {if(caml_call2(CCMonomorphic[1],k,len))return 1;
          var
           _gK_=caml_string_get(s,j + k | 0),
           _gL_=caml_string_get(sub,i + k | 0) === _gK_?1:0;
          if(_gL_){var k$0=k + 1 | 0,k=k$0;continue}
          return _gL_}}
      return _gM_}
    function kmp_pattern_length(p){return caml_ml_string_length(p[2])}
    function kmp_compile(dir,str)
     {var
       len=caml_ml_string_length(str),
       get=
        0 === dir
         ?caml_string_get
         :function(s,i)
           {return caml_string_get
                    (s,(caml_ml_string_length(s) - i | 0) - 1 | 0)};
      if(0 === len)return [0,[0],str];
      if(1 === len)return [0,[0,-1],str];
      var failure=caml_make_vect(len,0);
      caml_check_bound(failure,0)[1] = -1;
      var i=[0,2],j=[0,0];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i[1],len))
         {var match=j[1],_gF_=get(str,j[1]);
          if(get(str,i[1] - 1 | 0) === _gF_)
           {j[1]++;
            var _gH_=i[1],_gG_=j[1];
            caml_check_bound(failure,_gH_)[_gH_ + 1] = _gG_;
            i[1]++}
          else
           if(0 === match)
            {var _gI_=i[1];
             caml_check_bound(failure,_gI_)[_gI_ + 1] = 0;
             i[1]++}
           else
            {if(! caml_call2(CCMonomorphic[4],j[1],0))
              throw [0,Assert_failure,_cQ_];
             var _gJ_=j[1];
             j[1] = caml_check_bound(failure,_gJ_)[_gJ_ + 1]}
          continue}
        return [0,failure,str]}}
    function kmp_find(pattern,s,idx)
     {var
       len=caml_ml_string_length(s),
       i=[0,idx],
       j=[0,0],
       pat_len=kmp_pattern_length(pattern);
      for(;;)
       {if(caml_call2(CCMonomorphic[3],j[1],pat_len))
         if(caml_call2(CCMonomorphic[3],i[1] + j[1] | 0,len))
          {var
            c=caml_string_get(s,i[1] + j[1] | 0),
            expected=caml_string_get(pattern[2],j[1]);
           if(c === expected)
            j[1]++;
           else
            {var
              _gE_=j[1],
              fail_offset=caml_check_bound(pattern[1],_gE_)[_gE_ + 1];
             if(caml_call2(CCMonomorphic[6],fail_offset,0))
              {if(! caml_call2(CCMonomorphic[3],fail_offset,j[1]))
                throw [0,Assert_failure,_cR_];
               i[1] = (i[1] + j[1] | 0) - fail_offset | 0;
               j[1] = fail_offset}
             else
              {j[1] = 0;i[1]++}}
           continue}
        return caml_call2(CCMonomorphic[1],j[1],pat_len)?i[1]:-1}}
    function kmp_rfind(pattern,s,idx)
     {var
       len=caml_ml_string_length(s),
       i=[0,(len - idx | 0) - 1 | 0],
       j=[0,0],
       pat_len=kmp_pattern_length(pattern);
      for(;;)
       {if(caml_call2(CCMonomorphic[3],j[1],pat_len))
         if(caml_call2(CCMonomorphic[3],i[1] + j[1] | 0,len))
          {var
            c=caml_string_get(s,((len - i[1] | 0) - j[1] | 0) - 1 | 0),
            expected=
             caml_string_get
              (pattern[2],
               (caml_ml_string_length(pattern[2]) - j[1] | 0) - 1 | 0);
           if(c === expected)
            j[1]++;
           else
            {var
              _gC_=j[1],
              fail_offset=caml_check_bound(pattern[1],_gC_)[_gC_ + 1];
             if(caml_call2(CCMonomorphic[6],fail_offset,0))
              {if(! caml_call2(CCMonomorphic[3],fail_offset,j[1]))
                throw [0,Assert_failure,_cS_];
               i[1] = (i[1] + j[1] | 0) - fail_offset | 0;
               j[1] = fail_offset}
             else
              {j[1] = 0;i[1]++}}
           continue}
        if(caml_call2(CCMonomorphic[1],j[1],pat_len))
         {var _gD_=kmp_pattern_length(pattern);
          return (len - i[1] | 0) - _gD_ | 0}
        return -1}}
    function compile(sub)
     {return caml_call2(CCMonomorphic[1],caml_ml_string_length(sub),1)
              ?[0,caml_string_get(sub,0)]
              :[1,kmp_compile(0,sub)]}
    function rcompile(sub)
     {return caml_call2(CCMonomorphic[1],caml_ml_string_length(sub),1)
              ?[0,caml_string_get(sub,0)]
              :[1,kmp_compile(1,sub)]}
    function find$3(opt,pattern,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(0 === pattern[0])
       {var c=pattern[1];
        try
         {var _gA_=caml_call3(include$1[18],s,start,c);return _gA_}
        catch(_gB_)
         {_gB_ = caml_wrap_exception(_gB_);
          if(_gB_ === Not_found)return -1;
          throw _gB_}}
      var pattern$0=pattern[1];
      return kmp_find(pattern$0,s,start)}
    function rfind(start,pattern,s)
     {if(start)
       var n=start[1],start$0=n;
      else
       var start$0=caml_ml_string_length(s) - 1 | 0;
      if(0 === pattern[0])
       {var c=pattern[1];
        try
         {var _gy_=caml_call3(include$1[20],s,start$0,c);return _gy_}
        catch(_gz_)
         {_gz_ = caml_wrap_exception(_gz_);
          if(_gz_ === Not_found)return -1;
          throw _gz_}}
      var pattern$0=pattern[1];
      return kmp_rfind(pattern$0,s,start$0)}
    function find$4(opt,sub)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      var pattern=compile(sub);
      return function(s){return find$3([0,start],pattern,s)}}
    function find_all$0(opt,sub)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      var pattern=compile(sub);
      return function(s)
       {var i=[0,start];
        return function(param)
         {var res=find$3([0,i[1]],pattern,s);
          return caml_call2(CCMonomorphic[1],res,-1)
                  ?0
                  :(i[1] = res + 1 | 0,[0,res])}}}
    function find_all_l(start,sub,s)
     {var g=caml_call1(find_all$0(start,sub),s),acc=0;
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var i=match[1],acc$0=[0,i,acc],acc=acc$0;continue}
        return caml_call1(List[9],acc)}}
    function mem$1(start,sub,s)
     {var _gx_=caml_call1(find$4(start,sub),s);
      return caml_call2(CCMonomorphic[6],_gx_,0)}
    function rfind$0(sub)
     {var pattern=rcompile(sub);
      return function(s)
       {return rfind([0,caml_ml_string_length(s) - 1 | 0],pattern,s)}}
    function replace_at(pos,len,by,s)
     {var
       b=
        caml_call1
         (Buffer[1],
          (caml_ml_string_length(s) + caml_ml_string_length(by) | 0) - len | 0);
      caml_call4(Buffer[16],b,s,0,pos);
      caml_call2(Buffer[14],b,by);
      caml_call4
       (Buffer[16],
        b,
        s,
        pos + len | 0,
        (caml_ml_string_length(s) - pos | 0) - len | 0);
      return caml_call1(Buffer[2],b)}
    function replace(opt,sub,by,s)
     {if(opt)var sth=opt[1],which=sth;else var which=3256577;
      if(is_empty$0(sub))caml_call1(Pervasives[1],cst_CCString_replace);
      if(3256577 === which)
       {var
         pattern=compile(sub),
         b=caml_call1(Buffer[1],caml_ml_string_length(s)),
         start=[0,0];
        for(;;)
         {if(caml_call2(CCMonomorphic[3],start[1],caml_ml_string_length(s)))
           {var i=find$3([0,start[1]],pattern,s);
            if(caml_call2(CCMonomorphic[6],i,0))
             {caml_call4(Buffer[16],b,s,start[1],i - start[1] | 0);
              caml_call2(Buffer[14],b,by);
              start[1] = i + caml_ml_string_length(sub) | 0}
            else
             {caml_call4
               (Buffer[16],
                b,
                s,
                start[1],
                caml_ml_string_length(s) - start[1] | 0);
              start[1] = caml_ml_string_length(s)}
            continue}
          return caml_call1(Buffer[2],b)}}
      if(847852583 <= which)
       {var i$0=caml_call1(find$4(_cT_,sub),s);
        return caml_call2(CCMonomorphic[6],i$0,0)
                ?replace_at(i$0,caml_ml_string_length(sub),by,s)
                :s}
      var i$1=caml_call1(rfind$0(sub),s);
      return caml_call2(CCMonomorphic[6],i$1,0)
              ?replace_at(i$1,caml_ml_string_length(sub),by,s)
              :s}
    function split$1(by,s,state)
     {if(state)
       {var prev=state[1],j=find$3([0,prev],by,s);
        if(caml_call2(CCMonomorphic[3],j,0))
         return [0,[0,0,prev,caml_ml_string_length(s) - prev | 0]];
        var _gv_=j - prev | 0;
        if(0 === by[0])var _gw_=1;else var p=by[1],_gw_=kmp_pattern_length(p);
        return [0,[0,[0,j + _gw_ | 0],prev,_gv_]]}
      return 0}
    function tuple3(x,y,z){return [0,x,y,z]}
    function mkgen(drop,by,s,k)
     {var state=[0,_cU_],by$0=compile(by);
      function next(param)
       {for(;;)
         {var match=split$1(by$0,s,state[1]);
          if(match)
           {var _gr_=match[1],_gs_=_gr_[2],_gt_=_gr_[1];
            if(0 === _gs_)
             if(0 === _gr_[3])if(drop[1]){state[1] = _gt_;continue}
            var _gu_=_gr_[3];
            if(0 === _gu_)
             if(drop[2])
              if(caml_call2(CCMonomorphic[1],_gs_,caml_ml_string_length(s)))
               return 0;
            state[1] = _gt_;
            return [0,caml_call3(k,s,_gs_,_gu_)]}
          return 0}}
      return next}
    function gen$0(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mkgen(drop,by,s,tuple3)}
    function gen_cpy(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mkgen(drop,by,s,include$1[4])}
    function mklist(drop,by,s,k)
     {var by$0=compile(by),acc=0,state$0=state;
      for(;;)
       {var match=split$1(by$0,s,state$0);
        if(match)
         {var _gn_=match[1],_go_=_gn_[2],_gp_=_gn_[1];
          if(0 === _go_)
           if(0 === _gn_[3])if(drop[1]){var state$0=_gp_;continue}
          var _gq_=_gn_[3];
          if(0 === _gq_)
           if(drop[2])
            if(caml_call2(CCMonomorphic[1],_go_,caml_ml_string_length(s)))
             return caml_call1(List[9],acc);
          var acc$0=[0,caml_call3(k,s,_go_,_gq_),acc],acc=acc$0,state$0=_gp_;
          continue}
        return caml_call1(List[9],acc)}}
    function list$5(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mklist(drop,by,s,tuple3)}
    function list_cpy(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mklist(drop,by,s,include$1[4])}
    function mkklist(drop,by,s,k)
     {var by$0=compile(by);
      function make(state,param)
       {var state$0=state;
        for(;;)
         {var match=split$1(by$0,s,state$0);
          if(match)
           {var _gh_=match[1],_gi_=_gh_[2],_gj_=_gh_[1];
            if(0 === _gi_)
             if(0 === _gh_[3])if(drop[1]){var state$0=_gj_;continue}
            var _gk_=_gh_[3];
            if(0 === _gk_)
             if(drop[2])
              if(caml_call2(CCMonomorphic[1],_gi_,caml_ml_string_length(s)))
               return 3902385;
            var _gl_=function(_gm_){return make(_gj_,_gm_)};
            return [0,748545553,[0,caml_call3(k,s,_gi_,_gk_),_gl_]]}
          return 3902385}}
      return function(_gg_){return make(_cV_,_gg_)}}
    function klist$0(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mkklist(drop,by,s,tuple3)}
    function klist_cpy(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return mkklist(drop,by,s,include$1[4])}
    function mkseq(drop,by,s,f,k)
     {var by$0=compile(by),state=state$0;
      for(;;)
       {var match=split$1(by$0,s,state);
        if(match)
         {var _gc_=match[1],_gd_=_gc_[2],_ge_=_gc_[1];
          if(0 === _gd_)if(0 === _gc_[3])if(drop[1]){var state=_ge_;continue}
          var _gf_=_gc_[3];
          if(0 === _gf_)
           if(drop[2])
            if(caml_call2(CCMonomorphic[1],_gd_,caml_ml_string_length(s)))
             return 0;
          caml_call1(k,caml_call3(f,s,_gd_,_gf_));
          var state=_ge_;
          continue}
        return 0}}
    function seq$1(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      return function(_gb_){return mkseq(drop,by,s,tuple3,_gb_)}}
    function seq_cpy(opt,by,s)
     {if(opt)var sth=opt[1],drop=sth;else var drop=no_drop;
      var _f$_=include$1[4];
      return function(_ga_){return mkseq(drop,by,s,_f$_,_ga_)}}
    function left_exn(by,s)
     {var i=caml_call1(find$4(0,by),s);
      if(caml_call2(CCMonomorphic[1],i,-1))throw Not_found;
      var
       right=i + caml_ml_string_length(by) | 0,
       _f__=
        caml_call3(include$1[4],s,right,caml_ml_string_length(s) - right | 0);
      return [0,caml_call3(include$1[4],s,0,i),_f__]}
    function left(by,s)
     {try
       {var _f8_=[0,left_exn(by,s)];return _f8_}
      catch(_f9_)
       {_f9_ = caml_wrap_exception(_f9_);
        if(_f9_ === Not_found)return 0;
        throw _f9_}}
    function right_exn(by,s)
     {var i=caml_call1(rfind$0(by),s);
      if(caml_call2(CCMonomorphic[1],i,-1))throw Not_found;
      var
       right=i + caml_ml_string_length(by) | 0,
       _f7_=
        caml_call3(include$1[4],s,right,caml_ml_string_length(s) - right | 0);
      return [0,caml_call3(include$1[4],s,0,i),_f7_]}
    function right(by,s)
     {try
       {var _f5_=[0,right_exn(by,s)];return _f5_}
      catch(_f6_)
       {_f6_ = caml_wrap_exception(_f6_);
        if(_f6_ === Not_found)return 0;
        throw _f6_}}
    function split_on_char(c,s)
     {return list_cpy([0,no_drop],caml_call2(include$1[1],1,c),s)}
    function split$2(by,s){return list_cpy(0,by,s)}
    function compare_versions(a,b)
     {function of_int(s)
       {try
         {var _f3_=[0,caml_int_of_string(s)];return _f3_}
        catch(_f4_){return 0}}
      var b$0=gen_cpy(0,cst$47,b),a$0=gen_cpy(0,cst$48,a);
      for(;;)
       {var match=caml_call1(a$0,0),match$0=caml_call1(b$0,0);
        if(match)
         {var _f1_=match[1];
          if(match$0)
           {var y=match$0[1],match$1=of_int(_f1_),match$2=of_int(y);
            if(match$1)
             {var _f2_=match$1[1];
              if(match$2)
               {var y$0=match$2[1],c=caml_int_compare(_f2_,y$0);
                if(caml_call2(CCMonomorphic[2],c,0))return c;
                continue}
              return 1}
            if(match$2)return -1;
            var c$0=caml_call2(include$1[33],_f1_,y);
            if(caml_call2(CCMonomorphic[2],c$0,0))return c$0;
            continue}
          return 1}
        return match$0?-1:0}}
    function compare_natural(a,b)
     {function chunks(s)
       {var i=[0,0];
        function next(param)
         {if(caml_call2(CCMonomorphic[1],i[1],caml_ml_string_length(s)))
           return 0;
          var c=caml_string_get(s,i[1]),switcher=c - 48 | 0;
          if(9 < switcher >>> 0){i[1]++;return [0,[0,c]]}
          i[1]++;
          var n=c - 48 | 0,n$0=n;
          for(;;)
           {if(caml_call2(CCMonomorphic[1],i[1],caml_ml_string_length(s)))
             return [0,[1,n$0]];
            var c$0=caml_string_get(s,i[1]),switcher$0=c$0 - 48 | 0;
            if(9 < switcher$0 >>> 0)return [0,[1,n$0]];
            i[1]++;
            var n$1=((10 * n$0 | 0) + c$0 | 0) - 48 | 0,n$0=n$1;
            continue}}
        return next}
      var b$0=chunks(b),a$0=chunks(a);
      for(;;)
       {var match=caml_call1(a$0,0),match$0=caml_call1(b$0,0);
        if(match)
         {var _fY_=match[1];
          if(match$0)
           {var y=match$0[1];
            if(0 === _fY_[0])
             {var _fZ_=_fY_[1];
              if(0 === y[0])
               {var y$0=y[1],c=caml_call2(Char[7],_fZ_,y$0);
                if(caml_call2(CCMonomorphic[2],c,0))return c;
                continue}
              return -1}
            var _f0_=_fY_[1];
            if(0 === y[0])return 1;
            var y$1=y[1],c$0=caml_int_compare(_f0_,y$1);
            if(caml_call2(CCMonomorphic[2],c$0,0))return c$0;
            continue}
          return 1}
        return match$0?-1:0}}
    function edit_distance(s1,s2)
     {if(caml_call2(CCMonomorphic[1],caml_ml_string_length(s1),0))
       return caml_ml_string_length(s2);
      if(caml_call2(CCMonomorphic[1],caml_ml_string_length(s2),0))
       return caml_ml_string_length(s1);
      if(caml_string_equal(s1,s2))return 0;
      var
       v0=caml_make_vect(caml_ml_string_length(s2) + 1 | 0,0),
       v1=caml_make_vect(caml_ml_string_length(s2) + 1 | 0,0),
       _fF_=caml_ml_string_length(s2),
       _fE_=0;
      if(! (_fF_ < 0))
       {var i$0=_fE_;
        for(;;)
         {caml_check_bound(v0,i$0)[i$0 + 1] = i$0;
          var _fX_=i$0 + 1 | 0;
          if(_fF_ !== i$0){var i$0=_fX_;continue}
          break}}
      var _fH_=caml_ml_string_length(s1) - 1 | 0,_fG_=0;
      if(! (_fH_ < 0))
       {var i=_fG_;
        for(;;)
         {caml_check_bound(v1,0)[1] = i + 1 | 0;
          var _fK_=caml_ml_string_length(s2) - 1 | 0,_fJ_=0;
          if(! (_fK_ < 0))
           {var j=_fJ_;
            for(;;)
             {var
               _fM_=caml_string_get(s2,j),
               _fN_=caml_string_get(s1,i),
               _fO_=caml_call2(Char[7],_fN_,_fM_),
               cost=caml_call2(CCMonomorphic[1],_fO_,0)?0:1,
               _fQ_=j + 1 | 0,
               _fP_=caml_check_bound(v0,j)[j + 1] + cost | 0,
               _fR_=caml_check_bound(v0,_fQ_)[_fQ_ + 1] + 1 | 0,
               _fS_=caml_call2(CCMonomorphic[8],_fR_,_fP_),
               _fT_=caml_check_bound(v1,j)[j + 1] + 1 | 0,
               _fV_=j + 1 | 0,
               _fU_=caml_call2(CCMonomorphic[8],_fT_,_fS_);
              caml_check_bound(v1,_fV_)[_fV_ + 1] = _fU_;
              var _fW_=j + 1 | 0;
              if(_fK_ !== j){var j=_fW_;continue}
              break}}
          caml_call5(Array[10],v1,0,v0,0,caml_ml_string_length(s2) + 1 | 0);
          var _fL_=i + 1 | 0;
          if(_fH_ !== i){var i=_fL_;continue}
          break}}
      var _fI_=caml_ml_string_length(s2);
      return caml_check_bound(v1,_fI_)[_fI_ + 1]}
    function repeat$0(s,n)
     {if(caml_call2(CCMonomorphic[6],n,0))
       {var len=caml_ml_string_length(s);
        if(caml_call2(CCMonomorphic[4],len,0))
         return caml_call2
                 (init$1,
                  caml_mul(len,n),
                  function(i){return caml_string_get(s,caml_mod(i,len))});
        throw [0,Assert_failure,_cW_]}
      throw [0,Assert_failure,_cX_]}
    function prefix(pre,s)
     {var len=caml_ml_string_length(pre);
      if(caml_call2(CCMonomorphic[4],len,caml_ml_string_length(s)))return 0;
      var i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,len))return 1;
        if(caml_bytes_unsafe_get(s,i) !== caml_bytes_unsafe_get(pre,i))
         return 0;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function suffix(suf,s)
     {var len=caml_ml_string_length(suf);
      if(caml_call2(CCMonomorphic[4],len,caml_ml_string_length(s)))return 0;
      var off=caml_ml_string_length(s) - len | 0,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,len))return 1;
        if
         (caml_bytes_unsafe_get(s,off + i | 0)
          !==
          caml_bytes_unsafe_get(suf,i))
         return 0;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function take$0(n,s)
     {return caml_call2(CCMonomorphic[3],n,caml_ml_string_length(s))
              ?caml_call3(include$1[4],s,0,n)
              :s}
    function drop$0(n,s)
     {return caml_call2(CCMonomorphic[3],n,caml_ml_string_length(s))
              ?caml_call3(include$1[4],s,n,caml_ml_string_length(s) - n | 0)
              :cst$49}
    function take_drop$0(n,s)
     {var _fD_=drop$0(n,s);return [0,take$0(n,s),_fD_]}
    function chop_suffix(suf,s)
     {return suffix(suf,s)
              ?[0,
                caml_call3
                 (include$1[4],
                  s,
                  0,
                  caml_ml_string_length(s) - caml_ml_string_length(suf) | 0)]
              :0}
    function chop_prefix(pre,s)
     {return prefix(pre,s)
              ?[0,
                caml_call3
                 (include$1[4],
                  s,
                  caml_ml_string_length(pre),
                  caml_ml_string_length(s) - caml_ml_string_length(pre) | 0)]
              :0}
    var blit$1=include$1[6];
    function fold$3(f,acc,s)
     {var acc$0=acc,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,caml_ml_string_length(s)))
         return acc$0;
        var
         i$0=i + 1 | 0,
         acc$1=caml_call2(f,acc$0,caml_string_get(s,i)),
         acc$0=acc$1,
         i=i$0;
        continue}}
    function pad(opt,_fC_,n,s)
     {if(opt)var sth=opt[1],side=sth;else var side=847852583;
      if(_fC_)var sth$0=_fC_[1],c=sth$0;else var c=32;
      var len_s=caml_ml_string_length(s);
      if(caml_call2(CCMonomorphic[6],len_s,n))return s;
      var pad_len=n - len_s | 0;
      return 847852583 <= side
              ?caml_call2
                (init$1,
                 n,
                 function(i)
                  {return caml_call2(CCMonomorphic[3],i,pad_len)
                           ?c
                           :caml_string_get(s,i - pad_len | 0)})
              :caml_call2
                (init$1,
                 n,
                 function(i)
                  {return caml_call2(CCMonomorphic[3],i,len_s)
                           ?caml_string_get(s,i)
                           :c})}
    function to_gen$3(s,i0,len)
     {var i=[0,i0];
      return function(param)
       {if(caml_call2(CCMonomorphic[1],i[1],i0 + len | 0))return 0;
        var c=caml_bytes_unsafe_get(s,i[1]);
        i[1]++;
        return [0,c]}}
    function to_gen$4(s){return to_gen$3(s,0,caml_ml_string_length(s))}
    function of_char(c){return caml_call2(include$1[1],1,c)}
    function of_gen$0(g)
     {var b=caml_call1(Buffer[1],32);
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var c=match[1];caml_call2(Buffer[10],b,c);continue}
        return caml_call1(Buffer[2],b)}}
    function to_seq$6(s,k){return caml_call2(include$1[8],k,s)}
    function of_seq$1(seq)
     {var b=caml_call1(Buffer[1],32);
      caml_call1(seq,caml_call1(Buffer[10],b));
      return caml_call1(Buffer[2],b)}
    function to_klist$4(s,i,len,param)
     {if(caml_call2(CCMonomorphic[1],len,0))return 3902385;
      var _fy_=len - 1 | 0,_fz_=i + 1 | 0;
      function _fA_(_fB_){return to_klist$4(s,_fz_,_fy_,_fB_)}
      return [0,748545553,[0,caml_string_get(s,i),_fA_]]}
    function of_klist$0(l)
     {var b=caml_call1(Buffer[1],15),l$0=l;
      for(;;)
       {var match=caml_call1(l$0,0);
        if(typeof match === "number")return caml_call1(Buffer[2],b);
        var match$0=match[2],l$1=match$0[2],x=match$0[1];
        caml_call2(Buffer[10],b,x);
        var l$0=l$1;
        continue}}
    function to_klist$5(s)
     {var _fv_=caml_ml_string_length(s),_fw_=0;
      return function(_fx_){return to_klist$4(s,_fw_,_fv_,_fx_)}}
    function to_list$5(s){return to_list$4(s,0,0,caml_ml_string_length(s))}
    function of_list$2(l)
     {var
       _ft_=caml_call1(List[1],l),
       buf=caml_call1(Buffer[1],_ft_),
       _fu_=caml_call1(Buffer[10],buf);
      caml_call2(List[15],_fu_,l);
      return caml_call1(Buffer[2],buf)}
    function of_array(a)
     {return caml_call2
              (init$1,
               a.length - 1,
               function(i){return caml_check_bound(a,i)[i + 1]})}
    function to_array(s)
     {function _fs_(i){return caml_string_get(s,i)}
      return caml_call2(Array[2],caml_ml_string_length(s),_fs_)}
    function lines_gen(s){return gen_cpy(_cY_,cst$50,s)}
    function lines(s){return list_cpy(_cZ_,cst$51,s)}
    function concat_gen_buf(sep,g)
     {var b=caml_call1(Buffer[1],256),first=1;
      for(;;)
       {var match=caml_call1(g,0);
        if(match)
         {var s=match[1];
          if(1 - first)caml_call2(Buffer[14],b,sep);
          caml_call2(Buffer[14],b,s);
          var first=0;
          continue}
        return b}}
    function concat_gen(sep,g)
     {var buf=concat_gen_buf(sep,g);return caml_call1(Buffer[2],buf)}
    function unlines(l)
     {var _fq_=0;
      function _fr_(n,s){return (n + 1 | 0) + caml_ml_string_length(s) | 0}
      var
       len=caml_call3(List[20],_fr_,_fq_,l),
       buf=caml_create_bytes(len),
       i=0,
       l$0=l;
      for(;;)
       {if(l$0)
         {var tail=l$0[2],s=l$0[1],len_s=caml_ml_string_length(s);
          caml_call5(Bytes[12],s,0,buf,i,len_s);
          runtime.caml_bytes_set(buf,i + len_s | 0,10);
          var i$0=(i + len_s | 0) + 1 | 0,i=i$0,l$0=tail;
          continue}
        if(caml_call2(CCMonomorphic[1],i,len))return caml_call1(Bytes[6],buf);
        throw [0,Assert_failure,_c0_]}}
    function unlines_gen(g)
     {var buf=concat_gen_buf(cst$52,g);
      caml_call2(Buffer[10],buf,10);
      return caml_call1(Buffer[2],buf)}
    function set$2(s,i,c)
     {var
       _fo_=caml_call2(CCMonomorphic[3],i,0),
       _fp_=_fo_ || caml_call2(CCMonomorphic[6],i,caml_ml_string_length(s));
      if(_fp_)caml_call1(Pervasives[1],cst_CCString_set);
      return caml_call2
              (init$1,
               caml_ml_string_length(s),
               function(j)
                {return caml_call2(CCMonomorphic[1],i,j)
                         ?c
                         :caml_string_get(s,j)})}
    var iter$6=include$1[8];
    function filter_map$1(f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      caml_call2
       (iter$6,
        function(c)
         {var match=caml_call1(f,c);
          if(match){var c$0=match[1];return caml_call2(Buffer[10],buf,c$0)}
          return 0},
        s);
      return caml_call1(Buffer[2],buf)}
    function filter$2(f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      caml_call2
       (iter$6,
        function(c)
         {var _fn_=caml_call1(f,c);
          return _fn_?caml_call2(Buffer[10],buf,c):_fn_},
        s);
      return caml_call1(Buffer[2],buf)}
    function flat_map$4(sep,f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      caml_call2
       (iteri$2,
        function(i,c)
         {if(sep)
           {var sep$0=sep[1];
            if(! caml_call2(CCMonomorphic[1],i,0))
             caml_call2(Buffer[14],buf,sep$0)}
          var _fm_=caml_call1(f,c);
          return caml_call2(Buffer[14],buf,_fm_)},
        s);
      return caml_call1(Buffer[2],buf)}
    var MyExit=[248,cst_CCString_MyExit,caml_fresh_oo_id(0)];
    function for_all$3(p,s)
     {try
       {caml_call2
         (iter$6,
          function(c)
           {var _fl_=1 - caml_call1(p,c);if(_fl_)throw MyExit;return _fl_},
          s);
        var _fj_=1;
        return _fj_}
      catch(_fk_)
       {_fk_ = caml_wrap_exception(_fk_);
        if(_fk_ === MyExit)return 0;
        throw _fk_}}
    function exists$4(p,s)
     {try
       {caml_call2
         (iter$6,
          function(c)
           {var _fi_=caml_call1(p,c);if(_fi_)throw MyExit;return _fi_},
          s);
        var _fg_=0;
        return _fg_}
      catch(_fh_)
       {_fh_ = caml_wrap_exception(_fh_);
        if(_fh_ === MyExit)return 1;
        throw _fh_}}
    function drop_while$0(f,s)
     {var i=[0,0];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i[1],caml_ml_string_length(s)))
         if(caml_call1(f,caml_bytes_unsafe_get(s,i[1]))){i[1]++;continue}
        return caml_call2(CCMonomorphic[4],i[1],0)
                ?caml_call3(sub$2,s,i[1],caml_ml_string_length(s) - i[1] | 0)
                :s}}
    function rdrop_while(f,s)
     {var i=[0,caml_ml_string_length(s) - 1 | 0];
      for(;;)
       {if(caml_call2(CCMonomorphic[6],i[1],0))
         if(caml_call1(f,caml_bytes_unsafe_get(s,i[1]))){i[1] += -1;continue}
        return caml_call2
                 (CCMonomorphic[3],i[1],caml_ml_string_length(s) - 1 | 0)
                ?caml_call3(sub$2,s,0,i[1] + 1 | 0)
                :s}}
    function is_space$0(param)
     {var
       _ff_=param - 9 | 0,
       switch$0=4 < _ff_ >>> 0?23 === _ff_?1:0:2 === _ff_?0:1;
      return switch$0?1:0}
    function ltrim(s){return drop_while$0(is_space$0,s)}
    function rtrim(s){return rdrop_while(is_space$0,s)}
    function map2$5(f,s1,s2)
     {if
       (caml_call2
         (CCMonomorphic[2],
          caml_ml_string_length(s1),
          caml_ml_string_length(s2)))
       caml_call1(Pervasives[1],cst_CCString_map2);
      return caml_call2
              (init$1,
               caml_ml_string_length(s1),
               function(i)
                {var _fe_=caml_string_get(s2,i);
                 return caml_call2(f,caml_string_get(s1,i),_fe_)})}
    function iter2$2(f,s1,s2)
     {if
       (caml_call2
         (CCMonomorphic[2],
          caml_ml_string_length(s1),
          caml_ml_string_length(s2)))
       caml_call1(Pervasives[1],cst_CCString_iter2);
      var _fb_=caml_ml_string_length(s1) - 1 | 0,_fa_=0;
      if(! (_fb_ < 0))
       {var i=_fa_;
        for(;;)
         {var _fc_=caml_string_get(s2,i);
          caml_call2(f,caml_string_get(s1,i),_fc_);
          var _fd_=i + 1 | 0;
          if(_fb_ !== i){var i=_fd_;continue}
          break}}
      return 0}
    function iteri2$0(f,s1,s2)
     {if
       (caml_call2
         (CCMonomorphic[2],
          caml_ml_string_length(s1),
          caml_ml_string_length(s2)))
       caml_call1(Pervasives[1],cst_CCString_iteri2);
      var _e9_=caml_ml_string_length(s1) - 1 | 0,_e8_=0;
      if(! (_e9_ < 0))
       {var i=_e8_;
        for(;;)
         {var _e__=caml_string_get(s2,i);
          caml_call3(f,i,caml_string_get(s1,i),_e__);
          var _e$_=i + 1 | 0;
          if(_e9_ !== i){var i=_e$_;continue}
          break}}
      return 0}
    function fold2$1(f,acc,s1,s2)
     {if
       (caml_call2
         (CCMonomorphic[2],
          caml_ml_string_length(s1),
          caml_ml_string_length(s2)))
       caml_call1(Pervasives[1],cst_CCString_fold2);
      var acc$0=acc,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,caml_ml_string_length(s1)))
         return acc$0;
        var
         i$0=i + 1 | 0,
         _e7_=caml_string_get(s2,i),
         acc$1=caml_call3(f,acc$0,caml_string_get(s1,i),_e7_),
         acc$0=acc$1,
         i=i$0;
        continue}}
    function for_all2$2(p,s1,s2)
     {try
       {iter2$2
         (function(c1,c2)
           {var _e6_=1 - caml_call2(p,c1,c2);if(_e6_)throw MyExit;return _e6_},
          s1,
          s2);
        var _e4_=1;
        return _e4_}
      catch(_e5_)
       {_e5_ = caml_wrap_exception(_e5_);
        if(_e5_ === MyExit)return 0;
        throw _e5_}}
    function exists2$2(p,s1,s2)
     {try
       {iter2$2
         (function(c1,c2)
           {var _e3_=caml_call2(p,c1,c2);if(_e3_)throw MyExit;return _e3_},
          s1,
          s2);
        var _e1_=0;
        return _e1_}
      catch(_e2_)
       {_e2_ = caml_wrap_exception(_e2_);
        if(_e2_ === MyExit)return 1;
        throw _e2_}}
    function equal_caseless(s1,s2)
     {var
       _eZ_=
        caml_call2
         (CCMonomorphic[1],
          caml_ml_string_length(s1),
          caml_ml_string_length(s2));
      return _eZ_
              ?for_all2$2
                (function(c1,c2)
                  {var _e0_=lowercase_ascii(c2);
                   return lowercase_ascii(c1) === _e0_?1:0},
                 s1,
                 s2)
              :_eZ_}
    function pp_buf$0(buf,s)
     {caml_call2(Buffer[10],buf,34);
      caml_call2(Buffer[14],buf,s);
      return caml_call2(Buffer[10],buf,34)}
    function pp$11(fmt,s){return caml_call3(Format[112],fmt,_c1_,s)}
    function make$3(s,i,len)
     {var _eW_=caml_call2(CCMonomorphic[3],i,0);
      if(_eW_)
       var _eX_=_eW_;
      else
       var
        _eY_=caml_call2(CCMonomorphic[3],len,0),
        _eX_=
         _eY_
         ||
         caml_call2(CCMonomorphic[4],i + len | 0,caml_ml_string_length(s));
      if(_eX_)caml_call1(Pervasives[1],cst_CCString_Sub_make);
      return [0,s,i,len]}
    function full$0(s){return [0,s,0,caml_ml_string_length(s)]}
    function copy$2(param)
     {var len=param[3],i=param[2],s=param[1];
      return caml_call3(include$1[4],s,i,len)}
    function underlying$0(param){var s=param[1];return s}
    function sub$3(param,i,len)
     {var len$0=param[3],i$0=param[2],s=param[1];
      if(caml_call2(CCMonomorphic[4],(i$0 + i | 0) + len | 0,i$0 + len$0 | 0))
       caml_call1(Pervasives[1],cst_CCString_Sub_sub);
      return [0,s,i$0 + i | 0,len]}
    function length$3(param){var l=param[3];return l}
    function get$2(param,j)
     {var
       l=param[3],
       i=param[2],
       s=param[1],
       _eU_=caml_call2(CCMonomorphic[3],j,0),
       _eV_=_eU_ || caml_call2(CCMonomorphic[6],j,l);
      if(_eV_)caml_call1(Pervasives[1],cst_CCString_Sub_get);
      return caml_bytes_unsafe_get(s,i + j | 0)}
    function blit$2(param,o1,a2,o2,len)
     {var len1=param[3],i1=param[2],a1=param[1];
      if(caml_call2(CCMonomorphic[4],o1 + len | 0,len1))
       caml_call1(Pervasives[1],cst_CCString_Sub_blit);
      return caml_call5(blit$1,a1,i1 + o1 | 0,a2,o2,len)}
    function fold$4(f,acc,param)
     {var len=param[3],i=param[2],s=param[1],j=i + len | 0,acc$0=acc,i$0=i;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i$0,j))return acc$0;
        var
         i$1=i$0 + 1 | 0,
         acc$1=caml_call2(f,acc$0,caml_string_get(s,i$0)),
         acc$0=acc$1,
         i$0=i$1;
        continue}}
    function to_gen$5(param)
     {var len=param[3],i=param[2],s=param[1];return to_gen$3(s,i,len)}
    function to_seq$7(param,k)
     {var len=param[3],i=param[2],s=param[1],_eS_=(i + len | 0) - 1 | 0;
      if(! (_eS_ < i))
       {var i$0=i;
        for(;;)
         {caml_call1(k,caml_string_get(s,i$0));
          var _eT_=i$0 + 1 | 0;
          if(_eS_ !== i$0){var i$0=_eT_;continue}
          break}}
      return 0}
    function to_klist$6(param)
     {var len=param[3],i=param[2],s=param[1];
      return function(_eR_){return to_klist$4(s,i,len,_eR_)}}
    function to_list$6(param)
     {var len=param[3],i=param[2],s=param[1];return to_list$4(s,0,i,len)}
    function pp_buf$1(buf,param)
     {var len=param[3],i=param[2],s=param[1];
      caml_call2(Buffer[10],buf,34);
      caml_call4(Buffer[16],buf,s,i,len);
      return caml_call2(Buffer[10],buf,34)}
    function pp$12(fmt,s)
     {var _eQ_=copy$2(s);return caml_call3(Format[112],fmt,_c2_,_eQ_)}
    var
     CCString=
      [0,
       make$2,
       copy$1,
       sub$2,
       fill$0,
       concat$1,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       equal$14,
       compare$13,
       is_empty$0,
       hash$4,
       init$1,
       rev$1,
       pad,
       of_char,
       of_gen$0,
       of_seq$1,
       of_klist$0,
       of_list$2,
       of_array,
       to_array,
       find$4,
       find_all$0,
       find_all_l,
       mem$1,
       rfind$0,
       replace,
       is_sub,
       repeat$0,
       prefix,
       suffix,
       chop_prefix,
       chop_suffix,
       take$0,
       drop$0,
       take_drop$0,
       lines,
       lines_gen,
       concat_gen,
       unlines,
       unlines_gen,
       set$2,
       iter$6,
       iteri$2,
       map$10,
       mapi$1,
       filter_map$1,
       filter$2,
       flat_map$4,
       for_all$3,
       exists$4,
       length$2,
       blit$1,
       fold$3,
       to_gen$4,
       to_seq$6,
       to_klist$5,
       to_list$5,
       pp_buf$0,
       pp$11,
       drop_while$0,
       rdrop_while,
       ltrim,
       rtrim,
       map2$5,
       iter2$2,
       iteri2$0,
       fold2$1,
       for_all2$2,
       exists2$2,
       capitalize_ascii,
       uncapitalize_ascii,
       uppercase_ascii$0,
       lowercase_ascii$0,
       equal_caseless,
       [0,compile,rcompile,find$3,rfind],
       [0,
        no_drop,
        list$5,
        gen$0,
        seq$1,
        klist$0,
        list_cpy,
        gen_cpy,
        seq_cpy,
        klist_cpy,
        left,
        left_exn,
        right,
        right_exn],
       split_on_char,
       split$2,
       compare_versions,
       compare_natural,
       edit_distance,
       [0,
        make$3,
        full$0,
        copy$2,
        underlying$0,
        sub$3,
        get$2,
        length$3,
        blit$2,
        fold$4,
        to_gen$5,
        to_seq$7,
        to_klist$6,
        to_list$6,
        pp_buf$1,
        pp$12]];
    caml_register_global(326,CCString,"CCString");
    var
     hash$5=Hashtbl[21],
     pp$13=Format[13],
     concat$2=include$1[7],
     compare$14=include$1[33],
     equal$15=include$1[34];
    function to_string$5(x){return x}
    function make$4(opt,s)
     {if(opt)var sth=opt[1],idx=sth;else var idx=0;
      return [0,s,caml_ml_string_length(s),idx]}
    var
     n_bytes=caml_ml_string_length,
     Malformed=[248,cst_CCUtf8_string_Malformed,caml_fresh_oo_id(0)];
    function next$0(st,yield$0,stop,param)
     {function malformed(st){throw [0,Malformed,st[1],st[3]]}
      function read_multi(opt,n_bytes,acc)
       {if(opt)var sth=opt[1],overlong=sth;else var overlong=0;
        if(caml_call2(CCMonomorphic[6],n_bytes,1))
         {if(caml_call2(CCMonomorphic[3],st[3] + n_bytes | 0,st[2]))
           {var j=1,acc$0=acc;
            for(;;)
             {var c=caml_string_get(st[1],st[3] + j | 0);
              if(caml_call2(CCMonomorphic[2],c >>> 6 | 0,2))malformed(st);
              var _eN_=caml_call2(CCMonomorphic[1],j,1);
              if(_eN_)
               var
                _eO_=caml_call2(CCMonomorphic[2],overlong,0),
                _eP_=_eO_?caml_call2(CCMonomorphic[3],c & 63,overlong):_eO_;
              else
               var _eP_=_eN_;
              if(_eP_)malformed(st);
              var acc$1=acc$0 << 6 | c & 63;
              if(caml_call2(CCMonomorphic[1],j,n_bytes))
               return caml_call1(Uchar[7],acc$1)
                       ?(st[3]
                         =
                         (st[3] + j | 0)
                         +
                         1
                         |
                         0,
                         caml_call1(yield$0,caml_call1(Uchar[9],acc$1)))
                       :malformed(st);
              var j$0=j + 1 | 0,j=j$0,acc$0=acc$1;
              continue}}
          return malformed(st)}
        throw [0,Assert_failure,_c3_]}
      if(caml_call2(CCMonomorphic[6],st[3],st[2]))return caml_call1(stop,0);
      var c=caml_string_get(st[1],st[3]);
      if(225 <= c)
       {if(! (241 <= c))
         return 240 <= c?read_multi(_c4_,3,c & 7):read_multi(0,2,c & 15);
        if(! (245 <= c))return read_multi(0,3,c & 7)}
      else
       {if(194 <= c)
         return 224 <= c?read_multi(_c5_,2,c & 15):read_multi(0,1,c & 31);
        if(! (128 <= c))
         {st[3] = 1 + st[3] | 0;
          return caml_call1(yield$0,caml_call1(Uchar[8],c))}}
      return malformed(st)}
    function to_gen$6(opt,str)
     {if(opt)var sth=opt[1],idx=sth;else var idx=0;
      var st=make$4([0,idx],str);
      return function(param)
       {var _eL_=0;
        function _eM_(param){return 0}
        return next$0(st,function(c){return [0,c]},_eM_,_eL_)}}
    var Stop=[248,cst_CCUtf8_string_Stop,caml_fresh_oo_id(0)];
    function to_seq$8(opt,s,yield$0)
     {if(opt)var sth=opt[1],idx=sth;else var idx=0;
      var st=make$4([0,idx],s);
      try
       {for(;;)
         {var _eJ_=0;
          next$0(st,yield$0,function(param){throw Stop},_eJ_);
          continue}}
      catch(_eK_)
       {_eK_ = caml_wrap_exception(_eK_);if(_eK_ === Stop)return 0;throw _eK_}}
    function iter$7(idx,f,s){return to_seq$8(idx,s,f)}
    function fold$5(idx,f,acc,s)
     {var st=make$4(idx,s);
      function aux(acc)
       {var _eH_=0;
        function _eI_(param){return acc}
        return next$0
                (st,
                 function(x){var acc$0=caml_call2(f,acc,x);return aux(acc$0)},
                 _eI_,
                 _eH_)}
      return aux(acc)}
    var _c6_=0;
    function _c7_(x,param){return x + 1 | 0}
    var _c8_=0;
    function n_chars(_eG_){return fold$5(_c8_,_c7_,_c6_,_eG_)}
    function to_list$7(opt,s)
     {if(opt)var sth=opt[1],idx=sth;else var idx=0;
      var
       _eE_=0,
       _eF_=fold$5([0,idx],function(acc,x){return [0,x,acc]},_eE_,s);
      return caml_call1(List[9],_eF_)}
    function code_to_string(buf,c)
     {var c$0=caml_call1(Uchar[10],c);
      if(caml_call1(Uchar[7],c$0))
       return caml_call2(CCMonomorphic[5],c$0,127)
               ?caml_call2(Buffer[10],buf,c$0)
               :caml_call2(CCMonomorphic[5],c$0,2047)
                 ?(caml_call2(Buffer[10],buf,192 | c$0 >>> 6 | 0),
                   caml_call2(Buffer[10],buf,128 | c$0 & 63))
                 :caml_call2(CCMonomorphic[5],c$0,65535)
                   ?(caml_call2(Buffer[10],buf,224 | c$0 >>> 12 | 0),
                     caml_call2(Buffer[10],buf,128 | (c$0 >>> 6 | 0) & 63),
                     caml_call2(Buffer[10],buf,128 | c$0 & 63))
                   :caml_call2(CCMonomorphic[5],c$0,2097151)
                     ?(caml_call2(Buffer[10],buf,240 | c$0 >>> 18 | 0),
                       caml_call2(Buffer[10],buf,128 | (c$0 >>> 12 | 0) & 63),
                       caml_call2(Buffer[10],buf,128 | (c$0 >>> 6 | 0) & 63),
                       caml_call2(Buffer[10],buf,128 | c$0 & 63))
                     :(caml_call2(Buffer[10],buf,248 | c$0 >>> 24 | 0),
                       caml_call2(Buffer[10],buf,128 | (c$0 >>> 18 | 0) & 63),
                       caml_call2(Buffer[10],buf,128 | (c$0 >>> 12 | 0) & 63),
                       caml_call2(Buffer[10],buf,128 | (c$0 >>> 6 | 0) & 63),
                       caml_call2(Buffer[10],buf,128 | c$0 & 63));
      throw [0,Assert_failure,_c9_]}
    function of_gen$1(g)
     {var buf=caml_call1(Buffer[1],32);
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var c=match[1];code_to_string(buf,c);continue}
        return caml_call1(Buffer[2],buf)}}
    function of_seq$2(seq)
     {var buf=caml_call1(Buffer[1],32);
      caml_call1(seq,function(_eD_){return code_to_string(buf,_eD_)});
      return caml_call1(Buffer[2],buf)}
    function of_list$3(l)
     {var buf=caml_call1(Buffer[1],32);
      function _eB_(_eC_){return code_to_string(buf,_eC_)}
      caml_call2(List[15],_eB_,l);
      return caml_call1(Buffer[2],buf)}
    function map$11(f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      iter$7(0,function(c){return code_to_string(buf,caml_call1(f,c))},s);
      return caml_call1(Buffer[2],buf)}
    function filter_map$2(f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      iter$7
       (0,
        function(c)
         {var match=caml_call1(f,c);
          if(match){var c$0=match[1];return code_to_string(buf,c$0)}
          return 0},
        s);
      return caml_call1(Buffer[2],buf)}
    function flat_map$5(f,s)
     {var buf=caml_call1(Buffer[1],caml_ml_string_length(s));
      iter$7
       (0,
        function(c)
         {var _ez_=caml_call1(f,c);
          return iter$7
                  (0,function(_eA_){return code_to_string(buf,_eA_)},_ez_)},
        s);
      return caml_call1(Buffer[2],buf)}
    var append$2=Pervasives[16];
    function unsafe_of_string(s){return s}
    function is_valid(s)
     {try
       {var st=make$4(0,s);
        for(;;)
         {var _ew_=0,_ex_=function(param){throw Stop};
          next$0(st,function(param){return 0},_ex_,_ew_);
          continue}}
      catch(_ey_)
       {_ey_ = caml_wrap_exception(_ey_);
        if(_ey_[1] === Malformed)return 0;
        if(_ey_ === Stop)return 1;
        throw _ey_}}
    function of_string_exn$3(s)
     {return is_valid(s)
              ?s
              :caml_call1(Pervasives[1],cst_CCUtf8_string_of_string_exn)}
    function of_string$4(s){return is_valid(s)?[0,s]:0}
    var
     CCUtf8_string=
      [0,
       equal$15,
       hash$5,
       compare$14,
       pp$13,
       to_string$5,
       Malformed,
       to_gen$6,
       to_seq$8,
       to_list$7,
       fold$5,
       iter$7,
       n_chars,
       n_bytes,
       map$11,
       filter_map$2,
       flat_map$5,
       append$2,
       concat$2,
       of_seq$2,
       of_gen$1,
       of_list$3,
       of_string_exn$3,
       of_string$4,
       is_valid,
       unsafe_of_string];
    caml_register_global(328,CCUtf8_string,"CCUtf8_string");
    function freeze(v){return [0,v[1],v[2]]}
    function freeze_copy(v)
     {var _ev_=caml_call3(Array[7],v[2],0,v[1]);return [0,v[1],_ev_]}
    function create$1(param){return [0,0,[0]]}
    function create_with(opt,x)
     {if(opt)var sth=opt[1],capacity=sth;else var capacity=128;
      return [0,0,caml_make_vect(capacity,x)]}
    function return$6(x){return [0,1,[0,x]]}
    function make$5(n,x){return [0,n,caml_make_vect(n,x)]}
    function init$2(n,f){return [0,n,caml_call2(Array[2],n,f)]}
    function array_is_empty(v)
     {return caml_call2(CCMonomorphic[1],v[2].length - 1,0)}
    function resize(v,newcapacity)
     {if(caml_call2(CCMonomorphic[6],newcapacity,v[1]))
       {if(array_is_empty(v))throw [0,Assert_failure,_c__];
        var new_vec=caml_make_vect(newcapacity,caml_check_bound(v[2],0)[1]);
        caml_call5(Array[10],v[2],0,new_vec,0,v[1]);
        v[2] = new_vec;
        return 0}
      throw [0,Assert_failure,_c$_]}
    function ensure_assuming_not_empty(v,size)
     {if(caml_call2(CCMonomorphic[4],size,Sys[14]))
       return caml_call1(Pervasives[2],cst_vec_ensure_size_too_big);
      var n=[0,caml_call2(CCMonomorphic[9],8,v[2].length - 1)];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],n[1],size))
         {n[1] = caml_call2(CCMonomorphic[8],Sys[14],2 * n[1] | 0);continue}
        return resize(v,n[1])}}
    function ensure_with(init,v,size)
     {return caml_call2(CCMonomorphic[1],v[2].length - 1,0)
              ?(v[2] = caml_make_vect(size,init),0)
              :ensure_assuming_not_empty(v,size)}
    function ensure(v,size)
     {var _eu_=caml_call2(CCMonomorphic[4],v[2].length - 1,0);
      return _eu_?ensure_assuming_not_empty(v,size):_eu_}
    function clear$0(v){v[1] = 0;return 0}
    function is_empty$1(v){return caml_call2(CCMonomorphic[1],v[1],0)}
    function push_unsafe(v,x){v[2][v[1] + 1] = x;v[1] = v[1] + 1 | 0;return 0}
    function push$0(v,x)
     {if(caml_call2(CCMonomorphic[1],v[1],v[2].length - 1))
       if(array_is_empty(v))
        v[2] = caml_make_vect(4,x);
       else
        {var
          n=v[2].length - 1,
          size=caml_call2(CCMonomorphic[8],(2 * n | 0) + 3 | 0,Sys[14]);
         if(caml_call2(CCMonomorphic[1],size,n))
          caml_call1(Pervasives[2],cst_vec_can_t_grow_any_further);
         resize(v,size)}
      return push_unsafe(v,x)}
    function append$3(a,b)
     {if(array_is_empty(a))
       return array_is_empty(b)
               ?0
               :(a[2] = caml_call1(Array[8],b[2]),a[1] = b[1],0);
      ensure_assuming_not_empty(a,a[1] + b[1] | 0);
      if(caml_call2(CCMonomorphic[6],a[2].length - 1,a[1] + b[1] | 0))
       {caml_call5(Array[10],b[2],0,a[2],a[1],b[1]);
        a[1] = a[1] + b[1] | 0;
        return 0}
      throw [0,Assert_failure,_da_]}
    function get$3(v,i)
     {var
       _es_=caml_call2(CCMonomorphic[3],i,0),
       _et_=_es_ || caml_call2(CCMonomorphic[6],i,v[1]);
      if(_et_)caml_call1(Pervasives[1],cst_CCVector_get);
      return v[2][i + 1]}
    function set$3(v,i,x)
     {var
       _eq_=caml_call2(CCMonomorphic[3],i,0),
       _er_=_eq_ || caml_call2(CCMonomorphic[6],i,v[1]);
      if(_er_)caml_call1(Pervasives[1],cst_CCVector_set);
      return v[2][i + 1] = x}
    function remove$1(v,i)
     {var
       _em_=caml_call2(CCMonomorphic[3],i,0),
       _en_=_em_ || caml_call2(CCMonomorphic[6],i,v[1]);
      if(_en_)caml_call1(Pervasives[1],cst_CCVector_remove);
      if(caml_call2(CCMonomorphic[3],i,v[1] - 1 | 0))
       {var _eo_=v[1] - 1 | 0,_ep_=caml_check_bound(v[2],_eo_)[_eo_ + 1];
        caml_check_bound(v[2],i)[i + 1] = _ep_}
      v[1] = v[1] - 1 | 0;
      return 0}
    function append_seq(a,seq)
     {return caml_call1(seq,function(x){return push$0(a,x)})}
    function append_array(a,b)
     {var len_b=b.length - 1;
      return array_is_empty(a)
              ?(a[2] = caml_call1(Array[8],b),a[1] = len_b,0)
              :(ensure_assuming_not_empty(a,a[1] + len_b | 0),
                caml_call5(Array[10],b,0,a[2],a[1],len_b),
                a[1]
                =
                a[1]
                +
                len_b
                |
                0,
                0)}
    function append_list(a,b)
     {if(b)
       {var x=b[1],len_a=a[1],len_b=caml_call1(List[1],b);
        ensure_with(x,a,len_a + len_b | 0);
        var _ek_=function(_el_){return push_unsafe(a,_el_)};
        caml_call2(List[15],_ek_,b);
        return 0}
      return 0}
    function append_gen(a,b)
     {for(;;)
       {var match=caml_call1(b,0);
        if(match){var x=match[1];push$0(a,x);continue}
        return 0}}
    function equal$16(eq,v1,v2)
     {var _ef_=caml_call2(CCMonomorphic[1],v1[1],v2[1]);
      if(_ef_)
       {var n=v1[1],i=0;
        for(;;)
         {var _eg_=caml_call2(CCMonomorphic[1],i,n);
          if(_eg_)
           var _eh_=_eg_;
          else
           {var _ei_=get$3(v2,i),_ej_=caml_call2(eq,get$3(v1,i),_ei_);
            if(_ej_){var i$0=i + 1 | 0,i=i$0;continue}
            var _eh_=_ej_}
          return _eh_}}
      return _ef_}
    function compare$15(cmp,v1,v2)
     {var n=caml_call2(CCMonomorphic[8],v1[1],v2[1]),i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,n))
         return caml_call2(CCMonomorphic[7],v1[1],v2[1]);
        var _ee_=get$3(v2,i),c=caml_call2(cmp,get$3(v1,i),_ee_);
        if(caml_call2(CCMonomorphic[1],c,0)){var i$0=i + 1 | 0,i=i$0;continue}
        return c}}
    var Empty=[248,cst_CCVector_Empty,caml_fresh_oo_id(0)];
    function pop_exn$0(v)
     {if(caml_call2(CCMonomorphic[1],v[1],0))throw Empty;
      v[1] = v[1] - 1 | 0;
      var _ed_=v[1],x=caml_check_bound(v[2],_ed_)[_ed_ + 1];
      return x}
    function pop$0(v)
     {try
       {var _eb_=[0,pop_exn$0(v)];return _eb_}
      catch(_ec_)
       {_ec_ = caml_wrap_exception(_ec_);
        if(_ec_ === Empty)return 0;
        throw _ec_}}
    function top(v)
     {if(caml_call2(CCMonomorphic[1],v[1],0))return 0;
      var _ea_=v[1] - 1 | 0;
      return [0,caml_check_bound(v[2],_ea_)[_ea_ + 1]]}
    function top_exn(v)
     {if(caml_call2(CCMonomorphic[1],v[1],0))throw Empty;
      var _d$_=v[1] - 1 | 0;
      return caml_check_bound(v[2],_d$_)[_d$_ + 1]}
    function copy$3(v)
     {var _d__=caml_call3(Array[7],v[2],0,v[1]);return [0,v[1],_d__]}
    function shrink(v,n)
     {var
       _d8_=caml_call2(CCMonomorphic[3],n,v[1]),
       _d9_=_d8_?(v[1] = n,0):_d8_;
      return _d9_}
    function sort$1(cmp,v)
     {var
       a=
        caml_call2(CCMonomorphic[1],v[2].length - 1,v[1])
         ?v[2]
         :caml_call3(Array[7],v[2],0,v[1]);
      caml_call2(Array[27],cmp,a);
      v[2] = a;
      return 0}
    function sort$2(cmp,v)
     {var _d7_=caml_call3(Array[7],v[2],0,v[1]),v$0=[0,v[1],_d7_];
      caml_call2(Array[25],cmp,v$0[2]);
      return v$0}
    function uniq_sort(cmp,v)
     {sort$1(cmp,v);
      var n=v[1],_d6_=caml_call2(CCMonomorphic[4],v[1],0);
      if(_d6_)
       {var prev$1=caml_check_bound(v[2],0)[1],prev=prev$1,i=1,j=1;
        for(;;)
         {if(caml_call2(CCMonomorphic[6],i,n))return 0;
          var _d4_=caml_call2(cmp,prev,caml_check_bound(v[2],i)[i + 1]);
          if(caml_call2(CCMonomorphic[1],_d4_,0))
           {v[1] = v[1] - 1 | 0;var i$0=i + 1 | 0,i=i$0;continue}
          var _d5_=caml_check_bound(v[2],i)[i + 1];
          caml_check_bound(v[2],j)[j + 1] = _d5_;
          var
           j$0=j + 1 | 0,
           i$1=i + 1 | 0,
           prev$0=caml_check_bound(v[2],i)[i + 1],
           prev=prev$0,
           i=i$1,
           j=j$0;
          continue}}
      return _d6_}
    function iter$8(k,v)
     {var n=v[1],_d2_=n - 1 | 0,_d1_=0;
      if(! (_d2_ < 0))
       {var i=_d1_;
        for(;;)
         {caml_call1(k,v[2][i + 1]);
          var _d3_=i + 1 | 0;
          if(_d2_ !== i){var i=_d3_;continue}
          break}}
      return 0}
    function iteri$3(k,v)
     {var n=v[1],_dZ_=n - 1 | 0,_dY_=0;
      if(! (_dZ_ < 0))
       {var i=_dY_;
        for(;;)
         {caml_call2(k,i,v[2][i + 1]);
          var _d0_=i + 1 | 0;
          if(_dZ_ !== i){var i=_d0_;continue}
          break}}
      return 0}
    function map$12(f,v)
     {if(array_is_empty(v))return create$1(0);
      function _dX_(i){return caml_call1(f,v[2][i + 1])}
      var vec=caml_call2(Array[2],v[1],_dX_);
      return [0,v[1],vec]}
    function map_in_place(f,v)
     {return iteri$3
              (function(i,x)
                {var _dW_=caml_call1(f,x);return v[2][i + 1] = _dW_},
               v)}
    function filter$3(p,v)
     {var i=[0,0],j=[0,0],n=v[1];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i[1],n))
         {var _dS_=i[1];
          if(caml_call1(p,caml_check_bound(v[2],_dS_)[_dS_ + 1]))
           {if(caml_call2(CCMonomorphic[4],i[1],j[1]))
             {var
               _dT_=i[1],
               _dU_=caml_check_bound(v[2],_dT_)[_dT_ + 1],
               _dV_=j[1];
              caml_check_bound(v[2],_dV_)[_dV_ + 1] = _dU_}
            i[1]++;
            j[1]++;
            continue}
          i[1]++;
          continue}
        v[1] = j[1];
        return 0}}
    function filter$4(p,v)
     {if(array_is_empty(v))return create$1(0);
      var _dQ_=caml_check_bound(v[2],0)[1],v$0=create_with([0,v[1]],_dQ_);
      iter$8
       (function(x)
         {var _dR_=caml_call1(p,x);return _dR_?push_unsafe(v$0,x):_dR_},
        v);
      return v$0}
    function fold$6(f,acc,v)
     {var acc$0=acc,i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,v[1]))return acc$0;
        var
         x=v[2][i + 1],
         i$0=i + 1 | 0,
         acc$1=caml_call2(f,acc$0,x),
         acc$0=acc$1,
         i=i$0;
        continue}}
    function exists$5(p,v)
     {var n=v[1],i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,n))return 0;
        var _dP_=caml_call1(p,caml_check_bound(v[2],i)[i + 1]);
        if(_dP_)return _dP_;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$4(p,v)
     {var n=v[1],i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,n))return 1;
        var _dO_=caml_call1(p,caml_check_bound(v[2],i)[i + 1]);
        if(_dO_){var i$0=i + 1 | 0,i=i$0;continue}
        return _dO_}}
    function member(eq,x,v){return exists$5(caml_call1(eq,x),v)}
    function find_internal(p,v)
     {var n=v[1],i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,n))throw Not_found;
        var x=caml_check_bound(v[2],i)[i + 1];
        if(caml_call1(p,x))return x;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function find_exn(p,v)
     {try
       {var _dM_=find_internal(p,v);return _dM_}
      catch(_dN_)
       {_dN_ = caml_wrap_exception(_dN_);
        if(_dN_ === Not_found)throw Not_found;
        throw _dN_}}
    function find$5(p,v)
     {try
       {var _dK_=[0,find_internal(p,v)];return _dK_}
      catch(_dL_)
       {_dL_ = caml_wrap_exception(_dL_);
        if(_dL_ === Not_found)return 0;
        throw _dL_}}
    function find_map$0(f,v)
     {var n=v[1],i=0;
      for(;;)
       {if(caml_call2(CCMonomorphic[1],i,n))return 0;
        var res=caml_call1(f,caml_check_bound(v[2],i)[i + 1]);
        if(res)return res;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function filter_map$3(f,v)
     {var v$0=create$1(0);
      iter$8
       (function(x)
         {var match=caml_call1(f,x);
          if(match){var y=match[1];return push$0(v$0,y)}
          return 0},
        v);
      return v$0}
    function filter_map_in_place(f,v)
     {var i=[0,0],j=[0,0],n=v[1];
      for(;;)
       {if(caml_call2(CCMonomorphic[3],i[1],n))
         {var
           _dI_=i[1],
           match=caml_call1(f,caml_check_bound(v[2],_dI_)[_dI_ + 1]);
          if(match)
           {var y=match[1],_dJ_=j[1];
            caml_check_bound(v[2],_dJ_)[_dJ_ + 1] = y;
            i[1]++;
            j[1]++}
          else
           i[1]++;
          continue}
        v[1] = j[1];
        return 0}}
    function flat_map$6(f,v)
     {var v$0=create$1(0);
      iter$8
       (function(x)
         {var _dG_=caml_call1(f,x);
          return iter$8(function(_dH_){return push$0(v$0,_dH_)},_dG_)},
        v);
      return v$0}
    function flat_map_seq(f,v)
     {var v$0=create$1(0);
      iter$8
       (function(x){var seq=caml_call1(f,x);return append_seq(v$0,seq)},v);
      return v$0}
    function flat_map_list(f,v)
     {var v$0=create$1(0);
      iter$8(function(x){var l=caml_call1(f,x);return append_list(v$0,l)},v);
      return v$0}
    function _db_(x,f){return flat_map$6(f,x)}
    function _dc_(x,f){return map$12(f,x)}
    function rev_in_place(v)
     {var _dB_=caml_call2(CCMonomorphic[4],v[1],0);
      if(_dB_)
       {var n=v[1],vec=v[2],_dD_=(n - 1 | 0) / 2 | 0,_dC_=0;
        if(! (_dD_ < 0))
         {var i=_dC_;
          for(;;)
           {var x=vec[i + 1],y=vec[((n - i | 0) - 1 | 0) + 1];
            vec[i + 1] = y;
            vec[((n - i | 0) - 1 | 0) + 1] = x;
            var _dF_=i + 1 | 0;
            if(_dD_ !== i){var i=_dF_;continue}
            break}}
        var _dE_=0}
      else
       var _dE_=_dB_;
      return _dE_}
    function rev$2(v){var v$0=copy$3(v);rev_in_place(v$0);return v$0}
    function rev_iter(f,v)
     {var n=v[1],_dz_=n - 1 | 0;
      if(! (_dz_ < 0))
       {var i=_dz_;
        for(;;)
         {caml_call1(f,v[2][i + 1]);
          var _dA_=i - 1 | 0;
          if(0 !== i){var i=_dA_;continue}
          break}}
      return 0}
    function size$0(v){return v[1]}
    function length$4(v){return v[1]}
    function capacity(v){return v[2].length - 1}
    function unsafe_get_array(v){return v[2]}
    function of_seq$3(opt,seq)
     {if(opt)var sth=opt[1],init=sth;else var init=create$1(0);
      append_seq(init,seq);
      return init}
    function to_seq$9(v,k){return iter$8(k,v)}
    function to_seq_rev(v,k)
     {var n=v[1],_dx_=n - 1 | 0;
      if(! (_dx_ < 0))
       {var i=_dx_;
        for(;;)
         {caml_call1(k,v[2][i + 1]);
          var _dy_=i - 1 | 0;
          if(0 !== i){var i=_dy_;continue}
          break}}
      return 0}
    function slice_seq(v,start,len)
     {if(caml_call2(CCMonomorphic[6],start,0))
       if(caml_call2(CCMonomorphic[6],len,0))
        return function(k)
         {if(caml_call2(CCMonomorphic[5],start + len | 0,v[1]))
           {var _dv_=(start + len | 0) - 1 | 0;
            if(! (_dv_ < start))
             {var i=start;
              for(;;)
               {var x=v[2][i + 1];
                caml_call1(k,x);
                var _dw_=i + 1 | 0;
                if(_dv_ !== i){var i=_dw_;continue}
                break}}
            return 0}
          throw [0,Assert_failure,_dd_]};
      throw [0,Assert_failure,_de_]}
    function slice$0(v){return [0,v[2],0,v[1]]}
    function _df_(i,j)
     {return caml_call2(CCMonomorphic[4],i,j)
              ?init$2((i - j | 0) + 1 | 0,function(k){return i - k | 0})
              :init$2((j - i | 0) + 1 | 0,function(k){return i + k | 0})}
    function _dg_(i,j)
     {return caml_call2(CCMonomorphic[1],i,j)
              ?create$1(0)
              :caml_call2(CCMonomorphic[4],i,j)
                ?init$2(i - j | 0,function(k){return i - k | 0})
                :init$2(j - i | 0,function(k){return i + k | 0})}
    function of_array$0(a)
     {return caml_call2(CCMonomorphic[1],a.length - 1,0)
              ?create$1(0)
              :[0,a.length - 1,caml_call1(Array[8],a)]}
    function of_list$4(l)
     {if(l)
       {var _dr_=l[2],_ds_=l[1];
        if(_dr_)
         {if(_dr_[2])
           {var
             v=create_with([0,caml_call1(List[1],l)],_ds_),
             _dt_=function(_du_){return push_unsafe(v,_du_)};
            caml_call2(List[15],_dt_,l);
            return v}
          var y=_dr_[1];
          return [0,2,[0,_ds_,y]]}
        return return$6(_ds_)}
      return create$1(0)}
    function to_array$0(v){return caml_call3(Array[7],v[2],0,v[1])}
    function to_list$8(v)
     {var _dp_=0,_dq_=fold$6(function(acc,x){return [0,x,acc]},_dp_,v);
      return caml_call1(List[9],_dq_)}
    function of_gen$2(opt,g)
     {if(opt)var sth=opt[1],init=sth;else var init=create$1(0);
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1];push$0(init,x);continue}
        return init}}
    function to_gen$7(v)
     {var i=[0,0];
      return function(param)
       {if(caml_call2(CCMonomorphic[3],i[1],v[1]))
         {var _do_=i[1],x=caml_check_bound(v[2],_do_)[_do_ + 1];
          i[1]++;
          return [0,x]}
        return 0}}
    function of_klist$1(opt,l)
     {if(opt)var sth=opt[1],init=sth;else var init=create$1(0);
      var l$0=l;
      for(;;)
       {var match=caml_call1(l$0,0);
        if(typeof match === "number")return init;
        var match$0=match[2],l$1=match$0[2],x=match$0[1];
        push$0(init,x);
        var l$0=l$1;
        continue}}
    function to_klist$7(v)
     {function aux(i,param)
       {if(caml_call2(CCMonomorphic[1],i,v[1]))return 3902385;
        var _dl_=i + 1 | 0;
        function _dm_(_dn_){return aux(_dl_,_dn_)}
        return [0,748545553,[0,caml_check_bound(v[2],i)[i + 1],_dm_]]}
      var _dj_=0;
      return function(_dk_){return aux(_dj_,_dk_)}}
    function pp$14(opt,_di_,_dh_,pp_item,fmt,v)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$55;
      if(_di_)var sth$0=_di_[1],stop=sth$0;else var stop=cst$54;
      if(_dh_)var sth$1=_dh_[1],sep=sth$1;else var sep=cst$53;
      caml_call2(Format[13],fmt,start);
      iteri$3
       (function(i,x)
         {if(caml_call2(CCMonomorphic[4],i,0))
           {caml_call2(Format[13],fmt,sep);caml_call2(Format[27],fmt,0)}
          return caml_call2(pp_item,fmt,x)},
        v);
      return caml_call2(Format[13],fmt,stop)}
    var
     CCVector=
      [0,
       freeze,
       freeze_copy,
       create$1,
       create_with,
       return$6,
       make$5,
       init$2,
       clear$0,
       ensure_with,
       ensure,
       is_empty$1,
       push$0,
       append$3,
       append_array,
       append_seq,
       append_list,
       append_gen,
       equal$16,
       compare$15,
       Empty,
       pop$0,
       pop_exn$0,
       top,
       top_exn,
       copy$3,
       shrink,
       member,
       sort$2,
       sort$1,
       uniq_sort,
       iter$8,
       iteri$3,
       map$12,
       map_in_place,
       filter$4,
       filter$3,
       fold$6,
       exists$5,
       for_all$4,
       find$5,
       find_exn,
       find_map$0,
       filter_map$3,
       filter_map_in_place,
       flat_map$6,
       flat_map_seq,
       flat_map_list,
       _db_,
       _dc_,
       get$3,
       set$3,
       remove$1,
       rev$2,
       rev_in_place,
       rev_iter,
       size$0,
       length$4,
       capacity,
       unsafe_get_array,
       _df_,
       _dg_,
       of_array$0,
       of_list$4,
       to_array$0,
       to_list$8,
       of_seq$3,
       to_seq$9,
       to_seq_rev,
       slice$0,
       slice_seq,
       of_klist$1,
       to_klist$7,
       of_gen$2,
       to_gen$7,
       pp$14];
    caml_register_global(330,CCVector,"CCVector");
    var
     create$2=Hashtbl[1],
     clear$1=Hashtbl[2],
     reset=Hashtbl[3],
     copy$4=Hashtbl[4],
     add$0=Hashtbl[5],
     find$6=Hashtbl[6],
     find_opt$0=Hashtbl[7],
     find_all$1=Hashtbl[8],
     mem$2=Hashtbl[9],
     remove$2=Hashtbl[10],
     replace$0=Hashtbl[11],
     iter$9=Hashtbl[12],
     filter_map_inplace=Hashtbl[13],
     fold$7=Hashtbl[14],
     length$5=Hashtbl[15],
     randomize=Hashtbl[16],
     is_randomized=Hashtbl[17],
     stats=Hashtbl[18],
     Make$1=Hashtbl[19],
     MakeSeeded=Hashtbl[20],
     hash$6=Hashtbl[21],
     seeded_hash=Hashtbl[22],
     hash_param=Hashtbl[23],
     seeded_hash_param=Hashtbl[24],
     get$4=include$2[1],
     get_or$2=include$2[2],
     keys$0=include$2[3],
     values$0=include$2[4],
     keys_list$0=include$2[5],
     values_list$0=include$2[6],
     map_list$0=include$2[7],
     incr$0=include$2[8],
     decr$0=include$2[9],
     to_seq$10=include$2[10],
     add_list$0=include$2[11],
     add_seq$0=include$2[12],
     of_seq$4=include$2[13],
     add_seq_count$0=include$2[14],
     of_seq_count$0=include$2[15],
     to_list$9=include$2[16],
     of_list$5=include$2[17],
     update$2=include$2[18],
     get_or_add$0=include$2[19],
     pp$15=include$2[20],
     Hashtbl$0=
      [0,
       create$2,
       clear$1,
       reset,
       copy$4,
       add$0,
       find$6,
       find_opt$0,
       find_all$1,
       mem$2,
       remove$2,
       replace$0,
       iter$9,
       filter_map_inplace,
       fold$7,
       length$5,
       randomize,
       is_randomized,
       stats,
       Make$1,
       MakeSeeded,
       hash$6,
       seeded_hash,
       hash_param,
       seeded_hash_param,
       get$4,
       get_or$2,
       keys$0,
       values$0,
       keys_list$0,
       values_list$0,
       map_list$0,
       incr$0,
       decr$0,
       to_seq$10,
       add_list$0,
       add_seq$0,
       of_seq$4,
       add_seq_count$0,
       of_seq_count$0,
       to_list$9,
       of_list$5,
       update$2,
       get_or_add$0,
       pp$15,
       0],
     compare$16=CCMonomorphic[7],
     min$1=CCMonomorphic[8],
     max$1=CCMonomorphic[9],
     Containers=
      [0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       Hashtbl$0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       CCMonomorphic[1],
       CCMonomorphic[2],
       CCMonomorphic[3],
       CCMonomorphic[4],
       CCMonomorphic[5],
       CCMonomorphic[6],
       compare$16,
       min$1,
       max$1,
       CCMonomorphic[10],
       CCMonomorphic[11],
       CCMonomorphic[12],
       CCMonomorphic[13],
       CCMonomorphic[14],
       CCMonomorphic[15],
       CCMonomorphic[16],
       CCMonomorphic[17]];
    caml_register_global(331,Containers,"Containers");
    return}
  (function(){return this}()));


//# 1 ".js/containers.data/containers_data.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_div=runtime.caml_div,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_and=runtime.caml_int64_and,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_shift_right_unsigned=runtime.caml_int64_shift_right_unsigned,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_make_vect=runtime.caml_make_vect,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_update_dummy=runtime.caml_update_dummy,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_bv=caml_new_string("bv {"),
     cst=caml_new_string("}"),
     cst_reset_negative_index$0=caml_new_string("reset: negative index"),
     cst_reset_negative_index=caml_new_string("reset: negative index"),
     cst_set_negative_index=caml_new_string("set: negative index"),
     cst_get_negative_index=caml_new_string("get: negative index"),
     cst_resize_negative_size=caml_new_string("resize: negative size"),
     cst_CCBV_FoundFirst=caml_new_string("CCBV.FoundFirst"),
     cst_CCBitField_TooManyFields=caml_new_string("CCBitField.TooManyFields"),
     cst_CCBitField_Frozen=caml_new_string("CCBitField.Frozen"),
     cst_LRU_empty_queue=caml_new_string("LRU: empty queue"),
     cst_CCDeque_Empty=caml_new_string("CCDeque.Empty"),
     cst_take_back_l_cannot_take_negative_number_of_arguments$0=
      caml_new_string("take_back_l: cannot take negative number of arguments"),
     cst_take_back_l_cannot_take_negative_number_of_arguments=
      caml_new_string("take_back_l: cannot take negative number of arguments"),
     q=[0,0],
     cst_CCFQueue_Empty=caml_new_string("CCFQueue.Empty"),
     cst_Fun_vec_pop_exn=caml_new_string("Fun_vec.pop_exn"),
     cst_A_set=caml_new_string("A.set"),
     cst_A_pop=caml_new_string("A.pop"),
     cst_A_push=caml_new_string("A.push"),
     cst_A_get=caml_new_string("A.get"),
     cst_graph=caml_new_string("graph"),
     cst$0=caml_new_string("["),
     cst$1=caml_new_string("]"),
     cst_CCGraph_Sequence_once=caml_new_string("CCGraph.Sequence_once"),
     cst_CCGraph_Seq_Exit=caml_new_string("CCGraph.Seq.Exit_"),
     cst_CCGraph_Has_cycle=caml_new_string("CCGraph.Has_cycle"),
     cst$4=caml_new_string(","),
     cst$2=caml_new_string("{"),
     cst$3=caml_new_string("}"),
     cst_CCHashSet_Make_E_FastExit=
      caml_new_string("CCHashSet.Make(E).FastExit"),
     cst$5=caml_new_string(" -> "),
     cst_CCHashTrie_Make_Key_LocalExit=
      caml_new_string("CCHashTrie.Make(Key).LocalExit"),
     cst_CCHashTrie_Transient_Frozen=
      caml_new_string("CCHashTrie.Transient.Frozen"),
     cst_Store=caml_new_string("Store"),
     cst$8=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst$6=caml_new_string(", "),
     cst_CCImmutArray_ExitNow=caml_new_string("CCImmutArray.ExitNow"),
     cst$9=caml_new_string(", "),
     cst_CCMultiSet_update=caml_new_string("CCMultiSet.update"),
     cst_CCMultiSet_remove_mult=caml_new_string("CCMultiSet.remove_mult"),
     cst_CCMultiSet_add_mult=caml_new_string("CCMultiSet.add_mult"),
     cst$11=caml_new_string(","),
     cst$10=caml_new_string("->"),
     cst_CCPersistentHashtbl_Make_H_ExitPTbl=
      caml_new_string("CCPersistentHashtbl.Make(H).ExitPTbl"),
     cst_RAL_get=caml_new_string("RAL.get"),
     cst_RAL_get$0=caml_new_string("RAL.get"),
     cst_RAL_set=caml_new_string("RAL.set"),
     cst_RAL_set$0=caml_new_string("RAL.set"),
     cst$12=caml_new_string(", "),
     cst_RAL_front_exn=caml_new_string("RAL.front_exn"),
     cst_RAL_tl=caml_new_string("RAL.tl"),
     cst_RAL_hd=caml_new_string("RAL.hd"),
     cst_CCRingBuffer_get_back=caml_new_string("CCRingBuffer.get_back"),
     cst_CCRingBuffer_get_front=caml_new_string("CCRingBuffer.get_front"),
     cst_CCRingBuffer_get=caml_new_string("CCRingBuffer.get"),
     cst_CCRingBuffer_get$0=caml_new_string("CCRingBuffer.get"),
     cst_CCRingBuffer_skip=caml_new_string("CCRingBuffer.skip"),
     cst_CCRingBuffer_blit_into=caml_new_string("CCRingBuffer.blit_into"),
     cst_CCRingBuffer_blit_from=caml_new_string("CCRingBuffer.blit_from"),
     cst_CCRingBuffer_create=caml_new_string("CCRingBuffer.create"),
     cst_CCRingBuffer_MakeFromArray_A_Empty=
      caml_new_string("CCRingBuffer.MakeFromArray(A).Empty"),
     cst_Queue_peek$0=caml_new_string("Queue.peek"),
     cst_Queue_peek=caml_new_string("Queue.peek"),
     empty$8=[0,0,0],
     start=caml_new_string("["),
     stop=caml_new_string("]"),
     arrow=caml_new_string("->"),
     sep=caml_new_string(","),
     cst_zipper_right_exn=caml_new_string("zipper.right_exn"),
     cst_zipper_left_exn=caml_new_string("zipper.left_exn"),
     empty$9=[0,0,0],
     Format=global_data.Format,
     Pervasives=global_data.Pervasives,
     List=global_data.List,
     Array=global_data.Array,
     Not_found=global_data.Not_found,
     Assert_failure=global_data.Assert_failure,
     Sys=global_data.Sys,
     Map=global_data.Map,
     Hashtbl=global_data.Hashtbl,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Lazy=global_data.Lazy,
     Failure=global_data.Failure,
     Queue=global_data.Queue,
     Stack=global_data.Stack,
     Int64=global_data.Int64,
     Set=global_data.Set,
     Invalid_argument=global_data.Invalid_argument,
     Bytes=global_data.Bytes,
     Buffer=global_data.Buffer,
     String=global_data.String,
     Char=global_data.Char,
     Random=global_data.Random,
     width=Sys[10] - 1 | 0,
     a=caml_make_vect(width + 1 | 0,0),
     _c_=[0,caml_new_string("src/data/CCBV.ml"),233,2],
     _b_=[0,caml_new_string("src/data/CCBV.ml"),106,4],
     _d_=[0,caml_new_string("src/data/CCBijection.ml"),62,4],
     _m_=[0,caml_new_string("src/data/CCCache.ml"),348,4],
     _l_=[0,caml_new_string("src/data/CCCache.ml"),289,4],
     _k_=[0,caml_new_string("src/data/CCCache.ml"),211,4],
     _j_=[0,caml_new_string("src/data/CCCache.ml"),149,4],
     _i_=[0,caml_new_string("src/data/CCCache.ml"),96,4],
     _s_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _r_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<hov2>"),0],caml_new_string("<hov2>")]],
        [11,caml_new_string("deque {"),0]],
       caml_new_string("@[<hov2>deque {")],
     _t_=[0,[12,125,[17,0,0]],caml_new_string("}@]")],
     _q_=[0,caml_new_string("src/data/CCDeque.ml"),188,12],
     _p_=[0,caml_new_string("src/data/CCDeque.ml"),159,12],
     _o_=[0,caml_new_string("src/data/CCDeque.ml"),135,14],
     _n_=[0,caml_new_string("src/data/CCDeque.ml"),81,2],
     _v_=[0,caml_new_string("src/data/CCFQueue.ml"),63,38],
     _w_=[0,caml_new_string("src/data/CCFQueue.ml"),81,37],
     _x_=[0,caml_new_string("src/data/CCFQueue.ml"),106,29],
     _y_=[0,caml_new_string("src/data/CCFQueue.ml"),176,38],
     _D_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _C_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<hov2>"),0],caml_new_string("<hov2>")]],
        [11,caml_new_string("queue {"),0]],
       caml_new_string("@[<hov2>queue {")],
     _E_=[0,[12,125,[17,0,0]],caml_new_string("}@]")],
     _u_=[0,caml_new_string("src/data/CCFQueue.ml"),44,2],
     _M_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _K_=[0,caml_new_string("src/data/CCFun_vec.ml"),221,6],
     _L_=[0,caml_new_string("src/data/CCFun_vec.ml"),229,6],
     _I_=[0,caml_new_string("src/data/CCFun_vec.ml"),200,6],
     _H_=[0,caml_new_string("src/data/CCFun_vec.ml"),201,6],
     _G_=[0,caml_new_string("src/data/CCFun_vec.ml"),202,6],
     _J_=[0,caml_new_string("src/data/CCFun_vec.ml"),206,4],
     _F_=[0,caml_new_string("src/data/CCFun_vec.ml"),179,6],
     _ad_=[0,caml_new_string("src/data/CCGraph.ml"),730,25],
     _ab_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<h>"),0],caml_new_string("<h>")]],
        [15,[12,32,[15,[12,59,[17,0,[17,[0,caml_new_string("@,"),0,0],0]]]]]]],
       caml_new_string("@[<h>%a %a;@]@,")],
     _aa_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<h>"),0],caml_new_string("<h>")]],
        [15,
         [11,
          caml_new_string(" -> "),
          [15,
           [12,32,[15,[12,59,[17,0,[17,[0,caml_new_string("@,"),0,0],0]]]]]]]]],
       caml_new_string("@[<h>%a -> %a %a;@]@,")],
     ___=
      [0,
       [11,caml_new_string("vertex_"),[4,0,0,0,0]],
       caml_new_string("vertex_%d")],
     _U_=
      [0,
       [11,caml_new_string("weight="),[4,0,0,0,0]],
       caml_new_string("weight=%d")],
     _V_=
      [0,[11,caml_new_string("style="),[2,0,0]],caml_new_string("style=%s")],
     _W_=
      [0,[11,caml_new_string("shape="),[2,0,0]],caml_new_string("shape=%s")],
     _X_=
      [0,
       [11,caml_new_string('label="'),[2,0,[12,34,0]]],
       caml_new_string('label="%s"')],
     _Y_=
      [0,[11,caml_new_string("color="),[2,0,0]],caml_new_string("color=%s")],
     _Z_=
      [0,
       [2,0,[11,caml_new_string('="'),[2,0,[12,34,0]]]],
       caml_new_string('%s="%s"')],
     _$_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<v2>"),0],caml_new_string("<v2>")]],
        [11,
         caml_new_string('digraph "'),
         [2,
          0,
          [11,caml_new_string('" {'),[17,[0,caml_new_string("@;"),1,0],0]]]]],
       caml_new_string('@[<v2>digraph "%s" {@;')],
     _ac_=
      [0,
       [12,125,[17,0,[17,[0,caml_new_string("@;"),1,0],[17,2,0]]]],
       caml_new_string("}@]@;@?")],
     _T_=
      [0,[12,44,[17,[0,caml_new_string("@;"),1,0],0]],caml_new_string(",@;")],
     _P_=[0,caml_new_string("src/data/CCGraph.ml"),425,4],
     _Q_=[0,caml_new_string("src/data/CCGraph.ml"),429,6],
     _R_=[0,caml_new_string("src/data/CCGraph.ml"),466,17],
     _S_=[0,caml_new_string("src/data/CCGraph.ml"),482,6],
     _ax_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _aw_=[0,caml_new_string("src/data/CCHashTrie.ml"),363,20],
     _at_=[255,1,0,0],
     _au_=[255,1,0,0],
     _av_=[255,0,0,0],
     _aq_=[255,1,0,0],
     _ar_=[255,1,0,0],
     _as_=[255,0,0,0],
     _an_=[255,1,0,0],
     _ao_=[255,1,0,0],
     _ap_=[255,0,0,0],
     _ak_=[255,1,0,0],
     _al_=[255,0,0,0],
     _am_=[255,1,0,0],
     _aj_=[255,0,0,0],
     _ae_=[255,5592405,5592405,21845],
     _af_=[255,3355443,3355443,13107],
     _ag_=[255,3355443,3355443,13107],
     _ah_=[255,986895,986895,3855],
     _ai_=[255,127,0,0],
     _aA_=[0,caml_new_string("src/data/CCHet.ml"),152,13],
     _az_=[0,caml_new_string("src/data/CCHet.ml"),98,13],
     _ay_=[0,caml_new_string("src/data/CCHet.ml"),78,11],
     _aD_=[0,caml_new_string("src/data/CCIntMap.ml"),456,42],
     _aE_=[0,caml_new_string("src/data/CCIntMap.ml"),512,41],
     _aG_=
      [0,[4,0,0,0,[11,caml_new_string(" -> "),0]],caml_new_string("%d -> ")],
     _aF_=
      [0,
       [18,
        [1,[0,[11,caml_new_string("<hov2>"),0],caml_new_string("<hov2>")]],
        [11,caml_new_string("intmap {"),[17,[0,caml_new_string("@,"),0,0],0]]],
       caml_new_string("@[<hov2>intmap {@,")],
     _aH_=[0,[12,125,[17,0,0]],caml_new_string("}@]")],
     _aB_=[0,caml_new_string("src/data/CCIntMap.ml"),206,4],
     _aC_=[0,caml_new_string("src/data/CCIntMap.ml"),209,4],
     _aM_=[0,caml_new_string("src/data/CCMultiSet.ml"),193,25],
     _aL_=[0,caml_new_string("src/data/CCMultiSet.ml"),184,25],
     _aK_=[0,caml_new_string("src/data/CCMultiSet.ml"),176,25],
     _aJ_=[0,caml_new_string("src/data/CCMultiSet.ml"),167,25],
     _aO_=
      [0,[12,59,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(";@ ")],
     _aN_=[0,[11,caml_new_string("[|"),0],caml_new_string("[|")],
     _aP_=[0,[11,caml_new_string("|]"),0],caml_new_string("|]")],
     _aR_=[0,[15,[12,32,[2,0,[12,32,[15,0]]]]],caml_new_string("%a %s %a")],
     _aQ_=[0,caml_new_string("src/data/CCPersistentHashtbl.ml"),289,4],
     _aS_=[0,caml_new_string("src/data/CCRAL.ml"),352,4],
     _aT_=[0,caml_new_string("src/data/CCRAL.ml"),357,6],
     _a2_=[0,caml_new_string("src/data/CCRingBuffer.ml"),596,4],
     _a1_=[0,caml_new_string("src/data/CCRingBuffer.ml"),439,6],
     _a6_=
      [0,[12,44,[17,[0,caml_new_string("@ "),1,0],0]],caml_new_string(",@ ")],
     _a4_=[0,caml_new_string("src/data/CCSimple_queue.ml"),47,12],
     _a3_=[0,caml_new_string("src/data/CCSimple_queue.ml"),38,12],
     _a8_=[0,caml_new_string("src/data/CCTrie.ml"),505,29],
     _a7_=[0,caml_new_string("src/data/CCTrie.ml"),493,10],
     _a9_=[0,caml_new_string("src/data/CCTrie.ml"),656,10],
     _be_=[0,0,0,0],
     _bd_=[0,caml_new_string("src/data/CCWBTree.ml"),272,11],
     _bc_=[0,caml_new_string("src/data/CCWBTree.ml"),269,11],
     _bb_=[0,caml_new_string("src/data/CCWBTree.ml"),262,11],
     _ba_=[0,caml_new_string("src/data/CCWBTree.ml"),250,11],
     _a$_=[0,caml_new_string("src/data/CCWBTree.ml"),247,11],
     _a__=[0,caml_new_string("src/data/CCWBTree.ml"),240,11],
     _a_=1;
    if(! (width < 1))
     {var i=_a_;
      for(;;)
       {var
         _bf_=i - 1 | 0,
         _bg_=caml_check_bound(a,_bf_)[_bf_ + 1] | 1 << (i - 1 | 0);
        caml_check_bound(a,i)[i + 1] = _bg_;
        var _bh_=i + 1 | 0;
        if(width !== i){var i=_bh_;continue}
        break}}
    var all_ones=caml_check_bound(a,width)[width + 1];
    function length(t){return t[2]}
    function empty(param){return [0,[0],0]}
    function array_length_of_size(size)
     {return 0 === caml_mod(size,width)
              ?caml_div(size,width)
              :caml_div(size,width) + 1 | 0}
    function create(size,default$0)
     {if(0 === size)return [0,[0],size];
      var
       n=array_length_of_size(size),
       a$0=default$0?caml_make_vect(n,all_ones):caml_make_vect(n,0),
       r=caml_mod(size,width),
       _p7_=default$0?0 !== r?1:0:default$0;
      if(_p7_)a$0[(n - 1 | 0) + 1] = caml_check_bound(a,r)[r + 1];
      return [0,a$0,size]}
    function copy(bv)
     {var _p6_=bv[2];return [0,caml_call1(Array[8],bv[1]),_p6_]}
    function capacity(bv){return caml_mul(width,bv[1].length - 1)}
    function cardinal(bv)
     {if(0 === bv[2])return 0;
      var n$1=[0,0],_p4_=bv[1].length - 1 - 1 | 0,_p3_=0;
      if(! (_p4_ < 0))
       {var i=_p3_;
        a:
        for(;;)
         {var n$2=caml_check_bound(bv[1],i)[i + 1],count=0,n=n$2;
          for(;;)
           {if(0 !== n)
             {var
               n$0=n & (n - 1 | 0),
               count$0=count + 1 | 0,
               count=count$0,
               n=n$0;
              continue}
            n$1[1] = n$1[1] + count | 0;
            var _p5_=i + 1 | 0;
            if(_p4_ !== i){var i=_p5_;continue a}
            break}
          break}}
      return n$1[1]}
    function really_resize(bv,desired,current,size)
     {var a=caml_make_vect(desired,0);
      caml_call5(Array[10],bv[1],0,a,0,current);
      bv[1] = a;
      bv[2] = size;
      return 0}
    function grow(bv,size)
     {if(size <= capacity(bv)){bv[2] = size;return 0}
      var desired=array_length_of_size(size),current=bv[1].length - 1;
      if(current < desired)return really_resize(bv,desired,current,size);
      throw [0,Assert_failure,_b_]}
    function shrink(bv,size)
     {var desired=array_length_of_size(size),current=bv[1].length - 1;
      return really_resize(bv,desired,current,size)}
    function resize(bv,size)
     {if(size < 0)caml_call1(Pervasives[1],cst_resize_negative_size);
      return size < bv[2]?shrink(bv,size):size === bv[2]?0:grow(bv,size)}
    function is_empty(bv)
     {try
       {var _pZ_=bv[1].length - 1 - 1 | 0,_pY_=0;
        if(! (_pZ_ < 0))
         {var i=_pY_;
          for(;;)
           {if(0 !== caml_check_bound(bv[1],i)[i + 1])throw Pervasives[3];
            var _p1_=i + 1 | 0;
            if(_pZ_ !== i){var i=_p1_;continue}
            break}}
        var _p0_=1;
        return _p0_}
      catch(_p2_)
       {_p2_ = caml_wrap_exception(_p2_);
        if(_p2_ === Pervasives[3])return 0;
        throw _p2_}}
    function get(bv,i)
     {if(i < 0)caml_call1(Pervasives[1],cst_get_negative_index);
      var n=caml_div(i,width),i$0=caml_mod(i,width);
      return n < bv[1].length - 1?0 !== (bv[1][n + 1] & 1 << i$0)?1:0:0}
    function set(bv,i)
     {if(0 <= i)
       {var n=caml_div(i,width),j=caml_mod(i,width);
        if(bv[2] <= i)grow(bv,i + 1 | 0);
        bv[1][n + 1] = bv[1][n + 1] | 1 << j;
        return 0}
      return caml_call1(Pervasives[1],cst_set_negative_index)}
    function reset(bv,i)
     {if(0 <= i)
       {var n=caml_div(i,width),j=caml_mod(i,width);
        if(bv[2] <= i)grow(bv,i + 1 | 0);
        var _pX_=caml_call1(Pervasives[9],1 << j);
        bv[1][n + 1] = bv[1][n + 1] & _pX_;
        return 0}
      return caml_call1(Pervasives[1],cst_reset_negative_index)}
    function flip(bv,i)
     {if(0 <= i)
       {var n=caml_div(i,width),j=caml_mod(i,width);
        if(bv[2] <= i)grow(bv,i + 1 | 0);
        bv[1][n + 1] = bv[1][n + 1] ^ 1 << j;
        return 0}
      return caml_call1(Pervasives[1],cst_reset_negative_index$0)}
    function clear(bv){return caml_call4(Array[9],bv[1],0,bv[1].length - 1,0)}
    function iter(bv,f)
     {var len=array_length_of_size(bv[2]);
      if(len <= bv[1].length - 1)
       {var _pM_=len - 2 | 0,_pL_=0;
        if(! (_pM_ < 0))
         {var n=_pL_;
          for(;;)
           {var j$0=caml_mul(width,n),_pU_=width - 1 | 0,_pT_=0;
            if(! (_pU_ < 0))
             {var i$0=_pT_;
              for(;;)
               {caml_call2
                 (f,
                  j$0 + i$0 | 0,
                  0 !== (caml_check_bound(bv[1],n)[n + 1] & 1 << i$0)?1:0);
                var _pW_=i$0 + 1 | 0;
                if(_pU_ !== i$0){var i$0=_pW_;continue}
                break}}
            var _pV_=n + 1 | 0;
            if(_pM_ !== n){var n=_pV_;continue}
            break}}
        var _pN_=0 < bv[2]?1:0;
        if(_pN_)
         {var
           j=caml_mul(width,len - 1 | 0),
           r=caml_mod(bv[2],width),
           final_length=0 === r?width:r,
           _pP_=final_length - 1 | 0,
           _pO_=0;
          if(! (_pP_ < 0))
           {var i=_pO_;
            for(;;)
             {var _pR_=len - 1 | 0;
              caml_call2
               (f,
                j + i | 0,
                0 !== (caml_check_bound(bv[1],_pR_)[_pR_ + 1] & 1 << i)?1:0);
              var _pS_=i + 1 | 0;
              if(_pP_ !== i){var i=_pS_;continue}
              break}}
          var _pQ_=0}
        else
         var _pQ_=_pN_;
        return _pQ_}
      throw [0,Assert_failure,_c_]}
    function iter_true(bv,f)
     {return iter(bv,function(i,b){return b?caml_call1(f,i):0})}
    function to_list(bv)
     {var l=[0,0];
      iter_true(bv,function(i){l[1] = [0,i,l[1]];return 0});
      return l[1]}
    function to_sorted_list(bv)
     {var _pK_=to_list(bv);return caml_call1(List[9],_pK_)}
    function of_list(l)
     {var
       size=caml_call3(List[20],Pervasives[5],0,l) + 1 | 0,
       bv=create(size,0);
      function _pJ_(i){return set(bv,i)}
      caml_call2(List[15],_pJ_,l);
      return bv}
    var FoundFirst=[248,cst_CCBV_FoundFirst,caml_fresh_oo_id(0)];
    function first_exn(bv)
     {try
       {iter_true(bv,function(i){throw [0,FoundFirst,i]});throw Not_found}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === FoundFirst){var i=exn[2];return i}
        throw exn}}
    function first(bv)
     {try
       {var _pH_=[0,first_exn(bv)];return _pH_}
      catch(_pI_)
       {_pI_ = caml_wrap_exception(_pI_);
        if(_pI_ === Not_found)return 0;
        throw _pI_}}
    function filter(bv,p)
     {return iter_true
              (bv,
               function(i)
                {var _pG_=1 - caml_call1(p,i);return _pG_?reset(bv,i):_pG_})}
    function negate_self(b)
     {var len=b[1].length - 1,_pz_=len - 1 | 0,_py_=0;
      if(! (_pz_ < 0))
       {var n=_py_;
        for(;;)
         {var _pE_=caml_call1(Pervasives[9],b[1][n + 1]);
          b[1][n + 1] = _pE_;
          var _pF_=n + 1 | 0;
          if(_pz_ !== n){var n=_pF_;continue}
          break}}
      var r=caml_mod(b[2],width),_pA_=0 !== r?1:0;
      if(_pA_)
       {var
         l=b[1].length - 1 - 1 | 0,
         _pB_=b[1][l + 1],
         _pC_=caml_check_bound(a,r)[r + 1] & _pB_;
        b[1][l + 1] = _pC_;
        var _pD_=0}
      else
       var _pD_=_pA_;
      return _pD_}
    function negate(b)
     {var a$0=caml_call2(Array[15],Pervasives[9],b[1]),r=caml_mod(b[2],width);
      if(0 !== r)
       {var l=b[1].length - 1 - 1 | 0,_px_=a$0[l + 1];
        a$0[l + 1] = caml_check_bound(a,r)[r + 1] & _px_}
      return [0,a$0,b[2]]}
    function union_into(into,bv)
     {if(into[2] < bv[2])grow(into,bv[2]);
      var _pv_=into[1].length - 1 - 1 | 0,_pu_=0;
      if(! (_pv_ < 0))
       {var i=_pu_;
        for(;;)
         {into[1][i + 1] = into[1][i + 1] | bv[1][i + 1];
          var _pw_=i + 1 | 0;
          if(_pv_ !== i){var i=_pw_;continue}
          break}}
      return 0}
    function union(b1,b2)
     {if(b1[2] <= b2[2])
       {var into=copy(b2),_pp_=b1[1].length - 1 - 1 | 0,_po_=0;
        if(! (_pp_ < 0))
         {var i=_po_;
          for(;;)
           {into[1][i + 1] = into[1][i + 1] | b1[1][i + 1];
            var _pq_=i + 1 | 0;
            if(_pp_ !== i){var i=_pq_;continue}
            break}}
        return into}
      var into$0=copy(b1),_ps_=b1[1].length - 1 - 1 | 0,_pr_=0;
      if(! (_ps_ < 0))
       {var i$0=_pr_;
        for(;;)
         {into$0[1][i$0 + 1] = into$0[1][i$0 + 1] | b2[1][i$0 + 1];
          var _pt_=i$0 + 1 | 0;
          if(_ps_ !== i$0){var i$0=_pt_;continue}
          break}}
      return into$0}
    function inter_into(into,bv)
     {if(bv[2] < into[2])shrink(into,bv[2]);
      var _pm_=into[1].length - 1 - 1 | 0,_pl_=0;
      if(! (_pm_ < 0))
       {var i=_pl_;
        for(;;)
         {into[1][i + 1] = into[1][i + 1] & bv[1][i + 1];
          var _pn_=i + 1 | 0;
          if(_pm_ !== i){var i=_pn_;continue}
          break}}
      return 0}
    function inter(b1,b2)
     {if(b1[2] <= b2[2])
       {var into=copy(b1),_pg_=b1[1].length - 1 - 1 | 0,_pf_=0;
        if(! (_pg_ < 0))
         {var i=_pf_;
          for(;;)
           {into[1][i + 1] = into[1][i + 1] & b2[1][i + 1];
            var _ph_=i + 1 | 0;
            if(_pg_ !== i){var i=_ph_;continue}
            break}}
        return into}
      var into$0=copy(b2),_pj_=b2[1].length - 1 - 1 | 0,_pi_=0;
      if(! (_pj_ < 0))
       {var i$0=_pi_;
        for(;;)
         {into$0[1][i$0 + 1] = into$0[1][i$0 + 1] & b1[1][i$0 + 1];
          var _pk_=i$0 + 1 | 0;
          if(_pj_ !== i$0){var i$0=_pk_;continue}
          break}}
      return into$0}
    function diff_into(into,bv)
     {var
       n=caml_call2(Pervasives[4],into[1].length - 1,bv[1].length - 1),
       _pc_=n - 1 | 0,
       _pb_=0;
      if(! (_pc_ < 0))
       {var i=_pb_;
        for(;;)
         {var _pd_=caml_call1(Pervasives[9],bv[1][i + 1]);
          into[1][i + 1] = into[1][i + 1] & _pd_;
          var _pe_=i + 1 | 0;
          if(_pc_ !== i){var i=_pe_;continue}
          break}}
      return 0}
    function diff(in$0,not_in)
     {var into=copy(in$0);diff_into(into,not_in);return into}
    function select(bv,arr)
     {var l=[0,0];
      try
       {iter_true
         (bv,
          function(i)
           {if(arr.length - 1 <= i)throw Pervasives[3];
            var _pa_=l[1];
            l[1] = [0,caml_check_bound(arr,i)[i + 1],_pa_];
            return 0})}
      catch(_o$_)
       {_o$_ = caml_wrap_exception(_o$_);if(_o$_ !== Pervasives[3])throw _o$_}
      return l[1]}
    function selecti(bv,arr)
     {var l=[0,0];
      try
       {iter_true
         (bv,
          function(i)
           {if(arr.length - 1 <= i)throw Pervasives[3];
            var _o__=l[1];
            l[1] = [0,[0,caml_check_bound(arr,i)[i + 1],i],_o__];
            return 0})}
      catch(_o9_)
       {_o9_ = caml_wrap_exception(_o9_);if(_o9_ !== Pervasives[3])throw _o9_}
      return l[1]}
    function to_seq(bv,k){return iter_true(bv,k)}
    function of_seq(seq)
     {var l=[0,0],maxi=[0,0];
      caml_call1
       (seq,
        function(x)
         {l[1] = [0,x,l[1]];
          maxi[1] = caml_call2(Pervasives[5],maxi[1],x);
          return 0});
      var bv=create(maxi[1] + 1 | 0,0),_o7_=l[1];
      function _o8_(i){return set(bv,i)}
      caml_call2(List[15],_o8_,_o7_);
      return bv}
    function pp(out,bv)
     {caml_call2(Format[13],out,cst_bv);
      iter
       (bv,
        function(i,b){var _o6_=b?49:48;return caml_call2(Format[21],out,_o6_)});
      return caml_call2(Format[13],out,cst)}
    var
     CCBV=
      [0,
       empty,
       create,
       copy,
       cardinal,
       length,
       capacity,
       resize,
       is_empty,
       set,
       get,
       reset,
       flip,
       clear,
       iter,
       iter_true,
       to_list,
       to_sorted_list,
       of_list,
       first,
       first_exn,
       filter,
       negate_self,
       negate,
       union_into,
       inter_into,
       union,
       inter,
       diff_into,
       diff,
       select,
       selecti,
       to_seq,
       of_seq,
       pp];
    caml_register_global(188,CCBV,"CCBV");
    var
     CCBijection=
      [0,
       function(L,R)
        {var
          MapL=caml_call1(Map[1],L),
          MapR=caml_call1(Map[1],R),
          empty=[0,MapL[1],MapR[1]];
         function cardinal(m){return caml_call1(MapL[18],m[1])}
         function is_empty(m)
          {var res=caml_call1(MapL[2],m[1]);
           if(res === caml_call1(MapR[2],m[2]))return res;
           throw [0,Assert_failure,_d_]}
         function equal(a,b)
          {var _o3_=b[1],_o4_=a[1];
           function _o5_(a,b){return 0 === caml_call2(R[1],a,b)?1:0}
           return caml_call3(MapL[11],_o5_,_o4_,_o3_)}
         function compare(a,b){return caml_call3(MapL[10],R[1],a[1],b[1])}
         function add(a,b,m)
          {try
            {var
              found$0=caml_call2(MapL[27],a,m[1]),
              _o0_=
               0 === caml_call2(R[1],found$0,b)
                ?m[2]
                :caml_call2(MapR[7],found$0,m[2]),
              _oW_=_o0_}
           catch(_o2_)
            {_o2_ = caml_wrap_exception(_o2_);
             if(_o2_ !== Not_found)throw _o2_;
             var _oW_=m[2]}
           var _oX_=caml_call3(MapR[4],b,a,_oW_);
           try
            {var
              found=caml_call2(MapR[27],b,m[2]),
              _oZ_=
               0 === caml_call2(L[1],found,a)
                ?m[1]
                :caml_call2(MapL[7],found,m[1]),
              _oY_=_oZ_}
           catch(_o1_)
            {_o1_ = caml_wrap_exception(_o1_);
             if(_o1_ !== Not_found)throw _o1_;
             var _oY_=m[1]}
           return [0,caml_call3(MapL[4],a,b,_oY_),_oX_]}
         function find_left(key,m){return caml_call2(MapL[27],key,m[1])}
         function find_right(key,m){return caml_call2(MapR[27],key,m[2])}
         function mem(left,right,m)
          {try
            {var
              _oT_=find_left(left,m),
              _oU_=0 === caml_call2(R[1],right,_oT_)?1:0;
             return _oU_}
           catch(_oV_)
            {_oV_ = caml_wrap_exception(_oV_);
             if(_oV_ === Not_found)return 0;
             throw _oV_}}
         function mem_left(key,m){return caml_call2(MapL[3],key,m[1])}
         function mem_right(key,m){return caml_call2(MapR[3],key,m[2])}
         function remove(a,b,m)
          {if(mem(a,b,m))
            {var _oS_=caml_call2(MapR[7],b,m[2]);
             return [0,caml_call2(MapL[7],a,m[1]),_oS_]}
           return m}
         function remove_left(a,m)
          {try
            {var
              _oO_=m[2],
              _oP_=find_left(a,m),
              _oQ_=caml_call2(MapR[7],_oP_,_oO_),
              right=_oQ_}
           catch(_oR_)
            {_oR_ = caml_wrap_exception(_oR_);
             if(_oR_ !== Not_found)throw _oR_;
             var right=m[2]}
           return [0,caml_call2(MapL[7],a,m[1]),right]}
         function remove_right(b,m)
          {try
            {var
              _oK_=m[1],
              _oL_=find_right(b,m),
              _oM_=caml_call2(MapL[7],_oL_,_oK_),
              left=_oM_}
           catch(_oN_)
            {_oN_ = caml_wrap_exception(_oN_);
             if(_oN_ !== Not_found)throw _oN_;
             var left=m[1]}
           return [0,left,caml_call2(MapR[7],b,m[2])]}
         function list_left(m){return caml_call1(MapL[19],m[1])}
         function list_right(m){return caml_call1(MapR[19],m[2])}
         function add_list(l,m)
          {function _oJ_(m,param){var b=param[2],a=param[1];return add(a,b,m)}
           return caml_call3(List[20],_oJ_,m,l)}
         function of_list(l){return add_list(l,empty)}
         function add_seq(seq,m)
          {var m$0=[0,m];
           caml_call1
            (seq,
             function(param)
              {var v=param[2],k=param[1];m$0[1] = add(k,v,m$0[1]);return 0});
           return m$0[1]}
         function of_seq(l){return add_seq(l,empty)}
         function to_seq(m,yield$0)
          {var _oH_=m[1];
           function _oI_(k,v){return caml_call1(yield$0,[0,k,v])}
           return caml_call2(MapL[12],_oI_,_oH_)}
         return [0,
                 empty,
                 is_empty,
                 equal,
                 compare,
                 add,
                 cardinal,
                 mem,
                 mem_left,
                 mem_right,
                 find_left,
                 find_right,
                 remove,
                 remove_left,
                 remove_right,
                 list_left,
                 list_right,
                 add_seq,
                 of_seq,
                 to_seq,
                 add_list,
                 of_list,
                 list_left]}];
    caml_register_global(190,CCBijection,"CCBijection");
    var
     TooManyFields=[248,cst_CCBitField_TooManyFields,caml_fresh_oo_id(0)],
     Frozen=[248,cst_CCBitField_Frozen,caml_fresh_oo_id(0)],
     max_width=Sys[10] - 2 | 0;
    function all_bits(acc,w)
     {var acc$0=acc,w$0=w;
      for(;;)
       {if(0 === w$0)return acc$0;
        var
         acc$1=acc$0 | (1 << w$0) - 1 | 0,
         w$1=w$0 - 1 | 0,
         acc$0=acc$1,
         w$0=w$1;
        continue}}
    function Make(X)
     {var n=[0,0],frozen=[0,0],empty=0;
      function get(field,x){return 0 !== (x & field)?1:0}
      function set(field,b,x)
       {return b?x | field:x & caml_call1(Pervasives[9],field)}
      function mk_field(param)
       {if(frozen[1])throw Frozen;
        var x=n[1];
        n[1]++;
        if(max_width < x)throw TooManyFields;
        var mask=1 << x;
        return mask}
      function freeze(param){frozen[1] = 1;return 0}
      function total_width(param){return n[1]}
      return [0,empty,get,set,mk_field,freeze,total_width]}
    var CCBitField=[0,TooManyFields,Frozen,max_width,Make,all_bits];
    caml_register_global(191,CCBitField,"CCBitField");
    var default_hash=Hashtbl[21];
    function clear$0(c){return caml_call1(c[5],0)}
    function add(c,x,y)
     {try
       {caml_call1(c[2],x);var _oF_=0;return _oF_}
      catch(_oG_)
       {_oG_ = caml_wrap_exception(_oG_);
        if(_oG_ === Not_found){caml_call2(c[1],x,y);return 1}
        throw _oG_}}
    function default_callback(param,_oE_,_oD_){return 0}
    function with_cache(opt,c,f,x)
     {if(opt)var sth=opt[1],cb=sth;else var cb=default_callback;
      try
       {var y$0=caml_call1(c[2],x);caml_call3(cb,1,x,y$0);return y$0}
      catch(_oC_)
       {_oC_ = caml_wrap_exception(_oC_);
        if(_oC_ === Not_found)
         {var y=caml_call1(f,x);
          caml_call2(c[1],x,y);
          caml_call3(cb,0,x,y);
          return y}
        throw _oC_}}
    function with_cache_rec(opt,c,f)
     {if(opt)var sth=opt[1],cb=sth;else var cb=default_callback;
      function f$0(x){return with_cache([0,cb],c,caml_call1(f,f$0),x)}
      return f$0}
    function size(c){return caml_call1(c[3],0)}
    function iter$0(c,f){return caml_call1(c[4],f)}
    function _e_(param){return 0}
    function _f_(param){return 0}
    function _g_(param){return 0}
    function _h_(param){throw Not_found}
    var dummy=[0,function(param,_oB_){return 0},_h_,_g_,_f_,_e_];
    function iter$1(c,f)
     {var _oz_=c[2];
      function _oA_(param)
       {if(param){var y=param[2],x=param[1];return caml_call2(f,x,y)}return 0}
      return caml_call2(Array[13],_oA_,_oz_)}
    function linear(eq,size)
     {var size$0=caml_call2(Pervasives[5],size,1);
      if(0 < size$0)
       {var
         arr=[0,eq,caml_make_vect(size$0,0),0],
         _or_=
          function(param)
           {caml_call4(Array[9],arr[2],0,arr[2].length - 1,0);
            arr[3] = 0;
            return 0},
         _os_=function(_oy_){return iter$1(arr,_oy_)},
         _ot_=
          function(_ow_)
           {var r=[0,0];
            iter$1(arr,function(param,_ox_){r[1]++;return 0});
            return r[1]},
         _ou_=
          function(x$0)
           {var i=0;
            for(;;)
             {if(i === arr[2].length - 1)throw Not_found;
              var match=caml_check_bound(arr[2],i)[i + 1];
              if(match)
               {var y=match[2],x=match[1];
                if(caml_call2(arr[1],x$0,x))return y}
              var i$0=i + 1 | 0,i=i$0;
              continue}};
        return [0,
                function(x,y)
                 {var _ov_=arr[3];
                  caml_check_bound(arr[2],_ov_)[_ov_ + 1] = [0,x,y];
                  arr[3] = caml_mod(arr[3] + 1 | 0,arr[2].length - 1);
                  return 0},
                _ou_,
                _ot_,
                _os_,
                _or_]}
      throw [0,Assert_failure,_i_]}
    function replacing(eq,opt,size)
     {if(opt)var sth=opt[1],hash=sth;else var hash=default_hash;
      if(0 < size)
       {var
         c=[0,eq,hash,caml_make_vect(size,0),0],
         _oh_=
          function(param)
           {c[4] = 0;return caml_call4(Array[9],c[3],0,c[3].length - 1,0)},
         _oi_=
          function(f)
           {var _op_=c[3];
            function _oq_(param)
             {if(param){var y=param[2],x=param[1];return caml_call2(f,x,y)}
              return 0}
            return caml_call2(Array[13],_oq_,_op_)},
         _oj_=function(_oo_){return c[4]},
         _ok_=
          function(x$0)
           {var
             _on_=c[3].length - 1,
             i=caml_mod(caml_call1(c[2],x$0),_on_),
             match=caml_check_bound(c[3],i)[i + 1];
            if(match)
             {var y=match[2],x=match[1];if(caml_call2(c[1],x$0,x))return y}
            throw Not_found};
        return [0,
                function(x,y)
                 {var
                   _ol_=c[3].length - 1,
                   i=caml_mod(caml_call1(c[2],x),_ol_),
                   param=caml_check_bound(c[3],i)[i + 1],
                   _om_=param?0:1;
                  if(_om_)c[4] = c[4] + 1 | 0;
                  return caml_check_bound(c[3],i)[i + 1] = [0,x,y]},
                _ok_,
                _oj_,
                _oi_,
                _oh_]}
      throw [0,Assert_failure,_j_]}
    function lru(eq,opt,size)
     {if(opt)var sth=opt[1],hash=sth;else var hash=default_hash;
      var X=[0,eq,hash],H=caml_call1(Hashtbl[19],X);
      function push(c,n)
       {var _og_=c[2];
        if(_og_)
         {var n1=_og_[1];
          return n1 === n?0:(n[4] = n1[4],n[3] = n1,n1[4][3] = n,n1[4] = n,0)}
        n[3] = n;
        n[4] = n;
        c[2] = [0,n];
        return 0}
      if(0 < size)
       {var
         c=[0,caml_call1(H[1],size),0,size],
         _n__=function(param){caml_call1(H[2],c[1]);c[2] = 0;return 0},
         _n$_=
          function(f)
           {var _oe_=c[1];
            function _of_(x,node){return caml_call2(f,x,node[2])}
            return caml_call2(H[12],_of_,_oe_)},
         _oa_=function(_od_){return caml_call1(H[15],c[1])},
         _ob_=
          function(x)
           {var n=caml_call2(H[7],c[1],x);
            n[4][3] = n[3];
            n[3][4] = n[4];
            push(c,n);
            return n[2]};
        return [0,
                function(x,y)
                 {var len=caml_call1(H[15],c[1]);
                  if(len <= c[3])
                   {if(len === c[3])
                     {var _oc_=c[2];
                      if(_oc_)
                       var
                        n=_oc_[1],
                        n$0=
                         n[3] === n
                          ?(c[2] = 0,n)
                          :(c[2] = [0,n[3]],n[4][3] = n[3],n[3][4] = n[4],n);
                      else
                       var n$0=caml_call1(Pervasives[2],cst_LRU_empty_queue);
                      caml_call2(H[6],c[1],n$0[1]);
                      n$0[1] = x;
                      n$0[2] = y;
                      caml_call3(H[5],c[1],x,n$0);
                      push(c,n$0);
                      return 0}
                    var n$1=[];
                    caml_update_dummy(n$1,[0,x,y,n$1,n$1]);
                    caml_call3(H[5],c[1],x,n$1);
                    push(c,n$1);
                    return 0}
                  throw [0,Assert_failure,_l_]},
                _ob_,
                _oa_,
                _n$_,
                _n__]}
      throw [0,Assert_failure,_k_]}
    function unbounded(eq,opt,size)
     {if(opt)var sth=opt[1],hash=sth;else var hash=default_hash;
      var X=[0,eq,hash],H=caml_call1(Hashtbl[19],X);
      if(0 < size)
       {var
         c=caml_call1(H[1],size),
         _n5_=function(param){return caml_call1(H[2],c)},
         _n6_=function(f){return caml_call2(H[12],f,c)},
         _n7_=function(_n9_){return caml_call1(H[15],c)},
         _n8_=function(x){return caml_call2(H[7],c,x)};
        return [0,
                function(x,y){return caml_call3(H[10],c,x,y)},
                _n8_,
                _n7_,
                _n6_,
                _n5_]}
      throw [0,Assert_failure,_m_]}
    var
     CCCache=
      [0,
       clear$0,
       with_cache,
       with_cache_rec,
       size,
       iter$0,
       add,
       dummy,
       linear,
       replacing,
       lru,
       unbounded];
    caml_register_global(193,CCCache,"CCCache");
    var Empty=[248,cst_CCDeque_Empty,caml_fresh_oo_id(0)];
    function create$0(param)
     {var cur=[];caml_update_dummy(cur,[0,0,cur,cur]);return [0,cur,0]}
    function clear$1(q)
     {var cur=[];
      caml_update_dummy(cur,[0,0,cur,cur]);
      q[1] = cur;
      q[2] = 0;
      return 0}
    function incr_size(d){d[2] = d[2] + 1 | 0;return 0}
    function decr_size(d){d[2] = d[2] - 1 | 0;return 0}
    function is_zero(n){return typeof n[1] === "number"?1:0}
    function is_empty$0(d)
     {var res=0 === d[2]?1:0;
      if(res === is_zero(d[1]))return res;
      throw [0,Assert_failure,_n_]}
    function push_front(d,x)
     {incr_size(d);
      var _n4_=d[1][1];
      if(typeof _n4_ === "number")
       {d[1][1] = [0,x];return 0}
      else
       switch(_n4_[0])
        {case 0:var y=_n4_[1];d[1][1] = [1,x,y];return 0;
         case 1:var z=_n4_[2],y$0=_n4_[1];d[1][1] = [2,x,y$0,z];return 0;
         default:
          var node=[0,[0,x],d[1],d[1][3]];
          d[1][3][2] = node;
          d[1][3] = node;
          d[1] = node;
          return 0}}
    function push_back(d,x)
     {incr_size(d);
      var n=d[1][3],_n3_=n[1];
      if(typeof _n3_ === "number")
       {n[1] = [0,x];return 0}
      else
       switch(_n3_[0])
        {case 0:var y=_n3_[1];n[1] = [1,y,x];return 0;
         case 1:var z=_n3_[2],y$0=_n3_[1];n[1] = [2,y$0,z,x];return 0;
         default:var elt=[0,[0,x],d[1],n];n[2] = elt;d[1][3] = elt;return 0}}
    function peek_front(d)
     {var _n2_=d[1][1];
      if(typeof _n2_ === "number")
       throw Empty;
      else
       switch(_n2_[0])
        {case 0:var x=_n2_[1];return x;
         case 1:var x$0=_n2_[1];return x$0;
         default:var x$1=_n2_[1];return x$1}}
    function peek_back(d)
     {if(is_empty$0(d))throw Empty;
      var _n1_=d[1][3][1];
      if(typeof _n1_ === "number")
       throw [0,Assert_failure,_o_];
      else
       switch(_n1_[0])
        {case 0:var x=_n1_[1];return x;
         case 1:var x$0=_n1_[2];return x$0;
         default:var x$1=_n1_[3];return x$1}}
    function take_back_node(n)
     {var _n0_=n[1];
      if(typeof _n0_ === "number")
       throw [0,Assert_failure,_p_];
      else
       switch(_n0_[0])
        {case 0:var x=_n0_[1];n[1] = 0;return x;
         case 1:var y=_n0_[2],x$0=_n0_[1];n[1] = [0,x$0];return y;
         default:
          var z=_n0_[3],y$0=_n0_[2],x$1=_n0_[1];n[1] = [1,x$1,y$0];return z}}
    function take_back(d)
     {if(is_empty$0(d))throw Empty;
      if(d[1] === d[1][3]){decr_size(d);return take_back_node(d[1])}
      var n=d[1][3],x=take_back_node(n);
      decr_size(d);
      if(is_zero(n)){d[1][3] = n[3];n[3][2] = d[1]}
      return x}
    function take_front_node(n)
     {var _nZ_=n[1];
      if(typeof _nZ_ === "number")
       throw [0,Assert_failure,_q_];
      else
       switch(_nZ_[0])
        {case 0:var x=_nZ_[1];n[1] = 0;return x;
         case 1:var y=_nZ_[2],x$0=_nZ_[1];n[1] = [0,y];return x$0;
         default:
          var z=_nZ_[3],y$0=_nZ_[2],x$1=_nZ_[1];n[1] = [1,y$0,z];return x$1}}
    function take_front(d)
     {if(is_empty$0(d))throw Empty;
      if(d[1][3] === d[1]){decr_size(d);return take_front_node(d[1])}
      decr_size(d);
      var x=take_front_node(d[1]);
      if(is_zero(d[1]))
       {d[1][3][2] = d[1][2];d[1][2][3] = d[1][3];d[1] = d[1][2]}
      return x}
    function iter$2(f,d)
     {var n=d[1],_nY_=d[1];
      for(;;)
       {var _nW_=n[1];
        if(typeof _nW_ !== "number")
         switch(_nW_[0])
          {case 0:var x=_nW_[1];caml_call1(f,x);break;
           case 1:
            var y=_nW_[2],x$0=_nW_[1];caml_call1(f,x$0);caml_call1(f,y);break;
           default:
            var z=_nW_[3],y$0=_nW_[2],x$1=_nW_[1];
            caml_call1(f,x$1);
            caml_call1(f,y$0);
            caml_call1(f,z)}
        var _nX_=n[2] !== _nY_?1:0;
        if(_nX_){var n$0=n[2],n=n$0;continue}
        return _nX_}}
    function append_front(into,q)
     {return iter$2(function(_nV_){return push_front(into,_nV_)},q)}
    function append_back(into,q)
     {return iter$2(function(_nU_){return push_back(into,_nU_)},q)}
    function fold(f,acc,d)
     {var acc$0=acc,n=d[1],_nT_=d[1];
      for(;;)
       {var _nS_=n[1];
        if(typeof _nS_ === "number")
         var acc$1=acc$0;
        else
         switch(_nS_[0])
          {case 0:var x=_nS_[1],acc$1=caml_call2(f,acc$0,x);break;
           case 1:
            var
             y=_nS_[2],
             x$0=_nS_[1],
             acc$1=caml_call2(f,caml_call2(f,acc$0,x$0),y);
            break;
           default:
            var
             z=_nS_[3],
             y$0=_nS_[2],
             x$1=_nS_[1],
             acc$1=caml_call2(f,caml_call2(f,caml_call2(f,acc$0,x$1),y$0),z)}
        if(n[2] === _nT_)return acc$1;
        var n$0=n[2],acc$0=acc$1,n=n$0;
        continue}}
    function length$0(d){return d[2]}
    function add_seq_back(q,seq)
     {return caml_call1(seq,function(x){return push_back(q,x)})}
    function add_seq_front(q,seq)
     {return caml_call1(seq,function(x){return push_front(q,x)})}
    function of_seq$0(seq)
     {var deque=create$0(0);
      caml_call1(seq,function(x){return push_back(deque,x)});
      return deque}
    function to_seq$0(d,k){return iter$2(k,d)}
    function of_list$0(l)
     {var q=create$0(0);
      function _nQ_(_nR_){return push_back(q,_nR_)}
      caml_call2(List[15],_nQ_,l);
      return q}
    function to_rev_list(q)
     {var _nP_=0;return fold(function(l,x){return [0,x,l]},_nP_,q)}
    function to_list$0(q)
     {var _nO_=to_rev_list(q);return caml_call1(List[9],_nO_)}
    function of_gen(g)
     {var q=create$0(0);
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1];push_back(q,x);continue}
        return q}}
    function to_gen(q)
     {var first=q[1],cell=[0,q[1][1]],cur=[0,q[1]];
      function next(param)
       {for(;;)
         {var _nN_=cell[1];
          if(typeof _nN_ === "number")
           {if(cur[1][2] === first)return 0;
            var n=cur[1];
            cur[1] = n[2];
            cell[1] = n[2][1];
            continue}
          else
           switch(_nN_[0])
            {case 0:var x=_nN_[1];cell[1] = 0;return [0,x];
             case 1:var y=_nN_[2],x$0=_nN_[1];cell[1] = [0,y];return [0,x$0];
             default:
              var z=_nN_[3],y$0=_nN_[2],x$1=_nN_[1];
              cell[1] = [1,y$0,z];
              return [0,x$1]}}}
      return next}
    function copy$0(d)
     {var d$0=create$0(0);
      iter$2(function(x){return push_back(d$0,x)},d);
      return d$0}
    function equal(eq,a,b)
     {var b$0=to_gen(b),a$0=to_gen(a);
      for(;;)
       {var match=caml_call1(a$0,0),match$0=caml_call1(b$0,0);
        if(match)
         {if(match$0)
           {var y=match$0[1],x=match[1],_nM_=caml_call2(eq,x,y);
            if(_nM_)continue;
            return _nM_}}
        else
         if(! match$0)return 1;
        return 0}}
    function compare(cmp,a,b)
     {var b$0=to_gen(b),a$0=to_gen(a);
      for(;;)
       {var match=caml_call1(a$0,0),match$0=caml_call1(b$0,0);
        if(match)
         {var _nL_=match[1];
          if(match$0)
           {var y=match$0[1],c=caml_call2(cmp,_nL_,y);
            if(0 === c)continue;
            return c}
          return 1}
        return match$0?-1:0}}
    function pp$0(pp_x,out,d)
     {var first=[0,1];
      caml_call2(Format[112],out,_r_);
      iter$2
       (function(x)
         {if(first[1])first[1] = 0;else caml_call2(Format[112],out,_s_);
          return caml_call2(pp_x,out,x)},
        d);
      return caml_call2(Format[112],out,_t_)}
    var
     CCDeque=
      [0,
       Empty,
       create$0,
       clear$1,
       is_empty$0,
       equal,
       compare,
       length$0,
       push_front,
       push_back,
       peek_front,
       peek_back,
       take_back,
       take_front,
       append_front,
       append_back,
       iter$2,
       fold,
       of_seq$0,
       to_seq$0,
       of_gen,
       to_gen,
       add_seq_front,
       add_seq_back,
       copy$0,
       of_list$0,
       to_list$0,
       to_rev_list,
       pp$0];
    caml_register_global(194,CCDeque,"CCDeque");
    var Empty$0=[248,cst_CCFQueue_Empty,caml_fresh_oo_id(0)];
    function is_not_zero(param){return typeof param === "number"?0:1}
    function single(x){return [0,[0,x]]}
    function deep(n,hd,middle,tl)
     {if(is_not_zero(hd))if(is_not_zero(tl))return [1,n,hd,middle,tl];
      throw [0,Assert_failure,_u_]}
    function is_empty$1(param)
     {if(0 === param[0])if(typeof param[1] === "number")return 1;return 0}
    function singleton(x){return single(x)}
    function doubleton(x,y){return [0,[1,x,y]]}
    var empty$0=caml_call1(Lazy[4],q);
    function cons(x,q)
     {if(0 === q[0])
       {var _nC_=q[1];
        if(typeof _nC_ === "number")
         return single(x);
        else
         switch(_nC_[0])
          {case 0:var y=_nC_[1];return [0,[1,x,y]];
           case 1:var z=_nC_[2],y$0=_nC_[1];return [0,[2,x,y$0,z]];
           default:
            var z$0=_nC_[3],z$1=_nC_[2],y$1=_nC_[1];
            return deep(4,[1,x,y$1],empty$0,[1,z$1,z$0])}}
      var _nD_=q[2],_nE_=q[1];
      if(typeof _nD_ === "number")
       throw [0,Assert_failure,_v_];
      else
       switch(_nD_[0])
        {case 0:
          var tl=q[4],middle=q[3],y$2=_nD_[1];
          return deep(_nE_ + 1 | 0,[1,x,y$2],middle,tl);
         case 1:
          var tl$0=q[4],middle$0=q[3],z$2=_nD_[2],y$3=_nD_[1];
          return deep(_nE_ + 1 | 0,[2,x,y$3,z$2],middle$0,tl$0);
         default:
          var
           _nF_=q[3],
           _nJ_=caml_obj_tag(_nF_),
           _nG_=_nD_[3],
           _nH_=_nD_[2],
           _nI_=_nD_[1],
           q$0=
            250 === _nJ_
             ?_nF_[1]
             :246 === _nJ_?caml_call1(CamlinternalLazy[2],_nF_):_nF_,
           tail=q[4];
          return deep
                  (_nE_ + 1 | 0,
                   [1,x,_nI_],
                   [246,function(_nK_){return cons([0,_nH_,_nG_],q$0)}],
                   tail)}}
    function snoc(q,x)
     {if(0 === q[0])
       {var _nu_=q[1];
        if(typeof _nu_ === "number")
         return single(x);
        else
         switch(_nu_[0])
          {case 0:var y=_nu_[1];return [0,[1,y,x]];
           case 1:var z=_nu_[2],y$0=_nu_[1];return [0,[2,y$0,z,x]];
           default:
            var z$0=_nu_[3],z$1=_nu_[2],y$1=_nu_[1];
            return deep(4,[1,y$1,z$1],empty$0,[1,z$0,x])}}
      var _nv_=q[3],_nw_=q[2],_nx_=q[1],_ny_=q[4];
      if(typeof _ny_ === "number")
       throw [0,Assert_failure,_w_];
      else
       switch(_ny_[0])
        {case 0:var y$2=_ny_[1];return deep(_nx_ + 1 | 0,_nw_,_nv_,[1,y$2,x]);
         case 1:
          var z$2=_ny_[2],y$3=_ny_[1];
          return deep(_nx_ + 1 | 0,_nw_,_nv_,[2,y$3,z$2,x]);
         default:
          var
           _nz_=caml_obj_tag(_nv_),
           q$0=
            250 === _nz_
             ?_nv_[1]
             :246 === _nz_?caml_call1(CamlinternalLazy[2],_nv_):_nv_,
           match=q[4],
           z$3=match[3],
           z$4=match[2],
           y$4=match[1],
           _nA_=[1,z$3,x];
          return deep
                  (_nx_ + 1 | 0,
                   _nw_,
                   [246,function(_nB_){return snoc(q$0,[0,y$4,z$4])}],
                   _nA_)}}
    function take_front_exn(q$0)
     {if(0 === q$0[0])
       {var _nn_=q$0[1];
        if(typeof _nn_ === "number")
         throw Empty$0;
        else
         switch(_nn_[0])
          {case 0:var x=_nn_[1];return [0,x,q];
           case 1:var y=_nn_[2],x$0=_nn_[1];return [0,x$0,[0,[0,y]]];
           default:
            var z=_nn_[3],y$0=_nn_[2],x$1=_nn_[1];return [0,x$1,[0,[1,y$0,z]]]}}
      var _no_=q$0[2],_np_=q$0[1];
      if(typeof _no_ === "number")
       throw [0,Assert_failure,_x_];
      else
       switch(_no_[0])
        {case 0:
          var
           _nq_=q$0[3],
           _nr_=_no_[1],
           _ns_=caml_obj_tag(_nq_),
           q$1=
            250 === _ns_
             ?_nq_[1]
             :246 === _ns_?caml_call1(CamlinternalLazy[2],_nq_):_nq_,
           tail=q$0[4];
          if(is_empty$1(q$1))return [0,_nr_,[0,tail]];
          var
           _nt_=take_front_exn(q$1),
           q$2=_nt_[2],
           match=_nt_[1],
           z$0=match[2],
           y$1=match[1];
          return [0,
                  _nr_,
                  deep(_np_ - 1 | 0,[1,y$1,z$0],caml_call1(Lazy[4],q$2),tail)];
         case 1:
          var tail$0=q$0[4],middle=q$0[3],y$2=_no_[2],x$2=_no_[1];
          return [0,x$2,deep(_np_ - 1 | 0,[0,y$2],middle,tail$0)];
         default:
          var
           tail$1=q$0[4],
           middle$0=q$0[3],
           z$1=_no_[3],
           y$3=_no_[2],
           x$3=_no_[1];
          return [0,x$3,deep(_np_ - 1 | 0,[1,y$3,z$1],middle$0,tail$1)]}}
    function take_front$0(q)
     {try
       {var _nl_=[0,take_front_exn(q)];return _nl_}
      catch(_nm_)
       {_nm_ = caml_wrap_exception(_nm_);
        if(_nm_ === Empty$0)return 0;
        throw _nm_}}
    function take_front_l(n,q)
     {if(n < 0)
       caml_call1
        (Pervasives[1],
         cst_take_back_l_cannot_take_negative_number_of_arguments);
      var acc=0,q$0=q,n$0=n;
      for(;;)
       {if(0 !== n$0)
         if(! is_empty$1(q$0))
          {var
            match=take_front_exn(q$0),
            q$1=match[2],
            x=match[1],
            n$1=n$0 - 1 | 0,
            acc$0=[0,x,acc],
            acc=acc$0,
            q$0=q$1,
            n$0=n$1;
           continue}
        return [0,caml_call1(List[9],acc),q$0]}}
    function take_front_while(p,q)
     {var acc=0,q$0=q;
      for(;;)
       {if(is_empty$1(q$0))return [0,caml_call1(List[9],acc),q$0];
        var match=take_front_exn(q$0),q$1=match[2],x=match[1];
        if(caml_call1(p,x)){var acc$0=[0,x,acc],acc=acc$0,q$0=q$1;continue}
        return [0,caml_call1(List[9],acc),q$0]}}
    function take_back_exn(q$0)
     {if(0 === q$0[0])
       {var _ne_=q$0[1];
        if(typeof _ne_ === "number")
         throw Empty$0;
        else
         switch(_ne_[0])
          {case 0:var x=_ne_[1];return [0,q,x];
           case 1:var y=_ne_[2],x$0=_ne_[1];return [0,single(x$0),y];
           default:
            var z=_ne_[3],y$0=_ne_[2],x$1=_ne_[1];return [0,[0,[1,x$1,y$0]],z]}}
      var _nf_=q$0[3],_ng_=q$0[2],_nh_=q$0[1],_ni_=q$0[4];
      if(typeof _ni_ === "number")
       throw [0,Assert_failure,_y_];
      else
       switch(_ni_[0])
        {case 0:
          var
           _nj_=caml_obj_tag(_nf_),
           q$1=
            250 === _nj_
             ?_nf_[1]
             :246 === _nj_?caml_call1(CamlinternalLazy[2],_nf_):_nf_,
           match=q$0[4],
           x$2=match[1];
          if(is_empty$1(q$1))return [0,[0,_ng_],x$2];
          var
           _nk_=take_back_exn(q$1),
           match$0=_nk_[2],
           z$0=match$0[2],
           y$1=match$0[1],
           q$2=_nk_[1];
          return [0,
                  deep(_nh_ - 1 | 0,_ng_,caml_call1(Lazy[4],q$2),[1,y$1,z$0]),
                  x$2];
         case 1:
          var y$2=_ni_[2],x$3=_ni_[1];
          return [0,deep(_nh_ - 1 | 0,_ng_,_nf_,[0,x$3]),y$2];
         default:
          var z$1=_ni_[3],y$3=_ni_[2],x$4=_ni_[1];
          return [0,deep(_nh_ - 1 | 0,_ng_,_nf_,[1,x$4,y$3]),z$1]}}
    function take_back$0(q)
     {try
       {var _nc_=[0,take_back_exn(q)];return _nc_}
      catch(_nd_)
       {_nd_ = caml_wrap_exception(_nd_);
        if(_nd_ === Empty$0)return 0;
        throw _nd_}}
    function take_back_l(n,q)
     {if(n < 0)
       caml_call1
        (Pervasives[1],
         cst_take_back_l_cannot_take_negative_number_of_arguments$0);
      var acc=0,q$0=q,n$0=n;
      for(;;)
       {if(0 !== n$0)
         if(! is_empty$1(q$0))
          {var
            match=take_back_exn(q$0),
            x=match[2],
            q$1=match[1],
            n$1=n$0 - 1 | 0,
            acc$0=[0,x,acc],
            acc=acc$0,
            q$0=q$1,
            n$0=n$1;
           continue}
        return [0,q$0,acc]}}
    function take_back_while(p,q)
     {var acc=0,q$0=q;
      for(;;)
       {if(is_empty$1(q$0))return [0,q$0,acc];
        var match=take_back_exn(q$0),x=match[2],q$1=match[1];
        if(caml_call1(p,x)){var acc$0=[0,x,acc],acc=acc$0,q$0=q$1;continue}
        return [0,q$0,acc]}}
    function first$0(q)
     {try
       {var _na_=[0,take_front_exn(q)[1]];return _na_}
      catch(_nb_)
       {_nb_ = caml_wrap_exception(_nb_);
        if(_nb_ === Empty$0)return 0;
        throw _nb_}}
    function first_exn$0(q){return take_front_exn(q)[1]}
    function last(q)
     {try
       {var _m__=[0,take_back_exn(q)[2]];return _m__}
      catch(_m$_)
       {_m$_ = caml_wrap_exception(_m$_);
        if(_m$_ === Empty$0)return 0;
        throw _m$_}}
    function last_exn(q){return take_back_exn(q)[2]}
    function size_digit(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0]){case 0:return 1;case 1:return 2;default:return 3}}
    function size$0(param)
     {if(0 === param[0]){var d=param[1];return size_digit(d)}
      var n=param[1];
      return n}
    function nth_digit(i,match)
     {if(typeof match === "number")throw Not_found;
      if(! (2 < i >>> 0))
       switch(i)
        {case 0:
          if(typeof match !== "number")
           switch(match[0])
            {case 0:break;
             case 1:var x$0=match[1];return x$0;
             default:var x$1=match[1];return x$1}
          var x=match[1];
          return x;
         case 1:
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var x$2=match[2];return x$2;
             case 2:var x$3=match[2];return x$3
             }
          break;
         default:
          if(typeof match !== "number" && 2 === match[0])
           {var x$4=match[3];return x$4}}
      throw Not_found}
    function nth_exn(i,match)
     {if(0 === match[0])
       {if(typeof match[1] === "number")throw Not_found;
        if(! (2 < i >>> 0))
         switch(i)
          {case 0:
            var _m6_=match[1];
            if(typeof _m6_ !== "number")
             switch(_m6_[0])
              {case 0:break;
               case 1:var x$0=_m6_[1];return x$0;
               default:var x$1=_m6_[1];return x$1}
            var x=_m6_[1];
            return x;
           case 1:
            var _m7_=match[1];
            if(typeof _m7_ !== "number")
             switch(_m7_[0])
              {case 0:break;
               case 1:var x$2=_m7_[2];return x$2;
               default:var x$3=_m7_[2];return x$3}
            break;
           default:
            var _m8_=match[1];
            if(typeof _m8_ !== "number" && 2 === _m8_[0])
             {var x$4=_m8_[3];return x$4}}
        throw Not_found}
      var r=match[4],q=match[3],l=match[2];
      if(i < size_digit(l))return nth_digit(i,l);
      var
       i$0=i - size_digit(l) | 0,
       _m9_=caml_obj_tag(q),
       q$0=250 === _m9_?q[1]:246 === _m9_?caml_call1(CamlinternalLazy[2],q):q;
      if(i$0 < (2 * size$0(q$0) | 0))
       {var match$0=nth_exn(i$0 / 2 | 0,q$0),y=match$0[2],x$5=match$0[1];
        return 0 === (i$0 % 2 | 0)?x$5:y}
      return nth_digit(i$0 - (2 * size$0(q$0) | 0) | 0,r)}
    function nth(i,q)
     {try
       {var _m4_=[0,nth_exn(i,q)];return _m4_}
      catch(_m5_)
       {_m5_ = caml_wrap_exception(_m5_);
        if(_m5_[1] === Failure)return 0;
        throw _m5_}}
    function init(q)
     {try
       {var _m2_=take_back_exn(q)[1];return _m2_}
      catch(_m3_)
       {_m3_ = caml_wrap_exception(_m3_);
        if(_m3_ === Empty$0)return q;
        throw _m3_}}
    function tail(q)
     {try
       {var _m0_=take_front_exn(q)[2];return _m0_}
      catch(_m1_)
       {_m1_ = caml_wrap_exception(_m1_);
        if(_m1_ === Empty$0)return q;
        throw _m1_}}
    function add_seq_front$0(seq,q)
     {var l=[0,0];
      caml_call1(seq,function(x){l[1] = [0,x,l[1]];return 0});
      var _mY_=l[1];
      function _mZ_(q,x){return cons(x,q)}
      return caml_call3(List[20],_mZ_,q,_mY_)}
    function add_seq_back$0(q,seq)
     {var q$0=[0,q];
      caml_call1(seq,function(x){q$0[1] = snoc(q$0[1],x);return 0});
      return q$0[1]}
    function digit_to_seq(d,k)
     {if(typeof d === "number")
       return 0;
      else
       switch(d[0])
        {case 0:var x=d[1];return caml_call1(k,x);
         case 1:var y=d[2],x$0=d[1];caml_call1(k,x$0);return caml_call1(k,y);
         default:
          var z=d[3],y$0=d[2],x$1=d[1];
          caml_call1(k,x$1);
          caml_call1(k,y$0);
          return caml_call1(k,z)}}
    function to_seq$1(q,k)
     {if(0 === q[0]){var d=q[1];return digit_to_seq(d,k)}
      var
       _mV_=q[3],
       _mX_=caml_obj_tag(_mV_),
       _mW_=q[2],
       q$0=
        250 === _mX_
         ?_mV_[1]
         :246 === _mX_?caml_call1(CamlinternalLazy[2],_mV_):_mV_,
       tail=q[4];
      digit_to_seq(_mW_,k);
      to_seq$1
       (q$0,
        function(param)
         {var y=param[2],x=param[1];caml_call1(k,x);return caml_call1(k,y)});
      return digit_to_seq(tail,k)}
    function append(q1,q2)
     {if(0 === q1[0])if(typeof q1[1] === "number")return q2;
      if(0 === q2[0])if(typeof q2[1] === "number")return q1;
      return add_seq_back$0(q1,function(_mU_){return to_seq$1(q2,_mU_)})}
    function map_digit(f,d)
     {if(typeof d === "number")
       return 0;
      else
       switch(d[0])
        {case 0:var x=d[1];return [0,caml_call1(f,x)];
         case 1:
          var y=d[2],x$0=d[1],_mR_=caml_call1(f,y);
          return [1,caml_call1(f,x$0),_mR_];
         default:
          var
           z=d[3],
           y$0=d[2],
           x$1=d[1],
           _mS_=caml_call1(f,z),
           _mT_=caml_call1(f,y$0);
          return [2,caml_call1(f,x$1),_mT_,_mS_]}}
    function map(f,q)
     {if(0 === q[0]){var d=q[1];return [0,map_digit(f,d)]}
      var
       _mK_=q[3],
       _mN_=caml_obj_tag(_mK_),
       _mL_=q[2],
       _mM_=q[1],
       q$0=
        250 === _mN_
         ?_mK_[1]
         :246 === _mN_?caml_call1(CamlinternalLazy[2],_mK_):_mK_,
       tl=q[4],
       q$1=
        map
         (function(param)
           {var y=param[2],x=param[1],_mQ_=caml_call1(f,y);
            return [0,caml_call1(f,x),_mQ_]},
          q$0),
       _mO_=map_digit(f,tl),
       _mP_=caml_call1(Lazy[4],q$1);
      return deep(_mM_,map_digit(f,_mL_),_mP_,_mO_)}
    function _z_(q,f){return map(f,q)}
    function fold_digit(f,acc,d)
     {if(typeof d === "number")
       return acc;
      else
       switch(d[0])
        {case 0:var x=d[1];return caml_call2(f,acc,x);
         case 1:
          var y=d[2],x$0=d[1];return caml_call2(f,caml_call2(f,acc,x$0),y);
         default:
          var z=d[3],y$0=d[2],x$1=d[1];
          return caml_call2(f,caml_call2(f,caml_call2(f,acc,x$1),y$0),z)}}
    function fold$0(f,acc,q)
     {if(0 === q[0]){var d=q[1];return fold_digit(f,acc,d)}
      var
       _mH_=q[3],
       _mJ_=caml_obj_tag(_mH_),
       _mI_=q[2],
       q$0=
        250 === _mJ_
         ?_mH_[1]
         :246 === _mJ_?caml_call1(CamlinternalLazy[2],_mH_):_mH_,
       tl=q[4],
       acc$0=fold_digit(f,acc,_mI_),
       acc$1=
        fold$0
         (function(acc,param)
           {var y=param[2],x=param[1];
            return caml_call2(f,caml_call2(f,acc,x),y)},
          acc$0,
          q$0);
      return fold_digit(f,acc$1,tl)}
    function iter$3(f,q){return to_seq$1(q,f)}
    function of_list$1(l){return caml_call3(List[20],snoc,q,l)}
    function to_list$1(q)
     {var l=[0,0];
      to_seq$1(q,function(x){l[1] = [0,x,l[1]];return 0});
      return caml_call1(List[9],l[1])}
    function of_seq$1(seq){return add_seq_front$0(seq,q)}
    function rev(q$0)
     {var q$1=[0,q];
      iter$3(function(x){q$1[1] = cons(x,q$1[1]);return 0},q$0);
      return q$1[1]}
    function nil(param){return 3902385}
    function single$0(x,cont,param){return [0,748545553,[0,x,cont]]}
    function double$0(x,y,cont,param)
     {return [0,748545553,[0,x,function(_mG_){return single$0(y,cont,_mG_)}]]}
    function digit_to_klist(d,cont)
     {if(typeof d === "number")
       return nil;
      else
       switch(d[0])
        {case 0:
          var x=d[1];return function(_mD_){return single$0(x,cont,_mD_)};
         case 1:
          var y=d[2],x$0=d[1];
          return function(_mC_){return double$0(x$0,y,cont,_mC_)};
         default:
          var z=d[3],y$0=d[2],x$1=d[1];
          return function(_mE_)
           {return [0,
                    748545553,
                    [0,x$1,function(_mF_){return double$0(y$0,z,cont,_mF_)}]]}}}
    function flat_klist(l,cont,param)
     {var match=caml_call1(l,0);
      if(typeof match === "number")return caml_call1(cont,0);
      var
       _mz_=match[2],
       l$0=_mz_[2],
       match$0=_mz_[1],
       y=match$0[2],
       x=match$0[1],
       _mA_=0;
      return double$0
              (x,y,function(_mB_){return flat_klist(l$0,cont,_mB_)},_mA_)}
    function to_klist(q)
     {function aux(q,cont,param)
       {if(0 === q[0]){var d=q[1];return caml_call1(digit_to_klist(d,cont),0)}
        var
         _mr_=q[3],
         _mt_=caml_obj_tag(_mr_),
         _ms_=q[2],
         q$0=
          250 === _mt_
           ?_mr_[1]
           :246 === _mt_?caml_call1(CamlinternalLazy[2],_mr_):_mr_,
         tl=q[4],
         _mu_=0,
         _mv_=digit_to_klist(tl,cont);
        function _mw_(_my_){return aux(q$0,nil,_my_)}
        return caml_call1
                (digit_to_klist
                  (_ms_,function(_mx_){return flat_klist(_mw_,_mv_,_mx_)}),
                 _mu_)}
      return function(_mq_){return aux(q,nil,_mq_)}}
    function of_klist(l)
     {return add_seq_front$0
              (function(k)
                {var l$0=l;
                 for(;;)
                  {var match=caml_call1(l$0,0);
                   if(typeof match === "number")return 0;
                   var match$0=match[2],l$1=match$0[2],x=match$0[1];
                   caml_call1(k,x);
                   var l$0=l$1;
                   continue}},
               q)}
    function equal$0(eq,q1,q2)
     {var l2$1=to_klist(q2),l1$1=to_klist(q1),l1=l1$1,l2=l2$1;
      for(;;)
       {var match=caml_call1(l1,0),match$0=caml_call1(l2,0);
        if(typeof match === "number")
         {if(3902385 === match$0)return 1}
        else
         if(typeof match$0 !== "number")
          if(748545553 === match$0[1])
           {var
             _mo_=match$0[2],
             l2$0=_mo_[2],
             x2=_mo_[1],
             match$1=match[2],
             l1$0=match$1[2],
             x1=match$1[1],
             _mp_=caml_call2(eq,x1,x2);
            if(_mp_){var l1=l1$0,l2=l2$0;continue}
            return _mp_}
        return 0}}
    function _A_(a,b)
     {if(a <= b)
       {var q$0=q,a$0=a;
        for(;;)
         {if(a$0 === b)return snoc(q$0,a$0);
          var a$1=a$0 + 1 | 0,q$1=snoc(q$0,a$0),q$0=q$1,a$0=a$1;
          continue}}
      var q$2=q,a$2=a;
      for(;;)
       {if(a$2 === b)return snoc(q$2,a$2);
        var a$3=a$2 - 1 | 0,q$3=snoc(q$2,a$2),q$2=q$3,a$2=a$3;
        continue}}
    function _B_(a,b)
     {return a === b?q:a < b?_A_(a,b - 1 | 0):_A_(a,b + 1 | 0)}
    function pp$1(pp_x,out,d)
     {var first=[0,1];
      caml_call2(Format[112],out,_C_);
      iter$3
       (function(x)
         {if(first[1])first[1] = 0;else caml_call2(Format[112],out,_D_);
          return caml_call2(pp_x,out,x)},
        d);
      return caml_call2(Format[112],out,_E_)}
    var
     CCFQueue=
      [0,
       q,
       is_empty$1,
       singleton,
       doubleton,
       Empty$0,
       cons,
       snoc,
       take_front$0,
       take_front_exn,
       take_front_l,
       take_front_while,
       take_back$0,
       take_back_exn,
       take_back_l,
       take_back_while,
       first$0,
       last,
       first_exn$0,
       last_exn,
       nth,
       nth_exn,
       tail,
       init,
       append,
       rev,
       map,
       _z_,
       size$0,
       fold$0,
       iter$3,
       equal$0,
       of_list$1,
       to_list$1,
       add_seq_front$0,
       add_seq_back$0,
       to_seq$1,
       of_seq$1,
       to_klist,
       of_klist,
       _A_,
       _B_,
       pp$1];
    caml_register_global(198,CCFQueue,"CCFQueue");
    var iteri=Array[14],iter$4=Array[13],map$0=Array[15];
    function iteri_rev(f,a)
     {var _mm_=a.length - 1 - 1 | 0;
      if(! (_mm_ < 0))
       {var i=_mm_;
        for(;;)
         {caml_call2(f,i,caml_check_bound(a,i)[i + 1]);
          var _mn_=i - 1 | 0;
          if(0 !== i){var i=_mn_;continue}
          break}}
      return 0}
    var empty$1=[0];
    function get$0(a,i)
     {var _mk_=i < 0?1:0,_ml_=_mk_ || (a.length - 1 <= i?1:0);
      if(_ml_)caml_call1(Pervasives[1],cst_A_get);
      return a[i + 1]}
    function pop(a)
     {var n=a.length - 1;
      if(0 === n)caml_call1(Pervasives[1],cst_A_pop);
      return caml_call3(Array[7],a,0,n - 1 | 0)}
    function set$0(mut,a,i,x)
     {var _mh_=i < 0?1:0;
      if(_mh_)
       var _mi_=_mh_;
      else
       var _mj_=a.length - 1 < i?1:0,_mi_=_mj_ || (32 <= i?1:0);
      if(_mi_)caml_call1(Pervasives[1],cst_A_set);
      if(i === a.length - 1)
       {var arr=caml_make_vect(i + 1 | 0,x);
        caml_call5(Array[10],a,0,arr,0,i);
        return arr}
      if(mut){caml_check_bound(a,i)[i + 1] = x;return a}
      var arr$0=caml_call1(Array[8],a);
      caml_check_bound(arr$0,i)[i + 1] = x;
      return arr$0}
    var empty$2=[0,0,empty$1,empty$1];
    function is_empty$2(param){var size=param[1];return 0 === size?1:0}
    function length$1(param){var size=param[1];return size}
    function return$0(x){return [0,1,[0,x],empty$1]}
    function combine_idx(i,j){return i << 5 | j}
    function split_idx(i)
     {var low$1=[0,i & 31],high$1=i >>> 5 | 0,high=high$1,low=low$1;
      for(;;)
       {if(0 === high)return low;
        if(high < 32)return [1,high - 1 | 0,low];
        var
         low$0=[1,high & 31,low],
         high$0=high >>> 5 | 0,
         high=high$0,
         low=low$0;
        continue}}
    function get$1(i,m)
     {var l$0=split_idx(i),l=l$0,m$0=m;
      for(;;)
       {if(0 === l[0])
         {var x=l[1];
          if(x < m$0[2].length - 1)return get$0(m$0[2],x);
          throw [0,Assert_failure,_F_]}
        var tl=l[2],x$0=l[1],m$1=get$0(m$0[3],x$0),l=tl,m$0=m$1;
        continue}}
    function get_exn(i,v)
     {if(0 <= i)if(i < v[1])return get$1(i,v);throw Not_found}
    function get$2(i,v){if(0 <= i)if(i < v[1])return [0,get$1(i,v)];return 0}
    function push(x,v)
     {var _md_=v[1];
      function aux(l,m)
       {if(0 === l[0])
         {var i=l[1];
          if(i === m[2].length - 1)
           {if(m[2].length - 1 < 32)
             {if(0 === m[3].length - 1)
               {var _mf_=m[2],n=_mf_.length - 1,_me_=m[3];
                if(n === 32)caml_call1(Pervasives[1],cst_A_push);
                var arr=caml_make_vect(n + 1 | 0,x);
                caml_call5(Array[10],_mf_,0,arr,0,n);
                return [0,m[1] + 1 | 0,arr,_me_]}
              throw [0,Assert_failure,_G_]}
            throw [0,Assert_failure,_H_]}
          throw [0,Assert_failure,_I_]}
        var tl=l[2],i$0=l[1];
        if(i$0 <= m[3].length - 1)
         {var
           sub_m=i$0 < m[3].length - 1?get$0(m[3],i$0):empty$2,
           sub_m$0=aux(tl,sub_m),
           _mg_=set$0(0,m[3],i$0,sub_m$0);
          return [0,m[1] + 1 | 0,m[2],_mg_]}
        throw [0,Assert_failure,_J_]}
      return aux(split_idx(_md_),v)}
    function pop_exn(v)
     {if(0 === v[1])caml_call1(Pervasives[2],cst_Fun_vec_pop_exn);
      var _l__=v[1];
      function aux(l,init)
       {if(0 === l[0])
         {var x=l[1];
          if((x + 1 | 0) === init[2].length - 1)
           {var x$0=get$0(init[2],x),_l$_=init[3],_ma_=pop(init[2]);
            return [0,x$0,[0,init[1] - 1 | 0,_ma_,_l$_]]}
          throw [0,Assert_failure,_K_]}
        var
         tl=l[2],
         x$1=l[1],
         sub=get$0(init[3],x$1),
         match=aux(tl,sub),
         sub$0=match[2],
         y=match[1];
        if(is_empty$2(sub$0))
         {if((_l__ + 1 | 0) === init[3].length - 1)
           {var _mb_=pop(init[3]);
            return [0,y,[0,init[1] - 1 | 0,init[2],_mb_]]}
          throw [0,Assert_failure,_L_]}
        var _mc_=set$0(0,init[3],x$1,sub);
        return [0,y,[0,init[1] - 1 | 0,init[2],_mc_]]}
      return aux(split_idx(_l__),v)}
    function iteri$0(f,m)
     {var q=caml_call1(Queue[2],0);
      caml_call2(Queue[4],[0,0,m],q);
      for(;;)
       {if(caml_call1(Queue[11],q))return 0;
        var
         match=caml_call1(Queue[6],q),
         m$0=match[2],
         high=match[1],
         _l7_=m$0[2];
        caml_call2
         (iteri,
          function(high)
            {return function(i,x){return caml_call2(f,combine_idx(high,i),x)}}
           (high),
          _l7_);
        var _l8_=m$0[3];
        caml_call2
         (iteri,
          function(high)
            {return function(i,sub)
              {var _l9_=[0,combine_idx(i,high),sub];
               return caml_call2(Queue[4],_l9_,q)}}
           (high),
          _l8_);
        continue}}
    function iteri_rev$0(f,m)
     {function aux(high,m)
       {var _l5_=m[3];
        iteri_rev(function(i,sub){return aux(combine_idx(i,high),sub)},_l5_);
        var _l6_=m[2];
        return iteri_rev
                (function(i,x){return caml_call2(f,combine_idx(high,i),x)},
                 _l6_)}
      return aux(0,m)}
    function foldi(f,x,m)
     {var acc=[0,x];
      iteri$0(function(i,x){acc[1] = caml_call3(f,acc[1],i,x);return 0},m);
      return acc[1]}
    function iter$5(f,m)
     {return iteri$0(function(param,x){return caml_call1(f,x)},m)}
    function fold$1(f,x,m)
     {return foldi(function(acc,param,x){return caml_call2(f,acc,x)},x,m)}
    function map$1(f,m)
     {var
       _l1_=m[3],
       _l2_=caml_call2(map$0,function(_l4_){return map$1(f,_l4_)},_l1_),
       _l3_=caml_call2(map$0,f,m[2]);
      return [0,m[1],_l3_,_l2_]}
    function append$0(a,b)
     {return is_empty$2(b)?a:fold$1(function(v,x){return push(x,v)},a,b)}
    function add_list(v,l)
     {function _l0_(v,x){return push(x,v)}
      return caml_call3(List[20],_l0_,v,l)}
    function of_list$2(l){return add_list(empty$2,l)}
    function to_list$2(m)
     {var acc=[0,0];
      iteri_rev$0(function(i,x){acc[1] = [0,x,acc[1]];return 0},m);
      return acc[1]}
    function add_seq(v,seq)
     {var v$0=[0,v];
      caml_call1(seq,function(x){v$0[1] = push(x,v$0[1]);return 0});
      return v$0[1]}
    function of_seq$2(s){return add_seq(empty$2,s)}
    function to_seq$2(m,yield$0)
     {return iteri$0(function(param,v){return caml_call1(yield$0,v)},m)}
    function add_gen(m,g)
     {var m$0=m;
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1],m$1=push(x,m$0),m$0=m$1;continue}
        return m$0}}
    function of_gen$0(g){return add_gen(empty$2,g)}
    function to_gen$0(m)
     {var q_cur=caml_call1(Queue[2],0),q_sub=caml_call1(Queue[2],0);
      caml_call2(Queue[4],m,q_sub);
      function next(param)
       {for(;;)
         {if(caml_call1(Queue[11],q_cur))
           {if(caml_call1(Queue[11],q_sub))return 0;
            var m=caml_call1(Queue[6],q_sub),_lY_=m[2];
            caml_call2
             (iter$4,function(x){return caml_call2(Queue[4],x,q_cur)},_lY_);
            var _lZ_=m[3];
            caml_call2
             (iter$4,
              function(sub){return caml_call2(Queue[4],sub,q_sub)},
              _lZ_);
            continue}
          return [0,caml_call1(Queue[6],q_cur)]}}
      return next}
    function choose(m){return caml_call1(to_gen$0(m),0)}
    function pp$2(ppv,out,m)
     {var first=[0,1];
      return iter$5
              (function(v)
                {if(first[1])
                  first[1] = 0;
                 else
                  caml_call2(Format[112],out,_M_);
                 return caml_call2(ppv,out,v)},
               m)}
    var
     CCFun_vec=
      [0,
       empty$2,
       is_empty$2,
       return$0,
       length$1,
       push,
       get$2,
       get_exn,
       pop_exn,
       iter$5,
       iteri$0,
       iteri_rev$0,
       fold$1,
       foldi,
       append$0,
       map$1,
       choose,
       to_list$2,
       of_list$2,
       add_list,
       add_seq,
       of_seq$2,
       to_seq$2,
       add_gen,
       of_gen$0,
       to_gen$0,
       pp$2];
    caml_register_global(200,CCFun_vec,"CCFun_vec");
    var Sequence_once=[248,cst_CCGraph_Sequence_once,caml_fresh_oo_id(0)];
    function _N_(x,f){return caml_call1(f,x)}
    function return$1(x,k){return caml_call1(k,x)}
    function _O_(a,f,k)
     {return caml_call1(a,function(x){return caml_call2(f,x,k)})}
    function map$2(f,a,k)
     {return caml_call1(a,function(x){return caml_call1(k,caml_call1(f,x))})}
    function filter_map(f,a,k)
     {return caml_call1
              (a,
               function(x)
                {var match=caml_call1(f,x);
                 if(match){var y=match[1];return caml_call1(k,y)}
                 return 0})}
    function iter$6(f,a){return caml_call1(a,f)}
    function fold$2(f,acc,a)
     {var acc$0=[0,acc];
      caml_call1(a,function(x){acc$0[1] = caml_call2(f,acc$0[1],x);return 0});
      return acc$0[1]}
    function to_list$3(seq)
     {var _lW_=List[9],_lX_=0;
      return _N_(fold$2(function(acc,x){return [0,x,acc]},_lX_,seq),_lW_)}
    var Exit=[248,cst_CCGraph_Seq_Exit,caml_fresh_oo_id(0)];
    function exists(f,seq)
     {try
       {caml_call1
         (seq,
          function(x){var _lV_=caml_call1(f,x);if(_lV_)throw Exit;return _lV_});
        var _lT_=0;
        return _lT_}
      catch(_lU_)
       {_lU_ = caml_wrap_exception(_lU_);if(_lU_ === Exit)return 1;throw _lU_}}
    function make(f){return f}
    function mk_table(eq,opt,size)
     {if(opt)var sth=opt[1],hash=sth;else var hash=Hashtbl[21];
      var H=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(H[1],size);
      function _lR_(k,v){return caml_call3(H[10],tbl,k,v)}
      function _lS_(k){return caml_call2(H[7],tbl,k)}
      return [0,function(k){return caml_call2(H[11],tbl,k)},_lS_,_lR_]}
    function mk_map(cmp,param)
     {var M=caml_call1(Map[1],[0,cmp]),tbl=[0,M[1]];
      function _lP_(k,v){tbl[1] = caml_call3(M[4],k,v,tbl[1]);return 0}
      function _lQ_(k){return caml_call2(M[27],k,tbl[1])}
      return [0,function(k){return caml_call2(M[3],k,tbl[1])},_lQ_,_lP_]}
    function mk_queue(param)
     {var q=caml_call1(Queue[2],0);
      function _lN_(param){return caml_call1(Queue[6],q)}
      function _lO_(param){return caml_call1(Queue[11],q)}
      return [0,function(x){return caml_call2(Queue[4],x,q)},_lO_,_lN_]}
    function mk_stack(param)
     {var s=caml_call1(Stack[2],0);
      function _lL_(param){return caml_call1(Stack[4],s)}
      function _lM_(param){return caml_call1(Stack[8],s)}
      return [0,function(x){return caml_call2(Stack[3],x,s)},_lM_,_lL_]}
    function union$0(leq,t1,t2)
     {if(t1)
       {if(t2)
         {var r2=t2[3],l2=t2[2],x2=t2[1],r1=t1[3],l1=t1[2],x1=t1[1];
          return caml_call2(leq,x1,x2)
                  ?[0,x1,union$0(leq,t2,r1),l1]
                  :[0,x2,union$0(leq,t1,r2),l2]}
        return t1}
      return t2}
    function mk_heap(leq)
     {var t=[0,0];
      function _lI_(param)
       {var _lK_=t[1];
        if(_lK_)
         {var r=_lK_[3],l=_lK_[2],x=_lK_[1],h=union$0(leq,l,r);
          t[1] = h;
          return x}
        throw Not_found}
      function _lJ_(param){return t[1]?0:1}
      return [0,
              function(x){t[1] = union$0(leq,[0,x,0,0],t[1]);return 0},
              _lJ_,
              _lI_]}
    function generic_tag(tags,bag,graph,seq)
     {var first=[0,1];
      return function(k)
       {if(first[1])
         {first[1] = 0;
          iter$6(bag[1],seq);
          for(;;)
           {if(caml_call1(bag[2],0))return 0;
            var x=caml_call1(bag[3],0);
            if(1 - caml_call1(tags[1],x))
             {caml_call1(k,x);
              caml_call1(tags[2],x);
              var _lH_=caml_call1(graph,x);
              iter$6
               (function(param)
                 {var dest=param[2];return caml_call1(bag[1],dest)},
                _lH_)}
            continue}}
        throw Sequence_once}}
    function generic(tbl,bag,graph,seq)
     {function _lG_(v){return caml_call2(tbl[3],v,0)}
      var tags=[0,tbl[1],_lG_];
      return generic_tag(tags,bag,graph,seq)}
    function bfs(tbl,graph,seq){return generic(tbl,mk_queue(0),graph,seq)}
    function bfs_tag(tags,graph,seq)
     {return generic_tag(tags,mk_queue(0),graph,seq)}
    function dijkstra_tag(opt,tags,graph,seq)
     {if(opt)var sth=opt[1],dist=sth;else var dist=function(param){return 1};
      function _ly_(param){var v=param[1];return caml_call1(tags[2],v)}
      var
       tags$0=
        [0,function(param){var v=param[1];return caml_call1(tags[1],v)},_ly_];
      function _lz_(v){return [0,v,0,0]}
      function seq$0(_lF_){return map$2(_lz_,seq,_lF_)}
      function graph$0(param)
       {var p=param[3],d=param[2],v=param[1];
        function _lB_(param)
         {var v$0=param[2],e=param[1];
          return [0,e,[0,v$0,d + caml_call1(dist,e) | 0,[0,[0,v,e,v$0],p]]]}
        function _lC_(_lD_,_lE_){return map$2(_lB_,_lD_,_lE_)}
        return _N_(caml_call1(graph,v),_lC_)}
      var
       bag=
        mk_heap
         (function(param,_lA_){var d2=_lA_[2],d1=param[2];return d1 <= d2?1:0});
      return generic_tag(tags$0,bag,graph$0,seq$0)}
    function dijkstra(tbl,dist,graph,seq)
     {function _lx_(v){return caml_call2(tbl[3],v,0)}
      var tags=[0,tbl[1],_lx_];
      return dijkstra_tag(dist,tags,graph,seq)}
    function dfs(tbl,graph,seq){return generic(tbl,mk_stack(0),graph,seq)}
    function dfs_tag(tags,graph,seq)
     {return generic_tag(tags,mk_stack(0),graph,seq)}
    function get_vertex(param)
     {var _lw_=param[1];
      if(770176093 === _lw_)return 0;
      if(771171134 <= _lw_){var v=param[2];return [0,[0,v,771171134]]}
      var match=param[2],v$0=match[1];
      return [0,[0,v$0,62119160]]}
    function get_enter(param)
     {if(770176093 <= param[1])return 0;
      var match=param[2],v=match[1];
      return [0,v]}
    function get_exit(param)
     {if(771171134 <= param[1]){var v=param[2];return [0,v]}return 0}
    function get_edge(param)
     {if(770176093 === param[1])
       {var match=param[2],v2=match[3],e=match[2],v1=match[1];
        return [0,[0,v1,e,v2]]}
      return 0}
    function get_edge_kind(param)
     {if(770176093 === param[1])
       {var match=param[2],k=match[4],v=match[3],e=match[2],v$0=match[1];
        return [0,[0,v$0,e,v,k]]}
      return 0}
    function dfs_tag$0(eq,tags,graph,seq)
     {var first=[0,1];
      return function(k)
       {if(first[1])
         {first[1] = 0;
          var bag=mk_stack(0),n=[0,0];
          return iter$6
                  (function(v)
                    {caml_call1(bag[1],[0,62119160,[0,v,0]]);
                     for(;;)
                      {if(caml_call1(bag[2],0))return 0;
                       var match$0=caml_call1(bag[3],0),_lt_=match$0[1];
                       if(770176093 === _lt_)
                        {var
                          match$1=match$0[2],
                          path$1=match$1[4],
                          v$0=match$1[3],
                          e=match$1[2],
                          v$1=match$1[1];
                         if(caml_call1(tags[1],v$0))
                          {var path=path$1;
                           for(;;)
                            {if(path)
                              {var
                                path$0=path[2],
                                match=path[1],
                                v1=match[1],
                                _ls_=caml_call2(eq,v$0,v1);
                               if(! _ls_){var path=path$0;continue}
                               var _lu_=_ls_}
                             else
                              var _lu_=0;
                             var edge_kind=_lu_?736757319:-544747680;
                             break}}
                         else
                          {caml_call1(bag[1],[0,62119160,[0,v$0,path$1]]);
                           var edge_kind=857475493}
                         caml_call1(k,[0,770176093,[0,v$1,e,v$0,edge_kind]])}
                       else
                        if(771171134 <= _lt_)
                         {var x=match$0[2];caml_call1(k,[0,771171134,x])}
                        else
                         {var match$2=match$0[2],path$2=match$2[2],v$2=match$2[1];
                          if(1 - caml_call1(tags[1],v$2))
                           {var num=n[1];
                            n[1]++;
                            caml_call1(tags[2],v$2);
                            caml_call1(k,[0,62119160,[0,v$2,num,path$2]]);
                            caml_call1(bag[1],[0,771171134,v$2]);
                            var _lv_=caml_call1(graph,v$2);
                            iter$6
                             (function(path,v)
                                {return function(param)
                                  {var v$0=param[2],e=param[1];
                                   return caml_call1
                                           (bag[1],[0,770176093,[0,v,e,v$0,[0,[0,v,e,v$0],path]]])}}
                               (path$2,v$2),
                              _lv_)}}
                       continue}},
                   seq)}
        throw Sequence_once}}
    function dfs$0(tbl,eq,graph,seq)
     {function _lr_(v){return caml_call2(tbl[3],v,0)}
      var tags=[0,tbl[1],_lr_];
      return dfs_tag$0(eq,tags,graph,seq)}
    function is_dag(tbl,eq,graph,vs)
     {function _lo_(param)
       {if(typeof param !== "number")
         if(770176093 === param[1])if(736757319 === param[2][4])return 1;
        return 0}
      function _lp_(_lq_){return exists(_lo_,_lq_)}
      return _N_(dfs$0(tbl,eq,graph,vs),_lp_)}
    var Has_cycle=[248,cst_CCGraph_Has_cycle,caml_fresh_oo_id(0)];
    function topo_sort_tag(eq,opt,tags,graph,seq)
     {if(opt)var sth=opt[1],rev=sth;else var rev=0;
      var _lf_=0;
      function _lg_(acc,x){return [0,x,acc]}
      function _lh_(_ln_){return fold$2(_lg_,_lf_,_ln_)}
      function _li_(param)
       {var _lm_=param[1];
        if(770176093 === _lm_)
         {if(736757319 === param[2][4])throw Has_cycle}
        else
         if(771171134 <= _lm_){var v=param[2];return [0,v]}
        return 0}
      function _lj_(_lk_,_ll_){return filter_map(_li_,_lk_,_ll_)}
      var l=_N_(_N_(dfs_tag$0(eq,tags,graph,seq),_lj_),_lh_);
      return rev?caml_call1(List[9],l):l}
    function topo_sort(eq,rev,tbl,graph,seq)
     {function _le_(v){return caml_call2(tbl[3],v,0)}
      var tags=[0,tbl[1],_le_];
      return topo_sort_tag(eq,rev,tags,graph,seq)}
    function map_v(f,param)
     {var
       l=param[2],
       v=param[1],
       l$0=
        [246,
         function(_la_)
          {var
            _lb_=caml_obj_tag(l),
            _lc_=
             250 === _lb_
              ?l[1]
              :246 === _lb_?caml_call1(CamlinternalLazy[2],l):l;
           function _ld_(param)
            {var child=param[2],e=param[1];return [0,e,map_v(f,child)]}
           return caml_call2(List[17],_ld_,_lc_)}];
      return [0,caml_call1(f,v),l$0]}
    function fold_v(f,acc,param)
     {var
       l=param[2],
       v=param[1],
       acc$0=caml_call2(f,acc,v),
       _k9_=caml_obj_tag(l),
       _k__=250 === _k9_?l[1]:246 === _k9_?caml_call1(CamlinternalLazy[2],l):l;
      function _k$_(acc,param){var t=param[2];return fold_v(f,acc,t)}
      return caml_call3(List[20],_k$_,acc$0,_k__)}
    function spanning_tree_tag(tags,graph,v)
     {function mk_node(v)
       {var
         children=
          [246,
           function(_k6_)
            {var _k7_=caml_call1(graph,v),_k8_=0;
             return fold$2
                     (function(acc,param)
                       {var v=param[2],e=param[1];
                        return caml_call1(tags[1],v)
                                ?acc
                                :(caml_call1(tags[2],v),[0,[0,e,mk_node(v)],acc])},
                      _k8_,
                      _k7_)}];
        return [0,v,children]}
      return mk_node(v)}
    function spanning_tree(tbl,graph,v)
     {function _k5_(v){return caml_call2(tbl[3],v,0)}
      var tags=[0,tbl[1],_k5_];
      return spanning_tree_tag(tags,graph,v)}
    function scc(tbl,graph,seq)
     {var first=[0,1];
      return function(k)
       {if(first[1])
         {first[1] = 0;
          var
           to_explore=caml_call1(Stack[2],0),
           stack=caml_call1(Stack[2],0),
           n=[0,0];
          iter$6
           (function(v)
             {caml_call2(Stack[3],[0,62119160,v],to_explore);
              for(;;)
               {if(caml_call1(Stack[8],to_explore))return 0;
                var match=caml_call1(Stack[4],to_explore);
                if(771171134 <= match[1])
                 {var match$0=match[2],cell$1=match$0[2],v$0=match$0[1];
                  if(! cell$1[3])throw [0,Assert_failure,_R_];
                  var _k0_=caml_call1(graph,v$0);
                  iter$6
                   (function(cell)
                      {return function(param)
                        {var
                          dest=param[2],
                          dest_cell=caml_call1(tbl[2],dest),
                          _k3_=dest_cell[3],
                          _k4_=
                           _k3_
                            ?(cell[1]
                              =
                              caml_call2(Pervasives[4],cell[1],dest_cell[1]),
                              0)
                            :_k3_;
                         return _k4_}}
                     (cell$1),
                    _k0_);
                  if(cell$1[2] === cell$1[1])
                   {var acc=0,_k1_=cell$1[2];
                    for(;;)
                     {if(caml_call1(Stack[8],stack))throw [0,Assert_failure,_P_];
                      var cell$0=caml_call1(Stack[4],stack);
                      cell$0[3] = 0;
                      if(cell$0[2] !== _k1_)
                       {var acc$0=[0,cell$0[4],acc],acc=acc$0;continue}
                      if(cell$0[2] !== cell$0[1])throw [0,Assert_failure,_Q_];
                      var scc=[0,cell$0[4],acc];
                      caml_call1(k,scc);
                      break}}}
                else
                 {var v$1=match[2];
                  if(1 - caml_call1(tbl[1],v$1))
                   {var id=n[1];
                    n[1]++;
                    var cell=[0,id,id,0,v$1];
                    cell[3] = 1;
                    caml_call2(tbl[3],v$1,cell);
                    caml_call2(Stack[3],cell,stack);
                    caml_call2(Stack[3],[0,771171134,[0,v$1,cell]],to_explore);
                    var _k2_=caml_call1(graph,v$1);
                    iter$6
                     (function(param)
                       {var v=param[2];
                        return caml_call2(Stack[3],[0,62119160,v],to_explore)},
                      _k2_)}}
                continue}},
            seq);
          if(caml_call1(Stack[8],stack))return 0;
          throw [0,Assert_failure,_S_]}
        throw Sequence_once}}
    function pp_list(pp_x,out,l)
     {caml_call2(Format[13],out,cst$0);
      function _kZ_(i,x)
       {if(0 < i)caml_call2(Format[112],out,_T_);
        return caml_call2(pp_x,out,x)}
      caml_call2(List[16],_kZ_,l);
      return caml_call2(Format[13],out,cst$1)}
    function pp_seq(tbl,eq,opt,_kL_,_kK_,graph,out,seq)
     {if(opt)
       var sth=opt[1],attrs_v=sth;
      else
       var attrs_v=function(param){return 0};
      if(_kL_)
       var sth$0=_kL_[1],attrs_e=sth$0;
      else
       var attrs_e=function(param){return 0};
      if(_kK_)var sth$1=_kK_[1],name=sth$1;else var name=cst_graph;
      function pp_attr(out,attr)
       {var _kY_=attr[1];
        if(48004564 <= _kY_)
         {if(390796561 <= _kY_)
           {if(909829528 <= _kY_)
             {var w=attr[2];return caml_call3(Format[112],out,_U_,w)}
            var s=attr[2];
            return caml_call3(Format[112],out,_V_,s)}
          if(256529153 <= _kY_)
           {var s$0=attr[2];return caml_call3(Format[112],out,_W_,s$0)}
          var l=attr[2];
          return caml_call3(Format[112],out,_X_,l)}
        if(-578166461 <= _kY_)
         {var c=attr[2];return caml_call3(Format[112],out,_Y_,c)}
        var match=attr[2],value=match[2],name=match[1];
        return caml_call4(Format[112],out,_Z_,name,value)}
      var count=[0,0];
      function get_node(v)
       {try
         {var _kW_=caml_call1(tbl[2],v);return _kW_}
        catch(_kX_)
         {_kX_ = caml_wrap_exception(_kX_);
          if(_kX_ === Not_found)
           {var node=[0,0,count[1]];
            count[1]++;
            caml_call2(tbl[3],v,node);
            return node}
          throw _kX_}}
      function vertex_explored(v)
       {try
         {var _kU_=caml_call1(tbl[2],v)[1];return _kU_}
        catch(_kV_)
         {_kV_ = caml_wrap_exception(_kV_);
          if(_kV_ === Not_found)return 0;
          throw _kV_}}
      function set_explored(v){get_node(v)[1] = 1;return 0}
      function pp_vertex(out,v)
       {var _kT_=get_node(v)[2];return caml_call3(Format[112],out,___,_kT_)}
      caml_call3(Format[112],out,_$_,name);
      var
       tags=[0,vertex_explored,set_explored],
       events=dfs_tag$0(eq,tags,graph,seq);
      iter$6
       (function(param)
         {var _kM_=param[1];
          if(770176093 === _kM_)
           {var
             match=param[2],
             v2=match[3],
             e=match[2],
             v1=match[1],
             attrs=caml_call1(attrs_e,e),
             _kN_=function(_kR_,_kS_){return pp_list(pp_attr,_kR_,_kS_)};
            return caml_call8
                    (Format[112],out,_aa_,pp_vertex,v1,pp_vertex,v2,_kN_,attrs)}
          if(771171134 <= _kM_)return 0;
          var match$0=param[2],v=match$0[1],attrs$0=caml_call1(attrs_v,v);
          function _kO_(_kP_,_kQ_){return pp_list(pp_attr,_kP_,_kQ_)}
          return caml_call6(Format[112],out,_ab_,pp_vertex,v,_kO_,attrs$0)},
        events);
      caml_call2(Format[112],out,_ac_);
      return 0}
    function pp$3(tbl,eq,attrs_v,attrs_e,name,graph,fmt,v)
     {return pp_seq
              (tbl,
               eq,
               attrs_v,
               attrs_e,
               name,
               graph,
               fmt,
               function(_kJ_){return return$1(v,_kJ_)})}
    function with_out(filename,f)
     {var oc=caml_call1(Pervasives[48],filename);
      try
       {var fmt=caml_call1(Format[95],oc),x=caml_call1(f,fmt);
        caml_call2(Format[35],fmt,0);
        caml_call1(Pervasives[64],oc);
        return x}
      catch(e)
       {e = caml_wrap_exception(e);caml_call1(Pervasives[64],oc);throw e}}
    function mk_mut_tbl(eq,opt,size)
     {if(opt)var sth=opt[1],hash=sth;else var hash=Hashtbl[21];
      var Tbl=caml_call1(Hashtbl[19],[0,eq,hash]),tbl=caml_call1(Tbl[1],size);
      function _kC_(v){return caml_call2(Tbl[6],tbl,v)}
      function _kD_(v1,e,v2)
       {try
         {var _kH_=caml_call2(Tbl[7],tbl,v1),l=_kH_}
        catch(_kI_)
         {_kI_ = caml_wrap_exception(_kI_);
          if(_kI_ !== Not_found)throw _kI_;
          var l=0}
        return caml_call3(Tbl[10],tbl,v1,[0,[0,e,v2],l])}
      return [0,
              function(v,yield$0)
               {try
                 {var
                   _kE_=caml_call2(Tbl[7],tbl,v),
                   _kF_=caml_call2(List[15],yield$0,_kE_);
                  return _kF_}
                catch(_kG_)
                 {_kG_ = caml_wrap_exception(_kG_);
                  if(_kG_ === Not_found)return 0;
                  throw _kG_}},
              _kD_,
              _kC_]}
    function Map$0(O)
     {var M=caml_call1(Map[1],O);
      function as_graph(m,v,yield$0)
       {try
         {var
           sub=caml_call2(M[27],v,m),
           _kz_=function(v,e){return caml_call1(yield$0,[0,e,v])},
           _kA_=caml_call2(M[12],_kz_,sub);
          return _kA_}
        catch(_kB_)
         {_kB_ = caml_wrap_exception(_kB_);
          if(_kB_ === Not_found)return 0;
          throw _kB_}}
      var empty=M[1];
      function add_edge(v1,e,v2,m)
       {try
         {var _kx_=caml_call2(M[27],v1,m),sub=_kx_}
        catch(_ky_)
         {_ky_ = caml_wrap_exception(_ky_);
          if(_ky_ !== Not_found)throw _ky_;
          var sub=M[1]}
        var _kw_=caml_call3(M[4],v2,e,sub);
        return caml_call3(M[4],v1,_kw_,m)}
      function remove_edge(v1,v2,m)
       {try
         {var
           _kt_=caml_call2(M[27],v1,m),
           map=caml_call2(M[7],v2,_kt_),
           _ku_=
            caml_call1(M[2],map)
             ?caml_call2(M[7],v1,m)
             :caml_call3(M[4],v1,map,m);
          return _ku_}
        catch(_kv_)
         {_kv_ = caml_wrap_exception(_kv_);
          if(_kv_ === Not_found)return m;
          throw _kv_}}
      function add(v,m)
       {return caml_call2(M[3],v,m)?m:caml_call3(M[4],v,M[1],m)}
      function remove(v,m){return caml_call2(M[7],v,m)}
      function union(m1,m2)
       {function _kq_(param,s1,s2)
         {if(s1)
           {var _kr_=s1[1];
            if(s2)
             {var
               s2$0=s2[1],
               _ks_=function(param,e1,e2){return e1?e1:e2},
               s=caml_call3(M[8],_ks_,_kr_,s2$0);
              return [0,s]}
            var s$0=_kr_}
          else
           {if(! s2)throw [0,Assert_failure,_ad_];var s$0=s2[1]}
          return [0,s$0]}
        return caml_call3(M[8],_kq_,m1,m2)}
      function vertices(m,yield$0)
       {function _kp_(v,param){return caml_call1(yield$0,v)}
        return caml_call2(M[12],_kp_,m)}
      function vertices_l(m)
       {var _kn_=0;
        function _ko_(v,param,acc){return [0,v,acc]}
        return caml_call3(M[13],_ko_,m,_kn_)}
      function add_list(l,m)
       {function _km_(m,param)
         {var v2=param[3],e=param[2],v1=param[1];return add_edge(v1,e,v2,m)}
        return caml_call3(List[20],_km_,m,l)}
      function of_list(l){return add_list(l,empty)}
      function to_list(m)
       {var _kj_=0;
        function _kk_(v,map,acc)
         {function _kl_(v$0,e,acc){return [0,[0,v,e,v$0],acc]}
          return caml_call3(M[13],_kl_,map,acc)}
        return caml_call3(M[13],_kk_,m,_kj_)}
      function add_seq(seq,m)
       {return fold$2
                (function(m,param)
                  {var v2=param[3],e=param[2],v1=param[1];
                   return add_edge(v1,e,v2,m)},
                 m,
                 seq)}
      function of_seq(seq){return add_seq(seq,empty)}
      function to_seq(m,k)
       {function _kh_(v,map)
         {function _ki_(v$0,e){return caml_call1(k,[0,v,e,v$0])}
          return caml_call2(M[12],_ki_,map)}
        return caml_call2(M[12],_kh_,m)}
      return [0,
              as_graph,
              empty,
              add_edge,
              remove_edge,
              add,
              remove,
              union,
              vertices,
              vertices_l,
              of_list,
              add_list,
              to_list,
              of_seq,
              add_seq,
              to_seq]}
    function of_list$3(eq,l,v,yield$0)
     {function _kf_(param)
       {var b=param[2],a=param[1],_kg_=caml_call2(eq,a,v);
        return _kg_?caml_call1(yield$0,[0,0,b]):_kg_}
      return caml_call2(List[15],_kf_,l)}
    function of_fun(f,v,yield$0)
     {var l=caml_call1(f,v);
      function _ke_(v){return caml_call1(yield$0,[0,0,v])}
      return caml_call2(List[15],_ke_,l)}
    function of_hashtbl(tbl,v,yield$0)
     {try
       {var
         _ka_=caml_call2(Hashtbl[6],tbl,v),
         _kb_=function(b){return caml_call1(yield$0,[0,0,b])},
         _kc_=caml_call2(List[15],_kb_,_ka_);
        return _kc_}
      catch(_kd_)
       {_kd_ = caml_wrap_exception(_kd_);
        if(_kd_ === Not_found)return 0;
        throw _kd_}}
    function divisors_graph(i)
     {var j=1;
      return function(yield$0)
       {var j$0=j;
        for(;;)
         {var _j$_=j$0 < i?1:0;
          if(_j$_)
           {if(0 === caml_mod(i,j$0))caml_call1(yield$0,[0,0,j$0]);
            var j$1=j$0 + 1 | 0,j$0=j$1;
            continue}
          return _j$_}}}
    var
     CCGraph=
      [0,
       Sequence_once,
       [0,return$1,_O_,map$2,filter_map,iter$6,fold$2,to_list$3],
       make,
       mk_table,
       mk_map,
       mk_queue,
       mk_stack,
       mk_heap,
       [0,
        generic,
        generic_tag,
        dfs,
        dfs_tag,
        bfs,
        bfs_tag,
        dijkstra,
        dijkstra_tag,
        [0,
         get_vertex,
         get_enter,
         get_exit,
         get_edge,
         get_edge_kind,
         dfs$0,
         dfs_tag$0]],
       is_dag,
       Has_cycle,
       topo_sort,
       topo_sort_tag,
       [0,map_v,fold_v],
       spanning_tree,
       spanning_tree_tag,
       scc,
       [0,pp$3,pp_seq,with_out],
       mk_mut_tbl,
       Map$0,
       of_list$3,
       of_hashtbl,
       of_fun,
       divisors_graph];
    caml_register_global(202,CCGraph,"CCGraph");
    function Make$0(E)
     {var Tbl=caml_call1(Hashtbl[19],E),create=Tbl[1];
      function singleton(x)
       {var s=caml_call1(create,8);caml_call3(Tbl[10],s,x,x);return s}
      var clear=Tbl[2],copy=Tbl[4];
      function copy_into(into,s)
       {function _j__(x,param){return caml_call3(Tbl[10],into,x,x)}
        return caml_call2(Tbl[12],_j__,s)}
      function insert(s,x){return caml_call3(Tbl[10],s,x,x)}
      var remove=Tbl[6],cardinal=Tbl[15],mem=Tbl[11],find_exn=Tbl[7];
      function find(s,x)
       {try
         {var _j8_=[0,caml_call2(Tbl[7],s,x)];return _j8_}
        catch(_j9_)
         {_j9_ = caml_wrap_exception(_j9_);
          if(_j9_ === Not_found)return 0;
          throw _j9_}}
      function iter(f,s)
       {function _j7_(x,param){return caml_call1(f,x)}
        return caml_call2(Tbl[12],_j7_,s)}
      function fold(f,acc,s)
       {function _j6_(x,param,acc){return caml_call2(f,acc,x)}
        return caml_call3(Tbl[14],_j6_,s,acc)}
      function inter(a,b)
       {var
         _j3_=caml_call1(cardinal,b),
         _j4_=caml_call1(cardinal,a),
         res=caml_call1(create,caml_call2(Pervasives[4],_j4_,_j3_));
        iter
         (function(x)
           {var _j5_=caml_call2(mem,a,x);return _j5_?insert(res,x):_j5_},
          b);
        return res}
      function inter_mut(into,a)
       {return iter
                (function(x)
                  {var _j2_=1 - caml_call2(mem,a,x);
                   return _j2_?caml_call2(remove,into,x):_j2_},
                 into)}
      function union(a,b)
       {var res=caml_call1(copy,a);copy_into(res,b);return res}
      function union_mut(into,a){return copy_into(into,a)}
      function diff(a,b)
       {var res=caml_call1(copy,a);
        iter(function(x){return caml_call2(remove,res,x)},b);
        return res}
      var FastExit=[248,cst_CCHashSet_Make_E_FastExit,caml_fresh_oo_id(0)];
      function for_all(p,s)
       {try
         {var
           _jY_=
            function(x,param)
             {var _j1_=1 - caml_call1(p,x);if(_j1_)throw FastExit;return _j1_};
          caml_call2(Tbl[12],_jY_,s);
          var _jZ_=1;
          return _jZ_}
        catch(_j0_)
         {_j0_ = caml_wrap_exception(_j0_);
          if(_j0_ === FastExit)return 0;
          throw _j0_}}
      function exists(p,s)
       {try
         {var
           _jU_=
            function(x,param)
             {var _jX_=caml_call1(p,x);if(_jX_)throw FastExit;return _jX_};
          caml_call2(Tbl[12],_jU_,s);
          var _jV_=0;
          return _jV_}
        catch(_jW_)
         {_jW_ = caml_wrap_exception(_jW_);
          if(_jW_ === FastExit)return 1;
          throw _jW_}}
      function subset(a,b)
       {return for_all(function(x){return caml_call2(mem,b,x)},a)}
      function equal(a,b){var _jT_=subset(a,b);return _jT_?subset(b,a):_jT_}
      function elements(s)
       {var _jR_=0;
        function _jS_(x,param,acc){return [0,x,acc]}
        return caml_call3(Tbl[14],_jS_,s,_jR_)}
      function of_list(l)
       {var res=caml_call1(create,caml_call1(List[1],l));
        function _jP_(_jQ_){return insert(res,_jQ_)}
        caml_call2(List[15],_jP_,l);
        return res}
      function to_seq(s,yield$0){return iter(yield$0,s)}
      function add_seq(s,seq)
       {return caml_call1(seq,function(_jO_){return insert(s,_jO_)})}
      function of_seq(seq)
       {var s=caml_call1(create,32);
        caml_call1(seq,function(_jN_){return insert(s,_jN_)});
        return s}
      function pp(opt,pp_x,out,s)
       {if(opt)var sth=opt[1],sep=sth;else var sep=cst$4;
        caml_call2(Format[13],out,cst$2);
        var first=[0,1];
        function _jM_(x,param)
         {if(first[1])
           first[1] = 0;
          else
           {caml_call2(Format[13],out,sep);caml_call2(Format[27],out,0)}
          return caml_call2(pp_x,out,x)}
        caml_call2(Tbl[12],_jM_,s);
        return caml_call2(Format[13],out,cst$3)}
      return [0,
              create,
              singleton,
              clear,
              copy,
              copy_into,
              insert,
              remove,
              cardinal,
              mem,
              find_exn,
              find,
              inter,
              inter_mut,
              union,
              union_mut,
              diff,
              subset,
              equal,
              for_all,
              exists,
              iter,
              fold,
              elements,
              of_list,
              to_seq,
              of_seq,
              add_seq,
              pp]}
    var CCHashSet=[0,Make$0];
    caml_register_global(203,CCHashSet,"CCHashSet");
    var empty$3=[0,1];
    function equal$1(a,b){return a === b?1:0}
    function create$1(param){return [0,0]}
    function active(st){return 1 - st[1]}
    function frozen(st){return st[1]}
    function freeze(st){st[1] = 1;return 0}
    function with$0(f)
     {var r=create$1(0);
      try
       {var x=caml_call1(f,r);freeze(r);return x}
      catch(e){e = caml_wrap_exception(e);freeze(r);throw e}}
    var
     Frozen$0=[248,cst_CCHashTrie_Transient_Frozen,caml_fresh_oo_id(0)],
     lnot=Int64[9];
    function popcount(b)
     {var
       b$0=
        caml_int64_sub
         (b,caml_int64_and(caml_int64_shift_right_unsigned(b,1),_ae_)),
       b$1=
        caml_int64_add
         (caml_int64_and(b$0,_ag_),
          caml_int64_and(caml_int64_shift_right_unsigned(b$0,2),_af_)),
       b$2=
        caml_int64_and
         (caml_int64_add(b$1,caml_int64_shift_right_unsigned(b$1,4)),_ah_),
       b$3=caml_int64_add(b$2,caml_int64_shift_right_unsigned(b$2,8)),
       b$4=caml_int64_add(b$3,caml_int64_shift_right_unsigned(b$3,16)),
       b$5=caml_int64_add(b$4,caml_int64_shift_right_unsigned(b$4,32));
      return runtime.caml_int64_to_int32(caml_int64_and(b$5,_ai_))}
    function owns(id,a){var _jL_=active(id);return _jL_?id === a[3]?1:0:_jL_}
    function get$3(default$0,a,i)
     {var idx=caml_int64_shift_left(_ak_,i);
      if(caml_equal(caml_int64_and(a[1],idx),_al_))return default$0;
      var real_idx=popcount(caml_int64_and(a[1],caml_int64_sub(idx,_am_)));
      return caml_check_bound(a[2],real_idx)[real_idx + 1]}
    function set$1(mut,a,i,x)
     {var
       idx=caml_int64_shift_left(_an_,i),
       real_idx=popcount(caml_int64_and(a[1],caml_int64_sub(idx,_ao_)));
      if(caml_equal(caml_int64_and(a[1],idx),_ap_))
       {var
         bits=caml_int64_or(a[1],idx),
         n=a[2].length - 1,
         arr=caml_make_vect(n + 1 | 0,x);
        caml_check_bound(arr,real_idx)[real_idx + 1] = x;
        if(0 < real_idx)caml_call5(Array[10],a[2],0,arr,0,real_idx);
        if(real_idx < n)
         caml_call5
          (Array[10],a[2],real_idx,arr,real_idx + 1 | 0,n - real_idx | 0);
        return [0,bits,arr,a[3]]}
      if(mut){caml_check_bound(a[2],real_idx)[real_idx + 1] = x;return a}
      var arr$0=mut?a[2]:caml_call1(Array[8],a[2]);
      caml_check_bound(arr$0,real_idx)[real_idx + 1] = x;
      return [0,a[1],arr$0,a[3]]}
    function iter$7(f,a){return caml_call2(Array[13],f,a[2])}
    function fold$3(f,acc,a){return caml_call3(Array[17],f,acc,a[2])}
    function Make$1(Key)
     {var hash=Key[2],zero=0,empty=0;
      function is_empty(param)
       {if(typeof param === "number")
         return 1;
        else
         if(1 === param[0])
          if(typeof param[2] === "number")throw [0,Assert_failure,_aw_];
        return 0}
      function singleton(k,v){var h=caml_call1(hash,k);return [1,h,[2,k,v,0]]}
      function get_exn_list(k,l)
       {var l$0=l;
        for(;;)
         if(typeof l$0 === "number")
          throw Not_found;
         else
          switch(l$0[0])
           {case 0:
             var v=l$0[2],k$0=l$0[1];
             if(caml_call2(Key[1],k,k$0))return v;
             throw Not_found;
            case 1:
             var v2=l$0[4],k2=l$0[3],v1=l$0[2],k1=l$0[1];
             if(caml_call2(Key[1],k,k1))return v1;
             if(caml_call2(Key[1],k,k2))return v2;
             throw Not_found;
            default:
             var tail=l$0[3],v$0=l$0[2],k$1=l$0[1];
             if(caml_call2(Key[1],k,k$1))return v$0;
             var l$0=tail;
             continue}}
      function get_exn(k,h,m)
       {var h$0=h,m$0=m;
        for(;;)
         if(typeof m$0 === "number")
          throw Not_found;
         else
          switch(m$0[0])
           {case 0:
             var v=m$0[3],k$0=m$0[2];
             if(caml_call2(Key[1],k,k$0))return v;
             throw Not_found;
            case 1:var l=m$0[2];return get_exn_list(k,l);
            default:
             var a=m$0[2],leaf=m$0[1];
             if(0 === h$0)return get_exn_list(k,leaf);
             var
              i=h$0 & 63,
              h$1=h$0 >>> 6 | 0,
              m$1=get$3(0,a,i),
              h$0=h$1,
              m$0=m$1;
             continue}}
      function get_exn$0(k,m){return get_exn(k,caml_call1(hash,k),m)}
      function get(k,m)
       {try
         {var _jJ_=[0,get_exn(k,caml_call1(hash,k),m)];return _jJ_}
        catch(_jK_)
         {_jK_ = caml_wrap_exception(_jK_);
          if(_jK_ === Not_found)return 0;
          throw _jK_}}
      function mem(k,m)
       {try
         {get_exn(k,caml_call1(hash,k),m);var _jH_=1;return _jH_}
        catch(_jI_)
         {_jI_ = caml_wrap_exception(_jI_);
          if(_jI_ === Not_found)return 0;
          throw _jI_}}
      function add_list(k,v,l)
       {if(typeof l === "number")
         return [0,k,v];
        else
         switch(l[0])
          {case 0:
            var v1=l[2],k1=l[1];
            return caml_call2(Key[1],k,k1)?[0,k,v]:[1,k,v,k1,v1];
           case 1:
            var v2=l[4],k2=l[3],v1$0=l[2],k1$0=l[1];
            return caml_call2(Key[1],k,k1$0)
                    ?[1,k,v,k2,v2]
                    :caml_call2(Key[1],k,k2)?[1,k,v,k1$0,v1$0]:[2,k,v,l];
           default:
            var tail=l[3],v$0=l[2],k$0=l[1];
            return caml_call2(Key[1],k,k$0)
                    ?[2,k,v,tail]
                    :[2,k$0,v$0,add_list(k,v,tail)]}}
      function make_array(id,leaf,h$0,k,v,h)
       {var a=[0,_aj_,[0],id];
        if(0 === h$0)
         var a$0=a,leaf$0=leaf;
        else
         var
          i=h$0 & 63,
          h$1=h$0 >>> 6 | 0,
          a$3=set$1(1,a,i,[1,h$1,leaf]),
          a$0=a$3,
          leaf$0=0;
        if(0 === h)
         var a$1=a$0,leaf$1=add_list(k,v,leaf$0);
        else
         var a$2=add_to_array(id,1,k,v,h,a$0),a$1=a$2,leaf$1=leaf$0;
        return [2,leaf$1,a$1]}
      function add(id,k,v,h,m)
       {if(typeof m === "number")
         return [0,h,k,v];
        else
         switch(m[0])
          {case 0:
            var v$0=m[3],k$0=m[2],h$0=m[1];
            return h === h$0
                    ?caml_call2(Key[1],k,k$0)
                      ?[0,h,k,v]
                      :[1,h,[2,k,v,[2,k$0,v$0,0]]]
                    :make_array(id,[2,k$0,v$0,0],h$0,k,v,h);
           case 1:
            var l=m[2],h$1=m[1];
            return h === h$1?[1,h,add_list(k,v,l)]:make_array(id,l,h$1,k,v,h);
           default:
            var a=m[2],leaf=m[1];
            if(0 === h)return [2,add_list(k,v,leaf),a];
            var mut=owns(id,a);
            return [2,leaf,add_to_array(id,mut,k,v,h,a)]}}
      function add_to_array(id,mut,k,v,h,a)
       {var i=h & 63,h$0=h >>> 6 | 0;
        function f(x){return add(id,k,v,h$0,x)}
        var
         idx=caml_int64_shift_left(_aq_,i),
         real_idx=popcount(caml_int64_and(a[1],caml_int64_sub(idx,_ar_))),
         default$0=0;
        if(caml_equal(caml_int64_and(a[1],idx),_as_))
         {var
           x=f(default$0),
           bits=caml_int64_or(a[1],idx),
           n=a[2].length - 1,
           arr=caml_make_vect(n + 1 | 0,x);
          if(0 < real_idx)caml_call5(Array[10],a[2],0,arr,0,real_idx);
          if(real_idx < n)
           caml_call5
            (Array[10],a[2],real_idx,arr,real_idx + 1 | 0,n - real_idx | 0);
          return [0,bits,arr,a[3]]}
        var
         x$0=f(caml_check_bound(a[2],real_idx)[real_idx + 1]),
         arr$0=mut?a[2]:caml_call1(Array[8],a[2]);
        caml_check_bound(arr$0,real_idx)[real_idx + 1] = x$0;
        return [0,a[1],arr$0,a[3]]}
      function add$0(k,v,m){return add(empty$3,k,v,caml_call1(hash,k),m)}
      function add_mut(id,k,v,m)
       {if(id[1])throw Frozen$0;return add(id,k,v,caml_call1(hash,k),m)}
      var
       LocalExit=
        [248,cst_CCHashTrie_Make_Key_LocalExit,caml_fresh_oo_id(0)];
      function is_empty_arr(a)
       {try
         {iter$7
           (function(t)
             {var _jG_=1 - is_empty(t);if(_jG_)throw LocalExit;return _jG_},
            a);
          var _jE_=1;
          return _jE_}
        catch(_jF_)
         {_jF_ = caml_wrap_exception(_jF_);
          if(_jF_ === LocalExit)return 0;
          throw _jF_}}
      function is_empty_list(param){return typeof param === "number"?1:0}
      function remove_list(k,l)
       {if(typeof l === "number")
         return 0;
        else
         switch(l[0])
          {case 0:var k$0=l[1];return caml_call2(Key[1],k,k$0)?0:l;
           case 1:
            var v2=l[4],k2=l[3],v1=l[2],k1=l[1];
            return caml_call2(Key[1],k,k1)
                    ?[0,k2,v2]
                    :caml_call2(Key[1],k,k2)?[0,k1,v1]:l;
           default:
            var tail=l[3],v=l[2],k$1=l[1];
            return caml_call2(Key[1],k,k$1)?tail:[2,k$1,v,remove_list(k,tail)]}}
      function remove_rec(id,k,h,m)
       {if(typeof m === "number")
         return 0;
        else
         switch(m[0])
          {case 0:var k$0=m[2];return caml_call2(Key[1],k,k$0)?0:m;
           case 1:
            var l=m[2],h$0=m[1],l$0=remove_list(k,l);
            return is_empty_list(l$0)?0:[1,h$0,l$0];
           default:
            var a=m[2],leaf=m[1];
            if(0 === h)
             var leaf$0=remove_list(k,leaf),a$0=a;
            else
             {var
               i=h & 63,
               h$1=h >>> 6 | 0,
               new_t=remove_rec(id,k,h$1,get$3(0,a,i));
              if(is_empty(new_t))
               {var
                 idx=caml_int64_shift_left(_at_,i),
                 real_idx=
                  popcount(caml_int64_and(a[1],caml_int64_sub(idx,_au_)));
                if(caml_equal(caml_int64_and(a[1],idx),_av_))
                 var _jD_=a;
                else
                 {var
                   _jC_=caml_call1(lnot,idx),
                   bits=caml_int64_and(a[1],_jC_),
                   n=a[2].length - 1,
                   arr=
                    1 === n
                     ?[0]
                     :caml_make_vect(n - 1 | 0,caml_check_bound(a[2],0)[1]);
                  if(0 < real_idx)caml_call5(Array[10],a[2],0,arr,0,real_idx);
                  if((real_idx + 1 | 0) < n)
                   caml_call5
                    (Array[10],
                     a[2],
                     real_idx + 1 | 0,
                     arr,
                     real_idx,
                     (n - real_idx | 0) - 1 | 0);
                  var _jD_=[0,bits,arr,a[3]]}
                var leaf$0=leaf,a$0=_jD_}
              else
               var mut=owns(id,a),a$1=set$1(mut,a,i,new_t),leaf$0=leaf,a$0=a$1}
            if(is_empty_list(leaf$0))if(is_empty_arr(a$0))return 0;
            return [2,leaf$0,a$0]}}
      function remove(k,m){return remove_rec(empty$3,k,caml_call1(hash,k),m)}
      function remove_mut(id,k,m)
       {if(id[1])throw Frozen$0;return remove_rec(id,k,caml_call1(hash,k),m)}
      function update(id,k,f,m)
       {var h=caml_call1(hash,k);
        try
         {var _jA_=[0,get_exn(k,h,m)],opt_v=_jA_}
        catch(_jB_)
         {_jB_ = caml_wrap_exception(_jB_);
          if(_jB_ !== Not_found)throw _jB_;
          var opt_v=0}
        var match=caml_call1(f,opt_v);
        if(opt_v)
         {if(! match)return remove_rec(id,k,h,m);var v=match[1]}
        else
         {if(! match)return m;var v=match[1]}
        return add(id,k,v,h,m)}
      function update$0(k,f,m){return update(empty$3,k,f,m)}
      function update_mut(id,k,f,m)
       {if(id[1])throw Frozen$0;return update(id,k,f,m)}
      function iter(f,t)
       {function aux_list(param)
         {var param$0=param;
          for(;;)
           if(typeof param$0 === "number")
            return 0;
           else
            switch(param$0[0])
             {case 0:var v=param$0[2],k=param$0[1];return caml_call2(f,k,v);
              case 1:
               var v2=param$0[4],k2=param$0[3],v1=param$0[2],k1=param$0[1];
               caml_call2(f,k1,v1);
               return caml_call2(f,k2,v2);
              default:
               var tl=param$0[3],v$0=param$0[2],k$0=param$0[1];
               caml_call2(f,k$0,v$0);
               var param$0=tl;
               continue}}
        function aux(param)
         {if(typeof param === "number")
           return 0;
          else
           switch(param[0])
            {case 0:var v=param[3],k=param[2];return caml_call2(f,k,v);
             case 1:var l=param[2];return aux_list(l);
             default:
              var a=param[2],l$0=param[1];aux_list(l$0);return iter$7(aux,a)}}
        return aux(t)}
      function fold(f,acc,t)
       {function aux_list(acc,l)
         {var acc$0=acc,l$0=l;
          for(;;)
           if(typeof l$0 === "number")
            return acc$0;
           else
            switch(l$0[0])
             {case 0:var v=l$0[2],k=l$0[1];return caml_call3(f,acc$0,k,v);
              case 1:
               var v2=l$0[4],k2=l$0[3],v1=l$0[2],k1=l$0[1];
               return caml_call3(f,caml_call3(f,acc$0,k1,v1),k2,v2);
              default:
               var
                tl=l$0[3],
                v$0=l$0[2],
                k$0=l$0[1],
                acc$1=caml_call3(f,acc$0,k$0,v$0),
                acc$0=acc$1,
                l$0=tl;
               continue}}
        function aux(acc,t)
         {if(typeof t === "number")
           return acc;
          else
           switch(t[0])
            {case 0:var v=t[3],k=t[2];return caml_call3(f,acc,k,v);
             case 1:var l=t[2];return aux_list(acc,l);
             default:
              var a=t[2],l$0=t[1],acc$0=aux_list(acc,l$0);
              return fold$3(aux,acc$0,a)}}
        return aux(acc,t)}
      function cardinal(m)
       {var _jy_=0;
        return fold(function(n,param,_jz_){return n + 1 | 0},_jy_,m)}
      function to_list(m)
       {var _jx_=0;
        return fold(function(acc,k,v){return [0,[0,k,v],acc]},_jx_,m)}
      function add_list_mut(id,m,l)
       {function _jw_(acc,param)
         {var v=param[2],k=param[1];return add_mut(id,k,v,acc)}
        return caml_call3(List[20],_jw_,m,l)}
      function add_list$0(m,l)
       {return with$0(function(id){return add_list_mut(id,m,l)})}
      function of_list(l){return add_list$0(empty,l)}
      function add_seq_mut(id,m,seq)
       {var m$0=[0,m];
        caml_call1
         (seq,
          function(param)
           {var v=param[2],k=param[1];
            m$0[1] = add_mut(id,k,v,m$0[1]);
            return 0});
        return m$0[1]}
      function add_seq(m,seq)
       {return with$0(function(id){return add_seq_mut(id,m,seq)})}
      function of_seq(s){return add_seq(empty,s)}
      function to_seq(m,yield$0)
       {return iter(function(k,v){return caml_call1(yield$0,[0,k,v])},m)}
      function add_gen_mut(id,m,g)
       {var m$0=m;
        for(;;)
         {var match=caml_call1(g,0);
          if(match)
           {var
             match$0=match[1],
             v=match$0[2],
             k=match$0[1],
             m$1=add_mut(id,k,v,m$0),
             m$0=m$1;
            continue}
          return m$0}}
      function add_gen(m,g)
       {return with$0(function(id){return add_gen_mut(id,m,g)})}
      function of_gen(g){return add_gen(empty,g)}
      function to_gen(m)
       {var st=caml_call1(Stack[2],0);
        caml_call2(Stack[3],m,st);
        function next(param)
         {for(;;)
           {if(caml_call1(Stack[8],st))return 0;
            var match=caml_call1(Stack[4],st);
            if(typeof match === "number")
             continue;
            else
             switch(match[0])
              {case 0:var v=match[3],k=match[2];return [0,[0,k,v]];
               case 1:
                var _ju_=match[2],_jv_=match[1];
                if(typeof _ju_ === "number")
                 continue;
                else
                 switch(_ju_[0])
                  {case 0:var v$0=_ju_[2],k$0=_ju_[1];return [0,[0,k$0,v$0]];
                   case 1:
                    var v2=_ju_[4],k2=_ju_[3],v1=_ju_[2],k1=_ju_[1];
                    caml_call2(Stack[3],[1,_jv_,[0,k2,v2]],st);
                    return [0,[0,k1,v1]];
                   default:
                    var tl=_ju_[3],v$1=_ju_[2],k$1=_ju_[1];
                    caml_call2(Stack[3],[1,_jv_,tl],st);
                    return [0,[0,k$1,v$1]]}
               default:
                var a=match[2],l=match[1];
                iter$7(function(sub){return caml_call2(Stack[3],sub,st)},a);
                caml_call2(Stack[3],[1,zero,l],st);
                continue}}}
        return next}
      function choose(m){return caml_call1(to_gen(m),0)}
      function choose_exn(m)
       {var match=choose(m);
        if(match)
         {var match$0=match[1],v=match$0[2],k=match$0[1];return [0,k,v]}
        throw Not_found}
      function pp(ppk,ppv,out,m)
       {var first=[0,1];
        return iter
                (function(k,v)
                  {if(first[1])
                    first[1] = 0;
                   else
                    caml_call2(Format[112],out,_ax_);
                   caml_call2(ppk,out,k);
                   caml_call2(Format[13],out,cst$5);
                   return caml_call2(ppv,out,v)},
                 m)}
      function as_tree(m,param)
       {if(typeof m === "number")
         return 3902385;
        else
         switch(m[0])
          {case 0:
            var v=m[3],k=m[2],h=m[1];
            return [0,870528546,[0,[0,76,[0,h,[0,[0,k,v],0]]],0]];
           case 1:
            var l=m[2],h$0=m[1];
            return [0,870528546,[0,[0,76,[0,h$0,list_as_tree(l)]],0]];
           default:
            var
             a=m[2],
             l$0=m[1],
             _jq_=0,
             _jr_=
              fold$3
               (function(acc,t)
                 {return [0,function(_jt_){return as_tree(t,_jt_)},acc]},
                _jq_,
                a),
             _jp_=[1,zero,l$0];
            return [0,
                    870528546,
                    [0,78,[0,function(_js_){return as_tree(_jp_,_js_)},_jr_]]]}}
      function list_as_tree(l)
       {if(typeof l === "number")
         return 0;
        else
         switch(l[0])
          {case 0:var v=l[2],k=l[1];return [0,[0,k,v],0];
           case 1:
            var v2=l[4],k2=l[3],v1=l[2],k1=l[1];
            return [0,[0,k1,v1],[0,[0,k2,v2],0]];
           default:
            var tail=l[3],v$0=l[2],k$0=l[1];
            return [0,[0,k$0,v$0],list_as_tree(tail)]}}
      return [0,
              empty,
              is_empty,
              singleton,
              add$0,
              mem,
              get,
              get_exn$0,
              remove,
              update$0,
              add_mut,
              remove_mut,
              update_mut,
              cardinal,
              choose,
              choose_exn,
              iter,
              fold,
              to_list,
              add_list$0,
              add_list_mut,
              of_list,
              add_seq,
              add_seq_mut,
              of_seq,
              to_seq,
              add_gen,
              add_gen_mut,
              of_gen,
              to_gen,
              pp,
              as_tree]}
    var
     CCHashTrie=
      [0,
       [0,create$1,equal$1,frozen,active,freeze,with$0,Frozen$0],
       Make$1,
       popcount];
    caml_register_global(205,CCHashTrie,"CCHashTrie");
    var n=[0,0];
    function create$2(param)
     {n[1]++;
      var id=n[1],Store=[248,cst_Store,caml_fresh_oo_id(0)];
      return [0,Store,id]}
    function equal$2(K1,K2){return K1[2] === K2[2]?1:0}
    function pair_of_e_pair(param)
     {var e=param[2],k=param[1];
      if(e[1] === k[1]){var v=e[2];return [0,k,v]}
      throw [0,Assert_failure,_ay_]}
    function equal$3(i,j){return i === j?1:0}
    function hash(i){return caml_call1(Hashtbl[21],i)}
    var M=caml_call1(Hashtbl[19],[0,equal$3,hash]);
    function create$3(opt,param)
     {if(opt)var sth=opt[1],size=sth;else var size=16;
      return caml_call1(M[1],size)}
    function mem(t,k){return caml_call2(M[11],t,k[2])}
    function find_exn(t,K)
     {var match=caml_call2(M[7],t,K[2]),v=match[2];
      if(v[1] === K[1]){var v$0=v[2];return v$0}
      throw [0,Assert_failure,_az_]}
    function find(t,k)
     {try
       {var _jn_=[0,find_exn(t,k)];return _jn_}
      catch(_jo_)
       {_jo_ = caml_wrap_exception(_jo_);
        if(_jo_ === Not_found)return 0;
        throw _jo_}}
    function add_pair(t,p)
     {var v=p[2],k=p[1],p$0=[0,k,[0,k[1],v]];
      return caml_call3(M[10],t,k[2],p$0)}
    function add$0(t,k,v){return add_pair(t,[0,k,v])}
    function length$2(t){return caml_call1(M[15],t)}
    function iter$8(f,t)
     {function _jm_(param,pair){return caml_call1(f,pair_of_e_pair(pair))}
      return caml_call2(M[12],_jm_,t)}
    function to_seq$3(t,yield$0){return iter$8(yield$0,t)}
    function to_list$4(t)
     {var _jk_=0;
      function _jl_(param,p,l){return [0,pair_of_e_pair(p),l]}
      return caml_call3(M[14],_jl_,t,_jk_)}
    function add_list$0(t,l)
     {function _ji_(_jj_){return add_pair(t,_jj_)}
      return caml_call2(List[15],_ji_,l)}
    function add_seq$0(t,seq)
     {return caml_call1(seq,function(_jh_){return add_pair(t,_jh_)})}
    function of_list$4(l){var t=create$3(0,0);add_list$0(t,l);return t}
    function of_seq$3(seq){var t=create$3(0,0);add_seq$0(t,seq);return t}
    var
     compare$0=caml_int_compare,
     M$0=caml_call1(Map[1],[0,compare$0]),
     empty$4=M$0[1];
    function mem$0(k,t){return caml_call2(M$0[3],k[2],t)}
    function find_exn$0(K,t)
     {var match=caml_call2(M$0[27],K[2],t),e=match[2];
      if(e[1] === K[1]){var v=e[2];return v}
      throw [0,Assert_failure,_aA_]}
    function find$0(k,t)
     {try
       {var _jf_=[0,find_exn$0(k,t)];return _jf_}
      catch(_jg_)
       {_jg_ = caml_wrap_exception(_jg_);
        if(_jg_ === Not_found)return 0;
        throw _jg_}}
    function add_pair$0(p,t)
     {var k=p[1],v=p[2],p$0=[0,k,[0,k[1],v]];
      return caml_call3(M$0[4],k[2],p$0,t)}
    function add$1(k,v,t)
     {var p=[0,k,[0,k[1],v]],K=p[1];return caml_call3(M$0[4],K[2],p,t)}
    function cardinal$0(t){return caml_call1(M$0[18],t)}
    function iter$9(f,t)
     {function _je_(param,p){return caml_call1(f,pair_of_e_pair(p))}
      return caml_call2(M$0[12],_je_,t)}
    function to_seq$4(t,yield$0){return iter$9(yield$0,t)}
    function to_list$5(t)
     {var _jc_=0;
      function _jd_(param,p,l){return [0,pair_of_e_pair(p),l]}
      return caml_call3(M$0[13],_jd_,t,_jc_)}
    function add_list$1(t,l){return caml_call3(List[21],add_pair$0,l,t)}
    function add_seq$1(t,seq)
     {var t$0=[0,t];
      caml_call1
       (seq,function(pair){t$0[1] = add_pair$0(pair,t$0[1]);return 0});
      return t$0[1]}
    function of_list$5(l){return add_list$1(empty$4,l)}
    function of_seq$4(seq){return add_seq$1(empty$4,seq)}
    var
     CCHet=
      [0,
       [0,create$2,equal$2],
       [0,
        create$3,
        mem,
        add$0,
        length$2,
        find,
        find_exn,
        iter$8,
        to_seq$3,
        of_seq$3,
        add_seq$0,
        add_list$0,
        of_list$4,
        to_list$4],
       [0,
        empty$4,
        mem$0,
        add$1,
        cardinal$0,
        cardinal$0,
        find$0,
        find_exn$0,
        iter$9,
        to_seq$4,
        of_seq$4,
        add_seq$1,
        add_list$1,
        of_list$5,
        to_list$5]];
    caml_register_global(206,CCHet,"CCHet");
    var empty$5=[0];
    function length$3(_jb_){return _jb_.length - 1}
    function singleton$0(x){return [0,x]}
    function doubleton$0(x,y){return [0,x,y]}
    var make$0=caml_make_vect;
    function init$0(n,f){return caml_call2(Array[2],n,f)}
    function get$4(_ja_,_i$_){return caml_check_bound(_ja_,_i$_)[_i$_ + 1]}
    function set$2(a,n,x)
     {var a$0=caml_call1(Array[8],a);
      caml_check_bound(a$0,n)[n + 1] = x;
      return a$0}
    var sub=Array[7],map$3=Array[15],mapi=Array[16];
    function append$1(a,b)
     {var na=a.length - 1;
      function _i9_(i)
       {if(i < na)return caml_check_bound(a,i)[i + 1];
        var _i__=i - na | 0;
        return caml_check_bound(b,_i__)[_i__ + 1]}
      return caml_call2(Array[2],na + (b.length - 1) | 0,_i9_)}
    var iter$10=Array[13],iteri$1=Array[14],fold$4=Array[17];
    function foldi$0(f,acc,a)
     {var n=[0,0];
      function _i8_(acc,x)
       {var acc$0=caml_call3(f,acc,n[1],x);n[1]++;return acc$0}
      return caml_call3(Array[17],_i8_,acc,a)}
    var ExitNow=[248,cst_CCImmutArray_ExitNow,caml_fresh_oo_id(0)];
    function for_all(p,a)
     {try
       {var
         _i4_=
          function(x)
           {var _i7_=1 - caml_call1(p,x);if(_i7_)throw ExitNow;return _i7_};
        caml_call2(Array[13],_i4_,a);
        var _i5_=1;
        return _i5_}
      catch(_i6_)
       {_i6_ = caml_wrap_exception(_i6_);
        if(_i6_ === ExitNow)return 0;
        throw _i6_}}
    function exists$0(p,a)
     {try
       {var
         _i0_=
          function(x)
           {var _i3_=caml_call1(p,x);if(_i3_)throw ExitNow;return _i3_};
        caml_call2(Array[13],_i0_,a);
        var _i1_=0;
        return _i1_}
      catch(_i2_)
       {_i2_ = caml_wrap_exception(_i2_);
        if(_i2_ === ExitNow)return 1;
        throw _i2_}}
    var of_list$6=Array[12],to_list$6=Array[11];
    function of_array_unsafe(a){return a}
    function to_seq$5(a,k){return caml_call2(iter$10,k,a)}
    function of_seq$5(s)
     {var l=[0,0];
      caml_call1(s,function(x){l[1] = [0,x,l[1]];return 0});
      var _iZ_=caml_call1(List[9],l[1]);
      return caml_call1(Array[12],_iZ_)}
    function of_gen$1(g)
     {var acc=0;
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1],acc$0=[0,x,acc],acc=acc$0;continue}
        var l=caml_call1(List[9],acc);
        return caml_call1(Array[12],l)}}
    function to_gen$1(a)
     {var i=[0,0];
      return function(param)
       {if(i[1] < a.length - 1)
         {var _iY_=i[1],x=caml_check_bound(a,_iY_)[_iY_ + 1];
          i[1]++;
          return [0,x]}
        return 0}}
    function pp$4(opt,_iU_,_iT_,pp_item,out,a)
     {if(opt)var sth=opt[1],start=sth;else var start=cst$8;
      if(_iU_)var sth$0=_iU_[1],stop=sth$0;else var stop=cst$7;
      if(_iT_)var sth$1=_iT_[1],sep=sth$1;else var sep=cst$6;
      caml_call2(Format[13],out,start);
      var _iW_=a.length - 1 - 1 | 0,_iV_=0;
      if(! (_iW_ < 0))
       {var k=_iV_;
        for(;;)
         {if(0 < k)
           {caml_call2(Format[13],out,sep);caml_call2(Format[27],out,0)}
          caml_call2(pp_item,out,caml_check_bound(a,k)[k + 1]);
          var _iX_=k + 1 | 0;
          if(_iW_ !== k){var k=_iX_;continue}
          break}}
      caml_call2(Format[13],out,stop);
      return 0}
    var
     CCImmutArray=
      [0,
       empty$5,
       length$3,
       singleton$0,
       doubleton$0,
       make$0,
       init$0,
       get$4,
       set$2,
       sub,
       map$3,
       mapi,
       append$1,
       iter$10,
       iteri$1,
       foldi$0,
       fold$4,
       for_all,
       exists$0,
       of_list$6,
       to_list$6,
       of_array_unsafe,
       to_seq$5,
       of_seq$5,
       of_gen$1,
       to_gen$1,
       pp$4];
    caml_register_global(207,CCImmutArray,"CCImmutArray");
    var min_int=Pervasives[8];
    function highest_bit_naive(x,m)
     {var x$0=x,m$0=m;
      for(;;)
       {if(x$0 === m$0)return m$0;
        var
         m$1=2 * m$0 | 0,
         x$1=x$0 & caml_call1(Pervasives[9],m$0),
         x$0=x$1,
         m$0=m$1;
        continue}}
    var mask_20=1048576,mask_40=256;
    function highest(x)
     {if(0 <= x)
       {if(40 < Sys[10])
         if(256 < x)
          {var x$0=x & caml_call1(Pervasives[9],255);
           return highest_bit_naive(x$0,mask_40)}
        if(1048576 < x)
         {var x$1=x & caml_call1(Pervasives[9],1048575);
          return highest_bit_naive(x$1,mask_20)}
        return highest_bit_naive(x,1)}
      return min_int}
    function is_0(bit,x){return 0 === (x & bit)?1:0}
    function is_1(bit,x){return (x & bit) === bit?1:0}
    function mask(mask,x)
     {return (x | mask - 1 | 0) & caml_call1(Pervasives[9],mask)}
    function gt(a,b)
     {var _iQ_=b !== min_int?1:0;
      if(_iQ_)
       var _iR_=a === min_int?1:0,_iS_=_iR_ || (b < a?1:0);
      else
       var _iS_=_iQ_;
      return _iS_}
    function lt(a,b){return gt(b,a)}
    var equal_int=caml_equal,empty$6=0;
    function is_empty$3(param){return typeof param === "number"?1:0}
    function is_prefix(prefix,y,bit){return prefix === mask(bit,y)?1:0}
    function check_invariants(t)
     {function check_keys(path,t)
       {var path$0=path,t$0=t;
        for(;;)
         if(typeof t$0 === "number")
          return 1;
         else
          {if(0 === t$0[0])
            {var
              k=t$0[1],
              _iN_=
               function(param)
                {var
                  side=param[3],
                  switch$0=param[2],
                  prefix=param[1],
                  _iP_=is_prefix(prefix,k,switch$0);
                 return _iP_
                         ?847852583 <= side?is_0(switch$0,k):is_1(switch$0,k)
                         :_iP_};
             return caml_call2(List[27],_iN_,path$0)}
           var
            r=t$0[4],
            l=t$0[3],
            switch$0=t$0[2],
            prefix=t$0[1],
            _iO_=check_keys([0,[0,prefix,switch$0,847852583],path$0],l);
           if(_iO_)
            {var
              path$1=[0,[0,prefix,switch$0,-57574468],path$0],
              path$0=path$1,
              t$0=r;
             continue}
           return _iO_}}
      return check_keys(0,t)}
    function find_exn$1(k,t)
     {var t$0=t;
      for(;;)
       if(typeof t$0 === "number")
        throw Not_found;
       else
        {if(0 === t$0[0])
          {var v=t$0[2],k$0=t$0[1];if(k === k$0)return v;throw Not_found}
         var r=t$0[4],l=t$0[3],m=t$0[2],prefix=t$0[1];
         if(is_prefix(prefix,k,m))
          {if(is_0(m,k)){var t$0=l;continue}var t$0=r;continue}
         throw Not_found}}
    function find$1(k,t)
     {try
       {var _iL_=[0,find_exn$1(k,t)];return _iL_}
      catch(_iM_)
       {_iM_ = caml_wrap_exception(_iM_);
        if(_iM_ === Not_found)return 0;
        throw _iM_}}
    function mem$1(k,t)
     {try
       {find_exn$1(k,t);var _iJ_=1;return _iJ_}
      catch(_iK_)
       {_iK_ = caml_wrap_exception(_iK_);
        if(_iK_ === Not_found)return 0;
        throw _iK_}}
    function mk_node(prefix,switch$0,l,r)
     {if(typeof l === "number")
       var o=r;
      else
       {if(typeof r !== "number")return [1,prefix,switch$0,l,r];var o=l}
      return o}
    function join(t1,p1,t2,p2)
     {var switch$0=highest(p1 ^ p2),prefix=mask(switch$0,p1);
      if(is_0(switch$0,p1))
       {if(is_1(switch$0,p2))return mk_node(prefix,switch$0,t1,t2);
        throw [0,Assert_failure,_aB_]}
      if(is_0(switch$0,p2))return mk_node(prefix,switch$0,t2,t1);
      throw [0,Assert_failure,_aC_]}
    function singleton$1(k,v){return [0,k,v]}
    function insert(c,k,v,t)
     {if(typeof t === "number")
       return [0,k,v];
      else
       {if(0 === t[0])
         {var v$0=t[2],k$0=t[1];
          return k === k$0?[0,k,caml_call2(c,v$0,v)]:join(t,k$0,[0,k,v],k)}
        var r=t[4],l=t[3],switch$0=t[2],prefix=t[1];
        return is_prefix(prefix,k,switch$0)
                ?is_0(switch$0,k)
                  ?[1,prefix,switch$0,insert(c,k,v,l),r]
                  :[1,prefix,switch$0,l,insert(c,k,v,r)]
                :join([0,k,v],k,t,prefix)}}
    function add$2(k,v,t){return insert(function(param,v){return v},k,v,t)}
    function remove(k,t)
     {if(typeof t === "number")
       return 0;
      else
       {if(0 === t[0]){var k$0=t[1];return k === k$0?0:t}
        var r=t[4],l=t[3],switch$0=t[2],prefix=t[1];
        return is_prefix(prefix,k,switch$0)
                ?is_0(switch$0,k)
                  ?mk_node(prefix,switch$0,remove(k,l),r)
                  :mk_node(prefix,switch$0,l,remove(k,r))
                :t}}
    function update(k,f,t)
     {try
       {var v$0=find_exn$1(k,t),match$0=caml_call1(f,[0,v$0]);
        if(match$0)
         var v$1=match$0[1],_iH_=add$2(k,v$1,t);
        else
         var _iH_=remove(k,t);
        return _iH_}
      catch(_iI_)
       {_iI_ = caml_wrap_exception(_iI_);
        if(_iI_ === Not_found)
         {var match=caml_call1(f,0);
          if(match){var v=match[1];return add$2(k,v,t)}
          return t}
        throw _iI_}}
    function doubleton$1(k1,v1,k2,v2){return add$2(k1,v1,[0,k2,v2])}
    function equal$4(eq,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {var _iu_=a$0 === b$0?1:0;
        if(_iu_)
         var _iv_=_iu_;
        else
         {if(typeof a$0 === "number")
           {if(typeof b$0 === "number")return 1}
          else
           if(0 === a$0[0])
            {var _iw_=a$0[2],_ix_=a$0[1];
             if(typeof b$0 !== "number" && 1 !== b$0[0])
              {var vb=b$0[2],kb=b$0[1],_iy_=_ix_ === kb?1:0;
               return _iy_?caml_call2(eq,_iw_,vb):_iy_}}
           else
            {var _iz_=a$0[4],_iA_=a$0[3],_iB_=a$0[2],_iC_=a$0[1];
             if(typeof b$0 !== "number" && 0 !== b$0[0])
              {var
                rb=b$0[4],
                lb=b$0[3],
                sb=b$0[2],
                pb=b$0[1],
                _iD_=_iC_ === pb?1:0;
               if(_iD_)
                {var _iE_=_iB_ === sb?1:0;
                 if(_iE_)
                  {var _iF_=equal$4(eq,_iA_,lb);
                   if(_iF_){var a$0=_iz_,b$0=rb;continue}
                   var _iG_=_iF_}
                 else
                  var _iG_=_iE_}
               else
                var _iG_=_iD_;
               return _iG_}}
          var _iv_=0}
        return _iv_}}
    function iter$11(f,t)
     {var t$0=t;
      for(;;)
       if(typeof t$0 === "number")
        return 0;
       else
        {if(0 === t$0[0]){var v=t$0[2],k=t$0[1];return caml_call2(f,k,v)}
         var r=t$0[4],l=t$0[3];
         iter$11(f,l);
         var t$0=r;
         continue}}
    function fold$5(f,t,acc)
     {var t$0=t,acc$0=acc;
      for(;;)
       if(typeof t$0 === "number")
        return acc$0;
       else
        {if(0 === t$0[0])
          {var v=t$0[2],k=t$0[1];return caml_call3(f,k,v,acc$0)}
         var r=t$0[4],l=t$0[3],acc$1=fold$5(f,l,acc$0),t$0=r,acc$0=acc$1;
         continue}}
    function cardinal$1(t)
     {var _is_=0;
      return fold$5(function(param,_it_,n){return n + 1 | 0},t,_is_)}
    function mapi$0(f,t)
     {if(typeof t === "number")
       return 0;
      else
       {if(0 === t[0]){var v=t[2],k=t[1];return [0,k,caml_call2(f,k,v)]}
        var r=t[4],l=t[3],s=t[2],p=t[1],_ir_=mapi$0(f,r);
        return [1,p,s,mapi$0(f,l),_ir_]}}
    function map$4(f,t)
     {if(typeof t === "number")
       return 0;
      else
       {if(0 === t[0]){var v=t[2],k=t[1];return [0,k,caml_call1(f,v)]}
        var r=t[4],l=t[3],s=t[2],p=t[1],_iq_=map$4(f,r);
        return [1,p,s,map$4(f,l),_iq_]}}
    function choose_exn(param)
     {var param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        throw Not_found;
       else
        {if(0 === param$0[0]){var v=param$0[2],k=param$0[1];return [0,k,v]}
         var param$1=param$0[3],param$0=param$1;
         continue}}
    function choose$0(t)
     {try
       {var _io_=[0,choose_exn(t)];return _io_}
      catch(_ip_)
       {_ip_ = caml_wrap_exception(_ip_);
        if(_ip_ === Not_found)return 0;
        throw _ip_}}
    function union$1(f,t1,t2)
     {if(typeof t1 === "number")
       var o=t2,switch$0=1;
      else
       if(1 === t1[0])
        {var _ij_=t1[4],_ik_=t1[3],_il_=t1[2],_im_=t1[1];
         if(typeof t2 === "number")
          var switch$0=0;
         else
          {if(0 !== t2[0])
            {var r2=t2[4],l2=t2[3],m2=t2[2],p2=t2[1];
             if(_im_ === p2)
              if(_il_ === m2)
               {var _in_=union$1(f,_ij_,r2);
                return mk_node(_im_,_il_,union$1(f,_ik_,l2),_in_)}
             if(gt(_il_,m2))
              if(is_prefix(_im_,p2,_il_))
               return is_0(_il_,p2)
                       ?[1,_im_,_il_,union$1(f,_ik_,t2),_ij_]
                       :[1,_im_,_il_,_ik_,union$1(f,_ij_,t2)];
             if(lt(_il_,m2))
              if(is_prefix(p2,_im_,m2))
               return is_0(m2,_im_)
                       ?[1,p2,m2,union$1(f,t1,l2),r2]
                       :[1,p2,m2,l2,union$1(f,t1,r2)];
             return join(t1,_im_,t2,p2)}
           var o$0=t1,v=t2[2],k=t2[1],switch$0=2}}
       else
        var switch$0=0;
      switch(switch$0)
       {case 0:
         if(typeof t2 === "number")
          var o=t1,switch$1=0;
         else
          var o$0=t2,v=t1[2],k=t1[1],switch$1=1;
         break;
        case 1:var switch$1=0;break;
        default:var switch$1=1}
      return switch$1
              ?insert(function(old,v){return caml_call3(f,k,old,v)},k,v,o$0)
              :o}
    function inter$0(f,a,b)
     {var a$0=a,b$0=b;
      for(;;)
       {if(typeof a$0 === "number")
         var switch$0=1;
        else
         if(1 === a$0[0])
          {var _id_=a$0[4],_ie_=a$0[3],_if_=a$0[2],_ig_=a$0[1];
           if(typeof b$0 === "number")
            var switch$0=0;
           else
            {if(0 !== b$0[0])
              {var r2=b$0[4],l2=b$0[3],m2=b$0[2],p2=b$0[1];
               if(_ig_ === p2)
                if(_if_ === m2)
                 {var _ih_=inter$0(f,_id_,r2);
                  return mk_node(_ig_,_if_,inter$0(f,_ie_,l2),_ih_)}
               if(gt(_if_,m2))
                if(is_prefix(_ig_,p2,_if_))
                 {if(is_0(_if_,p2)){var a$0=_ie_;continue}
                  var a$0=_id_;
                  continue}
               if(lt(_if_,m2))
                if(is_prefix(p2,_ig_,m2))
                 {if(is_0(m2,_ig_)){var b$0=l2;continue}var b$0=r2;continue}
               return 0}
             var o=a$0,v=b$0[2],k=b$0[1],switch$0=2}}
         else
          var switch$0=0;
        switch(switch$0)
         {case 0:
           if(typeof b$0 === "number")
            var switch$1=0;
           else
            var o=b$0,v=a$0[2],k=a$0[1],switch$1=1;
           break;
          case 1:var switch$1=0;break;
          default:var switch$1=1}
        if(switch$1)
         try
          {var v$0=find_exn$1(k,o),_ic_=[0,k,caml_call3(f,k,v,v$0)];
           return _ic_}
         catch(_ii_)
          {_ii_ = caml_wrap_exception(_ii_);
           if(_ii_ === Not_found)return 0;
           throw _ii_}
        return 0}}
    function disjoint_union(t1,t2)
     {if(typeof t1 === "number")
       var o=t2,switch$0=1;
      else
       if(1 === t1[0])
        {var _h8_=t1[4],_h9_=t1[3],_h__=t1[2],_h$_=t1[1];
         if(typeof t2 === "number")
          var switch$0=0;
         else
          {if(0 !== t2[0])
            {var r2=t2[4],l2=t2[3],m2=t2[2],p2=t2[1];
             if(_h$_ === p2)
              if(_h__ === m2)
               {var _ia_=disjoint_union(_h8_,r2);
                return mk_node(_h$_,_h__,disjoint_union(_h9_,l2),_ia_)}
             if(gt(_h__,m2))
              if(is_prefix(_h$_,p2,_h__))
               return is_0(_h__,p2)
                       ?mk_node(_h$_,_h__,disjoint_union(_h9_,t2),_h8_)
                       :mk_node(_h$_,_h__,_h9_,disjoint_union(_h8_,t2));
             if(lt(_h__,m2))
              if(is_prefix(p2,_h$_,m2))
               return is_0(m2,_h$_)
                       ?mk_node(p2,m2,disjoint_union(t1,l2),r2)
                       :mk_node(p2,m2,l2,disjoint_union(t1,r2));
             return join(t1,_h$_,t2,p2)}
           var o$0=t1,v=t2[2],k=t2[1],switch$0=2}}
       else
        var switch$0=0;
      switch(switch$0)
       {case 0:
         if(typeof t2 === "number")
          var o=t1,switch$1=0;
         else
          var o$0=t2,v=t1[2],k=t1[1],switch$1=1;
         break;
        case 1:var switch$1=0;break;
        default:var switch$1=1}
      return switch$1
              ?insert
                (function(param,_ib_){throw [0,Assert_failure,_aD_]},k,v,o$0)
              :o}
    function filter$0(f,m)
     {if(typeof m === "number")
       return 0;
      else
       {if(0 === m[0]){var v=m[2],k=m[1];return caml_call2(f,k,v)?m:0}
        var r=m[4],l=m[3],_h7_=filter$0(f,r);
        return disjoint_union(filter$0(f,l),_h7_)}}
    function filter_map$0(f,m)
     {if(typeof m === "number")
       return 0;
      else
       {if(0 === m[0])
         {var v=m[2],k=m[1],match=caml_call2(f,k,v);
          if(match){var v$0=match[1];return [0,k,v$0]}
          return 0}
        var r=m[4],l=m[3],_h6_=filter_map$0(f,r);
        return disjoint_union(filter_map$0(f,l),_h6_)}}
    function merge(f,t1,t2)
     {function merge1(t)
       {return filter_map$0
                (function(k,v){return caml_call2(f,k,[0,847852583,v])},t)}
      function merge2(t)
       {return filter_map$0
                (function(k,v){return caml_call2(f,k,[0,-57574468,v])},t)}
      function add_some(k,opt,m)
       {if(opt)
         {var v=opt[1];
          return insert
                  (function(param,_h5_){throw [0,Assert_failure,_aE_]},k,v,m)}
        return m}
      if(typeof t1 === "number")
       return merge2(t2);
      else
       if(1 === t1[0])
        {var _hR_=t1[4],_hS_=t1[3],_hT_=t1[2],_hU_=t1[1];
         if(typeof t2 !== "number")
          {if(0 === t2[0])
            {var v$0=t2[2],k$0=t2[1],others$0=merge1(remove(k$0,t1));
             try
              {var
                _hW_=
                 caml_call2(f,k$0,[0,737457313,[0,find_exn$1(k$0,t1),v$0]]),
                _hV_=_hW_}
             catch(_h4_)
              {_h4_ = caml_wrap_exception(_h4_);
               if(_h4_ !== Not_found)throw _h4_;
               var _hV_=caml_call2(f,k$0,[0,-57574468,v$0])}
             return add_some(k$0,_hV_,others$0)}
           var r2=t2[4],l2=t2[3],m2=t2[2],p2=t2[1];
           if(_hU_ === p2)
            if(_hT_ === m2)
             {var _hX_=merge(f,_hR_,r2);
              return mk_node(_hU_,_hT_,merge(f,_hS_,l2),_hX_)}
           if(gt(_hT_,m2))
            if(is_prefix(_hU_,p2,_hT_))
             {if(is_0(_hT_,p2))
               {var _hY_=merge1(_hR_);
                return mk_node(_hU_,_hT_,merge(f,_hS_,t2),_hY_)}
              var _hZ_=merge(f,_hR_,t2);
              return mk_node(_hU_,_hT_,merge1(_hS_),_hZ_)}
           if(lt(_hT_,m2))
            if(is_prefix(p2,_hU_,m2))
             {if(is_0(m2,_hU_))
               {var _h0_=merge2(r2);return mk_node(p2,m2,merge(f,t1,l2),_h0_)}
              var _h1_=merge(f,t1,r2);
              return mk_node(p2,m2,merge2(l2),_h1_)}
           var _h2_=merge2(t2);
           return join(merge1(t1),_hU_,_h2_,p2)}}
      if(typeof t2 === "number")return merge1(t1);
      var v=t1[2],k=t1[1],others=merge2(remove(k,t2));
      try
       {var
         _hQ_=caml_call2(f,k,[0,737457313,[0,v,find_exn$1(k,t2)]]),
         _hP_=_hQ_}
      catch(_h3_)
       {_h3_ = caml_wrap_exception(_h3_);
        if(_h3_ !== Not_found)throw _h3_;
        var _hP_=caml_call2(f,k,[0,847852583,v])}
      return add_some(k,_hP_,others)}
    function add_list$2(t,l)
     {function _hO_(t,param){var v=param[2],k=param[1];return add$2(k,v,t)}
      return caml_call3(List[20],_hO_,t,l)}
    function of_list$7(l){return add_list$2(empty$6,l)}
    function to_list$7(t)
     {var _hN_=0;return fold$5(function(k,v,l){return [0,[0,k,v],l]},t,_hN_)}
    function add_seq$2(t,seq)
     {var t$0=[0,t];
      caml_call1
       (seq,
        function(param)
         {var v=param[2],k=param[1];t$0[1] = add$2(k,v,t$0[1]);return 0});
      return t$0[1]}
    function of_seq$6(seq){return add_seq$2(empty$6,seq)}
    function to_seq$6(t,yield$0)
     {return iter$11(function(k,v){return caml_call1(yield$0,[0,k,v])},t)}
    function keys(t,yield$0)
     {return iter$11(function(k,param){return caml_call1(yield$0,k)},t)}
    function values(t,yield$0)
     {return iter$11(function(param,v){return caml_call1(yield$0,v)},t)}
    function add_gen$0(m,g)
     {var m$0=m;
      for(;;)
       {var match=caml_call1(g,0);
        if(match)
         {var
           match$0=match[1],
           v=match$0[2],
           k=match$0[1],
           m$1=add$2(k,v,m$0),
           m$0=m$1;
          continue}
        return m$0}}
    function of_gen$2(g){return add_gen$0(empty$6,g)}
    function to_gen$2(m)
     {var st=caml_call1(Stack[2],0);
      caml_call2(Stack[3],m,st);
      function next$0(counter,param)
       {if(caml_call1(Stack[8],st))return 0;
        var n=caml_call1(Stack[4],st),n$0=n;
        for(;;)
         if(typeof n$0 === "number")
          {var _hM_=0;
           if(counter < 50)
            {var counter$0=counter + 1 | 0;return next$0(counter$0,_hM_)}
           return caml_trampoline_return(next$0,[0,_hM_])}
         else
          {if(0 === n$0[0]){var v=n$0[2],k=n$0[1];return [0,[0,k,v]]}
           var r=n$0[4],l=n$0[3];
           caml_call2(Stack[3],r,st);
           var n$0=l;
           continue}}
      function next(param){return caml_trampoline(next$0(0,param))}
      return next}
    function compare$1(cmp,a,b)
     {var b$0=to_gen$2(b),a$0=to_gen$2(a);
      for(;;)
       {var match=caml_call1(a$0,0),match$0=caml_call1(b$0,0);
        if(match)
         {var _hJ_=match[1],_hL_=_hJ_[1],_hK_=_hJ_[2];
          if(match$0)
           {var match$1=match$0[1],vb=match$1[2],kb=match$1[1];
            if(caml_equal(_hL_,kb))
             {var c=caml_call2(cmp,_hK_,vb);if(0 === c)continue;return c}
            return runtime.caml_compare(_hL_,kb)}
          return 1}
        return match$0?-1:0}}
    function add_klist(m,l)
     {var m$0=m,l$0=l;
      for(;;)
       {var match=caml_call1(l$0,0);
        if(typeof match === "number")return m$0;
        var
         _hI_=match[2],
         tl=_hI_[2],
         match$0=_hI_[1],
         v=match$0[2],
         k=match$0[1],
         m$1=add$2(k,v,m$0),
         m$0=m$1,
         l$0=tl;
        continue}}
    function of_klist$0(l){return add_klist(empty$6,l)}
    function to_klist$0(m)
     {function next$0(counter,st$1,param)
       {if(st$1)
         {var st$2=st$1[2],x=st$1[1],st=st$2,m=x;
          for(;;)
           if(typeof m === "number")
            {var _hG_=0;
             if(counter < 50)
              {var counter$0=counter + 1 | 0;return next$0(counter$0,st,_hG_)}
             return caml_trampoline_return(next$0,[0,st,_hG_])}
           else
            {if(0 === m[0])
              {var v=m[2],k=m[1];
               return [0,
                       748545553,
                       [0,[0,k,v],function(_hH_){return next(st,_hH_)}]]}
             var r=m[4],m$0=m[3],st$0=[0,r,st],st=st$0,m=m$0;
             continue}}
        return 3902385}
      function next(st,param){return caml_trampoline(next$0(0,st,param))}
      var _hE_=[0,m,0];
      return function(_hF_){return next(_hE_,_hF_)}}
    function as_tree(t,param)
     {if(typeof t === "number")
       return 3902385;
      else
       {if(0 === t[0])
         {var v=t[2],k=t[1];return [0,870528546,[0,[0,847851454,[0,k,v]],0]]}
        var
         r=t[4],
         l=t[3],
         switch$0=t[2],
         prefix=t[1],
         _hA_=0,
         _hB_=[0,function(_hD_){return as_tree(r,_hD_)},_hA_];
        return [0,
                870528546,
                [0,
                 [0,870528546,[0,prefix,switch$0]],
                 [0,function(_hC_){return as_tree(l,_hC_)},_hB_]]]}}
    function pp$5(pp_x,out,m)
     {caml_call2(Format[112],out,_aF_);
      var first=[0,1];
      iter$11
       (function(k,v)
         {if(first[1])first[1] = 0;else caml_call2(Format[13],out,cst$9);
          caml_call3(Format[112],out,_aG_,k);
          caml_call2(pp_x,out,v);
          return caml_call2(Format[27],out,0)},
        m);
      return caml_call2(Format[112],out,_aH_)}
    var
     CCIntMap=
      [0,
       empty$6,
       is_empty$3,
       singleton$1,
       doubleton$1,
       mem$1,
       find$1,
       find_exn$1,
       add$2,
       remove,
       equal$4,
       compare$1,
       update,
       filter$0,
       filter_map$0,
       cardinal$1,
       iter$11,
       fold$5,
       mapi$0,
       map$4,
       choose$0,
       choose_exn,
       union$1,
       inter$0,
       merge,
       add_list$2,
       of_list$7,
       to_list$7,
       add_seq$2,
       of_seq$6,
       to_seq$6,
       keys,
       values,
       add_gen$0,
       of_gen$2,
       to_gen$2,
       add_klist,
       of_klist$0,
       to_klist$0,
       as_tree,
       pp$5,
       [0,min_int,highest,equal_int],
       check_invariants];
    caml_register_global(208,CCIntMap,"CCIntMap");
    function create_inj(param)
     {var r=[0,0];
      function get(f){r[1] = 0;caml_call1(f,0);return r[1]}
      function set(v,param){r[1] = [0,v];return 0}
      return [0,get,set]}
    function Make$2(X)
     {var M=caml_call1(Map[1],X),empty=M[1];
      function find(inj,x,map)
       {var _hz_=caml_call2(M[27],x,map),match=caml_call1(inj[1],_hz_);
        if(match){var v=match[1];return v}
        throw Not_found}
      function get(inj,x,map)
       {try
         {var _hw_=caml_call2(M[27],x,map),_hx_=caml_call1(inj[1],_hw_);
          return _hx_}
        catch(_hy_)
         {_hy_ = caml_wrap_exception(_hy_);
          if(_hy_ === Not_found)return 0;
          throw _hy_}}
      function add(inj,x,y,map)
       {var _hv_=caml_call1(inj[2],y);return caml_call3(M[4],x,_hv_,map)}
      var cardinal=M[18],remove=M[7];
      function is_some(param){return param?1:0}
      function mem(inj,x,map)
       {try
         {var
           _hs_=caml_call2(M[27],x,map),
           _ht_=is_some(caml_call1(inj[1],_hs_));
          return _ht_}
        catch(_hu_)
         {_hu_ = caml_wrap_exception(_hu_);
          if(_hu_ === Not_found)return 0;
          throw _hu_}}
      function iter_keys(f,map)
       {function _hr_(x,param){return caml_call1(f,x)}
        return caml_call2(M[12],_hr_,map)}
      function fold_keys(f,x,map)
       {function _hq_(x,param,acc){return caml_call2(f,acc,x)}
        return caml_call3(M[13],_hq_,map,x)}
      function keys_seq(map,yield$0)
       {function _hp_(x,param){return caml_call1(yield$0,x)}
        return caml_call2(M[12],_hp_,map)}
      function bindings_of(inj,map,yield$0)
       {function _ho_(k,value)
         {var match=caml_call1(inj[1],value);
          if(match){var v=match[1];return caml_call1(yield$0,[0,k,v])}
          return 0}
        return caml_call2(M[12],_ho_,map)}
      function bindings(map,yield$0)
       {function _hn_(x,y)
         {return caml_call1
                  (yield$0,
                   [0,x,[0,function(inj){return caml_call1(inj[1],y)}]])}
        return caml_call2(M[12],_hn_,map)}
      return [0,
              empty,
              get,
              add,
              find,
              cardinal,
              remove,
              mem,
              iter_keys,
              fold_keys,
              keys_seq,
              bindings_of,
              bindings]}
    var CCMixmap=[0,create_inj,Make$2];
    caml_register_global(209,CCMixmap,"CCMixmap");
    var
     compare$2=caml_int_compare,
     IMap=caml_call1(Map[1],[0,compare$2]),
     newkey_n=[0,0];
    function newkey(param){var id=newkey_n[1];newkey_n[1]++;return [0,id,0]}
    var empty$7=IMap[1];
    function get$5(key,set)
     {key[2] = 0;
      try
       {caml_call1(caml_call2(IMap[27],key[1],set),0);
        var _hl_=key[2];
        return _hl_}
      catch(_hm_)
       {_hm_ = caml_wrap_exception(_hm_);
        if(_hm_ === Not_found)return 0;
        throw _hm_}}
    function get_exn$0(key,set)
     {var match=get$5(key,set);
      if(match){var v=match[1];return v}
      throw Not_found}
    function set$3(key,v,set)
     {function _hk_(param){key[2] = [0,v];return 0}
      return caml_call3(IMap[4],key[1],_hk_,set)}
    function cardinal$2(set){return caml_call1(IMap[18],set)}
    var CCMixset=[0,newkey,empty$7,set$3,get$5,get_exn$0,cardinal$2];
    caml_register_global(210,CCMixset,"CCMixset");
    function create$4(n){return caml_call2(Hashtbl[1],0,n)}
    function create_inj$0(param)
     {var r=[0,0];
      function get(f){r[1] = 0;caml_call1(f,0);return r[1]}
      function set(v,param){r[1] = [0,v];return 0}
      return [0,get,set]}
    function get$6(inj,tbl,x)
     {try
       {var _hh_=caml_call2(Hashtbl[6],tbl,x),_hi_=caml_call1(inj[1],_hh_);
        return _hi_}
      catch(_hj_)
       {_hj_ = caml_wrap_exception(_hj_);
        if(_hj_ === Not_found)return 0;
        throw _hj_}}
    function set$4(inj,tbl,x,y)
     {var _hg_=caml_call1(inj[2],y);return caml_call3(Hashtbl[11],tbl,x,_hg_)}
    function length$4(tbl){return caml_call1(Hashtbl[15],tbl)}
    function clear$2(tbl){return caml_call1(Hashtbl[2],tbl)}
    function remove$0(tbl,x){return caml_call2(Hashtbl[10],tbl,x)}
    function copy$1(tbl){return caml_call1(Hashtbl[4],tbl)}
    function is_some(param){return param?1:0}
    function mem$2(inj,tbl,x)
     {try
       {var
         _hd_=caml_call2(Hashtbl[6],tbl,x),
         _he_=is_some(caml_call1(inj[1],_hd_));
        return _he_}
      catch(_hf_)
       {_hf_ = caml_wrap_exception(_hf_);
        if(_hf_ === Not_found)return 0;
        throw _hf_}}
    function find$2(inj,tbl,x)
     {var _hc_=caml_call2(Hashtbl[6],tbl,x),match=caml_call1(inj[1],_hc_);
      if(match){var v=match[1];return v}
      throw Not_found}
    function iter_keys(tbl,f)
     {function _hb_(x,param){return caml_call1(f,x)}
      return caml_call2(Hashtbl[12],_hb_,tbl)}
    function fold_keys(tbl,acc,f)
     {function _ha_(x,param,acc){return caml_call2(f,acc,x)}
      return caml_call3(Hashtbl[14],_ha_,tbl,acc)}
    function keys_seq(tbl,yield$0)
     {function _g$_(x,param){return caml_call1(yield$0,x)}
      return caml_call2(Hashtbl[12],_g$_,tbl)}
    function bindings_of(inj,tbl,yield$0)
     {function _g__(k,value)
       {var match=caml_call1(inj[1],value);
        if(match){var v=match[1];return caml_call1(yield$0,[0,k,v])}
        return 0}
      return caml_call2(Hashtbl[12],_g__,tbl)}
    function bindings(tbl,yield$0)
     {function _g9_(x,y)
       {return caml_call1
                (yield$0,[0,x,[0,function(inj){return caml_call1(inj[1],y)}]])}
      return caml_call2(Hashtbl[12],_g9_,tbl)}
    var
     CCMixtbl=
      [0,
       create$4,
       create_inj$0,
       get$6,
       set$4,
       find$2,
       length$4,
       clear$2,
       remove$0,
       copy$1,
       mem$2,
       iter_keys,
       fold_keys,
       keys_seq,
       bindings_of,
       bindings];
    caml_register_global(211,CCMixtbl,"CCMixtbl");
    function Make$3(K,V)
     {var
       M=caml_call1(Map[1],K),
       S=caml_call1(Set[1],V),
       empty=M[1],
       is_empty=M[2];
      function add(m,k,v)
       {try
         {var _g7_=caml_call2(M[27],k,m),set=_g7_}
        catch(_g8_)
         {_g8_ = caml_wrap_exception(_g8_);
          if(_g8_ !== Not_found)throw _g8_;
          var set=S[1]}
        var _g6_=caml_call2(S[4],v,set);
        return caml_call3(M[4],k,_g6_,m)}
      function remove(m,k,v)
       {try
         {var
           set=caml_call2(M[27],k,m),
           set$0=caml_call2(S[6],v,set),
           _g4_=
            caml_call1(S[2],set$0)
             ?caml_call2(M[7],k,m)
             :caml_call3(M[4],k,set$0,m);
          return _g4_}
        catch(_g5_)
         {_g5_ = caml_wrap_exception(_g5_);
          if(_g5_ === Not_found)return m;
          throw _g5_}}
      function remove_all(m,k){return caml_call2(M[7],k,m)}
      function mem(m,k){return caml_call2(M[3],k,m)}
      function find(m,k)
       {try
         {var set=caml_call2(M[27],k,m),_g2_=caml_call1(S[21],set);
          return _g2_}
        catch(_g3_)
         {_g3_ = caml_wrap_exception(_g3_);
          if(_g3_ === Not_found)return 0;
          throw _g3_}}
      function find_iter(m,k,f)
       {try
         {var set=caml_call2(M[27],k,m),_g0_=caml_call2(S[13],f,set);
          return _g0_}
        catch(_g1_)
         {_g1_ = caml_wrap_exception(_g1_);
          if(_g1_ === Not_found)return 0;
          throw _g1_}}
      function count(m,k)
       {try
         {var set=caml_call2(M[27],k,m),_gY_=caml_call1(S[20],set);
          return _gY_}
        catch(_gZ_)
         {_gZ_ = caml_wrap_exception(_gZ_);
          if(_gZ_ === Not_found)return 0;
          throw _gZ_}}
      function iter(m,f)
       {function _gW_(k,set)
         {function _gX_(v){return caml_call2(f,k,v)}
          return caml_call2(S[13],_gX_,set)}
        return caml_call2(M[12],_gW_,m)}
      function fold(m,acc,f)
       {function _gU_(k,set,acc)
         {function _gV_(v,acc){return caml_call3(f,acc,k,v)}
          return caml_call3(S[15],_gV_,set,acc)}
        return caml_call3(M[13],_gU_,m,acc)}
      function size(m){return caml_call1(M[18],m)}
      function union(m1,m2)
       {function _gS_(k,v1,v2)
         {if(v1)
           {var _gT_=v1[1];
            if(v2){var set2=v2[1];return [0,caml_call2(S[7],_gT_,set2)]}
            var set=_gT_}
          else
           {if(! v2)return 0;var set=v2[1]}
          return [0,set]}
        return caml_call3(M[8],_gS_,m1,m2)}
      function inter(m1,m2)
       {function _gR_(k,v1,match)
         {if(v1)
           if(match)
            {var set2=match[1],set1=v1[1],set=caml_call2(S[8],set1,set2);
             return caml_call1(S[2],set)?0:[0,set]}
          return 0}
        return caml_call3(M[8],_gR_,m1,m2)}
      function diff(m1,m2)
       {function _gP_(k,v1,match)
         {if(v1)
           {var _gQ_=v1[1];
            if(match)
             {var set2=match[1],set=caml_call2(S[9],_gQ_,set2);
              return caml_call1(S[2],set)?0:[0,set]}
            return [0,_gQ_]}
          return 0}
        return caml_call3(M[8],_gP_,m1,m2)}
      function equal(m1,m2){return caml_call3(M[11],S[11],m1,m2)}
      function compare(m1,m2){return caml_call3(M[10],S[10],m1,m2)}
      function submap(m1,m2)
       {function _gM_(k,set1)
         {try
           {var set2=caml_call2(M[27],k,m2),_gN_=caml_call2(S[12],set1,set2);
            return _gN_}
          catch(_gO_)
           {_gO_ = caml_wrap_exception(_gO_);
            if(_gO_ === Not_found)return 0;
            throw _gO_}}
        return caml_call2(M[14],_gM_,m1)}
      function to_seq(m,k)
       {return iter(m,function(x,y){return caml_call1(k,[0,x,y])})}
      function of_seq(opt,seq)
       {if(opt)var sth=opt[1],init=sth;else var init=empty;
        var m=[0,init];
        caml_call1
         (seq,
          function(param)
           {var v=param[2],k=param[1];m[1] = add(m[1],k,v);return 0});
        return m[1]}
      function keys(m,k)
       {function _gL_(x,param){return caml_call1(k,x)}
        return caml_call2(M[12],_gL_,m)}
      function values(m,k)
       {return iter(m,function(param,v){return caml_call1(k,v)})}
      return [0,
              M,
              S,
              empty,
              is_empty,
              add,
              remove,
              remove_all,
              mem,
              find,
              find_iter,
              count,
              iter,
              fold,
              size,
              union,
              inter,
              diff,
              equal,
              compare,
              submap,
              to_seq,
              of_seq,
              keys,
              values]}
    function fold_seq(f,acc,seq)
     {var acc$0=[0,acc];
      caml_call1
       (seq,function(x){acc$0[1] = caml_call2(f,acc$0[1],x);return 0});
      return acc$0[1]}
    function head_seq(seq)
     {var r=[0,0];
      try
       {caml_call1(seq,function(x){r[1] = [0,x];throw Pervasives[3]})}
      catch(_gK_)
       {_gK_ = caml_wrap_exception(_gK_);if(_gK_ !== Pervasives[3])throw _gK_}
      return r[1]}
    function _aI_(L,R)
     {var MapL=Make$3(L,R),MapR=Make$3(R,L),empty=[0,MapL[3],MapR[3]];
      function is_empty(m){return caml_call1(MapL[4],m[1])}
      function add(m,a,b)
       {var _gJ_=caml_call3(MapR[5],m[2],b,a);
        return [0,caml_call3(MapL[5],m[1],a,b),_gJ_]}
      function remove(m,a,b)
       {var _gI_=caml_call3(MapR[6],m[2],b,a);
        return [0,caml_call3(MapL[6],m[1],a,b),_gI_]}
      function cardinal_left(m){return caml_call1(MapL[14],m[1])}
      function cardinal_right(m){return caml_call1(MapR[14],m[2])}
      function find_left(m,a){return caml_call2(MapL[10],m[1],a)}
      function find_right(m,b){return caml_call2(MapR[10],m[2],b)}
      function remove_left(m,a)
       {var _gH_=find_left(m,a);
        return fold_seq(function(m,b){return remove(m,a,b)},m,_gH_)}
      function remove_right(m,b)
       {var _gG_=find_right(m,b);
        return fold_seq(function(m,a){return remove(m,a,b)},m,_gG_)}
      function mem_left(m,a){return caml_call2(MapL[8],m[1],a)}
      function mem_right(m,b){return caml_call2(MapR[8],m[2],b)}
      function find1_left(m,a){return head_seq(find_left(m,a))}
      function find1_right(m,b){return head_seq(find_right(m,b))}
      function fold(f,acc,m){return caml_call3(MapL[13],m[1],acc,f)}
      function pairs(m){return caml_call1(MapL[21],m[1])}
      function add_pairs(m,seq)
       {return fold_seq
                (function(m,param)
                  {var b=param[2],a=param[1];return add(m,a,b)},
                 m,
                 seq)}
      function seq_left(m){return caml_call1(MapL[23],m[1])}
      function seq_right(m){return caml_call1(MapR[23],m[2])}
      return [0,
              empty,
              is_empty,
              add,
              remove,
              cardinal_left,
              cardinal_right,
              remove_left,
              remove_right,
              mem_left,
              mem_right,
              find_left,
              find_right,
              find1_left,
              find1_right,
              fold,
              pairs,
              add_pairs,
              seq_left,
              seq_right]}
    var
     CCMultiMap=
      [0,
       function(_gE_,_gD_)
        {var _gF_=Make$3(_gE_,_gD_);
         return [0,
                 _gF_[3],
                 _gF_[4],
                 _gF_[5],
                 _gF_[6],
                 _gF_[7],
                 _gF_[8],
                 _gF_[9],
                 _gF_[10],
                 _gF_[11],
                 _gF_[12],
                 _gF_[13],
                 _gF_[14],
                 _gF_[15],
                 _gF_[16],
                 _gF_[17],
                 _gF_[18],
                 _gF_[19],
                 _gF_[20],
                 _gF_[21],
                 _gF_[22],
                 _gF_[23],
                 _gF_[24]]},
       _aI_];
    caml_register_global(213,CCMultiMap,"CCMultiMap");
    var
     max_int=Pervasives[5],
     min_int$0=Pervasives[4],
     CCMultiSet=
      [0,
       function(O)
        {var M=caml_call1(Map[1],O),empty=M[1],is_empty=M[2];
         function mem(ms,x){return caml_call2(M[3],x,ms)}
         function count(ms,x)
          {try
            {var _gB_=caml_call2(M[27],x,ms);return _gB_}
           catch(_gC_)
            {_gC_ = caml_wrap_exception(_gC_);
             if(_gC_ === Not_found)return 0;
             throw _gC_}}
         function singleton(x){return caml_call2(M[6],x,1)}
         function add(ms,x)
          {var n=count(ms,x);return caml_call3(M[4],x,n + 1 | 0,ms)}
         function add_mult(ms,x,n)
          {if(n < 0)caml_call1(Pervasives[1],cst_CCMultiSet_add_mult);
           if(0 === n)return ms;
           var _gA_=count(ms,x) + n | 0;
           return caml_call3(M[4],x,_gA_,ms)}
         function remove_mult(ms,x,n)
          {if(n < 0)caml_call1(Pervasives[1],cst_CCMultiSet_remove_mult);
           var cur_n=count(ms,x),new_n=cur_n - n | 0;
           return 0 < new_n?caml_call3(M[4],x,new_n,ms):caml_call2(M[7],x,ms)}
         function remove(ms,x){return remove_mult(ms,x,1)}
         function remove_all(ms,x){return caml_call2(M[7],x,ms)}
         function update(ms,x,f)
          {var n=count(ms,x),n$0=caml_call1(f,n);
           return 0 === n$0
                   ?0 === n?ms:caml_call2(M[7],x,ms)
                   :0 <= n$0
                     ?caml_call3(M[4],x,n$0,ms)
                     :caml_call1(Pervasives[1],cst_CCMultiSet_update)}
         function min(ms){return caml_call1(M[20],ms)[1]}
         function max(ms){return caml_call1(M[22],ms)[1]}
         function union(m1,m2)
          {function _gy_(x,n1,n2)
            {if(n1)
              {var _gz_=n1[1];
               if(n2){var n2$0=n2[1];return [0,_gz_ + n2$0 | 0]}
               var n=_gz_}
             else
              {if(! n2)throw [0,Assert_failure,_aJ_];var n=n2[1]}
             return [0,n]}
           return caml_call3(M[8],_gy_,m1,m2)}
         function meet(m1,m2)
          {function _gw_(param,n1,n2)
            {if(n1)
              {var _gx_=n1[1];
               if(n2){var n2$0=n2[1];return [0,caml_call2(max_int,_gx_,n2$0)]}
               var n=_gx_}
             else
              {if(! n2)throw [0,Assert_failure,_aK_];var n=n2[1]}
             return [0,n]}
           return caml_call3(M[8],_gw_,m1,m2)}
         function intersection(m1,m2)
          {function _gv_(x,n1,n2)
            {if(n1)
              {if(n2)
                {var n2$0=n2[1],n1$0=n1[1];
                 return [0,caml_call2(min_int$0,n1$0,n2$0)]}}
             else
              if(! n2)throw [0,Assert_failure,_aL_];
             return 0}
           return caml_call3(M[8],_gv_,m1,m2)}
         function diff(m1,m2)
          {function _gt_(x,n1,n2)
            {if(n1)
              {var _gu_=n1[1];
               if(n2){var n2$0=n2[1];return n2$0 < _gu_?[0,_gu_ - n2$0 | 0]:0}
               return [0,_gu_]}
             if(n2)return 0;
             throw [0,Assert_failure,_aM_]}
           return caml_call3(M[8],_gt_,m1,m2)}
         function contains(m1,m2)
          {try
            {var
              _gq_=
               function(x,c)
                {return runtime.caml_greaterequal(caml_call2(M[27],x,m1),c)},
              _gr_=caml_call2(M[14],_gq_,m2);
             return _gr_}
           catch(_gs_)
            {_gs_ = caml_wrap_exception(_gs_);
             if(_gs_ === Not_found)return 0;
             throw _gs_}}
         function compare(m1,m2)
          {function _gp_(x,y){return x - y | 0}
           return caml_call3(M[10],_gp_,m1,m2)}
         function equal(m1,m2){return caml_call3(M[11],caml_equal,m1,m2)}
         function cardinal(m){return caml_call1(M[18],m)}
         function iter(m,f)
          {function _go_(x,n){return caml_call2(f,n,x)}
           return caml_call2(M[12],_go_,m)}
         function fold(m,acc,f)
          {function _gn_(x,n,acc){return caml_call3(f,acc,n,x)}
           return caml_call3(M[13],_gn_,m,acc)}
         function of_list(l)
          {var acc=empty,l$0=l;
           for(;;)
            {if(l$0)
              {var l$1=l$0[2],x=l$0[1],acc$0=add(acc,x),acc=acc$0,l$0=l$1;
               continue}
             return acc}}
         function to_list(m)
          {return fold
                   (m,
                    0,
                    function(acc,n$1,x)
                     {var n=n$1,l=acc;
                      for(;;)
                       {if(0 === n)return l;
                        if(1 === n)return [0,x,l];
                        var l$0=[0,x,l],n$0=n - 1 | 0,n=n$0,l=l$0;
                        continue}})}
         function to_seq(m,k)
          {function _gk_(x,n)
            {var _gl_=1;
             if(! (n < 1))
              {var i=_gl_;
               for(;;)
                {caml_call1(k,x);
                 var _gm_=i + 1 | 0;
                 if(n !== i){var i=_gm_;continue}
                 break}}
             return 0}
           return caml_call2(M[12],_gk_,m)}
         function of_seq(seq)
          {var m=[0,empty];
           caml_call1(seq,function(x){m[1] = add(m[1],x);return 0});
           return m[1]}
         function of_list_mult(l)
          {function _gj_(s,param)
            {var i=param[2],x=param[1];return add_mult(s,x,i)}
           return caml_call3(List[20],_gj_,empty,l)}
         function to_list_mult(m)
          {return fold(m,0,function(acc,n,x){return [0,[0,x,n],acc]})}
         function to_seq_mult(m,k)
          {function _gi_(x,n){return caml_call1(k,[0,x,n])}
           return caml_call2(M[12],_gi_,m)}
         function of_seq_mult(seq)
          {var m=[0,empty];
           caml_call1
            (seq,
             function(param)
              {var n=param[2],x=param[1];m[1] = add_mult(m[1],x,n);return 0});
           return m[1]}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 count,
                 singleton,
                 add,
                 remove,
                 add_mult,
                 remove_mult,
                 remove_all,
                 update,
                 min,
                 max,
                 union,
                 meet,
                 intersection,
                 diff,
                 contains,
                 compare,
                 equal,
                 cardinal,
                 iter,
                 fold,
                 of_list,
                 to_list,
                 to_seq,
                 of_seq,
                 of_list_mult,
                 to_list_mult,
                 to_seq_mult,
                 of_seq_mult]}];
    caml_register_global(214,CCMultiSet,"CCMultiSet");
    function make$1(n,a){return [0,[0,caml_make_vect(n,a)]]}
    function init$1(n,f){return [0,[0,caml_call2(Array[2],n,f)]]}
    function reroot(t$1)
     {var _gh_=t$1[1];
      if(0 === _gh_[0]){var a$0=_gh_[1];return a$0}
      function k$1(x){return x}
      var t=t$1,k=k$1;
      for(;;)
       {var _gg_=t[1];
        if(0 === _gg_[0]){var a=_gg_[1];return k(a)}
        var
         t$0=_gg_[3],
         v=_gg_[2],
         i=_gg_[1],
         k$2=
          function(k,t,t$0,v,i)
           {function k$0(a)
             {var v$0=caml_check_bound(a,i)[i + 1];
              caml_check_bound(a,i)[i + 1] = v;
              t[1] = [0,a];
              t$0[1] = [1,i,v$0,t];
              return k(a)}
            return k$0},
         k$0=k$2(k,t,t$0,v,i),
         t=t$0,
         k=k$0;
        continue}}
    function copy$2(t)
     {var _gf_=reroot(t);return [0,[0,caml_call1(Array[8],_gf_)]]}
    function get$7(t,i)
     {var _ge_=t[1];
      if(0 === _ge_[0]){var a=_ge_[1];return caml_check_bound(a,i)[i + 1]}
      return caml_check_bound(reroot(t),i)[i + 1]}
    function set$5(t,i,v)
     {var a=reroot(t),old=caml_check_bound(a,i)[i + 1];
      caml_check_bound(a,i)[i + 1] = v;
      var t$0=[0,[0,a]];
      t[1] = [1,i,old,t$0];
      return t$0}
    function length$5(t){return reroot(t).length - 1}
    function map$5(f,t)
     {var _gd_=reroot(t);return [0,[0,caml_call2(Array[15],f,_gd_)]]}
    function mapi$1(f,t)
     {var _gc_=reroot(t);return [0,[0,caml_call2(Array[16],f,_gc_)]]}
    function iter$12(f,t)
     {var _gb_=reroot(t);return caml_call2(Array[13],f,_gb_)}
    function iteri$2(f,t)
     {var _ga_=reroot(t);return caml_call2(Array[14],f,_ga_)}
    function fold_left(f,acc,t)
     {var _f$_=reroot(t);return caml_call3(Array[17],f,acc,_f$_)}
    function fold_right(f,t,acc)
     {var _f__=reroot(t);return caml_call3(Array[18],f,_f__,acc)}
    function append$2(a,b)
     {var n=length$5(a);
      function _f9_(i){return i < n?get$7(a,i):get$7(b,i - n | 0)}
      return init$1(n + length$5(b) | 0,_f9_)}
    function flatten(a)
     {var a$0=reroot(a),_f3_=0;
      function _f4_(acc,x){return acc + length$5(x) | 0}
      var n=caml_call3(Array[17],_f4_,_f3_,a$0),i=[0,0],j=[0,0];
      return init$1
              (n,
               function(param)
                {for(;;)
                  {var
                    _f5_=i[1],
                    _f6_=length$5(caml_check_bound(a$0,_f5_)[_f5_ + 1]);
                   if(j[1] === _f6_){i[1]++;j[1] = 0;continue}
                   var
                    _f8_=i[1],
                    _f7_=j[1],
                    x=get$7(caml_check_bound(a$0,_f8_)[_f8_ + 1],_f7_);
                   j[1]++;
                   return x}})}
    function flat_map(f,a){var a$0=map$5(f,a);return flatten(a$0)}
    function to_array(t){var _f2_=reroot(t);return caml_call1(Array[8],_f2_)}
    function of_array(a)
     {return init$1
              (a.length - 1,function(i){return caml_check_bound(a,i)[i + 1]})}
    function to_list$8(t)
     {var _f1_=reroot(t);return caml_call1(Array[11],_f1_)}
    function of_list$8(l){return [0,[0,caml_call1(Array[12],l)]]}
    function of_rev_list(l)
     {var a=caml_call1(Array[12],l),len=a.length - 1;
      if(0 !== len)
       {var _fU_=(len - 1 | 0) / 2 | 0,_fT_=0;
        if(! (_fU_ < 0))
         {var k=_fT_;
          for(;;)
           {var
             _fV_=k | 0,
             t=caml_check_bound(a,_fV_)[_fV_ + 1],
             _fW_=((len | 0) - 1 | 0) - k | 0,
             _fY_=k | 0,
             _fX_=caml_check_bound(a,_fW_)[_fW_ + 1];
            caml_check_bound(a,_fY_)[_fY_ + 1] = _fX_;
            var _fZ_=((len | 0) - 1 | 0) - k | 0;
            caml_check_bound(a,_fZ_)[_fZ_ + 1] = t;
            var _f0_=k + 1 | 0;
            if(_fU_ !== k){var k=_f0_;continue}
            break}}}
      return [0,[0,a]]}
    function to_seq$7(a,yield$0){return iter$12(yield$0,a)}
    function of_seq$7(seq)
     {var l=[0,0];
      caml_call1(seq,function(x){l[1] = [0,x,l[1]];return 0});
      return of_rev_list(l[1])}
    function of_gen$3(g)
     {var l=[0,0];
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1];l[1] = [0,x,l[1]];continue}
        return of_rev_list(l[1])}}
    function to_gen$3(a)
     {var i=[0,0],n=length$5(a);
      return function(param)
       {if(i[1] === n)return 0;var x=get$7(a,i[1]);i[1]++;return [0,x]}}
    function pp$6(pp_item,out,v)
     {caml_call2(Format[112],out,_aN_);
      iteri$2
       (function(i,x)
         {if(0 < i)caml_call2(Format[112],out,_aO_);
          return caml_call2(pp_item,out,x)},
        v);
      return caml_call2(Format[112],out,_aP_)}
    var
     CCPersistentArray=
      [0,
       make$1,
       init$1,
       get$7,
       set$5,
       length$5,
       copy$2,
       map$5,
       mapi$1,
       iter$12,
       iteri$2,
       fold_left,
       fold_right,
       append$2,
       flatten,
       flat_map,
       to_array,
       of_array,
       to_list$8,
       of_list$8,
       of_rev_list,
       to_seq$7,
       of_seq$7,
       of_gen$3,
       to_gen$3,
       pp$6];
    caml_register_global(215,CCPersistentArray,"CCPersistentArray");
    function Make$4(H)
     {function create(i)
       {var n=16;
        for(;;)
         {if(i <= n)return [0,[0,caml_make_vect(n,0)],0];
          var n$0=2 * n | 0,n=n$0;
          continue}}
      function empty(param){return create(16)}
      function reroot(t$1)
       {var _fS_=t$1[1];
        if(0 === _fS_[0]){var a$0=_fS_[1];return a$0}
        function k$1(x){return x}
        var t=t$1,k=k$1;
        for(;;)
         {var _fR_=t[1];
          if(0 === _fR_[0]){var a=_fR_[1];return k(a)}
          var
           t$0=_fR_[3],
           v=_fR_[2],
           i=_fR_[1],
           k$2=
            function(k,t,t$0,v,i)
             {function k$0(a)
               {var v$0=caml_check_bound(a,i)[i + 1];
                caml_check_bound(a,i)[i + 1] = v;
                t[1] = [0,a];
                t$0[1] = [1,i,v$0,t];
                return k(a)}
              return k$0},
           k$0=k$2(k,t,t$0,v,i),
           t=t$0,
           k=k$0;
          continue}}
      function is_empty(t){return 0 === t[2]?1:0}
      function length(t){return t[2]}
      function find_idx(a,h){return h & (a.length - 1 - 1 | 0)}
      function find(t,k$0)
       {var
         a=reroot(t),
         _fQ_=find_idx(a,caml_call1(H[2],k$0)),
         match=caml_check_bound(a,_fQ_)[_fQ_ + 1];
        if(match)
         {var l1=match[3],v1=match[2],k1=match[1];
          if(caml_call2(H[1],k$0,k1))return v1;
          if(l1)
           {var l2=l1[3],v2=l1[2],k2=l1[1];
            if(caml_call2(H[1],k$0,k2))return v2;
            if(l2)
             {var l3=l2[3],v3=l2[2],k3=l2[1];
              if(caml_call2(H[1],k$0,k3))return v3;
              if(l3)
               {var l4=l3[3],v4=l3[2],k4=l3[1];
                if(caml_call2(H[1],k$0,k4))return v4;
                var l=l4;
                for(;;)
                 {if(l)
                   {var l$0=l[3],v=l[2],k=l[1];
                    if(caml_call2(H[1],k$0,k))return v;
                    var l=l$0;
                    continue}
                  throw Not_found}}
              throw Not_found}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function get_exn(k,t){return find(t,k)}
      function get(k,t)
       {try
         {var _fO_=[0,find(t,k)];return _fO_}
        catch(_fP_)
         {_fP_ = caml_wrap_exception(_fP_);
          if(_fP_ === Not_found)return 0;
          throw _fP_}}
      function mem(t,k)
       {try
         {find(t,k);var _fM_=1;return _fM_}
        catch(_fN_)
         {_fN_ = caml_wrap_exception(_fN_);
          if(_fN_ === Not_found)return 0;
          throw _fN_}}
      function buck_rev_iter(f,l)
       {if(l)
         {var l$0=l[3],v=l[2],k=l[1];
          buck_rev_iter(f,l$0);
          return caml_call2(f,k,v)}
        return 0}
      function resize(k,v,h,a,new_size)
       {if(a.length - 1 < new_size)
         {var
           a$0=caml_make_vect(new_size,0),
           _fI_=
            function(k,v)
             {var i=find_idx(a$0,caml_call1(H[2],k));
              return a$0[i + 1] = [0,k,v,caml_check_bound(a$0,i)[i + 1]]},
           _fJ_=function(_fL_){return buck_rev_iter(_fI_,_fL_)};
          caml_call2(Array[13],_fJ_,a);
          var i=find_idx(a$0,h),_fK_=[0,k,v,caml_check_bound(a$0,i)[i + 1]];
          caml_check_bound(a$0,i)[i + 1] = _fK_;
          return a$0}
        throw [0,Assert_failure,_aQ_]}
      function replace_rec(k,v,l)
       {if(l)
         {var l$0=l[3],v$0=l[2],k$0=l[1];
          if(caml_call2(H[1],k,k$0))return [0,[0,k,v,l$0],0];
          var match=replace_rec(k,v,l$0),is_new=match[2],l$1=match[1];
          return [0,[0,k$0,v$0,l$1],is_new]}
        return [0,[0,k,v,0],1]}
      function replace(t,k,v)
       {var
         a=reroot(t),
         h=caml_call1(H[2],k),
         i=find_idx(a,h),
         l=caml_check_bound(a,i)[i + 1];
        if(l)
         {var match=replace_rec(k,v,l),is_new=match[2],l$0=match[1];
          if(is_new)
           if(a.length - 1 << 1 < t[2])
            {var
              new_size=
               caml_call2(Pervasives[4],2 * (a.length - 1) | 0,Sys[14]),
              a$0=resize(k,v,h,a,new_size);
             return [0,[0,a$0],t[2] + 1 | 0]}
          caml_check_bound(a,i)[i + 1] = l$0;
          var _fH_=is_new?t[2] + 1 | 0:t[2],t$0=[0,[0,a],_fH_];
          t[1] = [1,i,l,t$0];
          return t$0}
        if(a.length - 1 << 1 < t[2])
         {var
           new_size$0=caml_call2(Pervasives[4],2 * (a.length - 1) | 0,Sys[14]),
           a$1=resize(k,v,h,a,new_size$0);
          return [0,[0,a$1],t[2] + 1 | 0]}
        caml_check_bound(a,i)[i + 1] = [0,k,v,0];
        var t$1=[0,[0,a],t[2] + 1 | 0];
        t[1] = [1,i,0,t$1];
        return t$1}
      function add(t,k,v)
       {var a=reroot(t),h=caml_call1(H[2],k),i=find_idx(a,h);
        if(a.length - 1 << 1 < t[2])
         {var
           new_size=caml_call2(Pervasives[4],2 * (a.length - 1) | 0,Sys[14]),
           a$0=resize(k,v,h,a,new_size);
          return [0,[0,a$0],t[2] + 1 | 0]}
        var old=caml_check_bound(a,i)[i + 1];
        caml_check_bound(a,i)[i + 1] = [0,k,v,old];
        var t$0=[0,[0,a],t[2] + 1 | 0];
        t[1] = [1,i,old,t$0];
        return t$0}
      function remove_rec(k,l)
       {if(l)
         {var l$0=l[3],v=l[2],k$0=l[1];
          if(caml_call2(H[1],k,k$0))return [0,l$0];
          var match=remove_rec(k,l$0);
          if(match){var l$1=match[1];return [0,[0,k$0,v,l$1]]}
          return 0}
        return 0}
      function remove(t,k)
       {var
         a=reroot(t),
         i=find_idx(a,caml_call1(H[2],k)),
         l=caml_check_bound(a,i)[i + 1];
        if(l)
         {var match=remove_rec(k,l);
          if(match)
           {var l$0=match[1];
            caml_check_bound(a,i)[i + 1] = l$0;
            var t$0=[0,[0,a],t[2] - 1 | 0];
            t[1] = [1,i,l,t$0];
            return t$0}
          return t}
        return t}
      function update(t,k,f)
       {var v=get(k,t),match=caml_call1(f,v);
        if(v){if(! match)return remove(t,k)}else if(! match)return t;
        var v$0=match[1];
        return replace(t,k,v$0)}
      function copy(t)
       {var _fG_=reroot(t),a=caml_call1(Array[8],_fG_);return [0,[0,a],t[2]]}
      function iter(t,f)
       {var a=reroot(t);
        function _fF_(l$1)
         {var l=l$1;
          for(;;)
           {if(l)
             {var l$0=l[3],v=l[2],k=l[1];caml_call2(f,k,v);var l=l$0;continue}
            return 0}}
        return caml_call2(Array[13],_fF_,a)}
      function buck_fold(f,acc,l)
       {var acc$0=acc,l$0=l;
        for(;;)
         {if(l$0)
           {var
             l$1=l$0[3],
             v=l$0[2],
             k=l$0[1],
             acc$1=caml_call3(f,acc$0,k,v),
             acc$0=acc$1,
             l$0=l$1;
            continue}
          return acc$0}}
      function fold(f,acc,t)
       {var a=reroot(t);
        function _fC_(_fD_,_fE_){return buck_fold(f,_fD_,_fE_)}
        return caml_call3(Array[17],_fC_,acc,a)}
      function map(f,t)
       {function buck_map(f,l)
         {if(l)
           {var l$0=l[3],v=l[2],k=l[1],v$0=caml_call2(f,k,v);
            return [0,k,v$0,buck_map(f,l$0)]}
          return 0}
        var a=reroot(t);
        function _fA_(_fB_){return buck_map(f,_fB_)}
        var a$0=caml_call2(Array[15],_fA_,a);
        return [0,[0,a$0],t[2]]}
      function buck_filter(f,l)
       {if(l)
         {var l$0=l[3],v=l[2],k=l[1],l$1=buck_filter(f,l$0);
          return caml_call2(f,k,v)?[0,k,v,l$1]:l$1}
        return 0}
      function buck_length(b)
       {var _fy_=0;
        return buck_fold(function(n,param,_fz_){return n + 1 | 0},_fy_,b)}
      function filter(p,t)
       {var a=reroot(t),length=[0,0];
        function _fw_(b)
         {var b$0=buck_filter(p,b),_fx_=buck_length(b$0);
          length[1] = length[1] + _fx_ | 0;
          return b$0}
        var a$0=caml_call2(Array[15],_fw_,a);
        return [0,[0,a$0],length[1]]}
      function buck_filter_map(f,l)
       {if(l)
         {var
           l$0=l[3],
           v=l[2],
           k=l[1],
           l$1=buck_filter_map(f,l$0),
           match=caml_call2(f,k,v);
          if(match){var v$0=match[1];return [0,k,v$0,l$1]}
          return l$1}
        return 0}
      function filter_map(f,t)
       {var a=reroot(t),length=[0,0];
        function _fu_(b)
         {var b$0=buck_filter_map(f,b),_fv_=buck_length(b$0);
          length[1] = length[1] + _fv_ | 0;
          return b$0}
        var a$0=caml_call2(Array[15],_fu_,a);
        return [0,[0,a$0],length[1]]}
      var
       ExitPTbl=
        [248,cst_CCPersistentHashtbl_Make_H_ExitPTbl,caml_fresh_oo_id(0)];
      function for_all(p,t)
       {try
         {iter
           (t,
            function(k,v)
             {var _ft_=1 - caml_call2(p,k,v);
              if(_ft_)throw ExitPTbl;
              return _ft_});
          var _fr_=1;
          return _fr_}
        catch(_fs_)
         {_fs_ = caml_wrap_exception(_fs_);
          if(_fs_ === ExitPTbl)return 0;
          throw _fs_}}
      function exists(p,t)
       {try
         {iter
           (t,
            function(k,v)
             {var _fq_=caml_call2(p,k,v);if(_fq_)throw ExitPTbl;return _fq_});
          var _fo_=0;
          return _fo_}
        catch(_fp_)
         {_fp_ = caml_wrap_exception(_fp_);
          if(_fp_ === ExitPTbl)return 1;
          throw _fp_}}
      function merge(f,t1,t2)
       {var
         tbl=create(caml_call2(Pervasives[5],t1[2],t2[2])),
         tbl$0=
          fold
           (function(tbl,k,v1)
             {try
               {var _fm_=[0,737457313,[0,v1,find(t2,k)]],comb=_fm_}
              catch(_fn_)
               {_fn_ = caml_wrap_exception(_fn_);
                if(_fn_ !== Not_found)throw _fn_;
                var comb=[0,847852583,v1]}
              var match=caml_call2(f,k,comb);
              if(match){var v=match[1];return replace(tbl,k,v)}
              return tbl},
            tbl,
            t1);
        return fold
                (function(tbl,k,v2)
                  {if(mem(t1,k))return tbl;
                   var match=caml_call2(f,k,[0,-57574468,v2]);
                   if(match){var v=match[1];return replace(tbl,k,v)}
                   return tbl},
                 tbl$0,
                 t2)}
      function add_seq(init,seq)
       {var tbl=[0,init];
        caml_call1
         (seq,
          function(param)
           {var v=param[2],k=param[1];tbl[1] = replace(tbl[1],k,v);return 0});
        return tbl[1]}
      function of_seq(seq){return add_seq(empty(0),seq)}
      function add_list(init,l)
       {return add_seq(init,function(k){return caml_call2(List[15],k,l)})}
      function of_list(l){return add_list(empty(0),l)}
      function to_list(t)
       {var _fl_=0;
        return fold(function(acc,k,v){return [0,[0,k,v],acc]},_fl_,t)}
      function to_seq(t,k)
       {return iter(t,function(x,y){return caml_call1(k,[0,x,y])})}
      function equal(eq,t1,t2)
       {var _fk_=t1[2] === t2[2]?1:0;
        return _fk_
                ?for_all
                  (function(k,v)
                    {var match=get(k,t2);
                     if(match){var v$0=match[1];return caml_call2(eq,v,v$0)}
                     return 0},
                   t1)
                :_fk_}
      function pp(opt,_fj_,pp_k,pp_v,fmt,t)
       {if(opt)var sth=opt[1],sep=sth;else var sep=cst$11;
        if(_fj_)var sth$0=_fj_[1],arrow=sth$0;else var arrow=cst$10;
        var first=[0,1];
        iter
         (t,
          function(k,v)
           {if(first[1])
             first[1] = 0;
            else
             {caml_call2(Format[13],fmt,sep);caml_call2(Format[27],fmt,0)}
            return caml_call7(Format[112],fmt,_aR_,pp_k,k,arrow,pp_v,v)});
        return 0}
      function stats(t)
       {var a=reroot(t),_ff_=0;
        function _fg_(n,b)
         {var _fi_=buck_length(b);return caml_call2(Pervasives[5],n,_fi_)}
        var
         max_bucket_length=caml_call3(Array[17],_fg_,_ff_,a),
         bucket_histogram=caml_make_vect(max_bucket_length + 1 | 0,0);
        function _fh_(b)
         {var l=buck_length(b);
          return bucket_histogram[l + 1]
                 =
                 caml_check_bound(bucket_histogram,l)[l + 1]
                 +
                 1
                 |
                 0}
        caml_call2(Array[13],_fh_,a);
        return [0,t[2],a.length - 1,max_bucket_length,bucket_histogram]}
      return [0,
              empty,
              create,
              is_empty,
              find,
              get_exn,
              get,
              mem,
              length,
              add,
              replace,
              update,
              remove,
              copy,
              merge,
              iter,
              fold,
              map,
              filter,
              filter_map,
              for_all,
              exists,
              of_seq,
              of_list,
              add_seq,
              add_list,
              to_seq,
              to_list,
              equal,
              pp,
              stats]}
    var CCPersistentHashtbl=[0,Make$4];
    caml_register_global(216,CCPersistentHashtbl,"CCPersistentHashtbl");
    var acc=0;
    function return$2(x){return [0,1,[0,x],0]}
    function is_empty$4(param){return param?0:1}
    function get_exn$1(l,i)
     {var l$0=l,i$0=i;
      for(;;)
       {if(l$0)
         {var l$1=l$0[3],t=l$0[2],size=l$0[1];
          if(i$0 < size)
           {var size$0=size,t$0=t,i$2=i$0;
            for(;;)
             {if(0 === t$0[0])
               {var _fb_=t$0[1];
                return 0 === i$2?_fb_:caml_call1(Pervasives[1],cst_RAL_get$0)}
              var _fc_=t$0[3],_fd_=t$0[2],_fe_=t$0[1];
              if(0 === i$2)return _fe_;
              var size$1=size$0 / 2 | 0;
              if(i$2 <= size$1)
               {var i$3=i$2 - 1 | 0,size$0=size$1,t$0=_fd_,i$2=i$3;continue}
              var
               i$4=(i$2 - 1 | 0) - size$1 | 0,
               size$0=size$1,
               t$0=_fc_,
               i$2=i$4;
              continue}}
          var i$1=i$0 - size | 0,l$0=l$1,i$0=i$1;
          continue}
        return caml_call1(Pervasives[1],cst_RAL_get)}}
    function get$8(l,i)
     {try
       {var _e$_=[0,get_exn$1(l,i)];return _e$_}
      catch(_fa_)
       {_fa_ = caml_wrap_exception(_fa_);
        if(_fa_[1] === Invalid_argument)return 0;
        throw _fa_}}
    function set$6(l,i,v)
     {if(l)
       {var l$0=l[3],t=l[2],size=l[1];
        return i < size
                ?[0,size,tree_update(size,t,i,v),l$0]
                :[0,size,t,set$6(l$0,i - size | 0,v)]}
      return caml_call1(Pervasives[1],cst_RAL_set)}
    function tree_update(size,t,i,v)
     {if(0 === t[0])
       return 0 === i?[0,v]:caml_call1(Pervasives[1],cst_RAL_set$0);
      var _e8_=t[3],_e9_=t[2],_e__=t[1];
      if(0 === i)return [1,v,_e9_,_e8_];
      var size$0=size / 2 | 0;
      return i <= size$0
              ?[1,_e__,tree_update(size$0,_e9_,i - 1 | 0,v),_e8_]
              :[1,
                _e__,
                _e9_,
                tree_update(size$0,_e8_,(i - 1 | 0) - size$0 | 0,v)]}
    function cons$0(x,l)
     {if(l)
       {var _e7_=l[3];
        if(_e7_)
         {var l$0=_e7_[3],t2=_e7_[2],size2=_e7_[1],t1=l[2],size1=l[1];
          if(size1 === size2)
           return [0,(1 + size1 | 0) + size2 | 0,[1,x,t1,t2],l$0]}}
      return [0,1,[0,x],l]}
    function cons$1(l,x){return cons$0(x,l)}
    function hd(l)
     {if(l)
       {var _e6_=l[2];
        if(0 === _e6_[0]){var x=_e6_[1];return x}
        var x$0=_e6_[1];
        return x$0}
      return caml_call1(Pervasives[1],cst_RAL_hd)}
    function tl(l)
     {if(l)
       {var _e4_=l[2],_e5_=l[1];
        if(0 === _e4_[0]){var l$0=l[3];return l$0}
        var l$1=l[3],t2=_e4_[3],t1=_e4_[2],size=_e5_ / 2 | 0;
        return [0,size,t1,[0,size,t2,l$1]]}
      return caml_call1(Pervasives[1],cst_RAL_tl)}
    function front(l)
     {if(l)
       {var _e2_=l[2],_e3_=l[1];
        if(0 === _e2_[0]){var tl=l[3],x=_e2_[1];return [0,[0,x,tl]]}
        var l$0=l[3],t2=_e2_[3],t1=_e2_[2],x$0=_e2_[1],size=_e3_ / 2 | 0;
        return [0,[0,x$0,[0,size,t1,[0,size,t2,l$0]]]]}
      return 0}
    function front_exn(l)
     {if(l)
       {var _e0_=l[2],_e1_=l[1];
        if(0 === _e0_[0]){var tl=l[3],x=_e0_[1];return [0,x,tl]}
        var l$0=l[3],t2=_e0_[3],t1=_e0_[2],x$0=_e0_[1],size=_e1_ / 2 | 0;
        return [0,x$0,[0,size,t1,[0,size,t2,l$0]]]}
      return caml_call1(Pervasives[1],cst_RAL_front_exn)}
    function remove$1(l$1,i$1)
     {var prefix=0,l=l$1,i=i$1;
      for(;;)
       {var match=front_exn(l),l$0=match[2],x=match[1];
        if(0 === i)
         {var _eZ_=function(l,x){return cons$0(x,l)};
          return caml_call3(List[20],_eZ_,l,prefix)}
        var i$0=i - 1 | 0,prefix$0=[0,x,prefix],prefix=prefix$0,l=l$0,i=i$0;
        continue}}
    function map_tree(f,t)
     {if(0 === t[0]){var x=t[1];return [0,caml_call1(f,x)]}
      var r=t[3],l=t[2],x$0=t[1],_eX_=map_tree(f,r),_eY_=map_tree(f,l);
      return [1,caml_call1(f,x$0),_eY_,_eX_]}
    function map$6(f,l)
     {if(l)
       {var tl=l[3],t=l[2],i=l[1],_eW_=map$6(f,tl);
        return [0,i,map_tree(f,t),_eW_]}
      return 0}
    function mapi$2(f,l)
     {function aux(f,i,l)
       {if(l)
         {var tl=l[3],t=l[2],size=l[1],_eV_=aux(f,i + size | 0,tl);
          return [0,size,aux_t(f,size,i,t),_eV_]}
        return 0}
      function aux_t(f,size,i,t)
       {if(0 === t[0]){var x=t[1];return [0,caml_call2(f,i,x)]}
        var
         r=t[3],
         l=t[2],
         x$0=t[1],
         x$1=caml_call2(f,i,x$0),
         l$0=aux_t(f,size / 2 | 0,i + 1 | 0,l);
        return [1,
                x$1,
                l$0,
                aux_t(f,size / 2 | 0,(i + 1 | 0) + (size / 2 | 0) | 0,r)]}
      return aux(f,0,l)}
    function length$6(l)
     {if(l){var l$0=l[3],size=l[1];return size + length$6(l$0) | 0}return 0}
    function iter$13(f,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _eU_=l$0[2];
          if(0 === _eU_[0])
           {var l$1=l$0[3],x=_eU_[1];caml_call1(f,x);var l$0=l$1;continue}
          var l$2=l$0[3];
          iter_tree(_eU_,f);
          var l$0=l$2;
          continue}
        return 0}}
    function iter_tree(t,f)
     {var t$0=t;
      for(;;)
       {if(0 === t$0[0]){var x=t$0[1];return caml_call1(f,x)}
        var t2=t$0[3],t1=t$0[2],x$0=t$0[1];
        caml_call1(f,x$0);
        iter_tree(t1,f);
        var t$0=t2;
        continue}}
    function iteri$3(f,l)
     {function aux_t(f,size,i,t)
       {var size$0=size,i$0=i,t$0=t;
        for(;;)
         {if(0 === t$0[0]){var x=t$0[1];return caml_call2(f,i$0,x)}
          var r=t$0[3],l=t$0[2],x$0=t$0[1];
          caml_call2(f,i$0,x$0);
          var size$1=size$0 / 2 | 0;
          aux_t(f,size$1,i$0 + 1 | 0,l);
          var i$1=(i$0 + 1 | 0) + size$1 | 0,size$0=size$1,i$0=i$1,t$0=r;
          continue}}
      var i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var l$1=l$0[3],t=l$0[2],size=l$0[1];
          aux_t(f,size,i,t);
          var i$0=i + size | 0,i=i$0,l$0=l$1;
          continue}
        return 0}}
    function fold$6(f,acc,l)
     {var acc$0=acc,l$0=l;
      for(;;)
       {if(l$0)
         {var _eT_=l$0[2];
          if(0 === _eT_[0])
           {var
             l$1=l$0[3],
             x=_eT_[1],
             acc$1=caml_call2(f,acc$0,x),
             acc$0=acc$1,
             l$0=l$1;
            continue}
          var l$2=l$0[3],acc$2=fold_tree(_eT_,acc$0,f),acc$0=acc$2,l$0=l$2;
          continue}
        return acc$0}}
    function fold_tree(t,acc,f)
     {var t$0=t,acc$0=acc;
      for(;;)
       {if(0 === t$0[0]){var x=t$0[1];return caml_call2(f,acc$0,x)}
        var
         t2=t$0[3],
         t1=t$0[2],
         x$0=t$0[1],
         acc$1=caml_call2(f,acc$0,x$0),
         acc$2=fold_tree(t1,acc$1,f),
         t$0=t2,
         acc$0=acc$2;
        continue}}
    function fold_tree_rev(t,acc,f)
     {if(0 === t[0]){var x=t[1];return caml_call2(f,acc,x)}
      var
       t2=t[3],
       t1=t[2],
       x$0=t[1],
       acc$0=fold_tree_rev(t2,acc,f),
       acc$1=fold_tree_rev(t1,acc$0,f);
      return caml_call2(f,acc$1,x$0)}
    function fold_rev(f,acc,l)
     {if(l)
       {var _eS_=l[2];
        if(0 === _eS_[0])
         {var l$0=l[3],x=_eS_[1];return caml_call2(f,fold_rev(f,acc,l$0),x)}
        var l$1=l[3],acc$0=fold_rev(f,acc,l$1);
        return fold_tree_rev(_eS_,acc$0,f)}
      return acc}
    function rev_map(f,l)
     {return fold$6(function(acc,x){return cons$0(caml_call1(f,x),acc)},acc,l)}
    function rev$0(l){return fold$6(cons$1,acc,l)}
    function append$3(l1,l2)
     {return fold_rev(function(l2,x){return cons$0(x,l2)},l2,l1)}
    function append_tree(t,l){return fold_tree_rev(t,l,cons$1)}
    function filter$1(f,l)
     {return fold_rev
              (function(acc,x){return caml_call1(f,x)?cons$0(x,acc):acc},
               acc,
               l)}
    function filter_map$1(f,l)
     {return fold_rev
              (function(acc,x)
                {var match=caml_call1(f,x);
                 if(match){var y=match[1];return cons$0(y,acc)}
                 return acc},
               acc,
               l)}
    function flat_map$0(f,l)
     {return fold_rev
              (function(acc,x){var l=caml_call1(f,x);return append$3(l,acc)},
               acc,
               l)}
    function flatten$0(l)
     {return fold_rev(function(acc,l){return append$3(l,acc)},acc,l)}
    function app(funs,l)
     {return fold_rev
              (function(acc,f)
                {return fold_rev
                         (function(acc,x){return cons$0(caml_call1(f,x),acc)},acc,l)},
               acc,
               funs)}
    function stack_to_list(param)
     {if(typeof param === "number")
       return 0;
      else
       {if(0 === param[0])
         {var st=param[2],l=param[1];return append$3(l,stack_to_list(st))}
        var st$0=param[2],t=param[1];
        return append_tree(t,stack_to_list(st$0))}}
    function take_tree(size,n,t)
     {if(0 === n)return 0;
      if(0 === t[0]){var x=t[1];return cons$0(x,0)}
      var r=t[3],l=t[2],x$0=t[1],size$0=size / 2 | 0;
      return size$0 <= (n - 1 | 0)
              ?cons$0
                (x$0,
                 append_tree(l,take_tree(size$0,(n - size$0 | 0) - 1 | 0,r)))
              :cons$0(x$0,take_tree(size$0,n - 1 | 0,l))}
    function take(n,l)
     {if(l)
       {var tl=l[3],t=l[2],size=l[1];
        return size <= n
                ?append_tree(t,take(n - size | 0,tl))
                :take_tree(size,n,t)}
      return 0}
    function take_while(f,l)
     {function aux(p,st)
       {var st$0=st;
        for(;;)
         if(typeof st$0 === "number")
          return 0;
         else
          {if(0 === st$0[0])
            {var _eQ_=st$0[1];
             if(_eQ_)
              {var
                st$1=st$0[2],
                tl=_eQ_[3],
                t=_eQ_[2],
                st$2=[1,t,[0,tl,st$1]],
                st$0=st$2;
               continue}
             var st$3=st$0[2],st$0=st$3;
             continue}
           var _eR_=st$0[1];
           if(0 === _eR_[0])
            {var st$4=st$0[2],x=_eR_[1];
             return caml_call1(p,x)?cons$0(x,aux(p,st$4)):0}
           var st$5=st$0[2],r=_eR_[3],l=_eR_[2],x$0=_eR_[1];
           return caml_call1(p,x$0)?cons$0(x$0,aux(p,[1,l,[1,r,st$5]])):0}}
      return aux(f,[0,l,0])}
    function drop(n$2,l)
     {var n$3=n$2,l$0=l;
      for(;;)
       {if(0 === n$3)return l$0;
        if(l$0)
         {var tl=l$0[3],t$0=l$0[2],size$1=l$0[1];
          if(size$1 <= n$3){var n$4=n$3 - size$1 | 0,n$3=n$4,l$0=tl;continue}
          var size=size$1,n=n$3,t=t$0,tail=tl;
          for(;;)
           {if(0 === n)return tail;
            if(0 === t[0])
             {if(1 === n)return tail;throw [0,Assert_failure,_aS_]}
            var right=t[3],left=t[2];
            if(1 === n)return append_tree(left,append_tree(right,tail));
            if(1 === (size % 2 | 0))
             {var size$0=size / 2 | 0,n$0=n - 1 | 0;
              if(n$0 === size$0)return append_tree(right,tail);
              if(n$0 < size$0)
               {var
                 tail$0=append_tree(right,tail),
                 size=size$0,
                 n=n$0,
                 t=left,
                 tail=tail$0;
                continue}
              var n$1=n$0 - size$0 | 0,size=size$0,n=n$1,t=right;
              continue}
            throw [0,Assert_failure,_aT_]}}
        return 0}}
    function drop_while(p,l)
     {var st$6=[0,l,0],st=st$6;
      for(;;)
       if(typeof st === "number")
        return 0;
       else
        {if(0 === st[0])
          {var _eO_=st[1];
           if(_eO_)
            {var
              st$0=st[2],
              tail=_eO_[3],
              t=_eO_[2],
              st$1=[1,t,[0,tail,st$0]],
              st=st$1;
             continue}
           var st$2=st[2],st=st$2;
           continue}
         var _eP_=st[1];
         if(0 === _eP_[0])
          {var st$3=st[2],x=_eP_[1];
           if(caml_call1(p,x)){var st=st$3;continue}
           return cons$0(x,stack_to_list(st$3))}
         var st$4=st[2],r=_eP_[3],l$0=_eP_[2],x$0=_eP_[1];
         if(caml_call1(p,x$0)){var st$5=[1,l$0,[1,r,st$4]],st=st$5;continue}
         return append_tree(_eP_,stack_to_list(st$4))}}
    function take_drop(n,l){var _eN_=drop(n,l);return [0,take(n,l),_eN_]}
    function equal$5(eq,l1,l2)
     {function aux_t(eq,t1,t2)
       {var t1$0=t1,t2$0=t2;
        for(;;)
         {if(0 === t1$0[0])
           {var _eG_=t1$0[1];
            if(0 === t2$0[0]){var y=t2$0[1];return caml_call2(eq,_eG_,y)}}
          else
           {var _eH_=t1$0[3],_eI_=t1$0[2],_eJ_=t1$0[1];
            if(0 !== t2$0[0])
             {var
               r2=t2$0[3],
               l2=t2$0[2],
               x2=t2$0[1],
               _eK_=caml_call2(eq,_eJ_,x2);
              if(_eK_)
               {var _eL_=aux_t(eq,_eI_,l2);
                if(_eL_){var t1$0=_eH_,t2$0=r2;continue}
                var _eM_=_eL_}
              else
               var _eM_=_eK_;
              return _eM_}}
          return 0}}
      var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[3],
             t2=l2$0[2],
             size2=l2$0[1],
             l1$1=l1$0[3],
             t1=l1$0[2],
             size1=l1$0[1],
             _eD_=size1 === size2?1:0;
            if(_eD_)
             {var _eE_=aux_t(eq,t1,t2);
              if(_eE_){var l1$0=l1$1,l2$0=l2$1;continue}
              var _eF_=_eE_}
            else
             var _eF_=_eD_;
            return _eF_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function make$2(n,x)
     {var n$0=n,acc$0=acc;
      for(;;)
       {if(0 < n$0)
         {var acc$1=cons$0(x,acc$0),n$1=n$0 - 1 | 0,n$0=n$1,acc$0=acc$1;
          continue}
        return acc$0}}
    function repeat(n,l)
     {var n$0=n,acc$0=acc;
      for(;;)
       {if(0 < n$0)
         {var acc$1=append$3(l,acc$0),n$1=n$0 - 1 | 0,n$0=n$1,acc$0=acc$1;
          continue}
        return acc$0}}
    function range(i,j)
     {var j$0=j,acc$0=acc;
      for(;;)
       {if(i === j$0)return cons$0(i,acc$0);
        if(i < j$0)
         {var acc$1=cons$0(j$0,acc$0),j$1=j$0 - 1 | 0,j$0=j$1,acc$0=acc$1;
          continue}
        var acc$2=cons$0(j$0,acc$0),j$2=j$0 + 1 | 0,j$0=j$2,acc$0=acc$2;
        continue}}
    function range_r_open(i,j)
     {return i === j?acc:i < j?range(i,j - 1 | 0):range(i,j + 1 | 0)}
    function add_list$3(l,l2)
     {var _eB_=caml_call1(List[9],l2);
      function _eC_(acc,x){return cons$0(x,acc)}
      return caml_call3(List[20],_eC_,l,_eB_)}
    function of_list$9(l){return add_list$3(acc,l)}
    function to_list$9(l)
     {var _eA_=0;return fold_rev(function(acc,x){return [0,x,acc]},_eA_,l)}
    function add_array(l,a){return caml_call3(Array[18],cons$0,a,l)}
    function of_array$0(a){return add_array(acc,a)}
    function to_array$0(l)
     {if(l)
       {var match=l[2],x=match[1],len=length$6(l),arr=caml_make_vect(len,x);
        iteri$3(function(i,x){return caml_check_bound(arr,i)[i + 1] = x},l);
        return arr}
      return [0]}
    function of_seq$8(s)
     {var l=[0,acc];
      caml_call1(s,function(x){l[1] = cons$0(x,l[1]);return 0});
      return rev$0(l[1])}
    function add_seq$3(l,s)
     {var l1=[0,acc];
      caml_call1(s,function(x){l1[1] = cons$0(x,l1[1]);return 0});
      var _ez_=l1[1];
      return fold$6(function(acc,x){return cons$0(x,acc)},l,_ez_)}
    function to_seq$8(l,yield$0){return iter$13(yield$0,l)}
    function add_gen$1(l,g)
     {var l1=[0,acc];
      for(;;)
       {var match=caml_call1(g,0);
        if(match){var x=match[1];l1[1] = cons$0(x,l1[1]);continue}
        var _ey_=l1[1];
        return fold$6(function(acc,x){return cons$0(x,acc)},l,_ey_)}}
    function of_gen$4(g){return add_gen$1(acc,g)}
    function to_gen$4(l)
     {var st=caml_call1(Stack[2],0),l$0=[0,l];
      function next(param)
       {for(;;)
         {if(caml_call1(Stack[8],st))
           {var _ex_=l$0[1];
            if(_ex_)
             {var tl=_ex_[3],t=_ex_[2];
              l$0[1] = tl;
              caml_call2(Stack[3],t,st);
              continue}
            return 0}
          var match=caml_call1(Stack[4],st);
          if(0 === match[0]){var x=match[1];return [0,x]}
          var r=match[3],l=match[2],x$0=match[1];
          caml_call2(Stack[3],r,st);
          caml_call2(Stack[3],l,st);
          return [0,x$0]}}
      return next}
    function of_list_map(f,l)
     {if(l)
       {var l$0=l[2],x=l[1],y=caml_call1(f,x);
        return cons$0(y,of_list_map(f,l$0))}
      return acc}
    function compare$3(cmp,l1,l2)
     {var g2=to_gen$4(l2),g1=to_gen$4(l1);
      for(;;)
       {var match=caml_call1(g1,0),match$0=caml_call1(g2,0);
        if(match)
         {var _ew_=match[1];
          if(match$0)
           {var y=match$0[1],c=caml_call2(cmp,_ew_,y);
            if(0 === c)continue;
            return c}
          return 1}
        return match$0?-1:0}}
    function _aU_(l,f){return flat_map$0(f,l)}
    var
     Infix=
      [0,cons$0,_aU_,function(l,f){return map$6(f,l)},app,range,range_r_open],
     _aV_=Infix[1],
     _aW_=Infix[2],
     _aX_=Infix[3],
     _aY_=Infix[4],
     _aZ_=Infix[5],
     _a0_=Infix[6];
    function pp$7(opt,pp_item,fmt,l)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$12;
      var first=[0,1];
      iter$13
       (function(x)
         {if(first[1])
           first[1] = 0;
          else
           {caml_call2(Format[13],fmt,sep);caml_call2(Format[27],fmt,0)}
          return caml_call2(pp_item,fmt,x)},
        l);
      return 0}
    var
     CCRAL=
      [0,
       acc,
       is_empty$4,
       cons$0,
       return$2,
       map$6,
       mapi$2,
       hd,
       tl,
       front,
       front_exn,
       length$6,
       get$8,
       get_exn$1,
       set$6,
       remove$1,
       append$3,
       filter$1,
       filter_map$1,
       flat_map$0,
       flatten$0,
       app,
       take,
       take_while,
       drop,
       drop_while,
       take_drop,
       iter$13,
       iteri$3,
       fold$6,
       fold_rev,
       rev_map,
       rev$0,
       equal$5,
       compare$3,
       make$2,
       repeat,
       range,
       add_list$3,
       of_list$9,
       to_list$9,
       of_list_map,
       of_array$0,
       add_array,
       to_array$0,
       add_seq$3,
       of_seq$8,
       to_seq$8,
       add_gen$1,
       of_gen$4,
       to_gen$4,
       Infix,
       _aV_,
       _aW_,
       _aX_,
       _aY_,
       _aZ_,
       _a0_,
       pp$7];
    caml_register_global(218,CCRAL,"CCRAL");
    var
     copy$3=Bytes[4],
     sub$0=Bytes[7],
     blit=Bytes[11],
     iter$14=Bytes[15],
     Byte=
      [0,
       runtime.caml_create_bytes,
       runtime.caml_ml_bytes_length,
       runtime.caml_bytes_get,
       runtime.caml_bytes_set,
       sub$0,
       copy$3,
       blit,
       iter$14];
    function Make$5(Elt)
     {function create(size){return caml_make_vect(size,Elt[1])}
      function length(_ev_){return _ev_.length - 1}
      function get(_eu_,_et_){return caml_check_bound(_eu_,_et_)[_et_ + 1]}
      function set(_es_,_er_,_eq_)
       {return caml_check_bound(_es_,_er_)[_er_ + 1] = _eq_}
      var copy=Array[8],blit=Array[10],iter=Array[13],sub=Array[7];
      return [0,create,length,get,set,sub,copy,blit,iter]}
    var Array$0=[0,Byte,Make$5];
    function MakeFromArray(A)
     {var
       Empty=
        [248,cst_CCRingBuffer_MakeFromArray_A_Empty,caml_fresh_oo_id(0)];
      function create(size)
       {if(size < 1)caml_call1(Pervasives[1],cst_CCRingBuffer_create);
        return [0,0,0,caml_call1(A[1],size + 1 | 0)]}
      function copy(init)
       {var _ep_=caml_call1(A[6],init[3]);return [0,init[1],init[2],_ep_]}
      function capacity(b)
       {var len=caml_call1(A[2],b[3]);return 0 === len?0:len - 1 | 0}
      function length(b)
       {if(b[1] <= b[2])return b[2] - b[1] | 0;
        var _en_=b[2],_eo_=b[1];
        return (caml_call1(A[2],b[3]) - _eo_ | 0) + _en_ | 0}
      function is_full(b)
       {var _em_=caml_call1(A[2],b[3]);
        return (length(b) + 1 | 0) === _em_?1:0}
      function next(b,i)
       {var j=i + 1 | 0;return j === caml_call1(A[2],b[3])?0:j}
      function push_back(b,e)
       {caml_call3(A[4],b[3],b[2],e);
        b[2] = next(b,b[2]);
        if(b[1] === b[2])b[1] = next(b,b[1]);
        return 0}
      function blit_from(b,from_buf,o,len)
       {if(0 === len)return 0;
        if(caml_call1(A[2],from_buf) < (o + len | 0))
         return caml_call1(Pervasives[1],cst_CCRingBuffer_blit_from);
        var _ek_=(o + len | 0) - 1 | 0;
        if(! (_ek_ < o))
         {var i=o;
          for(;;)
           {push_back(b,caml_call2(A[3],from_buf,i));
            var _el_=i + 1 | 0;
            if(_ek_ !== i){var i=_el_;continue}
            break}}
        return 0}
      function blit_into(b,to_buf,o,len)
       {if(caml_call1(A[2],to_buf) < (o + len | 0))
         caml_call1(Pervasives[1],cst_CCRingBuffer_blit_into);
        if(b[1] <= b[2])
         {var n=caml_call2(Pervasives[4],b[2] - b[1] | 0,len);
          caml_call5(A[7],b[3],b[1],to_buf,o,n);
          return n}
        var
         _ei_=b[1],
         len_end=caml_call1(A[2],b[3]) - _ei_ | 0,
         _ej_=caml_call2(Pervasives[4],len_end,len);
        caml_call5(A[7],b[3],b[1],to_buf,o,_ej_);
        if(len <= len_end)return len;
        var n$0=caml_call2(Pervasives[4],b[2],len - len_end | 0);
        caml_call5(A[7],b[3],0,to_buf,o + len_end | 0,n$0);
        return n$0 + len_end | 0}
      function clear(b){b[2] = 0;b[1] = 0;return 0}
      function is_empty(b){return b[1] === b[2]?1:0}
      function take_front_exn(b)
       {if(b[1] === b[2])throw Empty;
        var c=caml_call2(A[3],b[3],b[1]);
        b[1] = next(b,b[1]);
        return c}
      function take_front(b)
       {try
         {var _eg_=[0,take_front_exn(b)];return _eg_}
        catch(_eh_)
         {_eh_ = caml_wrap_exception(_eh_);
          if(_eh_ === Empty)return 0;
          throw _eh_}}
      function take_back_exn(b)
       {if(b[1] === b[2])throw Empty;
        b[2] = 0 === b[2]?caml_call1(A[2],b[3]) - 1 | 0:b[2] - 1 | 0;
        return caml_call2(A[3],b[3],b[2])}
      function take_back(b)
       {try
         {var _ee_=[0,take_back_exn(b)];return _ee_}
        catch(_ef_)
         {_ef_ = caml_wrap_exception(_ef_);
          if(_ef_ === Empty)return 0;
          throw _ef_}}
      function junk_front(b)
       {if(b[1] === b[2])throw Empty;
        var _ed_=caml_call1(A[2],b[3]);
        return (b[1] + 1 | 0) === _ed_?(b[1] = 0,0):(b[1] = b[1] + 1 | 0,0)}
      function junk_back(b)
       {if(b[1] === b[2])throw Empty;
        return 0 === b[2]
                ?(b[2] = caml_call1(A[2],b[3]) - 1 | 0,0)
                :(b[2] = b[2] - 1 | 0,0)}
      function skip(b,len)
       {if(length(b) < len)caml_call1(Pervasives[1],cst_CCRingBuffer_skip);
        if(b[1] <= b[2])
         {b[1] = b[1] + len | 0;
          if(b[1] <= b[2])return 0;
          throw [0,Assert_failure,_a1_]}
        var _ec_=b[1],len_end=caml_call1(A[2],b[3]) - _ec_ | 0;
        return len_end <= len
                ?(b[1] = len - len_end | 0,0)
                :(b[1] = b[1] + len | 0,0)}
      function iter(b,f)
       {if(b[1] <= b[2])
         {var _d5_=b[1],_d6_=b[2] - 1 | 0;
          if(! (_d6_ < _d5_))
           {var i=_d5_;
            for(;;)
             {caml_call1(f,caml_call2(A[3],b[3],i));
              var _d7_=i + 1 | 0;
              if(_d6_ !== i){var i=_d7_;continue}
              break}}
          return 0}
        var _d8_=b[1],_d9_=caml_call1(A[2],b[3]) - 1 | 0;
        if(! (_d9_ < _d8_))
         {var i$1=_d8_;
          for(;;)
           {caml_call1(f,caml_call2(A[3],b[3],i$1));
            var _eb_=i$1 + 1 | 0;
            if(_d9_ !== i$1){var i$1=_eb_;continue}
            break}}
        var _d$_=b[2] - 1 | 0,_d__=0;
        if(! (_d$_ < 0))
         {var i$0=_d__;
          for(;;)
           {caml_call1(f,caml_call2(A[3],b[3],i$0));
            var _ea_=i$0 + 1 | 0;
            if(_d$_ !== i$0){var i$0=_ea_;continue}
            break}}
        return 0}
      function iteri(b,f)
       {if(b[1] <= b[2])
         {var _dW_=b[1],_dX_=b[2] - 1 | 0;
          if(! (_dX_ < _dW_))
           {var i=_dW_;
            for(;;)
             {caml_call2(f,i,caml_call2(A[3],b[3],i));
              var _dY_=i + 1 | 0;
              if(_dX_ !== i){var i=_dY_;continue}
              break}}
          return 0}
        var _dZ_=b[1],_d0_=caml_call1(A[2],b[3]) - 1 | 0;
        if(! (_d0_ < _dZ_))
         {var i$1=_dZ_;
          for(;;)
           {caml_call2(f,i$1,caml_call2(A[3],b[3],i$1));
            var _d4_=i$1 + 1 | 0;
            if(_d0_ !== i$1){var i$1=_d4_;continue}
            break}}
        var _d2_=b[2] - 1 | 0,_d1_=0;
        if(! (_d2_ < 0))
         {var i$0=_d1_;
          for(;;)
           {caml_call2(f,i$0,caml_call2(A[3],b[3],i$0));
            var _d3_=i$0 + 1 | 0;
            if(_d2_ !== i$0){var i$0=_d3_;continue}
            break}}
        return 0}
      function get(b,i)
       {if(b[1] <= b[2])
         return (b[2] - b[1] | 0) <= i
                 ?caml_call1(Pervasives[1],cst_CCRingBuffer_get)
                 :caml_call2(A[3],b[3],b[1] + i | 0);
        var _dV_=b[1],len_end=caml_call1(A[2],b[3]) - _dV_ | 0;
        return i < len_end
                ?caml_call2(A[3],b[3],b[1] + i | 0)
                :b[2] < (i - len_end | 0)
                  ?caml_call1(Pervasives[1],cst_CCRingBuffer_get$0)
                  :caml_call2(A[3],b[3],i - len_end | 0)}
      function get_front(b,i)
       {return is_empty(b)
                ?caml_call1(Pervasives[1],cst_CCRingBuffer_get_front)
                :get(b,i)}
      function get_back(b,i)
       {var offset=(length(b) - i | 0) - 1 | 0;
        return 0 <= offset
                ?get(b,offset)
                :caml_call1(Pervasives[1],cst_CCRingBuffer_get_back)}
      function to_list(b)
       {var len=length(b),i$1=len - 1 | 0,l=0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var i$0=i - 1 | 0,l$0=[0,get_front(b,i),l],l=l$0,i=i$0;continue}
          return l}}
      function append(b,into)
       {return iter(b,function(_dU_){return push_back(into,_dU_)})}
      function peek_front_exn(b)
       {if(is_empty(b))throw Empty;return caml_call2(A[3],b[3],b[1])}
      function peek_front(b)
       {try
         {var _dS_=[0,peek_front_exn(b)];return _dS_}
        catch(_dT_)
         {_dT_ = caml_wrap_exception(_dT_);
          if(_dT_ === Empty)return 0;
          throw _dT_}}
      function peek_back_exn(b)
       {if(is_empty(b))throw Empty;
        var i=0 === b[2]?caml_call1(A[2],b[3]) - 1 | 0:b[2] - 1 | 0;
        return caml_call2(A[3],b[3],i)}
      function peek_back(b)
       {try
         {var _dQ_=[0,peek_back_exn(b)];return _dQ_}
        catch(_dR_)
         {_dR_ = caml_wrap_exception(_dR_);
          if(_dR_ === Empty)return 0;
          throw _dR_}}
      function of_array(a)
       {var
         _dP_=caml_call1(A[2],a),
         b=create(caml_call2(Pervasives[5],_dP_,16));
        blit_from(b,a,0,caml_call1(A[2],a));
        return b}
      function to_array(b)
       {var
         _dO_=length(b),
         a=caml_call1(A[1],_dO_),
         n=blit_into(b,a,0,length(b));
        if(n === length(b))return a;
        throw [0,Assert_failure,_a2_]}
      return [0,
              A,
              Empty,
              create,
              copy,
              capacity,
              length,
              is_full,
              blit_from,
              blit_into,
              append,
              to_list,
              clear,
              is_empty,
              junk_front,
              junk_back,
              skip,
              iter,
              iteri,
              get_front,
              get_back,
              push_back,
              peek_front,
              peek_front_exn,
              peek_back,
              peek_back_exn,
              take_back,
              take_back_exn,
              take_front,
              take_front_exn,
              of_array,
              to_array]}
    var Byte$0=MakeFromArray(Array$0[1]);
    function Make$6(_dN_){return MakeFromArray(caml_call1(Array$0[2],_dN_))}
    var CCRingBuffer=[0,Array$0,Byte$0,MakeFromArray,Make$6];
    caml_register_global(220,CCRingBuffer,"CCRingBuffer");
    function make$3(hd,tl){return hd?[0,hd,tl]:[0,caml_call1(List[9],tl),0]}
    function list_is_empty(param){return param?0:1}
    function is_empty$5(q){return list_is_empty(q[1])}
    function push$0(x,q){return make$3(q[1],[0,x,q[2]])}
    function snoc$0(q,x){return push$0(x,q)}
    function peek_exn(q)
     {var _dM_=q[1];
      if(_dM_){var x=_dM_[1];return x}
      if(list_is_empty(q[2]))return caml_call1(Pervasives[1],cst_Queue_peek);
      throw [0,Assert_failure,_a3_]}
    function peek(q)
     {var _dL_=q[1];if(_dL_){var x=_dL_[1];return [0,x]}return 0}
    function pop_exn$0(q)
     {var _dK_=q[1];
      if(_dK_){var hd=_dK_[2],x=_dK_[1],q$0=make$3(hd,q[2]);return [0,x,q$0]}
      if(list_is_empty(q[2]))
       return caml_call1(Pervasives[1],cst_Queue_peek$0);
      throw [0,Assert_failure,_a4_]}
    function pop$0(q)
     {try
       {var _dI_=[0,pop_exn$0(q)];return _dI_}
      catch(_dJ_)
       {_dJ_ = caml_wrap_exception(_dJ_);
        if(_dJ_[1] === Invalid_argument)return 0;
        throw _dJ_}}
    function junk(q)
     {try
       {var match=pop_exn$0(q),q$0=match[2];return q$0}
      catch(_dH_)
       {_dH_ = caml_wrap_exception(_dH_);
        if(_dH_[1] === Invalid_argument)return q;
        throw _dH_}}
    function map$7(f,q)
     {var _dG_=caml_call2(List[17],f,q[2]);
      return [0,caml_call2(List[17],f,q[1]),_dG_]}
    function rev$1(q){return make$3(q[2],q[1])}
    function length$7(q)
     {var _dF_=caml_call1(List[1],q[2]);
      return caml_call1(List[1],q[1]) + _dF_ | 0}
    function fold$7(f,acc,q)
     {var acc$0=caml_call3(List[20],f,acc,q[1]),_dD_=q[2];
      function _dE_(x,acc){return caml_call2(f,acc,x)}
      return caml_call3(List[21],_dE_,_dD_,acc$0)}
    function rev_iter(f,l)
     {if(l){var tl=l[2],x=l[1];rev_iter(f,tl);return caml_call1(f,x)}return 0}
    function iter$15(f,q){caml_call2(List[15],f,q[1]);return rev_iter(f,q[2])}
    function to_list$10(q)
     {var _dB_=0,_dC_=fold$7(function(acc,x){return [0,x,acc]},_dB_,q);
      return caml_call1(List[9],_dC_)}
    function add_list$4(q,l){return caml_call3(List[20],snoc$0,q,l)}
    function of_list$10(l){return add_list$4(empty$8,l)}
    function to_seq$9(q,k){return iter$15(k,q)}
    function add_seq$4(q,seq)
     {var q$0=[0,q];
      caml_call1(seq,function(x){q$0[1] = push$0(x,q$0[1]);return 0});
      return q$0[1]}
    function of_seq$9(s){return add_seq$4(empty$8,s)}
    function add_klist$0(q,l)
     {return add_seq$4
              (q,
               function(f)
                {var k=l;
                 for(;;)
                  {var match=caml_call1(k,0);
                   if(typeof match === "number")return 0;
                   var match$0=match[2],tl=match$0[2],x=match$0[1];
                   caml_call1(f,x);
                   var k=tl;
                   continue}})}
    function of_klist$1(l){return add_klist$0(empty$8,l)}
    function to_klist$1(q)
     {function aux2(l,param)
       {if(l)
         {var tl=l[2],x=l[1];
          return [0,748545553,[0,x,function(_dA_){return aux2(tl,_dA_)}]]}
        return 3902385}
      function aux1(l,param)
       {if(l)
         {var tl=l[2],x=l[1];
          return [0,748545553,[0,x,function(_dz_){return aux1(tl,_dz_)}]]}
        return aux2(caml_call1(List[9],q[2]),0)}
      var _dx_=q[1];
      return function(_dy_){return aux1(_dx_,_dy_)}}
    function add_gen$2(q,g)
     {return add_seq$4
              (q,
               function(f)
                {for(;;)
                  {var match=caml_call1(g,0);
                   if(match){var x=match[1];caml_call1(f,x);continue}
                   return 0}})}
    function of_gen$5(g){return add_gen$2(empty$8,g)}
    function to_gen$5(q)
     {var st=[0,[0,847852583,q[1]]];
      function aux(param)
       {for(;;)
         {var _du_=st[1];
          if(typeof _du_ === "number")return 0;
          if(847852583 <= _du_[1])
           {var _dv_=_du_[2];
            if(_dv_)
             {var tl=_dv_[2],x=_dv_[1];st[1] = [0,847852583,tl];return [0,x]}
            st[1] = [0,-57574468,q[2]];
            continue}
          var _dw_=_du_[2];
          if(_dw_)
           {var tl$0=_dw_[2],x$0=_dw_[1];
            st[1] = [0,-57574468,tl$0];
            return [0,x$0]}
          st[1] = 926227490;
          return 0}}
      return aux}
    function equal$6(eq,q1,q2)
     {var l2$1=to_klist$1(q2),l1$1=to_klist$1(q1),l1=l1$1,l2=l2$1;
      for(;;)
       {var match=caml_call1(l1,0),match$0=caml_call1(l2,0);
        if(typeof match === "number")
         {if(3902385 === match$0)return 1}
        else
         if(typeof match$0 !== "number")
          if(748545553 === match$0[1])
           {var
             _ds_=match$0[2],
             l2$0=_ds_[2],
             x2=_ds_[1],
             match$1=match[2],
             l1$0=match$1[2],
             x1=match$1[1],
             _dt_=caml_call2(eq,x1,x2);
            if(_dt_){var l1=l1$0,l2=l2$0;continue}
            return _dt_}
        return 0}}
    function append$4(q1,q2)
     {return add_seq$4(q1,function(yield$0){return to_seq$9(q2,yield$0)})}
    function _a5_(q,f){return map$7(f,q)}
    function pp$8(opt,pp_item,out,l)
     {if(opt)
       var sth=opt[1],sep=sth;
      else
       var sep=function(out,param){return caml_call2(Format[112],out,_a6_)};
      var first=[0,1];
      return iter$15
              (function(x)
                {if(first[1])first[1] = 0;else caml_call2(sep,out,0);
                 return caml_call2(pp_item,out,x)},
               l)}
    var
     CCSimple_queue=
      [0,
       empty$8,
       is_empty$5,
       push$0,
       snoc$0,
       peek,
       peek_exn,
       pop$0,
       pop_exn$0,
       junk,
       append$4,
       map$7,
       rev$1,
       equal$6,
       [0,_a5_,append$4,snoc$0],
       _a5_,
       append$4,
       snoc$0,
       length$7,
       fold$7,
       iter$15,
       to_list$10,
       add_list$4,
       of_list$10,
       to_seq$9,
       add_seq$4,
       of_seq$9,
       to_klist$1,
       add_klist$0,
       of_klist$1,
       of_gen$5,
       add_gen$2,
       to_gen$5,
       pp$8];
    caml_register_global(221,CCSimple_queue,"CCSimple_queue");
    function Make$7(W)
     {var compare=W[1],M=caml_call1(Map[1],[0,compare]),empty=0;
      function check_invariants(param)
       {var param$0=param;
        for(;;)
         if(typeof param$0 === "number")
          return 1;
         else
          {if(0 === param$0[0])
            {var param$1=param$0[2],param$0=param$1;continue}
           if(! param$0[1])
            {var map$0=param$0[2];if(caml_call1(M[2],map$0))return 0}
           var
            map=param$0[2],
            _dr_=function(param,v){return check_invariants(v)};
           return caml_call2(M[14],_dr_,map)}}
      function is_empty(param){return typeof param === "number"?1:0}
      function id(x){return x}
      function fold_seq_and_then(f,finish,acc,seq)
       {var acc$0=[0,acc];
        caml_call1
         (seq,function(x){acc$0[1] = caml_call2(f,acc$0[1],x);return 0});
        return caml_call1(finish,acc$0[1])}
      function seq_append_list_rev(l,seq)
       {var l$0=[0,l];
        caml_call1(seq,function(x){l$0[1] = [0,x,l$0[1]];return 0});
        return l$0[1]}
      function seq_append_list(l,seq)
       {var _dq_=seq_append_list_rev(0,seq);
        return caml_call2(List[12],_dq_,l)}
      function seq_of_map(map,k)
       {function _dp_(key,v){return caml_call1(k,[0,key,v])}
        return caml_call2(M[12],_dp_,map)}
      function mk_node(value,map)
       {if(value)return [1,value,map];
        if(caml_call1(M[2],map))return 0;
        if(1 === caml_call1(M[18],map))
         {var match=caml_call1(M[20],map),sub=match[2],c=match[1];
          return [0,c,sub]}
        return [1,value,map]}
      function update(key,f,t)
       {function goto$0(param,c)
         {var rebuild=param[2],t=param[1];
          if(typeof t === "number")
           return [0,empty,function(t){return caml_call1(rebuild,[0,c,t])}];
          else
           {if(0 === t[0])
             {var t$0=t[2],c$0=t[1];
              if(0 === caml_call2(W[1],c,c$0))
               return [0,t$0,function(t){return caml_call1(rebuild,[0,c,t])}];
              var
               rebuild$0=
                function(new_child)
                 {if(is_empty(new_child))
                   var t$1=t;
                  else
                   var
                    map=caml_call2(M[6],c,new_child),
                    map$0=caml_call3(M[4],c$0,t$0,map),
                    t$1=mk_node(0,map$0);
                  return caml_call1(rebuild,t$1)};
              return [0,empty,rebuild$0]}
            var map=t[2],value=t[1];
            try
             {var
               t$1=caml_call2(M[27],c,map),
               rebuild$2=
                function(new_child)
                 {var
                   _do_=
                    is_empty(new_child)
                     ?mk_node(value,caml_call2(M[7],c,map))
                     :mk_node(value,caml_call3(M[4],c,new_child,map));
                  return caml_call1(rebuild,_do_)},
               _dm_=[0,t$1,rebuild$2];
              return _dm_}
            catch(_dn_)
             {_dn_ = caml_wrap_exception(_dn_);
              if(_dn_ === Not_found)
               {var
                 rebuild$1=
                  function(new_child)
                   {if(is_empty(new_child))return caml_call1(rebuild,t);
                    var map$0=caml_call3(M[4],c,new_child,map);
                    return caml_call1(rebuild,mk_node(value,map$0))};
                return [0,empty,rebuild$1]}
              throw _dn_}}}
        function finish(param)
         {var rebuild=param[2],t=param[1];
          if(typeof t === "number")
           {var _dk_=M[1];
            return caml_call1(rebuild,mk_node(caml_call1(f,0),_dk_))}
          else
           {if(0 === t[0])
             {var
               t$0=t[2],
               c=t[1],
               v=caml_call1(f,0),
               _dl_=v?mk_node(v,caml_call2(M[6],c,t$0)):t;
              return caml_call1(rebuild,_dl_)}
            var map=t[2],value=t[1],value$0=caml_call1(f,value);
            return caml_call1(rebuild,mk_node(value$0,map))}}
        var word=caml_call1(W[2],key);
        return fold_seq_and_then(goto$0,finish,[0,t,id],word)}
      function add(k,v,t){return update(k,function(param){return [0,v]},t)}
      function remove(k,t){return update(k,function(param){return 0},t)}
      function find_exn(k,t)
       {function goto$0(t,c)
         {if(typeof t === "number")
           throw Not_found;
          else
           {if(0 === t[0])
             {var t$0=t[2],c$0=t[1];
              if(0 === caml_call2(W[1],c,c$0))return t$0;
              throw Not_found}
            var map=t[2];
            return caml_call2(M[27],c,map)}}
        function finish(t)
         {if(typeof t !== "number" && 1 === t[0])
           {var _dj_=t[1];if(_dj_){var v=_dj_[1];return v}}
          throw Not_found}
        var word=caml_call1(W[2],k);
        return fold_seq_and_then(goto$0,finish,t,word)}
      function find(k,t)
       {try
         {var _dh_=[0,find_exn(k,t)];return _dh_}
        catch(_di_)
         {_di_ = caml_wrap_exception(_di_);
          if(_di_ === Not_found)return 0;
          throw _di_}}
      function difflist_add(f,x,l){return caml_call1(f,[0,x,l])}
      function longest_prefix(k,t)
       {function goto$0(param,c)
         {var prefix=param[2],t=param[1];
          if(typeof t === "number")
           return [0,0,prefix];
          else
           {if(0 === t[0])
             {var t$0=t[2],c$0=t[1];
              return 0 === caml_call2(W[1],c,c$0)
                      ?[0,t$0,function(_dg_){return difflist_add(prefix,c,_dg_)}]
                      :[0,0,prefix]}
            var map=t[2];
            try
             {var
               t$1=caml_call2(M[27],c,map),
               _dd_=[0,t$1,function(_df_){return difflist_add(prefix,c,_df_)}];
              return _dd_}
            catch(_de_)
             {_de_ = caml_wrap_exception(_de_);
              if(_de_ === Not_found)return [0,0,prefix];
              throw _de_}}}
        function finish(param)
         {var prefix=param[2],_dc_=caml_call1(prefix,0);
          return caml_call1(W[3],_dc_)}
        var word=caml_call1(W[2],k);
        return fold_seq_and_then(goto$0,finish,[0,t,id],word)}
      function fold(f,path,t,acc)
       {var path$0=path,t$0=t;
        for(;;)
         if(typeof t$0 === "number")
          return acc;
         else
          {if(0 === t$0[0])
            {var
              t$1=t$0[2],
              c=t$0[1],
              path$2=
               function(path,c)
                {function path$0(_db_){return difflist_add(path,c,_db_)}
                 return path$0},
              path$1=path$2(path$0,c),
              path$0=path$1,
              t$0=t$1;
             continue}
           var map=t$0[2],v=t$0[1];
           if(v)
            var v$0=v[1],acc$0=caml_call3(f,acc,path$0,v$0);
           else
            var acc$0=acc;
           var
            _c$_=
             function(c,t,acc)
              {return fold
                       (f,function(_da_){return difflist_add(path$0,c,_da_)},t,acc)};
           return caml_call3(M[13],_c$_,map,acc$0)}}
      function fold$0(f,acc,t)
       {return fold
                (function(acc,path,v)
                  {var _c__=caml_call1(path,0),key=caml_call1(W[3],_c__);
                   return caml_call3(f,acc,key,v)},
                 id,
                 t,
                 acc)}
      function mapi(f,t)
       {function map(prefix,t)
         {if(typeof t === "number")
           return 0;
          else
           {if(0 === t[0])
             {var t$0=t[2],c=t[1];
              return [0,
                      c,
                      map(function(_c9_){return difflist_add(prefix,c,_c9_)},t$0)]}
            var map$0=t[2],v=t[1];
            if(v)
             var
              v$0=v[1],
              _c6_=caml_call1(prefix,0),
              v$1=[0,caml_call2(f,caml_call1(W[3],_c6_),v$0)];
            else
             var v$1=0;
            var
             _c7_=
              function(c,t)
               {function prefix$0(_c8_){return difflist_add(prefix,c,_c8_)}
                return map(prefix$0,t)},
             map$1=caml_call2(M[34],_c7_,map$0);
            return [1,v$1,map$1]}}
        return map(id,t)}
      function map(f,t)
       {function map(param)
         {if(typeof param === "number")
           return 0;
          else
           {if(0 === param[0]){var t=param[2],c=param[1];return [0,c,map(t)]}
            var map$0=param[2],v=param[1];
            if(v)var v$0=v[1],v$1=[0,caml_call1(f,v$0)];else var v$1=0;
            var map$1=caml_call2(M[33],map,map$0);
            return [1,v$1,map$1]}}
        return map(t)}
      function iter(f,t)
       {var _c4_=0;
        return fold
                (function(param,path,y)
                  {var _c5_=caml_call1(path,0);
                   return caml_call2(f,caml_call1(W[3],_c5_),y)},
                 id,
                 t,
                 _c4_)}
      function fold_values(f,acc,t)
       {var t$0=t;
        for(;;)
         if(typeof t$0 === "number")
          return acc;
         else
          {if(0 === t$0[0]){var t$1=t$0[2],t$0=t$1;continue}
           var map=t$0[2],v=t$0[1];
           if(v)var v$0=v[1],acc$0=caml_call2(f,acc,v$0);else var acc$0=acc;
           var _c3_=function(c,t,acc){return fold_values(f,acc,t)};
           return caml_call3(M[13],_c3_,map,acc$0)}}
      function iter_values(f,t)
       {var _c2_=0;
        return fold_values(function(param,x){return caml_call1(f,x)},_c2_,t)}
      function merge(f,t1,t2)
       {var t1$0=t1,t2$0=t2;
        for(;;)
         {if(typeof t1$0 === "number")
           return t2$0;
          else
           if(0 === t1$0[0])
            {var _cT_=t1$0[2],_cU_=t1$0[1];
             if(typeof t2$0 !== "number")
              {if(0 === t2$0[0])
                {var t2$1=t2$0[2],c2=t2$0[1];
                 if(0 === caml_call2(W[1],_cU_,c2))
                  return [0,_cU_,merge(f,_cT_,t2$1)];
                 var
                  map=caml_call3(M[4],_cU_,_cT_,M[1]),
                  map$0=caml_call3(M[4],c2,t2$1,map);
                 return mk_node(0,map$0)}
               var map$1=t2$0[2],value=t2$0[1];
               try
                {var
                  t2$2=caml_call2(M[27],_cU_,map$1),
                  new_t=merge(f,_cT_,t2$2),
                  map$2=
                   is_empty(new_t)
                    ?caml_call2(M[7],_cU_,map$1)
                    :caml_call3(M[4],_cU_,new_t,map$1),
                  _cV_=mk_node(value,map$2);
                 return _cV_}
               catch(_c0_)
                {_c0_ = caml_wrap_exception(_c0_);
                 if(_c0_ === Not_found)
                  {if(is_empty(_cT_))throw [0,Assert_failure,_a7_];
                   return [1,value,caml_call3(M[4],_cU_,_cT_,map$1)]}
                 throw _c0_}}}
           else
            {var _cX_=t1$0[1],_cW_=t1$0[2];
             if(typeof t2$0 !== "number")
              {if(0 === t2$0[0]){var _cZ_=t2$0,t2$0=t1$0,t1$0=_cZ_;continue}
               var map2=t2$0[2],v2=t2$0[1];
               if(_cX_)
                if(v2)
                 var v2$0=v2[1],v1=_cX_[1],v=caml_call2(f,v1,v2$0);
                else
                 var v=_cX_;
               else
                var v=v2;
               var
                _cY_=
                 function(c,t1,t2)
                  {if(t1)
                    {var _c1_=t1[1];
                     if(t2)
                      {var t2$0=t2[1],new_t=merge(f,_c1_,t2$0);
                       return is_empty(new_t)?0:[0,new_t]}
                     var t=_c1_}
                   else
                    {if(! t2)throw [0,Assert_failure,_a8_];var t=t2[1]}
                   return [0,t]},
                map$3=caml_call3(M[8],_cY_,_cW_,map2);
               return mk_node(v,map$3)}}
          return t1$0}}
      function size(t)
       {var t$0=t;
        for(;;)
         if(typeof t$0 === "number")
          return 0;
         else
          {if(0 === t$0[0]){var t$1=t$0[2],t$0=t$1;continue}
           var
            map=t$0[2],
            v=t$0[1],
            s=v?1:0,
            _cS_=function(param,t,acc){return size(t) + acc | 0};
           return caml_call3(M[13],_cS_,map,s)}}
      function to_list(t)
       {var _cR_=0;
        return fold$0(function(acc,k,v){return [0,[0,k,v],acc]},_cR_,t)}
      function of_list(l)
       {function _cQ_(acc,param)
         {var v=param[2],k=param[1];return add(k,v,acc)}
        return caml_call3(List[20],_cQ_,empty,l)}
      function to_seq(t,k)
       {return iter(function(key,v){return caml_call1(k,[0,key,v])},t)}
      function to_seq_values(t,k){return iter_values(k,t)}
      function of_seq(seq)
       {return fold_seq_and_then
                (function(acc,param)
                  {var v=param[2],k=param[1];return add(k,v,acc)},
                 id,
                 empty,
                 seq)}
      function to_tree(t,param)
       {if(typeof t === "number")
         return 3902385;
        else
         {if(0 === t[0])
           {var t$0=t[2],c=t[1],_cK_=0;
            return [0,
                    870528546,
                    [0,
                     [0,748194550,c],
                     [0,function(_cP_){return to_tree(t$0,_cP_)},_cK_]]]}
          var map=t[2],v=t[1];
          if(v)var v$0=v[1],x=[0,4298433,v$0];else var x=-99762668;
          var
           l=caml_call1(M[19],map),
           _cL_=
            function(param)
             {var
               t=param[2],
               c=param[1],
               _cM_=0,
               l=[0,function(_cO_){return to_tree(t,_cO_)},_cM_],
               x=[0,748194550,c];
              return function(_cN_){return [0,870528546,[0,x,l]]}};
          return [0,870528546,[0,x,caml_call2(List[17],_cL_,l)]]}}
      function explore(dir,k,alt)
       {var alt$0=alt;
        for(;;)
         {if(0 === alt$0[0])
           {var prefix=alt$0[2],v=alt$0[1],_cD_=caml_call1(prefix,0);
            return caml_call1(k,[0,caml_call1(W[3],_cD_),v])}
          var _cE_=alt$0[1];
          if(typeof _cE_ === "number")
           return 0;
          else
           {if(0 === _cE_[0])
             {var
               prefix$0=alt$0[2],
               t=_cE_[2],
               c=_cE_[1],
               alt$1=
                [1,
                 t,
                 function(prefix,c)
                   {return function(_cJ_){return difflist_add(prefix,c,_cJ_)}}
                  (prefix$0,c)],
               alt$0=alt$1;
              continue}
            var prefix$1=alt$0[2],map=_cE_[2],o=_cE_[1];
            if(o)
             if(0 === dir)
              {var v$0=o[1],_cF_=caml_call1(prefix$1,0);
               caml_call1(k,[0,caml_call1(W[3],_cF_),v$0]);
               var switch$0=1}
             else
              var switch$0=0;
            else
             var switch$0=0;
            var
             seq=
              function(k)
               {return seq_of_map
                        (map,
                         function(param)
                          {var t=param[2],c=param[1];
                           return caml_call1
                                   (k,
                                    [1,t,function(_cI_){return difflist_add(prefix$1,c,_cI_)}])})};
            if(0 === dir)
             var l=seq_append_list(0,seq);
            else
             if(o)
              var v$1=o[1],l=seq_append_list_rev([0,[0,v$1,prefix$1],0],seq);
             else
              var l=seq_append_list_rev(0,seq);
            var _cG_=function(_cH_){return explore(dir,k,_cH_)};
            return caml_call2(List[15],_cG_,l)}}}
      function list_eq(l1,l2)
       {try
         {var
           _cA_=function(x,y){return 0 === caml_call2(W[1],x,y)?1:0},
           _cB_=caml_call3(List[29],_cA_,l1,l2);
          return _cB_}
        catch(_cC_)
         {_cC_ = caml_wrap_exception(_cC_);
          if(_cC_[1] === Invalid_argument)return 0;
          throw _cC_}}
      function half_range(dir,p,key,t,k)
       {function on_char(param,c)
         {var alternatives=param[2],cur=param[1];
          if(cur)
           {var _ct_=cur[1],_cu_=_ct_[1];
            if(typeof _cu_ === "number")
             return [0,0,alternatives];
            else
             {if(0 === _cu_[0])
               {var trail=_ct_[2],t=_cu_[2],c$0=_cu_[1];
                return 0 === caml_call2(W[1],c,c$0)
                        ?[0,
                          [0,[0,t,function(_cz_){return difflist_add(trail,c,_cz_)}]],
                          alternatives]
                        :[0,0,alternatives]}
              var trail$0=_ct_[2],map=_cu_[2],o=_cu_[1];
              if(o)
               if(0 === dir)
                var switch$0=0;
               else
                var
                 v=o[1],
                 alternatives$0=[0,[0,v,trail$0],alternatives],
                 switch$0=1;
              else
               var switch$0=0;
              if(! switch$0)var alternatives$0=alternatives;
              var
               seq=
                function(k)
                 {return seq_of_map
                          (map,
                           function(param)
                            {var
                              t=param[2],
                              c$0=param[1],
                              match=
                               caml_call2(p,c,c$0)
                                ?[0,
                                  [1,t,function(_cy_){return difflist_add(trail$0,c$0,_cy_)}]]
                                :0;
                             if(match){var y=match[1];return caml_call1(k,y)}
                             return 0})},
               alternatives$1=
                0 === dir
                 ?seq_append_list(alternatives$0,seq)
                 :seq_append_list_rev(alternatives$0,seq);
              try
               {var
                 t$0=caml_call2(M[27],c,map),
                 _cv_=
                  [0,
                   [0,
                    [0,t$0,function(_cx_){return difflist_add(trail$0,c,_cx_)}]],
                   alternatives$1];
                return _cv_}
              catch(_cw_)
               {_cw_ = caml_wrap_exception(_cw_);
                if(_cw_ === Not_found)return [0,0,alternatives$1];
                throw _cw_}}}
          return [0,0,alternatives]}
        function finish(param)
         {var alternatives=param[2],cur=param[1];
          if(cur)
           {var _cn_=cur[1],_co_=_cn_[1];
            if(0 === dir)
             {var prefix=_cn_[2],_ck_=0;
              fold
               (function(param,path,v)
                 {var
                   _cs_=caml_call1(prefix,caml_call1(path,0)),
                   key=caml_call1(W[3],_cs_);
                  return caml_call1(k,[0,key,v])},
                id,
                _co_,
                _ck_);
              var switch$1=1}
            else
             {if(typeof _co_ === "number")
               var switch$2=1;
              else
               if(1 === _co_[0])
                {var _cq_=_co_[1];
                 if(_cq_)
                  {var
                    prefix$0=_cn_[2],
                    v=_cq_[1],
                    _cl_=seq_append_list_rev(0,caml_call1(W[2],key)),
                    _cm_=caml_call1(List[9],_cl_);
                   if(! list_eq(caml_call1(prefix$0,0),_cm_))
                    throw [0,Assert_failure,_a9_];
                   caml_call1(k,[0,key,v]);
                   var switch$1=1,switch$2=0}
                 else
                  var switch$2=1}
               else
                var switch$2=1;
              if(switch$2)var switch$0=0,switch$1=0}
            if(switch$1)var switch$0=1}
          else
           var switch$0=0;
          function _cp_(_cr_){return explore(dir,k,_cr_)}
          return caml_call2(List[15],_cp_,alternatives)}
        var word=caml_call1(W[2],key);
        return fold_seq_and_then(on_char,finish,[0,[0,[0,t,id]],0],word)}
      function above(key,t)
       {function _ch_(cur,other){return caml_call2(W[1],cur,other) < 0?1:0}
        var _ci_=0;
        return function(_cj_){return half_range(_ci_,_ch_,key,t,_cj_)}}
      function below(key,t)
       {function _ce_(cur,other){return 0 < caml_call2(W[1],cur,other)?1:0}
        var _cf_=1;
        return function(_cg_){return half_range(_cf_,_ce_,key,t,_cg_)}}
      return [0,
              empty,
              is_empty,
              add,
              remove,
              find,
              find_exn,
              longest_prefix,
              update,
              fold$0,
              mapi,
              map,
              iter,
              fold_values,
              iter_values,
              merge,
              size,
              to_list,
              of_list,
              to_seq,
              of_seq,
              to_seq_values,
              to_tree,
              above,
              below,
              check_invariants]}
    function MakeArray(X)
     {var compare=X[1];
      function to_seq(a,k){return caml_call2(Array[13],k,a)}
      var of_list=Array[12];
      return Make$7([0,compare,to_seq,of_list])}
    function MakeList(X)
     {var compare=X[1];
      function to_seq(a,k){return caml_call2(List[15],k,a)}
      function of_list(l){return l}
      return Make$7([0,compare,to_seq,of_list])}
    var compare$4=Char[7];
    function to_seq$10(s,k){return caml_call2(String[8],k,s)}
    function of_list$11(l)
     {var _cc_=caml_call1(List[1],l),buf=caml_call1(Buffer[1],_cc_);
      function _cd_(c){return caml_call2(Buffer[10],buf,c)}
      caml_call2(List[15],_cd_,l);
      return caml_call1(Buffer[2],buf)}
    var
     String$0=Make$7([0,compare$4,to_seq$10,of_list$11]),
     CCTrie=[0,Make$7,MakeArray,MakeList,String$0];
    caml_register_global(225,CCTrie,"CCTrie");
    function MakeFull(K)
     {var empty=0;
      function is_empty(param){return param?0:1}
      function get_exn(k,m)
       {var m$0=m;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             l=m$0[3],
             v=m$0[2],
             k$0=m$0[1],
             n=caml_call2(K[1],k,k$0);
            if(0 === n)return v;
            if(0 <= n){var m$0=r;continue}
            var m$0=l;
            continue}
          throw Not_found}}
      function get(k,m)
       {try
         {var _ca_=[0,get_exn(k,m)];return _ca_}
        catch(_cb_)
         {_cb_ = caml_wrap_exception(_cb_);
          if(_cb_ === Not_found)return 0;
          throw _cb_}}
      function mem(k,m)
       {try
         {get_exn(k,m);var _b__=1;return _b__}
        catch(_b$_)
         {_b$_ = caml_wrap_exception(_b$_);
          if(_b$_ === Not_found)return 0;
          throw _b$_}}
      function singleton(k,v){return [0,k,v,0,0,caml_call1(K[2],k)]}
      function weight(param){if(param){var w=param[5];return w}return 0}
      function is_balanced(l,r)
       {var _b9_=2 * (weight(r) + 1 | 0) | 0;
        return _b9_ <= (5 * (weight(l) + 1 | 0) | 0)?1:0}
      function is_single(l,r)
       {var _b8_=3 * (weight(r) + 1 | 0) | 0;
        return (2 * (weight(l) + 1 | 0) | 0) < _b8_?1:0}
      function balanced(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var r=param$0[4],l=param$0[3],_b4_=is_balanced(l,r);
            if(_b4_)
             {var _b5_=is_balanced(r,l);
              if(_b5_)
               {var _b6_=balanced(l);
                if(_b6_){var param$0=r;continue}
                var _b7_=_b6_}
              else
               var _b7_=_b5_}
            else
             var _b7_=_b4_;
            return _b7_}
          return 1}}
      function mk_node(k,v,l,r)
       {var _b2_=caml_call1(K[2],k),_b3_=weight(r);
        return [0,k,v,l,r,(weight(l) + _b3_ | 0) + _b2_ | 0]}
      function balance_l(k,v,l,r)
       {if(is_balanced(l,r))return mk_node(k,v,l,r);
        if(r)
         {var rr=r[4],rl=r[3];
          if(is_single(rl,rr))
           {if(r)
             {var t3=r[4],t2=r[3],v2=r[2],k2=r[1];
              return mk_node(k2,v2,mk_node(k,v,l,t2),t3)}
            throw [0,Assert_failure,_a__]}
          if(r)
           {var _b0_=r[3];
            if(_b0_)
             {var
               t4=r[4],
               t3$0=_b0_[4],
               t2$0=_b0_[3],
               v3=_b0_[2],
               k3=_b0_[1],
               v2$0=r[2],
               k2$0=r[1],
               _b1_=mk_node(k2$0,v2$0,t3$0,t4);
              return mk_node(k3,v3,mk_node(k,v,l,t2$0),_b1_)}}
          throw [0,Assert_failure,_a$_]}
        throw [0,Assert_failure,_ba_]}
      function balance_r(k,v,l,r)
       {if(is_balanced(r,l))return mk_node(k,v,l,r);
        if(l)
         {var lr=l[4],ll=l[3];
          if(is_single(lr,ll))
           {if(l)
             {var t12=l[4],t11=l[3],v2=l[2],k2=l[1];
              return mk_node(k2,v2,t11,mk_node(k,v,t12,r))}
            throw [0,Assert_failure,_bb_]}
          if(l)
           {var _bY_=l[4];
            if(_bY_)
             {var
               t122=_bY_[4],
               t121=_bY_[3],
               v3=_bY_[2],
               k3=_bY_[1],
               t11$0=l[3],
               v2$0=l[2],
               k2$0=l[1],
               _bZ_=mk_node(k,v,t122,r);
              return mk_node(k3,v3,mk_node(k2$0,v2$0,t11$0,t121),_bZ_)}}
          throw [0,Assert_failure,_bc_]}
        throw [0,Assert_failure,_bd_]}
      function add(k,v,m)
       {if(m)
         {var r=m[4],l=m[3],v$0=m[2],k$0=m[1],n=caml_call2(K[1],k,k$0);
          return 0 === n
                  ?mk_node(k,v,l,r)
                  :0 <= n
                    ?balance_l(k$0,v$0,l,add(k,v,r))
                    :balance_r(k$0,v$0,add(k,v,l),r)}
        return singleton(k,v)}
      function extract_min(m)
       {if(m)
         {var _bV_=m[3],_bW_=m[2],_bX_=m[1];
          if(_bV_)
           {var
             r=m[4],
             match=extract_min(_bV_),
             l=match[3],
             v=match[2],
             k=match[1];
            return [0,k,v,balance_l(_bX_,_bW_,l,r)]}
          var r$0=m[4];
          return [0,_bX_,_bW_,r$0]}
        throw Not_found}
      function extract_max(m)
       {if(m)
         {var _bR_=m[4],_bS_=m[3],_bT_=m[2],_bU_=m[1];
          if(_bR_)
           {var match=extract_max(_bR_),r=match[3],v=match[2],k=match[1];
            return [0,k,v,balance_r(_bU_,_bT_,_bS_,r)]}
          return [0,_bU_,_bT_,_bS_]}
        throw Not_found}
      function remove(k,m)
       {if(m)
         {var r=m[4],l=m[3],v=m[2],k$0=m[1],n=caml_call2(K[1],k,k$0);
          if(0 === n)
           {if(l)
             {if(r)
               {var _bQ_=weight(r);
                if(_bQ_ < weight(l))
                 {var
                   match=extract_max(l),
                   l$0=match[3],
                   v$0=match[2],
                   k$1=match[1];
                  return balance_l(k$1,v$0,l$0,r)}
                var
                 match$0=extract_min(r),
                 r$0=match$0[3],
                 v$1=match$0[2],
                 k$2=match$0[1];
                return balance_r(k$2,v$1,l,r$0)}
              var o=l}
            else
             {if(! r)return 0;var o=r}
            return o}
          return 0 <= n
                  ?balance_r(k$0,v,l,remove(k,r))
                  :balance_l(k$0,v,remove(k,l),r)}
        return 0}
      function update(k,f,m)
       {var maybe_v=get(k,m),match=caml_call1(f,maybe_v);
        if(maybe_v){if(! match)return remove(k,m)}else if(! match)return m;
        var v=match[1];
        return add(k,v,m)}
      function nth_exn(i,m)
       {var i$0=i,m$0=m;
        for(;;)
         {if(m$0)
           {var
             w=m$0[5],
             r=m$0[4],
             l=m$0[3],
             v=m$0[2],
             k=m$0[1],
             c=i$0 - weight(l) | 0;
            if(0 === c)return [0,k,v];
            if(0 <= c)
             {if(i$0 < (w - weight(r) | 0))return [0,k,v];
              var i$1=(i$0 + weight(r) | 0) - w | 0,i$0=i$1,m$0=r;
              continue}
            var m$0=l;
            continue}
          throw Not_found}}
      function nth(i,m)
       {try
         {var _bO_=[0,nth_exn(i,m)];return _bO_}
        catch(_bP_)
         {_bP_ = caml_wrap_exception(_bP_);
          if(_bP_ === Not_found)return 0;
          throw _bP_}}
      function get_rank(k,m)
       {var i=0,m$0=m;
        for(;;)
         {if(m$0)
           {var r=m$0[4],l=m$0[3],k$0=m$0[1],n=caml_call2(K[1],k,k$0);
            if(0 === n)return [0,14611,i + weight(l) | 0];
            if(0 <= n)
             {var i$0=(1 + weight(l) | 0) + i | 0,i=i$0,m$0=r;continue}
            var m$0=l;
            continue}
          return 0 === i?332064784:[0,818927100,i]}}
      function fold(f,acc,m)
       {var acc$0=acc,m$0=m;
        for(;;)
         {if(m$0)
           {var
             r=m$0[4],
             l=m$0[3],
             v=m$0[2],
             k=m$0[1],
             acc$1=fold(f,acc$0,l),
             acc$2=caml_call3(f,acc$1,k,v),
             acc$0=acc$2,
             m$0=r;
            continue}
          return acc$0}}
      function mapi(f,param)
       {if(param)
         {var
           w=param[5],
           r=param[4],
           l=param[3],
           v=param[2],
           k=param[1],
           _bM_=mapi(f,r),
           _bN_=mapi(f,l);
          return [0,k,caml_call2(f,k,v),_bN_,_bM_,w]}
        return 0}
      function map(f,param)
       {if(param)
         {var
           w=param[5],
           r=param[4],
           l=param[3],
           v=param[2],
           k=param[1],
           _bK_=map(f,r),
           _bL_=map(f,l);
          return [0,k,caml_call1(f,v),_bL_,_bK_,w]}
        return 0}
      function iter(f,m)
       {var m$0=m;
        for(;;)
         {if(m$0)
           {var r=m$0[4],l=m$0[3],v=m$0[2],k=m$0[1];
            iter(f,l);
            caml_call2(f,k,v);
            var m$0=r;
            continue}
          return 0}}
      function choose_exn(param)
       {if(param){var v=param[2],k=param[1];return [0,k,v]}throw Not_found}
      function choose(param)
       {if(param){var v=param[2],k=param[1];return [0,[0,k,v]]}return 0}
      function random_choose(st,m)
       {var w=weight(m);
        if(0 === w)throw Not_found;
        return nth_exn(caml_call2(Random[11][5],st,w),m)}
      function node_shallow(k,v,l,r)
       {return is_balanced(l,r)
                ?is_balanced(r,l)?mk_node(k,v,l,r):balance_r(k,v,l,r)
                :balance_l(k,v,l,r)}
      function node(k,v,l,r)
       {if(l)
         {if(r)
           {var
             rr=r[4],
             rl=r[3],
             vr=r[2],
             kr=r[1],
             lr=l[4],
             ll=l[3],
             vl=l[2],
             kl=l[1],
             left=is_balanced(l,r);
            if(left)if(is_balanced(r,l))return mk_node(k,v,l,r);
            return left
                    ?node_shallow(kl,vl,ll,node(k,v,lr,r))
                    :node_shallow(kr,vr,node(k,v,l,rl),rr)}
          var o=l}
        else
         {if(! r)return singleton(k,v);var o=r}
        return add(k,v,o)}
      function mk_node_or_join(k$1,o_v,l$0,r$0)
       {if(o_v){var v$1=o_v[1];return node(k$1,v$1,l$0,r$0)}
        if(l$0)
         {if(r$0)
           {var _bJ_=weight(r$0);
            if(weight(l$0) <= _bJ_)
             {var match=extract_min(r$0),r=match[3],v=match[2],k=match[1];
              return node(k,v,l$0,r)}
            var
             match$0=extract_max(l$0),
             l=match$0[3],
             v$0=match$0[2],
             k$0=match$0[1];
            return node(k$0,v$0,l,r$0)}
          var o=l$0}
        else
         {if(! r$0)return 0;var o=r$0}
        return o}
      function split(k,m)
       {if(m)
         {var r=m[4],l=m[3],v=m[2],k$0=m[1],n=caml_call2(K[1],k,k$0);
          if(0 === n)return [0,l,[0,v],r];
          if(0 <= n)
           {var match=split(k,r),rr=match[3],o=match[2],rl=match[1];
            return [0,node(k$0,v,l,rl),o,rr]}
          var match$0=split(k,l),lr=match$0[3],o$0=match$0[2],ll=match$0[1];
          return [0,ll,o$0,node(k$0,v,lr,r)]}
        return _be_}
      function merge(f,a,match)
       {if(a)
         {var _bx_=a[4],_by_=a[3],_bz_=a[2],_bA_=a[1],_bw_=a[5];
          if(match)
           {var w2=match[5],r2=match[4],l2=match[3],v2=match[2],k2=match[1];
            if(0 === caml_call2(K[1],_bA_,k2))
             {var _bB_=merge(f,_bx_,r2),_bC_=merge(f,_by_,l2);
              return mk_node_or_join
                      (_bA_,caml_call3(f,_bA_,[0,_bz_],[0,v2]),_bC_,_bB_)}
            if(_bw_ <= w2)
             {var
               match$0=split(k2,a),
               r1=match$0[3],
               v1=match$0[2],
               l1=match$0[1],
               _bD_=merge(f,r1,r2),
               _bE_=merge(f,l1,l2);
              return mk_node_or_join(k2,caml_call3(f,k2,v1,[0,v2]),_bE_,_bD_)}
            var
             match$1=split(_bA_,match),
             r2$0=match$1[3],
             v2$0=match$1[2],
             l2$0=match$1[1],
             _bF_=merge(f,_bx_,r2$0),
             _bG_=merge(f,_by_,l2$0);
            return mk_node_or_join
                    (_bA_,caml_call3(f,_bA_,[0,_bz_],v2$0),_bG_,_bF_)}
          var v=caml_call3(f,_bA_,[0,_bz_],0),_bH_=merge(f,_bx_,0);
          return mk_node_or_join(_bA_,v,merge(f,_by_,0),_bH_)}
        if(match)
         {var
           r=match[4],
           l=match[3],
           v$0=match[2],
           k=match[1],
           v$1=caml_call3(f,k,0,[0,v$0]),
           _bI_=merge(f,0,r);
          return mk_node_or_join(k,v$1,merge(f,0,l),_bI_)}
        return 0}
      function cardinal(m)
       {var _bu_=0;
        return fold(function(acc,param,_bv_){return acc + 1 | 0},_bu_,m)}
      function add_list(m,l)
       {function _bt_(acc,param)
         {var v=param[2],k=param[1];return add(k,v,acc)}
        return caml_call3(List[20],_bt_,m,l)}
      function of_list(l){return add_list(empty,l)}
      function to_list(m)
       {var _bs_=0;
        return fold(function(acc,k,v){return [0,[0,k,v],acc]},_bs_,m)}
      function add_seq(m,seq)
       {var m$0=[0,m];
        caml_call1
         (seq,
          function(param)
           {var v=param[2],k=param[1];m$0[1] = add(k,v,m$0[1]);return 0});
        return m$0[1]}
      function of_seq(s){return add_seq(empty,s)}
      function to_seq(m,yield$0)
       {return iter(function(k,v){return caml_call1(yield$0,[0,k,v])},m)}
      function add_gen(m,g)
       {var m$0=m;
        for(;;)
         {var match=caml_call1(g,0);
          if(match)
           {var
             match$0=match[1],
             v=match$0[2],
             k=match$0[1],
             m$1=add(k,v,m$0),
             m$0=m$1;
            continue}
          return m$0}}
      function of_gen(g){return add_gen(empty,g)}
      function to_gen(m)
       {var st=caml_call1(Stack[2],0);
        caml_call2(Stack[3],m,st);
        function next(param)
         {for(;;)
           {if(caml_call1(Stack[8],st))return 0;
            var match=caml_call1(Stack[4],st);
            if(match)
             {var r=match[4],l=match[3],v=match[2],k=match[1];
              caml_call2(Stack[3],r,st);
              caml_call2(Stack[3],l,st);
              return [0,[0,k,v]]}
            continue}}
        return next}
      function pp(pp_k,pp_v,fmt,m)
       {caml_call2(Format[13],fmt,start);
        var first=[0,1];
        iter
         (function(k,v)
           {if(first[1])first[1] = 0;else caml_call2(Format[13],fmt,sep);
            caml_call2(pp_k,fmt,k);
            caml_call2(Format[13],fmt,arrow);
            caml_call2(pp_v,fmt,v);
            return caml_call2(Format[27],fmt,0)},
          m);
        return caml_call2(Format[13],fmt,stop)}
      return [0,
              empty,
              is_empty,
              singleton,
              mem,
              get,
              get_exn,
              nth,
              nth_exn,
              get_rank,
              add,
              remove,
              update,
              cardinal,
              weight,
              fold,
              mapi,
              map,
              iter,
              split,
              merge,
              extract_min,
              extract_max,
              choose,
              choose_exn,
              random_choose,
              add_list,
              of_list,
              to_list,
              add_seq,
              of_seq,
              to_seq,
              add_gen,
              of_gen,
              to_gen,
              pp,
              node,
              balanced]}
    function Make$8(X)
     {var compare=X[1];
      function weight(param){return 1}
      return MakeFull([0,compare,weight])}
    var CCWBTree=[0,Make$8,MakeFull];
    caml_register_global(227,CCWBTree,"CCWBTree");
    function is_empty$6(param){if(! param[1])if(! param[2])return 1;return 0}
    function to_list$11(param)
     {var r=param[2],l=param[1];return caml_call2(List[12],l,r)}
    function to_rev_list$0(param)
     {var r=param[2],l=param[1];return caml_call2(List[12],r,l)}
    function make$4(l){return [0,0,l]}
    function left(param)
     {var _br_=param[1];
      if(_br_){var r=param[2],l=_br_[2],x=_br_[1];return [0,l,[0,x,r]]}
      var r$0=param[2];
      return [0,0,r$0]}
    function left_exn(param)
     {var _bq_=param[1];
      if(_bq_){var r=param[2],l=_bq_[2],x=_bq_[1];return [0,l,[0,x,r]]}
      return caml_call1(Pervasives[1],cst_zipper_left_exn)}
    function right(param)
     {var _bo_=param[2],_bp_=param[1];
      if(_bo_){var r=_bo_[2],x=_bo_[1];return [0,[0,x,_bp_],r]}
      return [0,_bp_,0]}
    function right_exn(param)
     {var _bm_=param[2],_bn_=param[1];
      if(_bm_){var r=_bm_[2],x=_bm_[1];return [0,[0,x,_bn_],r]}
      return caml_call1(Pervasives[1],cst_zipper_right_exn)}
    function modify(f,z)
     {var _bk_=z[2],_bl_=z[1];
      if(_bk_)
       {var r=_bk_[2],x=_bk_[1],match=caml_call1(f,[0,x]);
        return match?[0,_bl_,[0,x,r]]:[0,_bl_,r]}
      var match$0=caml_call1(f,0);
      if(match$0){var x$0=match$0[1];return [0,_bl_,[0,x$0,0]]}
      return z}
    function is_focused(param){return param[2]?1:0}
    function focused(param)
     {var _bj_=param[2];if(_bj_){var x=_bj_[1];return [0,x]}return 0}
    function focused_exn(param)
     {var _bi_=param[2];if(_bi_){var x=_bi_[1];return x}throw Not_found}
    function insert$0(x,param){var r=param[2],l=param[1];return [0,l,[0,x,r]]}
    function remove$2(param)
     {var r=param[2],l=param[1];
      if(r){var r$0=r[2];return [0,l,r$0]}
      return [0,l,0]}
    function drop_before(param){var r=param[2];return [0,0,r]}
    function drop_after(param)
     {var r=param[2],l=param[1];
      if(r){var x=r[1];return [0,l,[0,x,0]]}
      return [0,l,0]}
    function drop_after_and_focused(param){var l=param[1];return [0,l,0]}
    var
     CCZipper=
      [0,
       empty$9,
       is_empty$6,
       to_list$11,
       to_rev_list$0,
       make$4,
       left,
       left_exn,
       right,
       right_exn,
       modify,
       insert$0,
       remove$2,
       is_focused,
       focused,
       focused_exn,
       drop_before,
       drop_after,
       drop_after_and_focused];
    caml_register_global(228,CCZipper,"CCZipper");
    return}
  (function(){return this}()));


//# 1 ".js/unix/unix.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_sys_exit=runtime.caml_sys_exit,
     caml_wrap_exception=runtime.caml_wrap_exception,
     unix_inet_addr_of_string=runtime.unix_inet_addr_of_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_close_process_full=caml_new_string("close_process_full"),
     cst_close_process=caml_new_string("close_process"),
     cst_close_process_out=caml_new_string("close_process_out"),
     cst_close_process_in=caml_new_string("close_process_in"),
     cst$9=caml_new_string(""),
     shell=caml_new_string("/bin/sh"),
     cst_c$0=caml_new_string("-c"),
     cst_c=caml_new_string("-c"),
     cst_bin_sh$0=caml_new_string("/bin/sh"),
     cst_bin_sh$1=caml_new_string("/bin/sh"),
     cst$8=caml_new_string(""),
     cst_udp$1=caml_new_string("udp"),
     cst_tcp$1=caml_new_string("tcp"),
     cst$5=caml_new_string(""),
     cst$7=caml_new_string(""),
     cst_tcp=caml_new_string("tcp"),
     cst_udp=caml_new_string("udp"),
     cst_udp$0=caml_new_string("udp"),
     cst_tcp$0=caml_new_string("tcp"),
     cst$6=caml_new_string(""),
     cst_0_0_0_0$0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1$0=caml_new_string("127.0.0.1"),
     cst_Unix_sendto=caml_new_string("Unix.sendto"),
     cst_Unix_send=caml_new_string("Unix.send"),
     cst_Unix_recvfrom=caml_new_string("Unix.recvfrom"),
     cst_Unix_recv=caml_new_string("Unix.recv"),
     cst_Unix_single_write=caml_new_string("Unix.single_write"),
     cst_Unix_write=caml_new_string("Unix.write"),
     cst_Unix_read=caml_new_string("Unix.read"),
     cst$4=caml_new_string(""),
     cst_execvpe=caml_new_string("execvpe"),
     cst_bin_sh=caml_new_string("/bin/sh"),
     cst_PATH=caml_new_string("PATH"),
     cst_bin_usr_bin=caml_new_string("/bin:/usr/bin"),
     cst$1=caml_new_string(': "'),
     cst_failed=caml_new_string('" failed'),
     cst_on=caml_new_string(' on "'),
     cst$2=caml_new_string('"'),
     cst$3=caml_new_string(": "),
     cst_E2BIG=caml_new_string("E2BIG"),
     cst_EACCES=caml_new_string("EACCES"),
     cst_EAGAIN=caml_new_string("EAGAIN"),
     cst_EBADF=caml_new_string("EBADF"),
     cst_EBUSY=caml_new_string("EBUSY"),
     cst_ECHILD=caml_new_string("ECHILD"),
     cst_EDEADLK=caml_new_string("EDEADLK"),
     cst_EDOM=caml_new_string("EDOM"),
     cst_EEXIST=caml_new_string("EEXIST"),
     cst_EFAULT=caml_new_string("EFAULT"),
     cst_EFBIG=caml_new_string("EFBIG"),
     cst_EINTR=caml_new_string("EINTR"),
     cst_EINVAL=caml_new_string("EINVAL"),
     cst_EIO=caml_new_string("EIO"),
     cst_EISDIR=caml_new_string("EISDIR"),
     cst_EMFILE=caml_new_string("EMFILE"),
     cst_EMLINK=caml_new_string("EMLINK"),
     cst_ENAMETOOLONG=caml_new_string("ENAMETOOLONG"),
     cst_ENFILE=caml_new_string("ENFILE"),
     cst_ENODEV=caml_new_string("ENODEV"),
     cst_ENOENT=caml_new_string("ENOENT"),
     cst_ENOEXEC=caml_new_string("ENOEXEC"),
     cst_ENOLCK=caml_new_string("ENOLCK"),
     cst_ENOMEM=caml_new_string("ENOMEM"),
     cst_ENOSPC=caml_new_string("ENOSPC"),
     cst_ENOSYS=caml_new_string("ENOSYS"),
     cst_ENOTDIR=caml_new_string("ENOTDIR"),
     cst_ENOTEMPTY=caml_new_string("ENOTEMPTY"),
     cst_ENOTTY=caml_new_string("ENOTTY"),
     cst_ENXIO=caml_new_string("ENXIO"),
     cst_EPERM=caml_new_string("EPERM"),
     cst_EPIPE=caml_new_string("EPIPE"),
     cst_ERANGE=caml_new_string("ERANGE"),
     cst_EROFS=caml_new_string("EROFS"),
     cst_ESPIPE=caml_new_string("ESPIPE"),
     cst_ESRCH=caml_new_string("ESRCH"),
     cst_EXDEV=caml_new_string("EXDEV"),
     cst_EWOULDBLOCK=caml_new_string("EWOULDBLOCK"),
     cst_EINPROGRESS=caml_new_string("EINPROGRESS"),
     cst_EALREADY=caml_new_string("EALREADY"),
     cst_ENOTSOCK=caml_new_string("ENOTSOCK"),
     cst_EDESTADDRREQ=caml_new_string("EDESTADDRREQ"),
     cst_EMSGSIZE=caml_new_string("EMSGSIZE"),
     cst_EPROTOTYPE=caml_new_string("EPROTOTYPE"),
     cst_ENOPROTOOPT=caml_new_string("ENOPROTOOPT"),
     cst_EPROTONOSUPPORT=caml_new_string("EPROTONOSUPPORT"),
     cst_ESOCKTNOSUPPORT=caml_new_string("ESOCKTNOSUPPORT"),
     cst_EOPNOTSUPP=caml_new_string("EOPNOTSUPP"),
     cst_EPFNOSUPPORT=caml_new_string("EPFNOSUPPORT"),
     cst_EAFNOSUPPORT=caml_new_string("EAFNOSUPPORT"),
     cst_EADDRINUSE=caml_new_string("EADDRINUSE"),
     cst_EADDRNOTAVAIL=caml_new_string("EADDRNOTAVAIL"),
     cst_ENETDOWN=caml_new_string("ENETDOWN"),
     cst_ENETUNREACH=caml_new_string("ENETUNREACH"),
     cst_ENETRESET=caml_new_string("ENETRESET"),
     cst_ECONNABORTED=caml_new_string("ECONNABORTED"),
     cst_ECONNRESET=caml_new_string("ECONNRESET"),
     cst_ENOBUFS=caml_new_string("ENOBUFS"),
     cst_EISCONN=caml_new_string("EISCONN"),
     cst_ENOTCONN=caml_new_string("ENOTCONN"),
     cst_ESHUTDOWN=caml_new_string("ESHUTDOWN"),
     cst_ETOOMANYREFS=caml_new_string("ETOOMANYREFS"),
     cst_ETIMEDOUT=caml_new_string("ETIMEDOUT"),
     cst_ECONNREFUSED=caml_new_string("ECONNREFUSED"),
     cst_EHOSTDOWN=caml_new_string("EHOSTDOWN"),
     cst_EHOSTUNREACH=caml_new_string("EHOSTUNREACH"),
     cst_ELOOP=caml_new_string("ELOOP"),
     cst_EOVERFLOW=caml_new_string("EOVERFLOW"),
     cst_Unix_Unix_error=caml_new_string("Unix.Unix_error"),
     cst=caml_new_string(""),
     cst$0=caml_new_string(""),
     cst_Unix_Unix_error$0=caml_new_string("Unix.Unix_error"),
     cst_0_0_0_0=caml_new_string("0.0.0.0"),
     cst_127_0_0_1=caml_new_string("127.0.0.1"),
     cst$10=caml_new_string("::"),
     cst_1=caml_new_string("::1"),
     Pervasives=global_data.Pervasives,
     Sys_error=global_data.Sys_error,
     Hashtbl=global_data.Hashtbl,
     Not_found=global_data.Not_found,
     Invalid_argument=global_data.Invalid_argument,
     List=global_data.List,
     Failure=global_data.Failure,
     Array=global_data.Array,
     Bytes=global_data.Bytes,
     Filename=global_data.Filename,
     String=global_data.String,
     Sys=global_data.Sys,
     Printf=global_data.Printf,
     Callback=global_data.Callback,
     Printexc=global_data.Printexc,
     Unix_error=[248,cst_Unix_Unix_error,runtime.caml_fresh_oo_id(0)];
    caml_call2(Callback[2],cst_Unix_Unix_error$0,[0,Unix_error,0,cst$0,cst]);
    var
     _p_=[0,1],
     _q_=[0,1],
     _o_=[0,1],
     _l_=[0,1],
     _m_=[0,1],
     _n_=[0,1],
     _j_=[0,1],
     _k_=[0,1],
     _i_=[0,1],
     _h_=[0,1],
     _e_=[0,0],
     _f_=[0,0],
     _g_=[0,0],
     _d_=[255,0,0,0],
     _c_=
      [0,
       [11,caml_new_string("EUNKNOWNERR "),[4,0,0,0,0]],
       caml_new_string("EUNKNOWNERR %d")],
     _b_=
      [0,
       [11,
        caml_new_string("Unix.Unix_error(Unix."),
        [2,
         0,
         [11,
          caml_new_string(", "),
          [3,0,[11,caml_new_string(", "),[3,0,[12,41,0]]]]]]],
       caml_new_string("Unix.Unix_error(Unix.%s, %S, %S)")];
    function _a_(param)
     {if(param[1] === Unix_error)
       {var s=param[4],s$0=param[3],e=param[2];
        if(typeof e === "number")
         {var _dx_=e;
          if(34 <= _dx_)
           switch(_dx_)
            {case 34:var msg=cst_ESPIPE;break;
             case 35:var msg=cst_ESRCH;break;
             case 36:var msg=cst_EXDEV;break;
             case 37:var msg=cst_EWOULDBLOCK;break;
             case 38:var msg=cst_EINPROGRESS;break;
             case 39:var msg=cst_EALREADY;break;
             case 40:var msg=cst_ENOTSOCK;break;
             case 41:var msg=cst_EDESTADDRREQ;break;
             case 42:var msg=cst_EMSGSIZE;break;
             case 43:var msg=cst_EPROTOTYPE;break;
             case 44:var msg=cst_ENOPROTOOPT;break;
             case 45:var msg=cst_EPROTONOSUPPORT;break;
             case 46:var msg=cst_ESOCKTNOSUPPORT;break;
             case 47:var msg=cst_EOPNOTSUPP;break;
             case 48:var msg=cst_EPFNOSUPPORT;break;
             case 49:var msg=cst_EAFNOSUPPORT;break;
             case 50:var msg=cst_EADDRINUSE;break;
             case 51:var msg=cst_EADDRNOTAVAIL;break;
             case 52:var msg=cst_ENETDOWN;break;
             case 53:var msg=cst_ENETUNREACH;break;
             case 54:var msg=cst_ENETRESET;break;
             case 55:var msg=cst_ECONNABORTED;break;
             case 56:var msg=cst_ECONNRESET;break;
             case 57:var msg=cst_ENOBUFS;break;
             case 58:var msg=cst_EISCONN;break;
             case 59:var msg=cst_ENOTCONN;break;
             case 60:var msg=cst_ESHUTDOWN;break;
             case 61:var msg=cst_ETOOMANYREFS;break;
             case 62:var msg=cst_ETIMEDOUT;break;
             case 63:var msg=cst_ECONNREFUSED;break;
             case 64:var msg=cst_EHOSTDOWN;break;
             case 65:var msg=cst_EHOSTUNREACH;break;
             case 66:var msg=cst_ELOOP;break;
             default:var msg=cst_EOVERFLOW}
          else
           switch(_dx_)
            {case 0:var msg=cst_E2BIG;break;
             case 1:var msg=cst_EACCES;break;
             case 2:var msg=cst_EAGAIN;break;
             case 3:var msg=cst_EBADF;break;
             case 4:var msg=cst_EBUSY;break;
             case 5:var msg=cst_ECHILD;break;
             case 6:var msg=cst_EDEADLK;break;
             case 7:var msg=cst_EDOM;break;
             case 8:var msg=cst_EEXIST;break;
             case 9:var msg=cst_EFAULT;break;
             case 10:var msg=cst_EFBIG;break;
             case 11:var msg=cst_EINTR;break;
             case 12:var msg=cst_EINVAL;break;
             case 13:var msg=cst_EIO;break;
             case 14:var msg=cst_EISDIR;break;
             case 15:var msg=cst_EMFILE;break;
             case 16:var msg=cst_EMLINK;break;
             case 17:var msg=cst_ENAMETOOLONG;break;
             case 18:var msg=cst_ENFILE;break;
             case 19:var msg=cst_ENODEV;break;
             case 20:var msg=cst_ENOENT;break;
             case 21:var msg=cst_ENOEXEC;break;
             case 22:var msg=cst_ENOLCK;break;
             case 23:var msg=cst_ENOMEM;break;
             case 24:var msg=cst_ENOSPC;break;
             case 25:var msg=cst_ENOSYS;break;
             case 26:var msg=cst_ENOTDIR;break;
             case 27:var msg=cst_ENOTEMPTY;break;
             case 28:var msg=cst_ENOTTY;break;
             case 29:var msg=cst_ENXIO;break;
             case 30:var msg=cst_EPERM;break;
             case 31:var msg=cst_EPIPE;break;
             case 32:var msg=cst_ERANGE;break;
             default:var msg=cst_EROFS}}
        else
         var x=e[1],msg=caml_call2(Printf[4],_c_,x);
        return [0,caml_call4(Printf[4],_b_,msg,s$0,s)]}
      return 0}
    caml_call1(Printexc[8],_a_);
    function handle_unix_error(f,arg)
     {try
       {var _dw_=caml_call1(f,arg);return _dw_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Unix_error)
         {var
           arg$0=exn[4],
           fun_name=exn[3],
           err=exn[2],
           _du_=caml_check_bound(Sys[1],0)[1];
          caml_call1(Pervasives[37],_du_);
          caml_call1(Pervasives[37],cst$1);
          caml_call1(Pervasives[37],fun_name);
          caml_call1(Pervasives[37],cst_failed);
          if(0 < caml_ml_string_length(arg$0))
           {caml_call1(Pervasives[37],cst_on);
            caml_call1(Pervasives[37],arg$0);
            caml_call1(Pervasives[37],cst$2)}
          caml_call1(Pervasives[37],cst$3);
          var _dv_=runtime.unix_error_message(err);
          caml_call1(Pervasives[41],_dv_);
          return caml_call1(Pervasives[87],2)}
        throw exn}}
    function execvpe(name,args,env)
     {try
       {var _do_=runtime.unix_execvpe(name,args,env);return _do_}
      catch(_dp_)
       {_dp_ = caml_wrap_exception(_dp_);
        if(_dp_[1] === Unix_error)
         {var _dn_=_dp_[2];
          if(typeof _dn_ === "number")
           if(25 === _dn_)
            {var
              exec=
               function(file)
                {try
                  {var _ds_=runtime.unix_execve(file,args,env);return _ds_}
                 catch(_dt_)
                  {_dt_ = caml_wrap_exception(_dt_);
                   if(_dt_[1] === Unix_error)
                    {var _dr_=_dt_[2];
                     if(typeof _dr_ === "number")
                      if(21 === _dr_)
                       {var
                         argc=args.length - 1,
                         args$0=
                          0 === argc?args:caml_call3(Array[7],args,1,argc - 1 | 0),
                         new_args=caml_call2(Array[5],[0,cst_bin_sh,file],args$0);
                        return runtime.unix_execve
                                (caml_check_bound(new_args,0)[1],new_args,env)}}
                   throw _dt_}};
             if(caml_call2(String[22],name,47))return exec(name);
             try
              {var _dm_=runtime.caml_sys_unsafe_getenv(cst_PATH),_dl_=_dm_}
             catch(_dq_)
              {_dq_ = caml_wrap_exception(_dq_);
               if(_dq_ !== Not_found)throw _dq_;
               var _dl_=cst_bin_usr_bin}
             var
              param$0=caml_call2(String[35],58,_dl_),
              eacces=0,
              param=param$0;
             for(;;)
              {if(param)
                {var
                  rem=param[2],
                  dir=param[1],
                  dir$0=caml_string_equal(dir,cst$4)?Filename[1]:dir;
                 try
                  {var _dj_=exec(caml_call2(Filename[4],dir$0,name));
                   return _dj_}
                 catch(exn)
                  {exn = caml_wrap_exception(exn);
                   if(exn[1] === Unix_error)
                    {var err=exn[2];
                     if(typeof err === "number")
                      {var _di_=err - 62 | 0;
                       if(4 < _di_ >>> 0)
                        if(-35 <= _di_)
                         var switch$0=0;
                        else
                         {var switcher=_di_ + 62 | 0;
                          switch(switcher)
                           {case 1:var eacces=1,param=rem;continue;
                            case 14:
                            case 17:
                            case 19:
                            case 20:
                            case 26:var switch$0=1;break;
                            default:var switch$0=0}}
                       else
                        var switch$0=2 < (_di_ - 1 | 0) >>> 0?1:0;
                       if(switch$0){var param=rem;continue}}
                     throw exn}
                   throw exn}}
               var _dk_=eacces?1:20;
               throw [0,Unix_error,_dk_,cst_execvpe,name]}}}
        throw _dp_}}
    var stdin=0,stdout=1,stderr=2;
    function read(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_read(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_read)}
    function write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_write)}
    function single_write(fd,buf,ofs,len)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_single_write(fd,buf,ofs,len);
      return caml_call1(Pervasives[1],cst_Unix_single_write)}
    function write_substring(fd,buf,ofs,len)
     {return write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function single_write_substring(fd,buf,ofs,len)
     {return single_write(fd,caml_call1(Bytes[43],buf),ofs,len)}
    function map_file(fd,opt,kind,layout,shared,dims)
     {if(opt)var sth=opt[1],pos=sth;else var pos=_d_;
      return runtime.caml_unix_map_file_bytecode
              (fd,kind,layout,shared,dims,pos)}
    function pause(param)
     {var sigs=runtime.unix_sigprocmask(1,0);
      return runtime.unix_sigsuspend(sigs)}
    function sleep(duration){return runtime.unix_sleep(duration)}
    var
     inet_addr_any=unix_inet_addr_of_string(cst_0_0_0_0),
     inet_addr_loopback=unix_inet_addr_of_string(cst_127_0_0_1);
    try
     {var _z_=unix_inet_addr_of_string(cst$10),inet_addr_any$0=_z_}
    catch(_dh_)
     {_dh_ = caml_wrap_exception(_dh_);
      if(_dh_[1] !== Failure)throw _dh_;
      var inet_addr_any$0=inet_addr_any}
    try
     {var _y_=unix_inet_addr_of_string(cst_1),inet6_addr_loopback=_y_}
    catch(_dg_)
     {_dg_ = caml_wrap_exception(_dg_);
      if(_dg_[1] !== Failure)throw _dg_;
      var inet6_addr_loopback=inet_addr_loopback}
    function domain_of_sockaddr(param)
     {if(0 === param[0])return 0;
      var a=param[1];
      return 16 === caml_ml_string_length(a)?2:1}
    function recv(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recv(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recv)}
    function recvfrom(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_recvfrom(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_recvfrom)}
    function send(fd,buf,ofs,len,flags)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_send(fd,buf,ofs,len,flags);
      return caml_call1(Pervasives[1],cst_Unix_send)}
    function sendto(fd,buf,ofs,len,flags,addr)
     {if(0 <= ofs)
       if(0 <= len)
        if(! ((caml_ml_bytes_length(buf) - len | 0) < ofs))
         return runtime.unix_sendto(fd,buf,ofs,len,flags,addr);
      return caml_call1(Pervasives[1],cst_Unix_sendto)}
    function send_substring(fd,buf,ofs,len,flags)
     {return send(fd,caml_call1(Bytes[43],buf),ofs,len,flags)}
    function sendto_substring(fd,buf,ofs,len,flags,addr)
     {return sendto(fd,caml_call1(Bytes[43],buf),ofs,len,flags,addr)}
    function getsockopt(fd,opt){return runtime.unix_getsockopt(0,fd,opt)}
    function setsockopt(fd,opt,v){return runtime.unix_setsockopt(0,fd,opt,v)}
    function getsockopt_int(fd,opt){return runtime.unix_getsockopt(1,fd,opt)}
    function setsockopt_int(fd,opt,v)
     {return runtime.unix_setsockopt(1,fd,opt,v)}
    function getsockopt_optint(fd,opt)
     {return runtime.unix_getsockopt(2,fd,opt)}
    function setsockopt_optint(fd,opt,v)
     {return runtime.unix_setsockopt(2,fd,opt,v)}
    function getsockopt_float(fd,opt)
     {return runtime.unix_getsockopt(3,fd,opt)}
    function setsockopt_float(fd,opt,v)
     {return runtime.unix_setsockopt(3,fd,opt,v)}
    function getsockopt_error(fd){return runtime.unix_getsockopt(4,fd,0)}
    function getaddrinfo(node,service,opts)
     {try
       {var
         _c8_=runtime.unix_getaddrinfo(node,service,opts),
         _c9_=caml_call1(List[9],_c8_);
        return _c9_}
      catch(_c__)
       {_c__ = caml_wrap_exception(_c__);
        if(_c__[1] === Invalid_argument)
         {var
           opt_socktype=[0,0],
           opt_protocol=[0,0],
           opt_passive=[0,0],
           _cV_=
            function(param)
             {if(typeof param === "number")
               {if(2 === param){opt_passive[1] = 1;return 0}}
              else
               switch(param[0])
                {case 1:var s=param[1];opt_socktype[1] = [0,s];return 0;
                 case 2:var p=param[1];opt_protocol[1] = p;return 0
                 }
              return 0};
          caml_call2(List[15],_cV_,opts);
          var
           get_port=
            function(ty,kind)
             {if(caml_string_equal(service,cst$5))return [0,[0,ty,0],0];
              try
               {var _dd_=[0,[0,ty,runtime.caml_int_of_string(service)],0];
                return _dd_}
              catch(_de_)
               {_de_ = caml_wrap_exception(_de_);
                if(_de_[1] === Failure)
                 try
                  {var
                    _dc_=
                     [0,[0,ty,runtime.unix_getservbyname(service,kind)[3]],0];
                   return _dc_}
                 catch(_df_)
                  {_df_ = caml_wrap_exception(_df_);
                   if(_df_ === Not_found)return 0;
                   throw _df_}
                throw _de_}},
           _cW_=opt_socktype[1];
          if(_cW_)
           var
            _cX_=_cW_[1],
            _cY_=
             1 === _cX_
              ?get_port(1,cst_udp)
              :0 === _cX_
                ?get_port(0,cst_tcp)
                :caml_string_equal(service,cst$7)?[0,[0,_cX_,0],0]:0,
            ports=_cY_;
          else
           var
            _c6_=get_port(1,cst_udp$0),
            _c7_=get_port(0,cst_tcp$0),
            ports=caml_call2(Pervasives[25],_c7_,_c6_);
          if(caml_string_equal(node,cst$6))
           var
            addresses=
             caml_call2(List[31],2,opts)
              ?[0,[0,inet_addr_any,cst_0_0_0_0$0],0]
              :[0,[0,inet_addr_loopback,cst_127_0_0_1$0],0];
          else
           try
            {var
              _c5_=[0,[0,unix_inet_addr_of_string(node),node],0],
              addresses=_c5_}
           catch(_da_)
            {_da_ = caml_wrap_exception(_da_);
             if(_da_[1] !== Failure)throw _da_;
             try
              {var
                he=runtime.unix_gethostbyname(node),
                _c2_=caml_call1(Array[11],he[4]),
                _c3_=function(a){return [0,a,he[1]]},
                _c4_=caml_call2(List[17],_c3_,_c2_),
                _c1_=_c4_}
             catch(_db_)
              {_db_ = caml_wrap_exception(_db_);
               if(_db_ !== Not_found)throw _db_;
               var _c1_=0}
             var addresses=_c1_}
          var
           _cZ_=
            function(param)
             {var port=param[2],ty=param[1];
              function _c$_(param)
               {var name=param[2],addr=param[1];
                return [0,1,ty,opt_protocol[1],[1,addr,port],name]}
              return caml_call2(List[17],_c$_,addresses)},
           _c0_=caml_call2(List[17],_cZ_,ports);
          return caml_call1(List[14],_c0_)}
        throw _c__}}
    function getnameinfo(addr,opts)
     {try
       {var _cR_=runtime.unix_getnameinfo(addr,opts);return _cR_}
      catch(_cS_)
       {_cS_ = caml_wrap_exception(_cS_);
        if(_cS_[1] === Invalid_argument)
         {if(0 === addr[0]){var f=addr[1];return [0,cst$8,f]}
          var p=addr[2],a=addr[1];
          try
           {if(caml_call2(List[31],1,opts))throw Not_found;
            var _cQ_=runtime.unix_gethostbyaddr(a)[1],hostname=_cQ_}
          catch(_cU_)
           {_cU_ = caml_wrap_exception(_cU_);
            if(_cU_ !== Not_found)throw _cU_;
            if(caml_call2(List[31],2,opts))throw Not_found;
            var hostname=runtime.unix_string_of_inet_addr(a)}
          try
           {if(caml_call2(List[31],3,opts))throw Not_found;
            var
             kind=caml_call2(List[31],4,opts)?cst_udp$1:cst_tcp$1,
             _cP_=runtime.unix_getservbyport(p,kind)[1],
             service=_cP_}
          catch(_cT_)
           {_cT_ = caml_wrap_exception(_cT_);
            if(_cT_ !== Not_found)throw _cT_;
            var service=caml_call1(Pervasives[21],p)}
          return [0,hostname,service]}
        throw _cS_}}
    function waitpid_non_intr(pid)
     {for(;;)
       try
        {var _cN_=runtime.unix_waitpid(0,pid);return _cN_}
       catch(_cO_)
        {_cO_ = caml_wrap_exception(_cO_);
         if(_cO_[1] === Unix_error)
          {var _cM_=_cO_[2];
           if(typeof _cM_ === "number")if(11 === _cM_)continue}
         throw _cO_}}
    function system(cmd)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {var _cK_=runtime.unix_execv(cst_bin_sh$1,[0,cst_bin_sh$0,cst_c,cmd]);
         return _cK_}
       catch(_cL_){return caml_sys_exit(127)}
      return waitpid_non_intr(id)[2]}
    function file_descr_not_standard(fd)
     {var fd$0=fd;
      for(;;)
       {if(3 <= fd$0)return fd$0;
        var fd$1=runtime.unix_dup(0,fd$0),fd$0=fd$1;
        continue}}
    function safe_close(fd)
     {try
       {var _cI_=runtime.unix_close(fd);return _cI_}
      catch(_cJ_)
       {_cJ_ = caml_wrap_exception(_cJ_);
        if(_cJ_[1] === Unix_error)return 0;
        throw _cJ_}}
    function perform_redirections(new_stdin,new_stdout,new_stderr)
     {var
       new_stdin$0=file_descr_not_standard(new_stdin),
       new_stdout$0=file_descr_not_standard(new_stdout),
       new_stderr$0=file_descr_not_standard(new_stderr);
      runtime.unix_dup2(_e_,new_stdin$0,0);
      runtime.unix_dup2(_f_,new_stdout$0,1);
      runtime.unix_dup2(_g_,new_stderr$0,2);
      safe_close(new_stdin$0);
      safe_close(new_stdout$0);
      return safe_close(new_stderr$0)}
    function create_process(cmd,args,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cG_=runtime.unix_execvp(cmd,args);
         return _cG_}
       catch(_cH_){return caml_sys_exit(127)}
      return id}
    function create_process_env(cmd,args,env,new_stdin,new_stdout,new_stderr)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       try
        {perform_redirections(new_stdin,new_stdout,new_stderr);
         var _cE_=execvpe(cmd,args,env);
         return _cE_}
       catch(_cF_){return caml_sys_exit(127)}
      return id}
    var popen_processes=caml_call2(Hashtbl[1],0,7);
    function open_proc(cmd,envopt,proc,input,output,error)
     {var id=runtime.unix_fork(0);
      if(0 === id)
       {perform_redirections(input,output,error);
        var argv=[0,shell,cst_c$0,cmd];
        try
         {if(envopt)
           var env=envopt[1],_cC_=runtime.unix_execve(shell,argv,env);
          else
           var _cC_=runtime.unix_execv(shell,argv);
          return _cC_}
        catch(_cD_){return caml_sys_exit(127)}}
      return caml_call3(Hashtbl[5],popen_processes,proc,id)}
    function open_process_in(cmd)
     {var
       match=runtime.unix_pipe(_h_,0),
       in_write=match[2],
       in_read=match[1],
       inchan=caml_ml_open_descriptor_in(in_read);
      try
       {open_proc(cmd,0,[1,inchan],stdin,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[81],inchan);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(in_write);
      return inchan}
    function open_process_out(cmd)
     {var
       match=runtime.unix_pipe(_i_,0),
       out_write=match[2],
       out_read=match[1],
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[2,outchan],out_read,stdout,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[64],outchan);
        runtime.unix_close(out_read);
        throw e}
      runtime.unix_close(out_read);
      return outchan}
    function open_process(cmd)
     {var match=runtime.unix_pipe(_j_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_k_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var
       out_write=match$0[2],
       out_read=match$0[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write);
      try
       {open_proc(cmd,0,[0,inchan,outchan],out_read,in_write,stderr)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      return [0,inchan,outchan]}
    function open_process_full(cmd,env)
     {var match=runtime.unix_pipe(_l_,0),in_write=match[2],in_read=match[1];
      try
       {var match$0=runtime.unix_pipe(_m_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        throw e}
      var out_write=match$0[2],out_read=match$0[1];
      try
       {var match$1=runtime.unix_pipe(_n_,0)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        throw e}
      var
       err_write=match$1[2],
       err_read=match$1[1],
       inchan=caml_ml_open_descriptor_in(in_read),
       outchan=caml_ml_open_descriptor_out(out_write),
       errchan=caml_ml_open_descriptor_in(err_read);
      try
       {open_proc
         (cmd,[0,env],[3,inchan,outchan,errchan],out_read,in_write,err_write)}
      catch(e)
       {e = caml_wrap_exception(e);
        runtime.unix_close(out_read);
        runtime.unix_close(out_write);
        runtime.unix_close(in_read);
        runtime.unix_close(in_write);
        runtime.unix_close(err_read);
        runtime.unix_close(err_write);
        throw e}
      runtime.unix_close(out_read);
      runtime.unix_close(in_write);
      runtime.unix_close(err_write);
      return [0,inchan,outchan,errchan]}
    function find_proc_id(fun_name,proc)
     {try
       {var pid=caml_call2(Hashtbl[6],popen_processes,proc);
        caml_call2(Hashtbl[10],popen_processes,proc);
        return pid}
      catch(_cB_)
       {_cB_ = caml_wrap_exception(_cB_);
        if(_cB_ === Not_found)throw [0,Unix_error,3,fun_name,cst$9];
        throw _cB_}}
    function close_process_in(inchan)
     {var pid=find_proc_id(cst_close_process_in,[1,inchan]);
      caml_call1(Pervasives[81],inchan);
      return waitpid_non_intr(pid)[2]}
    function close_process_out(outchan)
     {var pid=find_proc_id(cst_close_process_out,[2,outchan]);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cA_)
       {_cA_ = caml_wrap_exception(_cA_);if(_cA_[1] !== Sys_error)throw _cA_}
      return waitpid_non_intr(pid)[2]}
    function close_process(param)
     {var
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process,[0,inchan,outchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cz_)
       {_cz_ = caml_wrap_exception(_cz_);if(_cz_[1] !== Sys_error)throw _cz_}
      return waitpid_non_intr(pid)[2]}
    function close_process_full(param)
     {var
       errchan=param[3],
       outchan=param[2],
       inchan=param[1],
       pid=find_proc_id(cst_close_process_full,[3,inchan,outchan,errchan]);
      caml_call1(Pervasives[81],inchan);
      try
       {caml_call1(Pervasives[64],outchan)}
      catch(_cy_)
       {_cy_ = caml_wrap_exception(_cy_);if(_cy_[1] !== Sys_error)throw _cy_}
      caml_call1(Pervasives[81],errchan);
      return waitpid_non_intr(pid)[2]}
    function open_connection(sockaddr)
     {var sock=runtime.unix_socket(_o_,domain_of_sockaddr(sockaddr),0,0);
      try
       {runtime.unix_connect(sock,sockaddr);
        var
         _cw_=caml_ml_open_descriptor_out(sock),
         _cx_=[0,caml_ml_open_descriptor_in(sock),_cw_];
        return _cx_}
      catch(exn)
       {exn = caml_wrap_exception(exn);runtime.unix_close(sock);throw exn}}
    function shutdown_connection(inchan)
     {return runtime.unix_shutdown(runtime.caml_channel_descriptor(inchan),1)}
    function accept_non_intr(s)
     {for(;;)
       try
        {var _cu_=runtime.unix_accept(_p_,s);return _cu_}
       catch(_cv_)
        {_cv_ = caml_wrap_exception(_cv_);
         if(_cv_[1] === Unix_error)
          {var _ct_=_cv_[2];
           if(typeof _ct_ === "number")if(11 === _ct_)continue}
         throw _cv_}}
    function establish_server(server_fun,sockaddr)
     {var sock=runtime.unix_socket(_q_,domain_of_sockaddr(sockaddr),0,0);
      runtime.unix_setsockopt(0,sock,2,1);
      runtime.unix_bind(sock,sockaddr);
      runtime.unix_listen(sock,5);
      for(;;)
       {var match=accept_non_intr(sock),s=match[1],id=runtime.unix_fork(0);
        if(0 === id)
         {if(0 !== runtime.unix_fork(0))caml_sys_exit(0);
          runtime.unix_close(sock);
          var
           inchan=caml_ml_open_descriptor_in(s),
           outchan=caml_ml_open_descriptor_out(s);
          caml_call2(server_fun,inchan,outchan);
          caml_call1(Pervasives[87],0)}
        else
         {runtime.unix_close(s);waitpid_non_intr(id)}
        continue}}
    function setsid(_cs_){return runtime.unix_setsid(_cs_)}
    function tcflow(_cr_,_cq_){return runtime.unix_tcflow(_cr_,_cq_)}
    function tcflush(_cp_,_co_){return runtime.unix_tcflush(_cp_,_co_)}
    function tcdrain(_cn_){return runtime.unix_tcdrain(_cn_)}
    function tcsendbreak(_cm_,_cl_)
     {return runtime.unix_tcsendbreak(_cm_,_cl_)}
    function tcsetattr(_ck_,_cj_,_ci_)
     {return runtime.unix_tcsetattr(_ck_,_cj_,_ci_)}
    function tcgetattr(_ch_){return runtime.unix_tcgetattr(_ch_)}
    function getservbyport(_cg_,_cf_)
     {return runtime.unix_getservbyport(_cg_,_cf_)}
    function getservbyname(_ce_,_cd_)
     {return runtime.unix_getservbyname(_ce_,_cd_)}
    function getprotobynumber(_cc_)
     {return runtime.unix_getprotobynumber(_cc_)}
    function getprotobyname(_cb_){return runtime.unix_getprotobyname(_cb_)}
    function gethostbyaddr(_ca_){return runtime.unix_gethostbyaddr(_ca_)}
    function gethostbyname(_b$_){return runtime.unix_gethostbyname(_b$_)}
    function gethostname(_b__){return runtime.unix_gethostname(_b__)}
    function getpeername(_b9_){return runtime.unix_getpeername(_b9_)}
    function getsockname(_b8_){return runtime.unix_getsockname(_b8_)}
    function shutdown(_b7_,_b6_){return runtime.unix_shutdown(_b7_,_b6_)}
    function listen(_b5_,_b4_){return runtime.unix_listen(_b5_,_b4_)}
    function connect(_b3_,_b2_){return runtime.unix_connect(_b3_,_b2_)}
    function bind(_b1_,_b0_){return runtime.unix_bind(_b1_,_b0_)}
    function accept(_bZ_,_bY_){return runtime.unix_accept(_bZ_,_bY_)}
    function socketpair(_bX_,_bW_,_bV_,_bU_)
     {return runtime.unix_socketpair(_bX_,_bW_,_bV_,_bU_)}
    function socket(_bT_,_bS_,_bR_,_bQ_)
     {return runtime.unix_socket(_bT_,_bS_,_bR_,_bQ_)}
    function string_of_inet_addr(_bP_)
     {return runtime.unix_string_of_inet_addr(_bP_)}
    function inet_addr_of_string(_bO_){return unix_inet_addr_of_string(_bO_)}
    function getgrgid(_bN_){return runtime.unix_getgrgid(_bN_)}
    function getpwuid(_bM_){return runtime.unix_getpwuid(_bM_)}
    function getgrnam(_bL_){return runtime.unix_getgrnam(_bL_)}
    function getpwnam(_bK_){return runtime.unix_getpwnam(_bK_)}
    function getlogin(_bJ_){return runtime.unix_getlogin(_bJ_)}
    function initgroups(_bI_,_bH_){return runtime.unix_initgroups(_bI_,_bH_)}
    function setgroups(_bG_){return runtime.unix_setgroups(_bG_)}
    function getgroups(_bF_){return runtime.unix_getgroups(_bF_)}
    function setgid(_bE_){return runtime.unix_setgid(_bE_)}
    function getegid(_bD_){return runtime.unix_getegid(_bD_)}
    function getgid(_bC_){return runtime.unix_getgid(_bC_)}
    function setuid(_bB_){return runtime.unix_setuid(_bB_)}
    function geteuid(_bA_){return runtime.unix_geteuid(_bA_)}
    function getuid(_bz_){return runtime.unix_getuid(_bz_)}
    function setitimer(_by_,_bx_){return runtime.unix_setitimer(_by_,_bx_)}
    function getitimer(_bw_){return runtime.unix_getitimer(_bw_)}
    function utimes(_bv_,_bu_,_bt_)
     {return runtime.unix_utimes(_bv_,_bu_,_bt_)}
    function times(_bs_){return runtime.unix_times(_bs_)}
    function _r_(_br_){return runtime.unix_sleep(_br_)}
    function alarm(_bq_){return runtime.unix_alarm(_bq_)}
    var
     mktime=runtime.unix_mktime,
     localtime=runtime.unix_localtime,
     gmtime=runtime.unix_gmtime;
    function gettimeofday(_bp_){return runtime.unix_gettimeofday(_bp_)}
    function time(_bo_){return runtime.unix_time(_bo_)}
    function sigsuspend(_bn_){return runtime.unix_sigsuspend(_bn_)}
    function sigpending(_bm_){return runtime.unix_sigpending(_bm_)}
    function sigprocmask(_bl_,_bk_)
     {return runtime.unix_sigprocmask(_bl_,_bk_)}
    function kill(_bj_,_bi_){return runtime.unix_kill(_bj_,_bi_)}
    function lockf(_bh_,_bg_,_bf_){return runtime.unix_lockf(_bh_,_bg_,_bf_)}
    function select(_be_,_bd_,_bc_,_bb_)
     {return runtime.unix_select(_be_,_bd_,_bc_,_bb_)}
    function readlink(_ba_){return runtime.unix_readlink(_ba_)}
    function has_symlink(_a$_){return runtime.unix_has_symlink(_a$_)}
    function symlink(_a__,_a9_,_a8_)
     {return runtime.unix_symlink(_a__,_a9_,_a8_)}
    function mkfifo(_a7_,_a6_){return runtime.unix_mkfifo(_a7_,_a6_)}
    function pipe(_a5_,_a4_){return runtime.unix_pipe(_a5_,_a4_)}
    function closedir(_a3_){return runtime.unix_closedir(_a3_)}
    function rewinddir(_a2_){return runtime.unix_rewinddir(_a2_)}
    function readdir(_a1_){return runtime.unix_readdir(_a1_)}
    function opendir(_a0_){return runtime.unix_opendir(_a0_)}
    function chroot(_aZ_){return runtime.unix_chroot(_aZ_)}
    function getcwd(_aY_){return runtime.unix_getcwd(_aY_)}
    function chdir(_aX_){return runtime.unix_chdir(_aX_)}
    function rmdir(_aW_){return runtime.unix_rmdir(_aW_)}
    function mkdir(_aV_,_aU_){return runtime.unix_mkdir(_aV_,_aU_)}
    function clear_close_on_exec(_aT_)
     {return runtime.unix_clear_close_on_exec(_aT_)}
    function set_close_on_exec(_aS_)
     {return runtime.unix_set_close_on_exec(_aS_)}
    function clear_nonblock(_aR_){return runtime.unix_clear_nonblock(_aR_)}
    function set_nonblock(_aQ_){return runtime.unix_set_nonblock(_aQ_)}
    function dup2(_aP_,_aO_,_aN_){return runtime.unix_dup2(_aP_,_aO_,_aN_)}
    function dup(_aM_,_aL_){return runtime.unix_dup(_aM_,_aL_)}
    function access(_aK_,_aJ_){return runtime.unix_access(_aK_,_aJ_)}
    function umask(_aI_){return runtime.unix_umask(_aI_)}
    function fchown(_aH_,_aG_,_aF_)
     {return runtime.unix_fchown(_aH_,_aG_,_aF_)}
    function chown(_aE_,_aD_,_aC_){return runtime.unix_chown(_aE_,_aD_,_aC_)}
    function fchmod(_aB_,_aA_){return runtime.unix_fchmod(_aB_,_aA_)}
    function chmod(_az_,_ay_){return runtime.unix_chmod(_az_,_ay_)}
    function link(_ax_,_aw_){return runtime.unix_link(_ax_,_aw_)}
    function rename(_av_,_au_){return runtime.unix_rename(_av_,_au_)}
    function unlink(_at_){return runtime.unix_unlink(_at_)}
    function _s_(_as_){return runtime.unix_fstat_64(_as_)}
    function _t_(_ar_){return runtime.unix_lstat_64(_ar_)}
    function _u_(_aq_){return runtime.unix_stat_64(_aq_)}
    function _v_(_ap_,_ao_){return runtime.unix_ftruncate_64(_ap_,_ao_)}
    function _w_(_an_,_am_){return runtime.unix_truncate_64(_an_,_am_)}
    var
     LargeFile=
      [0,
       function(_al_,_ak_,_aj_){return runtime.unix_lseek_64(_al_,_ak_,_aj_)},
       _w_,
       _v_,
       _u_,
       _t_,
       _s_];
    function isatty(_ai_){return runtime.unix_isatty(_ai_)}
    function fstat(_ah_){return runtime.unix_fstat(_ah_)}
    function lstat(_ag_){return runtime.unix_lstat(_ag_)}
    function stat(_af_){return runtime.unix_stat(_af_)}
    function ftruncate(_ae_,_ad_){return runtime.unix_ftruncate(_ae_,_ad_)}
    function truncate(_ac_,_ab_){return runtime.unix_truncate(_ac_,_ab_)}
    function lseek(_aa_,_$_,___){return runtime.unix_lseek(_aa_,_$_,___)}
    function descr_of_out_channel(_Z_)
     {return runtime.caml_channel_descriptor(_Z_)}
    function descr_of_in_channel(_Y_)
     {return runtime.caml_channel_descriptor(_Y_)}
    var
     out_channel_of_descr=caml_ml_open_descriptor_out,
     in_channel_of_descr=caml_ml_open_descriptor_in;
    function close(_X_){return runtime.unix_close(_X_)}
    function openfile(_W_,_V_,_U_){return runtime.unix_open(_W_,_V_,_U_)}
    function nice(_T_){return runtime.unix_nice(_T_)}
    function getppid(_S_){return runtime.unix_getppid(_S_)}
    function getpid(_R_){return runtime.unix_getpid(_R_)}
    function waitpid(_Q_,_P_){return runtime.unix_waitpid(_Q_,_P_)}
    function wait(_O_){return runtime.unix_wait(_O_)}
    function fork(_N_){return runtime.unix_fork(_N_)}
    function execvp(_M_,_L_){return runtime.unix_execvp(_M_,_L_)}
    function execve(_K_,_J_,_I_){return runtime.unix_execve(_K_,_J_,_I_)}
    function execv(_H_,_G_){return runtime.unix_execv(_H_,_G_)}
    function putenv(_F_,_E_){return runtime.unix_putenv(_F_,_E_)}
    function unsafe_getenv(_D_){return runtime.caml_sys_unsafe_getenv(_D_)}
    var getenv=runtime.caml_sys_getenv;
    function _x_(_C_){return runtime.unix_environment_unsafe(_C_)}
    function environment(_B_){return runtime.unix_environment(_B_)}
    function error_message(_A_){return runtime.unix_error_message(_A_)}
    var
     include=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       _x_,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       _r_,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(146,include,"Unix");
    var
     UnixLabels=
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet_addr_any$0,
       inet6_addr_loopback,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
    caml_register_global(147,UnixLabels,"UnixLabels");
    return}
  (function(){return this}()));


//# 1 ".js/bigarray/bigarray.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_check_bound=runtime.caml_check_bound,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Bigarray_array3_of_genarray=
      caml_new_string("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarray=
      caml_new_string("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarray=
      caml_new_string("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarray=
      caml_new_string("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_non_cubic_data=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_non_cubic_data$0=
      caml_new_string("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_non_rectangular_data=
      caml_new_string("Bigarray.Array2.of_array: non-rectangular data"),
     Pervasives=global_data.Pervasives,
     Array=global_data.Array,
     Sys=global_data.Sys,
     _a_=[255,0,0,0],
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32=6,
     int64=7,
     int$0=8,
     nativeint=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return Sys[10] / 8 | 0;
        case 9:return Sys[10] / 8 | 0;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var
       n=caml_ba_num_dims(a),
       d=runtime.caml_make_vect(n,0),
       _I_=n - 1 | 0,
       _H_=0;
      if(! (_I_ < 0))
       {var i=_H_;
        for(;;)
         {var _J_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[i + 1] = _J_;
          var _K_=i + 1 | 0;
          if(_I_ !== i){var i=_K_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _B_=dims(arr),_C_=1;
      function _D_(_G_,_F_){return caml_mul(_G_,_F_)}
      var _E_=caml_call3(Array[17],_D_,_C_,_B_);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_E_)}
    function map_file(fd,opt,kind,layout,shared,dims)
     {if(opt)var sth=opt[1],pos=sth;else var pos=_a_;
      return runtime.caml_ba_map_file_bytecode(fd,kind,layout,shared,dims,pos)}
    var Genarray=[0,dims,size_in_bytes,map_file];
    function create(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set(arr)
     {var _z_=[0];
      return function(_A_){return runtime.caml_ba_set_generic(arr,_z_,_A_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create(kind,layout);caml_call1(set(a),v);return a}
    function create$0(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _y_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_y_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return 0 === match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$0(kind,layout,data.length - 1),
       ofs=0 === layout?0:1,
       _w_=data.length - 1 - 1 | 0,
       _v_=0;
      if(! (_w_ < 0))
       {var i=_v_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[i + 1]);
          var _x_=i + 1 | 0;
          if(_w_ !== i){var i=_x_;continue}
          break}}
      return ba}
    function map_file$0(fd,pos,kind,layout,shared,dim)
     {return caml_call6(Genarray[3],fd,pos,kind,layout,shared,[0,dim])}
    function create$1(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _t_=caml_ba_dim_2(arr),_u_=caml_ba_dim_1(arr);
      return caml_mul(caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_u_),_t_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$1(kind,layout,dim1,dim2),
       ofs=0 === layout?0:1,
       _o_=dim1 - 1 | 0,
       _n_=0;
      if(! (_o_ < 0))
       {var i=_n_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           caml_call1
            (Pervasives[1],cst_Bigarray_Array2_of_array_non_rectangular_data);
          var _q_=dim2 - 1 | 0,_p_=0;
          if(! (_q_ < 0))
           {var j=_p_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[j + 1]);
              var _s_=j + 1 | 0;
              if(_q_ !== j){var j=_s_;continue}
              break}}
          var _r_=i + 1 | 0;
          if(_o_ !== i){var i=_r_;continue}
          break}}
      return ba}
    function map_file$1(fd,pos,kind,layout,shared,dim1,dim2)
     {return caml_call6(Genarray[3],fd,pos,kind,layout,shared,[0,dim1,dim2])}
    function create$2(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _k_=runtime.caml_ba_dim_3(arr),
       _l_=caml_ba_dim_2(arr),
       _m_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_m_),_l_),
               _k_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$2(kind,layout,dim1,dim2,dim3),
       ofs=0 === layout?0:1,
       _c_=dim1 - 1 | 0,
       _b_=0;
      if(! (_c_ < 0))
       {var i=_b_;
        for(;;)
         {var row=caml_check_bound(data,i)[i + 1];
          if(row.length - 1 !== dim2)
           caml_call1
            (Pervasives[1],cst_Bigarray_Array3_of_array_non_cubic_data);
          var _e_=dim2 - 1 | 0,_d_=0;
          if(! (_e_ < 0))
           {var j=_d_;
            for(;;)
             {var col=caml_check_bound(row,j)[j + 1];
              if(col.length - 1 !== dim3)
               caml_call1
                (Pervasives[1],cst_Bigarray_Array3_of_array_non_cubic_data$0);
              var _h_=dim3 - 1 | 0,_g_=0;
              if(! (_h_ < 0))
               {var k=_g_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[k + 1]);
                  var _j_=k + 1 | 0;
                  if(_h_ !== k){var k=_j_;continue}
                  break}}
              var _i_=j + 1 | 0;
              if(_e_ !== j){var j=_i_;continue}
              break}}
          var _f_=i + 1 | 0;
          if(_c_ !== i){var i=_f_;continue}
          break}}
      return ba}
    function map_file$2(fd,pos,kind,layout,shared,dim1,dim2,dim3)
     {return caml_call6
              (Genarray[3],fd,pos,kind,layout,shared,[0,dim1,dim2,dim3])}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :caml_call1(Pervasives[1],cst_Bigarray_array0_of_genarray)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :caml_call1(Pervasives[1],cst_Bigarray_array1_of_genarray)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :caml_call1(Pervasives[1],cst_Bigarray_array2_of_genarray)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :caml_call1(Pervasives[1],cst_Bigarray_array3_of_genarray)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$0,
       int32,
       int64,
       nativeint,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create,caml_ba_change_layout,size_in_bytes$0,get,set,of_value],
       [0,
        create$0,
        caml_ba_change_layout,
        size_in_bytes$1,
        slice,
        of_array,
        map_file$0],
       [0,
        create$1,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0,
        map_file$1],
       [0,
        create$2,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1,
        map_file$2],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    runtime.caml_register_global(11,Bigarray,"Bigarray");
    return}
  (function(){return this}()));


//# 1 ".js/parsexp/parsexp.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mul=runtime.caml_mul,
     caml_new_string=runtime.caml_new_string,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Parsexp_Positions_find=caml_new_string("Parsexp.Positions.find"),
     cst_Parsexp_Position_find=caml_new_string("Parsexp.Position.find"),
     cst_Parsexp_Positions_add_gen=
      caml_new_string("Parsexp.Positions.add_gen"),
     beginning_of_file=[0,1,0,0],
     cst_Parsexp_Positions_Iterator_No_more=
      caml_new_string("Parsexp__Positions.Iterator.No_more"),
     cst_Parsexp_Positions_Sexp_search_Found=
      caml_new_string("Parsexp__Positions.Sexp_search.Found"),
     cst_unterminated_hexadecimal_escape_sequence=
      caml_new_string("unterminated hexadecimal escape sequence"),
     cst_unterminated_decimal_escape_sequence=
      caml_new_string("unterminated decimal escape sequence"),
     cst_unterminated_quoted_string=
      caml_new_string("unterminated quoted string"),
     cst_unterminated_block_comment=
      caml_new_string("unterminated block comment"),
     cst_escape_sequence_in_quoted_string_out_of_range=
      caml_new_string("escape sequence in quoted string out of range"),
     cst_unclosed_parentheses_at_end_of_input=
      caml_new_string("unclosed parentheses at end of input"),
     cst_s_expression_followed_by_data=
      caml_new_string("s-expression followed by data"),
     cst_unexpected_character=caml_new_string("unexpected character: ')'"),
     cst$0=caml_new_string("|"),
     cst_illegal_end_of_comment=caml_new_string("illegal end of comment"),
     cst_comment_tokens_in_unquoted_atom=
      caml_new_string("comment tokens in unquoted atom"),
     cst_unterminated_sexp_comment=
      caml_new_string("unterminated sexp comment"),
     cst_unexpected_end_of_input_after_carriage_return=
      caml_new_string("unexpected end of input after carriage return"),
     cst_unexpected_character_after_carriage_return=
      caml_new_string("unexpected character after carriage return"),
     cst_no_s_expression_found_in_input=
      caml_new_string("no s-expression found in input"),
     cst_Parsexp_Parser_automaton_parser_is_dead=
      caml_new_string("Parsexp.Parser_automaton: parser is dead"),
     cst=caml_new_string("|"),
     cst_Parser_automaton_sexps_cst_of_stack=
      caml_new_string("Parser_automaton.sexps_cst_of_stack"),
     cst_Parser_automaton_sexps_of_stack=
      caml_new_string("Parser_automaton.sexps_of_stack"),
     cst_Parser_automaton_sexp_of_stack=
      caml_new_string("Parser_automaton.sexp_of_stack"),
     cst_Parsexp_Parser_automaton_internal_Public_Parse_error=
      caml_new_string("Parsexp__Parser_automaton_internal.Public.Parse_error"),
     cst_Parsexp_parse_gen_None=caml_new_string("Parsexp.parse_gen: None"),
     cst_Parsexp_Make_eager_Params_Lexbuf_consumer_Got_sexp=
      caml_new_string("Parsexp.Make_eager(Params).Lexbuf_consumer.Got_sexp"),
     partial=[12,10,0],
     cst_Parsexp_feed_subbytes=caml_new_string("Parsexp.feed_subbytes"),
     cst_Parsexp_feed_substring=caml_new_string("Parsexp.feed_substring"),
     cst_Parsexp_Of_sexp_error=caml_new_string("Parsexp.Of_sexp_error"),
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     ListLabels=global_data.ListLabels,
     Array=global_data.Array,
     Pervasives=global_data.Pervasives,
     Assert_failure=global_data.Assert_failure,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Sys=global_data.Sys,
     Buffer=global_data.Buffer,
     List=global_data.List,
     Char=global_data.Char,
     String=global_data.String,
     Sexplib0_Sexp=global_data.Sexplib0__Sexp,
     Printexc=global_data.Printexc,
     Format=global_data.Format,
     Parsexp=[0,0,0,0,0,0,0,0];
    caml_register_global(90,Parsexp,"Parsexp__");
    var
     Ppx_sexp_conv_lib=[0,0,0,0],
     default_string_of_float=Sexplib0_Sexp_conv[1],
     write_old_option_format=Sexplib0_Sexp_conv[2],
     read_old_option_format=Sexplib0_Sexp_conv[3],
     list_map=Sexplib0_Sexp_conv[4],
     sexp_of_unit=Sexplib0_Sexp_conv[5],
     sexp_of_bool=Sexplib0_Sexp_conv[6],
     sexp_of_string=Sexplib0_Sexp_conv[7],
     sexp_of_bytes=Sexplib0_Sexp_conv[8],
     sexp_of_char=Sexplib0_Sexp_conv[9],
     sexp_of_int=Sexplib0_Sexp_conv[10],
     sexp_of_float=Sexplib0_Sexp_conv[11],
     sexp_of_int32=Sexplib0_Sexp_conv[12],
     sexp_of_int64=Sexplib0_Sexp_conv[13],
     sexp_of_nativeint=Sexplib0_Sexp_conv[14],
     sexp_of_ref=Sexplib0_Sexp_conv[15],
     sexp_of_lazy_t=Sexplib0_Sexp_conv[16],
     sexp_of_option=Sexplib0_Sexp_conv[17],
     sexp_of_pair=Sexplib0_Sexp_conv[18],
     sexp_of_triple=Sexplib0_Sexp_conv[19],
     sexp_of_list=Sexplib0_Sexp_conv[20],
     sexp_of_array=Sexplib0_Sexp_conv[21],
     sexp_of_hashtbl=Sexplib0_Sexp_conv[22],
     sexp_of_opaque=Sexplib0_Sexp_conv[23],
     sexp_of_fun=Sexplib0_Sexp_conv[24],
     Of_sexp_error=Sexplib0_Sexp_conv[25],
     record_check_extra_fields=Sexplib0_Sexp_conv[26],
     of_sexp_error=Sexplib0_Sexp_conv[27],
     of_sexp_error_exn=Sexplib0_Sexp_conv[28],
     unit_of_sexp=Sexplib0_Sexp_conv[29],
     bool_of_sexp=Sexplib0_Sexp_conv[30],
     string_of_sexp=Sexplib0_Sexp_conv[31],
     bytes_of_sexp=Sexplib0_Sexp_conv[32],
     char_of_sexp=Sexplib0_Sexp_conv[33],
     int_of_sexp=Sexplib0_Sexp_conv[34],
     float_of_sexp=Sexplib0_Sexp_conv[35],
     int32_of_sexp=Sexplib0_Sexp_conv[36],
     int64_of_sexp=Sexplib0_Sexp_conv[37],
     nativeint_of_sexp=Sexplib0_Sexp_conv[38],
     ref_of_sexp=Sexplib0_Sexp_conv[39],
     lazy_t_of_sexp=Sexplib0_Sexp_conv[40],
     option_of_sexp=Sexplib0_Sexp_conv[41],
     pair_of_sexp=Sexplib0_Sexp_conv[42],
     triple_of_sexp=Sexplib0_Sexp_conv[43],
     list_of_sexp=Sexplib0_Sexp_conv[44],
     array_of_sexp=Sexplib0_Sexp_conv[45],
     hashtbl_of_sexp=Sexplib0_Sexp_conv[46],
     opaque_of_sexp=Sexplib0_Sexp_conv[47],
     fun_of_sexp=Sexplib0_Sexp_conv[48],
     sexp_of_exn=Sexplib0_Sexp_conv[49],
     sexp_of_exn_opt=Sexplib0_Sexp_conv[50],
     Exn_converter=Sexplib0_Sexp_conv[51],
     Parsexp_Import=
      [0,
       Ppx_sexp_conv_lib,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_of_exn,
       sexp_of_exn_opt,
       Exn_converter];
    caml_register_global(92,Parsexp_Import,"Parsexp__Import");
    var
     _h_=[0,caml_new_string("src/positions.ml"),402,12],
     _g_=[0,caml_new_string("src/positions.ml"),381,12],
     _f_=[0,caml_new_string("src/positions.ml"),204,12],
     _d_=[0,caml_new_string("end_pos")],
     _e_=[0,caml_new_string("start_pos")],
     _a_=[0,caml_new_string("offset")],
     _b_=[0,caml_new_string("col")],
     _c_=[0,caml_new_string("line")],
     _j_=[0,caml_new_string("unescaped")],
     _k_=[0,caml_new_string("atom")],
     _l_=[0,caml_new_string("loc")],
     _m_=[0,caml_new_string("Atom")],
     _n_=[0,caml_new_string("elements")],
     _o_=[0,caml_new_string("loc")],
     _p_=[0,caml_new_string("List")],
     _q_=[0,caml_new_string("Sexp")],
     _r_=[0,caml_new_string("Comment")],
     _s_=[0,caml_new_string("comment")],
     _t_=[0,caml_new_string("loc")],
     _u_=[0,caml_new_string("Plain_comment")],
     _v_=[0,caml_new_string("sexp")],
     _w_=[0,caml_new_string("comments")],
     _x_=[0,caml_new_string("hash_semi_pos")],
     _y_=[0,caml_new_string("Sexp_comment")],
     _L_=[0,caml_new_string("src/parser_automaton_internal.ml"),563,26],
     _M_=[0,caml_new_string("src/parser_automaton_internal.ml"),591,4],
     _S_=[0,1],
     _R_=[0,-1],
     _Q_=[0,-1],
     _P_=[0,1],
     _O_=[0,0],
     _N_=[0,1],
     _K_=[0,caml_new_string("src/parser_automaton_internal.ml"),521,6],
     _I_=
      [0,caml_new_string("parser_automaton_internal.ml.Public.Parse_error")],
     _J_=[0,caml_new_string("src/parser_automaton_internal.ml"),217,15],
     _F_=[0,caml_new_string("message")],
     _G_=[0,caml_new_string("position")],
     _z_=[0,caml_new_string("Parsing_toplevel_whitespace")],
     _A_=[0,caml_new_string("Parsing_nested_whitespace")],
     _B_=[0,caml_new_string("Parsing_atom")],
     _C_=[0,caml_new_string("Parsing_list")],
     _D_=[0,caml_new_string("Parsing_sexp_comment")],
     _E_=[0,caml_new_string("Parsing_block_comment")],
     _T_=[0,0,0,1,2,2,2,0,2,2,2,2,2,2,2,2,2,5,5,5,5,5,5,5,5,5,5,5],
     _ad_=[0,caml_new_string("src/parsexp.ml"),454,13],
     _ac_=[0,caml_new_string("src/parsexp.ml"),334,13],
     _aa_=[0,caml_new_string("parsexp.ml.Of_sexp_error")],
     _ab_=[0,caml_new_string("src/parsexp.ml"),155,13],
     _Z_=[0,caml_new_string("Parse_error")],
     ___=[0,caml_new_string("Of_sexp_error")],
     _Y_=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", characters "),
            [4,
             0,
             0,
             0,
             [12,
              45,
              [4,
               0,
               0,
               0,
               [11,
                caml_new_string
                 (":\nError: s-expression conversion error;\nexception "),
                [2,0,partial]]]]]]]]]],
       caml_new_string
        ('File "%s", line %d, characters %d-%d:\nError: s-expression conversion error;\nexception %s\n')],
     _V_=[0,caml_new_string("location")],
     _W_=[0,caml_new_string("sub_sexp")],
     _X_=[0,caml_new_string("user_exn")],
     _U_=
      [0,
       [11,
        caml_new_string('File "'),
        [2,
         0,
         [11,
          caml_new_string('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_new_string(", character "),
            [4,
             0,
             0,
             0,
             [11,
              caml_new_string(":\nError: s-expression parsing error;\n"),
              [2,0,[12,10,0]]]]]]]]],
       caml_new_string
        ('File "%s", line %d, character %d:\nError: s-expression parsing error;\n%s\n')];
    function sexp_of_pos(param)
     {var
       v_offset=param[3],
       v_col=param[2],
       v_line=param[1],
       arg=caml_call1(sexp_of_int,v_offset),
       bnds=[0,[1,[0,_a_,[0,arg,0]]],0],
       arg$0=caml_call1(sexp_of_int,v_col),
       bnds$0=[0,[1,[0,_b_,[0,arg$0,0]]],bnds],
       arg$1=caml_call1(sexp_of_int,v_line),
       bnds$1=[0,[1,[0,_c_,[0,arg$1,0]]],bnds$0];
      return [1,bnds$1]}
    var compare_pos=caml_compare;
    function shift_pos(pos,cols)
     {return [0,pos[1],pos[2] + cols | 0,pos[3] + cols | 0]}
    function sexp_of_range(param)
     {var
       v_end_pos=param[2],
       v_start_pos=param[1],
       arg=sexp_of_pos(v_end_pos),
       bnds=[0,[1,[0,_d_,[0,arg,0]]],0],
       arg$0=sexp_of_pos(v_start_pos),
       bnds$0=[0,[1,[0,_e_,[0,arg$0,0]]],bnds];
      return [1,bnds$0]}
    var compare_range=caml_compare;
    function make_range_incl(start_pos,last_pos)
     {return [0,start_pos,shift_pos(last_pos,1)]}
    function memory_footprint_in_bytes(param)
     {var
       _bq_=caml_obj_tag(param),
       t=
        250 === _bq_
         ?param[1]
         :246 === _bq_?caml_call1(CamlinternalLazy[2],param):param,
       _br_=Sys[10];
      if(32 === _br_)
       var word_bytes=4;
      else
       {if(64 !== _br_)throw [0,Assert_failure,_f_];var word_bytes=8}
      var
       n=runtime.caml_div((64 + word_bytes | 0) - 1 | 0,word_bytes),
       chunk_words=n + 1 | 0;
      return caml_mul
              (9
               +
               caml_mul(caml_call1(ListLabels[1],t[1]),chunk_words + 3 | 0)
               |
               0,
               word_bytes)}
    function create(opt,param)
     {if(opt)
       var sth=opt[1],initial_pos=sth;
      else
       var initial_pos=beginning_of_file;
      return [0,caml_create_bytes(62),0,0,initial_pos[3],0,0,initial_pos]}
    function reset(t,pos)
     {t[1] = caml_create_bytes(62);
      t[2] = 0;
      t[3] = 0;
      t[4] = pos[3];
      t[5] = 0;
      t[6] = 0;
      t[7] = pos;
      return 0}
    function add_uint16(t,n)
     {if(t[2] === 62)
       {t[3] = [0,t[1],t[3]];t[1] = caml_create_bytes(62);t[2] = 0}
      return runtime.caml_string_set16(t[1],t[2],n)}
    function add_bits(t,n,num_bits)
     {var int_buf=t[5] << num_bits | n,num_bits$0=t[6] + num_bits | 0;
      t[5] = int_buf;
      if(16 <= num_bits$0)
       {var num_bits$1=num_bits$0 - 16 | 0;
        t[6] = num_bits$1;
        add_uint16(t,int_buf >>> num_bits$1 | 0);
        t[2] = t[2] + 2 | 0;
        return 0}
      t[6] = num_bits$0;
      return 0}
    function contents(t)
     {add_uint16(t,t[5]);
      var
       rev_chunks=[0,t[1],t[3]],
       chunk_pos=t[2],
       extra_bits=t[6],
       initial_pos=t[7];
      return [246,
              function(_bo_)
               {var
                 _bp_=
                  ((caml_call1(ListLabels[1],rev_chunks) - 1 | 0) * 62 | 0)
                  +
                  chunk_pos
                  |
                  0;
                return [0,
                        caml_call1(ListLabels[9],rev_chunks),
                        _bp_,
                        extra_bits,
                        initial_pos]}]}
    function add_gen(t,offset,instr,instr_bits)
     {var n$0=offset - t[4] | 0;
      t[4] = offset + 1 | 0;
      if(5 <= n$0)
       {if(! (37 <= n$0))
         return add_bits
                 (t,
                  (192 | n$0 - 5 | 0) << instr_bits | instr,
                  8 + instr_bits | 0)}
      else
       if(0 <= n$0)
        {var num_bits=(n$0 << 1) + instr_bits | 0;
         return add_bits
                 (t,
                  (170 << instr_bits | instr) & ((1 << num_bits) - 1 | 0),
                  num_bits)}
      if(n$0 < 0)caml_call1(Pervasives[1],cst_Parsexp_Positions_add_gen);
      var n=[0,n$0 - 5 | 0];
      for(;;)
       {if(0 < n[1])
         {add_bits(t,192 | n[1] & 31,8);n[1] = n[1] >>> 5 | 0;continue}
        return add_bits(t,instr,instr_bits)}}
    function add(t,offset){return add_gen(t,offset,0,1)}
    function add_twice(t,offset){return add_gen(t,offset,15,4)}
    function add_newline(t,offset){return add_gen(t,offset,14,4)}
    function create$0(param)
     {var
       _bm_=caml_obj_tag(param),
       p=
        250 === _bm_
         ?param[1]
         :246 === _bm_?caml_call1(CamlinternalLazy[2],param):param,
       _bn_=p[1];
      if(_bn_)
       {var chunks=_bn_[2],chunk=_bn_[1];
        return [0,
                chunk,
                chunks,
                p[2],
                p[3],
                0,
                p[4][3],
                p[4][1],
                p[4][3] - p[4][2] | 0,
                0,
                0,
                0]}
      throw [0,Assert_failure,_g_]}
    var
     No_more=
      [248,cst_Parsexp_Positions_Iterator_No_more,caml_fresh_oo_id(0)];
    function no_more(param){throw No_more}
    function next_instruction_bits(t,num_bits)
     {if(t[10] < num_bits)
       {if(t[3] < t[5])no_more(0);
        if(t[5] === 62)
         {var _bl_=t[2];
          if(! _bl_)throw [0,Assert_failure,_h_];
          var chunks=_bl_[2],chunk=_bl_[1];
          t[5] = 0;
          t[3] = t[3] - 62 | 0;
          t[1] = chunk;
          t[2] = chunks}
        var
         v=runtime.caml_string_get16(t[1],t[5]),
         added_bits=t[5] === t[3]?t[4]:16;
        t[9] = t[9] << added_bits | v & ((1 << added_bits) - 1 | 0);
        t[10] = t[10] + added_bits | 0;
        t[5] = t[5] + 2 | 0;
        if(t[10] < num_bits)no_more(0)}
      var n=(t[9] >>> (t[10] - num_bits | 0) | 0) & ((1 << num_bits) - 1 | 0);
      t[10] = t[10] - num_bits | 0;
      return n}
    function advance(t,skip,offset_shift,offset_shift_num_bits)
     {var
       skip$0=skip,
       offset_shift$0=offset_shift,
       offset_shift_num_bits$0=offset_shift_num_bits;
      for(;;)
       {var match=next_instruction_bits(t,1);
        if(0 === match)
         {var offset=t[6] + offset_shift$0 | 0;
          t[6] = offset + 1 | 0;
          if(0 === skip$0)return [0,t[7],offset - t[8] | 0,offset];
          var
           skip$1=skip$0 - 1 | 0,
           skip$0=skip$1,
           offset_shift$0=0,
           offset_shift_num_bits$0=0;
          continue}
        var match$0=next_instruction_bits(t,1);
        if(0 === match$0)
         {t[6] = (t[6] + offset_shift$0 | 0) + 1 | 0;
          var offset_shift$0=0,offset_shift_num_bits$0=0;
          continue}
        var match$1=next_instruction_bits(t,1);
        if(0 === match$1)
         {var
           n=next_instruction_bits(t,5),
           offset_shift$1=0 === offset_shift_num_bits$0?5:offset_shift$0,
           offset_shift_num_bits$1=offset_shift_num_bits$0 + 5 | 0,
           offset_shift$2=offset_shift$1 + (n << offset_shift_num_bits$0) | 0,
           offset_shift$0=offset_shift$2,
           offset_shift_num_bits$0=offset_shift_num_bits$1;
          continue}
        var match$2=next_instruction_bits(t,1);
        if(0 === match$2)
         {t[6] = (t[6] + offset_shift$0 | 0) + 1 | 0;
          t[8] = t[6];
          t[7] = t[7] + 1 | 0;
          var offset_shift$0=0,offset_shift_num_bits$0=0;
          continue}
        var offset$0=t[6] + offset_shift$0 | 0;
        t[6] = offset$0 + 1 | 0;
        if(1 < skip$0)
         {var
           skip$2=skip$0 - 2 | 0,
           skip$0=skip$2,
           offset_shift$0=0,
           offset_shift_num_bits$0=0;
          continue}
        var pos=[0,t[7],offset$0 - t[8] | 0,offset$0];
        if(0 === skip$0)t[11] = [0,pos];
        return pos}}
    function advance_exn(t,skip)
     {var _bk_=t[11];
      if(_bk_)
       {var pos=_bk_[1];
        t[11] = 0;
        return 0 === skip?pos:advance(t,skip - 1 | 0,0,0)}
      return advance(t,skip,0,0)}
    var Iterator=[0,create$0,No_more,advance_exn];
    function find(t,a,b)
     {var _bg_=a < 0?1:0,_bh_=_bg_ || (b <= a?1:0);
      if(_bh_)caml_call1(Pervasives[1],cst_Parsexp_Positions_find);
      var iter=caml_call1(Iterator[1],t);
      try
       {var
         start_pos=caml_call2(Iterator[3],iter,a),
         last_pos=caml_call2(Iterator[3],iter,(b - a | 0) - 1 | 0),
         _bi_=make_range_incl(start_pos,last_pos);
        return _bi_}
      catch(_bj_)
       {_bj_ = caml_wrap_exception(_bj_);
        if(_bj_ === Iterator[2])
         return caml_call1(Pervasives[2],cst_Parsexp_Position_find);
        throw _bj_}}
    function sub_sexp_count(sexp)
     {if(0 === sexp[0])return 1;
      var l=sexp[1],_be_=1;
      function _bf_(acc,x){return acc + sub_sexp_count(x) | 0}
      return caml_call3(ListLabels[20],_bf_,_be_,l)}
    var
     Found=
      [248,cst_Parsexp_Positions_Sexp_search_Found,caml_fresh_oo_id(0)];
    function loop(sub,index,sexp)
     {if(sexp === sub)throw [0,Found,index];
      if(0 === sexp[0])return index + 2 | 0;
      var l=sexp[1],index$0=loop_list(sub,index + 1 | 0,l);
      return index$0 + 1 | 0}
    function loop_list(sub,index,sexps)
     {function _bb_(_bc_,_bd_){return loop(sub,_bc_,_bd_)}
      return caml_call3(ListLabels[20],_bb_,index,sexps)}
    function finalize(t,sub,a)
     {var b=(a + (sub_sexp_count(sub) * 2 | 0) | 0) - 1 | 0;
      return [0,find(t,a,b)]}
    function find$0(t,sexp,sub)
     {try
       {loop(sub,0,sexp)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Found){var n=exn[2];return finalize(t,sub,n)}
        throw exn}
      return 0}
    function find$1(t,sexps,sub)
     {try
       {loop_list(sub,0,sexps)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Found){var n=exn[2];return finalize(t,sub,n)}
        throw exn}
      return 0}
    function to_list(t)
     {var iter=caml_call1(Iterator[1],t);
      function loop(acc)
       {var acc$0=acc;
        for(;;)
         {try
           {var pos=caml_call2(Iterator[3],iter,0)}
          catch(_ba_)
           {_ba_ = caml_wrap_exception(_ba_);
            if(_ba_ === Iterator[2])return caml_call1(ListLabels[9],acc$0);
            throw _ba_}
          var acc$1=[0,pos,acc$0],acc$0=acc$1;
          continue}}
      return loop(0)}
    function to_array(t)
     {var _a$_=to_list(t);return caml_call1(Array[12],_a$_)}
    function compare(t1,t2)
     {var _a__=to_array(t2);return caml_compare(to_array(t1),_a__)}
    function sexp_of_t(t)
     {return caml_call2(sexp_of_array,sexp_of_pos,to_array(t))}
    var
     _i_=[0,create,add,add_twice,add_newline,contents,reset],
     Parsexp_Positions=
      [0,
       sexp_of_t,
       compare,
       sexp_of_pos,
       compare_pos,
       beginning_of_file,
       shift_pos,
       sexp_of_range,
       compare_range,
       make_range_incl,
       _i_,
       to_list,
       to_array,
       find,
       find$0,
       find$1,
       memory_footprint_in_bytes,
       Iterator];
    caml_register_global(99,Parsexp_Positions,"Parsexp__Positions");
    function sexp_of_t$0(param)
     {if(0 === param[0])
       {var
         v_unescaped=param[3],
         v_atom=param[2],
         v_loc=param[1],
         arg=caml_call2(sexp_of_option,sexp_of_string,v_unescaped),
         bnds=[0,[1,[0,_j_,[0,arg,0]]],0],
         arg$0=caml_call1(sexp_of_string,v_atom),
         bnds$0=[0,[1,[0,_k_,[0,arg$0,0]]],bnds],
         arg$1=sexp_of_range(v_loc),
         bnds$1=[0,[1,[0,_l_,[0,arg$1,0]]],bnds$0];
        return [1,[0,_m_,bnds$1]]}
      var
       v_elements=param[2],
       v_loc$0=param[1],
       arg$2=caml_call2(sexp_of_list,sexp_of_t_or_comment,v_elements),
       bnds$2=[0,[1,[0,_n_,[0,arg$2,0]]],0],
       arg$3=sexp_of_range(v_loc$0),
       bnds$3=[0,[1,[0,_o_,[0,arg$3,0]]],bnds$2];
      return [1,[0,_p_,bnds$3]]}
    function sexp_of_t_or_comment(param)
     {if(0 === param[0])
       {var v0=param[1],v0$0=sexp_of_t$0(v0);return [1,[0,_q_,[0,v0$0,0]]]}
      var v0$1=param[1],v0$2=sexp_of_comment(v0$1);
      return [1,[0,_r_,[0,v0$2,0]]]}
    function sexp_of_comment(param)
     {if(0 === param[0])
       {var
         v_comment=param[2],
         v_loc=param[1],
         arg=caml_call1(sexp_of_string,v_comment),
         bnds=[0,[1,[0,_s_,[0,arg,0]]],0],
         arg$0=sexp_of_range(v_loc),
         bnds$0=[0,[1,[0,_t_,[0,arg$0,0]]],bnds];
        return [1,[0,_u_,bnds$0]]}
      var
       v_sexp=param[3],
       v_comments=param[2],
       v_hash_semi_pos=param[1],
       arg$1=sexp_of_t$0(v_sexp),
       bnds$1=[0,[1,[0,_v_,[0,arg$1,0]]],0],
       arg$2=caml_call2(sexp_of_list,sexp_of_comment,v_comments),
       bnds$2=[0,[1,[0,_w_,[0,arg$2,0]]],bnds$1],
       arg$3=sexp_of_pos(v_hash_semi_pos),
       bnds$3=[0,[1,[0,_x_,[0,arg$3,0]]],bnds$2];
      return [1,[0,_y_,bnds$3]]}
    var
     compare$0=caml_compare,
     compare_t_or_comment=caml_compare,
     compare_comment=caml_compare;
    function forget_t$0(counter,t,k)
     {if(0 === t[0]){var atom=t[2];return caml_call1(k,[0,atom])}
      var elements=t[2];
      function _a9_(xs){return caml_call1(k,[1,xs])}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return forget_tocs$0(counter$0,elements,_a9_)}
      return caml_trampoline_return(forget_tocs$0,[0,elements,_a9_])}
    function forget_tocs$0(counter,tocs,k)
     {if(tocs)
       {var
         tocs$0=tocs[2],
         toc=tocs[1],
         _a8_=
          function(param)
           {if(param)
             {var x=param[1];
              return forget_tocs
                      (tocs$0,function(xs){return caml_call1(k,[0,x,xs])})}
            return forget_tocs(tocs$0,k)};
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return forget_toc$0(counter$0,toc,_a8_)}
        return caml_trampoline_return(forget_toc$0,[0,toc,_a8_])}
      return caml_call1(k,0)}
    function forget_toc$0(counter,toc,k)
     {if(0 === toc[0])
       {var t=toc[1],_a7_=function(x){return caml_call1(k,[0,x])};
        if(counter < 50)
         {var counter$0=counter + 1 | 0;return forget_t$0(counter$0,t,_a7_)}
        return caml_trampoline_return(forget_t$0,[0,t,_a7_])}
      return caml_call1(k,0)}
    function forget_t(t,k){return caml_trampoline(forget_t$0(0,t,k))}
    function forget_tocs(tocs,k)
     {return caml_trampoline(forget_tocs$0(0,tocs,k))}
    function forget_toc(toc,k){return caml_trampoline(forget_toc$0(0,toc,k))}
    function t(x){return forget_t(x,function(y){return y})}
    function t_or_comment(x){return forget_toc(x,function(y){return y})}
    function t_or_comments(x){return forget_tocs(x,function(y){return y})}
    var
     Parsexp_Cst=
      [0,
       compare$0,
       compare_t_or_comment,
       compare_comment,
       sexp_of_t$0,
       sexp_of_t_or_comment,
       sexp_of_comment,
       [0,t,t_or_comment,t_or_comments]];
    caml_register_global(100,Parsexp_Cst,"Parsexp__Cst");
    var empty_stack=0,empty_stack_cst=0,initial_state=0,error_state=1;
    function new_state(opt,mode,kind)
     {if(opt)
       var sth=opt[1],initial_pos=sth;
      else
       var initial_pos=beginning_of_file;
      var
       _a2_=initial_pos[3] - initial_pos[2] | 0,
       _a3_=initial_pos[1],
       _a4_=initial_pos[3],
       _a5_=0;
      switch(kind)
       {case 0:var _a6_=caml_call2(_i_[1],[0,initial_pos],0);break;
        case 1:var _a6_=0;break;
        case 2:var _a6_=caml_call2(_i_[1],[0,initial_pos],0);break;
        default:var _a6_=[0,caml_call1(Buffer[1],128),beginning_of_file]}
      return [0,
              initial_state,
              kind,
              0,
              0,
              0,
              0,
              caml_call1(Buffer[1],128),
              _a6_,
              mode,
              _a5_,
              _a4_,
              _a3_,
              _a2_]}
    function mode(t){return t[9]}
    function positions(t){return caml_call1(_i_[5],t[8])}
    function atom_buffer(t){return t[7]}
    function offset(state){return state[11]}
    function line(state){return state[12]}
    function column(state){return state[11] - state[13] | 0}
    function position(t)
     {var _a0_=t[11],_a1_=column(t);return [0,t[12],_a1_,_a0_]}
    function reset$0(opt,t)
     {if(opt)var sth=opt[1],pos=sth;else var pos=beginning_of_file;
      t[3] = 0;
      t[1] = initial_state;
      t[4] = 0;
      t[5] = 0;
      t[6] = 0;
      t[10] = 0;
      t[11] = pos[3];
      t[12] = pos[1];
      t[13] = pos[3] - pos[2] | 0;
      switch(t[2])
       {case 0:var _aY_=position(t);caml_call2(_i_[6],t[8],_aY_);break;
        case 1:break;
        case 2:var _aZ_=position(t);caml_call2(_i_[6],t[8],_aZ_);break;
        default:caml_call1(Buffer[8],t[8][1])}
      return caml_call1(Buffer[8],t[7])}
    function is_ignoring(state){return state[5]?1:0}
    function is_not_ignoring(state){return 1 - is_ignoring(state)}
    function context(state){return is_not_ignoring(state)?1:0}
    function has_unclosed_paren(state){return 0 < state[3]?1:0}
    function set_error_state(state){state[1] = error_state;return 0}
    function sexp_of_t$1(param)
     {switch(param)
       {case 0:return _z_;
        case 1:return _A_;
        case 2:return _B_;
        case 3:return _C_;
        case 4:return _D_;
        default:return _E_}}
    var Old_parser_cont_state=[0,sexp_of_t$1];
    function sexp_of_t$2(param)
     {var
       message=param[2],
       position=param[1],
       _aX_=[0,[1,[0,_F_,[0,caml_call1(sexp_of_string,message),0]]],0];
      return [1,[0,[1,[0,_G_,[0,sexp_of_pos(position),0]]],_aX_]]}
    function position$0(t){return t[1]}
    function message(t){return t[2]}
    function old_parser_exn(t){return t[3]}
    var
     include=[0,sexp_of_t$2,position$0,message,old_parser_exn],
     Parse_error=
      [248,
       cst_Parsexp_Parser_automaton_internal_Public_Parse_error,
       caml_fresh_oo_id(0)];
    function _H_(param)
     {if(param[1] === Parse_error)
       {var v0=param[2],v0$0=caml_call1(include[1],v0);
        return [1,[0,_I_,[0,v0$0,0]]]}
      throw [0,Assert_failure,_J_]}
    caml_call3(Sexplib0_Sexp_conv[51][2],0,Parse_error,_H_);
    function sexp_of_stack(param)
     {if(typeof param !== "number" && 1 === param[0])
       if(typeof param[2] === "number"){var sexp=param[1];return sexp}
      return caml_call1(Pervasives[2],cst_Parser_automaton_sexp_of_stack)}
    function sexps_of_stack(stack)
     {var acc=0,param=stack;
      for(;;)
       if(typeof param === "number")
        return acc;
       else
        {if(0 === param[0])
          return caml_call1(Pervasives[2],cst_Parser_automaton_sexps_of_stack);
         var
          param$0=param[2],
          sexp=param[1],
          acc$0=[0,sexp,acc],
          acc=acc$0,
          param=param$0;
         continue}}
    function sexps_cst_of_stack(stack$1)
     {var acc=0,stack=stack$1;
      for(;;)
       if(typeof stack === "number")
        return acc;
       else
        {if(0 === stack[0])
          {var
            stack$0=stack[2],
            t=stack[1],
            acc$0=[0,t,acc],
            acc=acc$0,
            stack=stack$0;
           continue}
         return caml_call1
                 (Pervasives[2],cst_Parser_automaton_sexps_cst_of_stack)}}
    function automaton_state(state){return state[1]}
    var
     sexp_of_t$3=include[1],
     position$1=include[2],
     message$0=include[3],
     old_parser_exn$0=include[4],
     Reason=[0];
    function raise(state,at_eof,reason)
     {set_error_state(state);
      switch(reason)
       {case 0:var message=cst_unterminated_hexadecimal_escape_sequence;break;
        case 1:var message=cst_unterminated_decimal_escape_sequence;break;
        case 2:var message=cst_unterminated_quoted_string;break;
        case 3:var message=cst_unterminated_block_comment;break;
        case 4:
         var message=cst_escape_sequence_in_quoted_string_out_of_range;break;
        case 5:var message=cst_unclosed_parentheses_at_end_of_input;break;
        case 6:var message=cst_s_expression_followed_by_data;break;
        case 7:var message=cst_unexpected_character;break;
        case 8:
         var
          _aW_=caml_call1(Buffer[2],state[7]),
          message=
           caml_call2(String[34],_aW_,cst$0)
            ?cst_illegal_end_of_comment
            :cst_comment_tokens_in_unquoted_atom;
         break;
        case 9:var message=cst_unterminated_sexp_comment;break;
        case 10:
         var
          message=
           at_eof
            ?cst_unexpected_end_of_input_after_carriage_return
            :cst_unexpected_character_after_carriage_return;
         break;
        case 11:var message=cst_no_s_expression_found_in_input;break;
        default:
         var
          message=
           caml_call1
            (Pervasives[2],cst_Parsexp_Parser_automaton_parser_is_dead)}
      if(6 === reason)
       var switch$0=0;
      else
       if(0 === at_eof)
        {if(8 === reason)
          {var _aV_=caml_call1(Buffer[2],state[7]);
           if(caml_call2(String[34],_aV_,cst))
            var old_parser_exn=-464807894,switch$0=1,switch$1=0;
           else
            var switch$1=1}
         else
          var switch$1=1;
         if(switch$1)var old_parser_exn=434889564,switch$0=1}
       else
        var switch$0=0;
      if(! switch$0)var old_parser_exn=-464807894;
      var position=[0,state[12],state[11] - state[13] | 0,state[11]];
      throw [0,Parse_error,[0,position,message,old_parser_exn]]}
    var
     Error=
      [0,sexp_of_t$3,position$1,message$0,old_parser_exn$0,Reason,raise];
    function current_pos(opt,state)
     {if(opt)var sth=opt[1],delta=sth;else var delta=0;
      var offset=state[11] + delta | 0;
      return [0,state[12],offset - state[13] | 0,offset]}
    function set_automaton_state(state,x){state[1] = x;return 0}
    function advance$0(state){state[11] = state[11] + 1 | 0;return 0}
    function advance_eol(state)
     {var newline_offset=state[11];
      state[11] = newline_offset + 1 | 0;
      state[13] = state[11];
      state[12] = state[12] + 1 | 0;
      var _aU_=state[2];
      if(! (3 <= _aU_))
       switch(_aU_)
        {case 0:return caml_call2(_i_[4],state[8],newline_offset);
         case 2:return caml_call2(_i_[4],state[8],newline_offset)
         }
      return 0}
    function block_comment_depth(state){return state[4]}
    function add_token_char(state,char$0,stack)
     {return 3 <= state[2]
              ?(caml_call2(Buffer[10],state[8][1],char$0),stack)
              :stack}
    function add_atom_char(state,c,stack)
     {caml_call2(Buffer[10],state[7],c);return stack}
    function add_quoted_atom_char(state,c,stack)
     {caml_call2(Buffer[10],state[7],c);return add_token_char(state,c,stack)}
    function check_new_sexp_allowed(state)
     {var _aR_=state[9];
      if(typeof _aR_ === "number")
       if(0 === _aR_)var is_single=1,switch$0=1;else var switch$0=0;
      else
       var switch$0=0;
      if(! switch$0)var is_single=0;
      if(is_single)
       var _aS_=0 < state[10]?1:0,_aT_=_aS_?is_not_ignoring(state):_aS_;
      else
       var _aT_=is_single;
      return _aT_?caml_call3(Error[6],state,0,6):_aT_}
    function add_pos(state,delta)
     {return caml_call2(_i_[2],state[8],state[11] + delta | 0)}
    function add_first_char(state,char$0,stack)
     {check_new_sexp_allowed(state);
      caml_call2(Buffer[10],state[7],char$0);
      return stack}
    function eps_add_first_char_hash(state,stack)
     {check_new_sexp_allowed(state);
      caml_call2(Buffer[10],state[7],35);
      return stack}
    function start_quoted_string(state,char$0,stack)
     {check_new_sexp_allowed(state);
      switch(state[2])
       {case 0:if(is_not_ignoring(state))add_pos(state,0);return stack;
        case 1:return stack;
        case 2:if(is_not_ignoring(state))add_pos(state,0);return stack;
        default:
         var _aQ_=current_pos(0,state);
         state[8][2] = _aQ_;
         caml_call2(Buffer[10],state[8][1],34);
         return stack}}
    function add_escaped(state,c,stack)
     {var _aO_=c - 34 | 0;
      if(5 < _aO_ >>> 0)
       {var switcher=_aO_ - 58 | 0;
        if(24 < switcher >>> 0)
         var switch$0=0;
        else
         {switch(switcher)
           {case 0:var switch$0=1,switch$1=0;break;
            case 6:var _aP_=8,switch$1=1;break;
            case 18:var _aP_=10,switch$1=1;break;
            case 22:var _aP_=13,switch$1=1;break;
            case 24:var _aP_=9,switch$1=1;break;
            default:var switch$0=0,switch$1=0}
          if(switch$1)var c$0=_aP_,switch$0=2}}
      else
       var switch$0=3 < (_aO_ - 1 | 0) >>> 0?1:0;
      switch(switch$0)
       {case 0:caml_call2(Buffer[10],state[7],92);var c$0=c;break;
        case 1:var c$0=c;break
        }
      caml_call2(Buffer[10],state[7],c$0);
      return add_token_char(state,c,stack)}
    function eps_add_escaped_cr(state,stack)
     {caml_call2(Buffer[10],state[7],13);return stack}
    function hex_val(c)
     {if(58 <= c)
       {var switcher=c - 97 | 0;
        if(! (5 < switcher >>> 0))return (c - 97 | 0) + 10 | 0}
      else
       if(48 <= c)return c - 48 | 0;
      return (c - 65 | 0) + 10 | 0}
    function add_dec_escape_char(state,c,stack)
     {state[6] = (state[6] * 10 | 0) + (c - 48 | 0) | 0;
      return add_token_char(state,c,stack)}
    function add_last_dec_escape_char(state,c,stack)
     {var value=(state[6] * 10 | 0) + (c - 48 | 0) | 0;
      state[6] = 0;
      if(255 < value)caml_call3(Error[6],state,0,4);
      var _aN_=caml_call1(Char[1],value);
      caml_call2(Buffer[10],state[7],_aN_);
      return add_token_char(state,c,stack)}
    function comment_add_last_dec_escape_char(state,c,stack)
     {var value=(state[6] * 10 | 0) + (c - 48 | 0) | 0;
      state[6] = 0;
      if(255 < value)caml_call3(Error[6],state,0,4);
      return add_token_char(state,c,stack)}
    function add_hex_escape_char(state,c,stack)
     {var _aM_=hex_val(c);
      state[6] = state[6] << 4 | _aM_;
      return add_token_char(state,c,stack)}
    function add_last_hex_escape_char(state,c,stack)
     {var _aK_=hex_val(c),value=state[6] << 4 | _aK_;
      state[6] = 0;
      var _aL_=caml_call1(Char[1],value);
      caml_call2(Buffer[10],state[7],_aL_);
      return add_token_char(state,c,stack)}
    function opening(state,char$0,stack)
     {check_new_sexp_allowed(state);
      state[3] = state[3] + 1 | 0;
      switch(state[2])
       {case 0:if(is_not_ignoring(state))add_pos(state,0);return stack;
        case 1:return is_not_ignoring(state)?[0,stack]:stack;
        case 2:
         return is_not_ignoring(state)?(add_pos(state,0),[0,stack]):stack;
        default:return [1,current_pos(0,state),stack]}}
    function do_reset_positions(state)
     {return caml_call2
              (_i_[6],
               state[8],
               [0,state[12],state[11] - state[13] | 0,state[11]])}
    function reset_positions(state)
     {switch(state[2])
       {case 0:return do_reset_positions(state);
        case 1:return 0;
        case 2:return do_reset_positions(state);
        default:return 0}}
    function toplevel_sexp_or_comment_added(state,stack,delta)
     {var _aJ_=state[9];
      if(typeof _aJ_ === "number")return stack;
      var f=_aJ_[1],saved_offset=state[11];
      state[11] = state[11] + delta | 0;
      var saved_full_sexps=state[10];
      try
       {var stack$0=caml_call2(f,state,stack)}
      catch(e){e = caml_wrap_exception(e);set_error_state(state);throw e}
      if(state[11] === (saved_offset + delta | 0))
       if(state[10] === saved_full_sexps)
        {state[11] = saved_offset;reset_positions(state);return stack$0}
      throw [0,Assert_failure,_K_]}
    function is_top_level(state)
     {var _aH_=is_not_ignoring(state),_aI_=_aH_?0 === state[3]?1:0:_aH_;
      return _aI_}
    function comment_added_assuming_cst(state,stack,delta)
     {return is_top_level(state)
              ?toplevel_sexp_or_comment_added(state,stack,delta)
              :stack}
    function sexp_added(state,stack,delta)
     {var _aF_=state[5];
      if(_aF_)
       {var tl=_aF_[2],inner_comment_depth=_aF_[1];
        if(state[3] < inner_comment_depth)
         var is_comment=caml_call3(Error[6],state,0,9),switch$0=1;
        else
         if(inner_comment_depth === state[3])
          {state[5] = tl;var is_comment=1,switch$0=1}
         else
          var switch$0=0}
      else
       var switch$0=0;
      if(! switch$0)var is_comment=0;
      if(is_top_level(state))
       {if(1 - is_comment)state[10] = state[10] + 1 | 0;
        if(is_comment){var _aG_=3 <= state[2]?1:0;if(! _aG_)return stack}
        return toplevel_sexp_or_comment_added(state,stack,delta)}
      return stack}
    function make_list(acc,param)
     {var acc$0=acc,param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        throw [0,Assert_failure,_L_];
       else
        {if(0 === param$0[0]){var stack=param$0[1];return [1,[1,acc$0],stack]}
         var
          param$1=param$0[2],
          sexp=param$0[1],
          acc$1=[0,sexp,acc$0],
          acc$0=acc$1,
          param$0=param$1;
         continue}}
    function add_comment_to_stack_cst(comment,stack)
     {if(typeof stack !== "number" && 2 === stack[0])
       return [2,stack[1],[0,comment,stack[2]],stack[3]];
      return [0,[1,comment],stack]}
    function add_sexp_to_stack_cst(sexp,stack)
     {if(typeof stack !== "number" && 2 === stack[0])
       {var
         stack$0=stack[3],
         rev_comments=stack[2],
         hash_semi_pos=stack[1],
         comment=[1,hash_semi_pos,caml_call1(List[9],rev_comments),sexp];
        return add_comment_to_stack_cst(comment,stack$0)}
      return [0,[0,sexp],stack]}
    function closing(state,char$0,stack$0)
     {if(0 < state[3])
       {switch(state[2])
         {case 0:
           if(is_not_ignoring(state))add_pos(state,0);
           var stack$1=stack$0;
           break;
          case 1:
           var stack$1=is_not_ignoring(state)?make_list(0,stack$0):stack$0;
           break;
          case 2:
           var
            stack$1=
             is_not_ignoring(state)
              ?(add_pos(state,0),make_list(0,stack$0))
              :stack$0;
           break;
          default:
           var end_pos=current_pos(_N_,state),acc=0,param=stack$0;
           for(;;)
            {if(typeof param === "number")
              var switch$0=0;
             else
              switch(param[0])
               {case 0:
                 var
                  param$0=param[2],
                  t=param[1],
                  acc$0=[0,t,acc],
                  acc=acc$0,
                  param=param$0;
                 continue;
                case 1:
                 var
                  stack=param[2],
                  start_pos=param[1],
                  sexp=[1,[0,start_pos,end_pos],acc],
                  stack$1=add_sexp_to_stack_cst(sexp,stack),
                  switch$0=1;
                 break;
                default:var switch$0=0}
             if(! switch$0)throw [0,Assert_failure,_M_];
             break}}
        state[3] = state[3] - 1 | 0;
        return sexp_added(state,stack$1,1)}
      return caml_call3(Error[6],state,0,7)}
    function make_loc(opt,state)
     {if(opt)var sth=opt[1],delta=sth;else var delta=0;
      var _aE_=current_pos([0,delta],state);
      return [0,state[8][2],_aE_]}
    function add_non_quoted_atom_pos(state,atom)
     {var len=caml_ml_string_length(atom);
      return 1 === len
              ?caml_call2(_i_[3],state[8],state[11] - 1 | 0)
              :(add_pos(state,- len | 0),add_pos(state,-1))}
    function eps_push_atom(state,stack)
     {var str=caml_call1(Buffer[2],state[7]);
      caml_call1(Buffer[8],state[7]);
      switch(state[2])
       {case 0:
         if(is_not_ignoring(state))add_non_quoted_atom_pos(state,str);
         var stack$0=stack;
         break;
        case 1:
         var stack$0=is_not_ignoring(state)?[1,[0,str],stack]:stack;break;
        case 2:
         var
          stack$0=
           is_not_ignoring(state)
            ?(add_non_quoted_atom_pos(state,str),[1,[0,str],stack])
            :stack;
         break;
        default:
         var
          _aD_=current_pos(_O_,state),
          loc=[0,current_pos([0,- caml_ml_string_length(str) | 0],state),_aD_],
          sexp=[0,loc,str,0],
          stack$0=add_sexp_to_stack_cst(sexp,stack)}
      return sexp_added(state,stack$0,0)}
    function push_quoted_atom(state,char$0,stack)
     {var str=caml_call1(Buffer[2],state[7]);
      caml_call1(Buffer[8],state[7]);
      switch(state[2])
       {case 0:
         if(is_not_ignoring(state))add_pos(state,0);var stack$0=stack;break;
        case 1:
         var stack$0=is_not_ignoring(state)?[1,[0,str],stack]:stack;break;
        case 2:
         var
          stack$0=
           is_not_ignoring(state)?(add_pos(state,0),[1,[0,str],stack]):stack;
         break;
        default:
         var buf=state[8][1];
         caml_call2(Buffer[10],buf,34);
         var s=caml_call1(Buffer[2],buf);
         caml_call1(Buffer[8],buf);
         var
          sexp=[0,make_loc(_P_,state),str,[0,s]],
          stack$0=add_sexp_to_stack_cst(sexp,stack)}
      return sexp_added(state,stack$0,1)}
    function start_sexp_comment(state,char$0,stack)
     {state[5] = [0,state[3],state[5]];
      return 3 <= state[2]?[2,current_pos(_Q_,state),0,stack]:stack}
    function start_block_comment(state,char$0,stack)
     {state[4] = state[4] + 1 | 0;
      switch(state[2])
       {case 0:return stack;
        case 1:return stack;
        case 2:return stack;
        default:
         if(1 === state[4])
          {var _aC_=current_pos(_R_,state);
           state[8][2] = _aC_;
           caml_call2(Buffer[10],state[8][1],35)}
         caml_call2(Buffer[10],state[8][1],char$0);
         return stack}}
    function end_block_comment(state,char$0,stack)
     {state[4] = state[4] - 1 | 0;
      switch(state[2])
       {case 0:return stack;
        case 1:return stack;
        case 2:return stack;
        default:
         var buf=state[8][1];
         caml_call2(Buffer[10],buf,char$0);
         if(0 === state[4])
          {var s=caml_call1(Buffer[2],buf);
           caml_call1(Buffer[8],buf);
           var
            comment=[0,make_loc(_S_,state),s],
            stack$0=add_comment_to_stack_cst(comment,stack);
           return comment_added_assuming_cst(state,stack$0,1)}
         return stack}}
    function start_line_comment(state,char$0,stack)
     {if(3 <= state[2])
       {var _aB_=current_pos(0,state);
        state[8][2] = _aB_;
        caml_call2(Buffer[10],state[8][1],char$0);
        return stack}
      return stack}
    function end_line_comment(state,stack)
     {switch(state[2])
       {case 0:return stack;
        case 1:return stack;
        case 2:return stack;
        default:
         var buf=state[8][1],s=caml_call1(Buffer[2],buf);
         caml_call1(Buffer[8],buf);
         var
          comment=[0,make_loc(0,state),s],
          stack$0=add_comment_to_stack_cst(comment,stack);
         return comment_added_assuming_cst(state,stack$0,0)}}
    function eps_eoi_check(state,stack)
     {if(0 < state[3])caml_call3(Error[6],state,1,5);
      if(is_ignoring(state))caml_call3(Error[6],state,1,9);
      if(0 === state[10])
       {var
         _aA_=state[9],
         switch$0=typeof _aA_ === "number"?0 === _aA_?1:0:0 === _aA_[2]?0:1;
        if(switch$0)caml_call3(Error[6],state,1,11)}
      return stack}
    var
     include$0=
      [0,
       empty_stack,
       empty_stack_cst,
       new_state,
       reset$0,
       positions,
       mode,
       offset,
       line,
       column,
       has_unclosed_paren,
       set_error_state,
       sexp_of_stack,
       sexps_of_stack,
       sexps_cst_of_stack,
       include,
       Parse_error,
       atom_buffer,
       Old_parser_cont_state,
       automaton_state],
     Parsexp_Parser_automaton_internal=
      [0,
       include$0,
       Error,
       context,
       set_automaton_state,
       advance$0,
       advance_eol,
       block_comment_depth,
       add_atom_char,
       add_quoted_atom_char,
       add_escaped,
       add_dec_escape_char,
       add_last_dec_escape_char,
       comment_add_last_dec_escape_char,
       add_hex_escape_char,
       add_last_hex_escape_char,
       start_sexp_comment,
       add_first_char,
       start_quoted_string,
       add_token_char,
       opening,
       closing,
       push_quoted_atom,
       start_block_comment,
       end_block_comment,
       start_line_comment,
       end_line_comment,
       eps_push_atom,
       eps_add_first_char_hash,
       eps_eoi_check,
       eps_add_escaped_cr];
    caml_register_global
     (105,
      Parsexp_Parser_automaton_internal,
      "Parsexp__Parser_automaton_internal");
    var
     empty=include$0[1],
     empty$0=include$0[2],
     new_state$0=include$0[3],
     reset$1=include$0[4],
     positions$0=include$0[5],
     mode$0=include$0[6],
     offset$0=include$0[7],
     line$0=include$0[8],
     column$0=include$0[9],
     has_unclosed_paren$0=include$0[10],
     set_error_state$0=include$0[11],
     sexp_of_stack$0=include$0[12],
     sexps_of_stack$0=include$0[13],
     sexps_cst_of_stack$0=include$0[14],
     include$1=include$0[15],
     Parse_error$0=include$0[16],
     atom_buffer$0=include$0[17],
     Old_parser_cont_state$0=include$0[18],
     automaton_state$0=include$0[19],
     raise$0=Error[6];
    function tr_00(state,char$0,stack)
     {var stack$0=add_first_char(state,char$0,stack);
      set_automaton_state(state,3);
      advance$0(state);
      return stack$0}
    function tr_01(state,char$0,stack)
     {set_automaton_state(state,0);advance$0(state);return stack}
    function tr_02(state,char$0,stack)
     {set_automaton_state(state,0);advance_eol(state);return stack}
    function tr_03(state,char$0,stack)
     {set_automaton_state(state,2);advance$0(state);return stack}
    function tr_04(state,char$0,stack)
     {var stack$0=start_quoted_string(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_05(state,char$0,stack)
     {set_automaton_state(state,7);advance$0(state);return stack}
    function tr_06(state,char$0,stack)
     {var stack$0=opening(state,char$0,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_07(state,char$0,stack)
     {var stack$0=closing(state,char$0,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_08(state,char$0,stack)
     {var stack$0=start_line_comment(state,char$0,stack);
      set_automaton_state(state,6);
      advance$0(state);
      return stack$0}
    function tr_09(state,char$0,stack)
     {var stack$0=add_first_char(state,char$0,stack);
      set_automaton_state(state,5);
      advance$0(state);
      return stack$0}
    function tr_10(state,char$0,stack){return caml_call3(raise$0,state,0,12)}
    function tr_11(state,char$0,stack){return caml_call3(raise$0,state,0,10)}
    function tr_12(state,char$0,stack)
     {var stack$0=add_atom_char(state,char$0,stack);
      set_automaton_state(state,3);
      advance$0(state);
      return stack$0}
    function tr_13(state,char$0,stack)
     {var stack$0=eps_push_atom(state,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_14(state,char$0,stack)
     {var stack$0=eps_push_atom(state,stack);
      set_automaton_state(state,0);
      advance_eol(state);
      return stack$0}
    function tr_15(state,char$0,stack)
     {var stack$0=eps_push_atom(state,stack);
      set_automaton_state(state,2);
      advance$0(state);
      return stack$0}
    function tr_16(state,char$0,stack)
     {var
       stack$0=eps_push_atom(state,stack),
       stack$1=start_quoted_string(state,char$0,stack$0);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$1}
    function tr_17(state,char$0,stack)
     {var stack$0=add_atom_char(state,char$0,stack);
      set_automaton_state(state,4);
      advance$0(state);
      return stack$0}
    function tr_18(state,char$0,stack)
     {var
       stack$0=eps_push_atom(state,stack),
       stack$1=opening(state,char$0,stack$0);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$1}
    function tr_19(state,char$0,stack)
     {var
       stack$0=eps_push_atom(state,stack),
       stack$1=closing(state,char$0,stack$0);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$1}
    function tr_20(state,char$0,stack)
     {var
       stack$0=eps_push_atom(state,stack),
       stack$1=start_line_comment(state,char$0,stack$0);
      set_automaton_state(state,6);
      advance$0(state);
      return stack$1}
    function tr_21(state,char$0,stack)
     {var stack$0=add_atom_char(state,char$0,stack);
      set_automaton_state(state,5);
      advance$0(state);
      return stack$0}
    function tr_22(state,char$0,stack){return caml_call3(raise$0,state,0,8)}
    function tr_23(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,6);
      advance$0(state);
      return stack$0}
    function tr_24(state,char$0,stack)
     {var stack$0=end_line_comment(state,stack);
      set_automaton_state(state,0);
      advance_eol(state);
      return stack$0}
    function tr_25(state,char$0,stack)
     {var stack$0=end_line_comment(state,stack);
      set_automaton_state(state,2);
      advance$0(state);
      return stack$0}
    function tr_26(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=add_atom_char(state,char$0,stack$0);
      set_automaton_state(state,3);
      advance$0(state);
      return stack$1}
    function tr_27(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$1}
    function tr_28(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0);
      set_automaton_state(state,0);
      advance_eol(state);
      return stack$1}
    function tr_29(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0);
      set_automaton_state(state,2);
      advance$0(state);
      return stack$1}
    function tr_30(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0),
       stack$2=start_quoted_string(state,char$0,stack$1);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$2}
    function tr_31(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=add_atom_char(state,char$0,stack$0);
      set_automaton_state(state,4);
      advance$0(state);
      return stack$1}
    function tr_32(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0),
       stack$2=opening(state,char$0,stack$1);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$2}
    function tr_33(state,char$0,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0),
       stack$2=closing(state,char$0,stack$1);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$2}
    function tr_34(state,char$0,stack)
     {var stack$0=start_sexp_comment(state,char$0,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_35(state,char$0,stack)
     {var stack$0=start_block_comment(state,char$0,stack);
      set_automaton_state(state,16);
      advance$0(state);
      return stack$0}
    function tr_36(state,char$0,stack)
     {var stack$0=add_quoted_atom_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_37(state,char$0,stack)
     {var stack$0=add_quoted_atom_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance_eol(state);
      return stack$0}
    function tr_38(state,char$0,stack)
     {var stack$0=push_quoted_atom(state,char$0,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_39(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,9);
      advance$0(state);
      return stack$0}
    function tr_40(state,char$0,stack)
     {var stack$0=add_escaped(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_41(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,15);
      advance_eol(state);
      return stack$0}
    function tr_42(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,10);
      advance$0(state);
      return stack$0}
    function tr_43(state,char$0,stack)
     {var stack$0=add_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,11);
      advance$0(state);
      return stack$0}
    function tr_44(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,13);
      advance$0(state);
      return stack$0}
    function tr_45(state,char$0,stack)
     {var
       stack$0=eps_add_escaped_cr(state,stack),
       stack$1=add_quoted_atom_char(state,char$0,stack$0);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$1}
    function tr_46(state,char$0,stack)
     {var
       stack$0=eps_add_escaped_cr(state,stack),
       stack$1=push_quoted_atom(state,char$0,stack$0);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$1}
    function tr_47(state,char$0,stack)
     {var
       stack$0=eps_add_escaped_cr(state,stack),
       stack$1=add_token_char(state,char$0,stack$0);
      set_automaton_state(state,9);
      advance$0(state);
      return stack$1}
    function tr_48(state,char$0,stack){return caml_call3(raise$0,state,0,1)}
    function tr_49(state,char$0,stack)
     {var stack$0=add_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,12);
      advance$0(state);
      return stack$0}
    function tr_50(state,char$0,stack)
     {var stack$0=add_last_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_51(state,char$0,stack){return caml_call3(raise$0,state,0,0)}
    function tr_52(state,char$0,stack)
     {var stack$0=add_hex_escape_char(state,char$0,stack);
      set_automaton_state(state,14);
      advance$0(state);
      return stack$0}
    function tr_53(state,char$0,stack)
     {var stack$0=add_last_hex_escape_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_54(state,char$0,stack)
     {var stack$0=add_quoted_atom_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance$0(state);
      return stack$0}
    function tr_55(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,15);
      advance$0(state);
      return stack$0}
    function tr_56(state,char$0,stack)
     {var stack$0=add_quoted_atom_char(state,char$0,stack);
      set_automaton_state(state,8);
      advance_eol(state);
      return stack$0}
    function tr_57(state,char$0,stack)
     {var stack$0=push_quoted_atom(state,char$0,stack);
      set_automaton_state(state,0);
      advance$0(state);
      return stack$0}
    function tr_58(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,9);
      advance$0(state);
      return stack$0}
    function tr_59(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,16);
      advance$0(state);
      return stack$0}
    function tr_60(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,16);
      advance_eol(state);
      return stack$0}
    function tr_61(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,19);
      advance$0(state);
      return stack$0}
    function tr_62(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,18);
      advance$0(state);
      return stack$0}
    function tr_63(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,17);
      advance$0(state);
      return stack$0}
    function tr_64(state,char$0,stack)
     {var
       stack$0=end_block_comment(state,char$0,stack),
       _az_=0 === state[4]?0:16;
      set_automaton_state(state,_az_);
      advance$0(state);
      return stack$0}
    function tr_65(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,19);
      advance_eol(state);
      return stack$0}
    function tr_66(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,20);
      advance$0(state);
      return stack$0}
    function tr_67(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,26);
      advance_eol(state);
      return stack$0}
    function tr_68(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,21);
      advance$0(state);
      return stack$0}
    function tr_69(state,char$0,stack)
     {var stack$0=add_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,22);
      advance$0(state);
      return stack$0}
    function tr_70(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,24);
      advance$0(state);
      return stack$0}
    function tr_71(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,19);
      advance$0(state);
      return stack$0}
    function tr_72(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,16);
      advance$0(state);
      return stack$0}
    function tr_73(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,20);
      advance$0(state);
      return stack$0}
    function tr_74(state,char$0,stack)
     {var stack$0=add_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,23);
      advance$0(state);
      return stack$0}
    function tr_75(state,char$0,stack)
     {var stack$0=comment_add_last_dec_escape_char(state,char$0,stack);
      set_automaton_state(state,19);
      advance$0(state);
      return stack$0}
    function tr_76(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,25);
      advance$0(state);
      return stack$0}
    function tr_77(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,26);
      advance$0(state);
      return stack$0}
    function tr_78(state,char$0,stack)
     {var stack$0=add_token_char(state,char$0,stack);
      set_automaton_state(state,19);
      advance_eol(state);
      return stack$0}
    function tr_eoi_00(state,stack){return eps_eoi_check(state,stack)}
    function tr_eoi_01(state,stack){return caml_call3(raise$0,state,1,12)}
    function tr_eoi_02(state,stack){return caml_call3(raise$0,state,1,10)}
    function tr_eoi_03(state,stack)
     {var stack$0=eps_push_atom(state,stack);
      return eps_eoi_check(state,stack$0)}
    function tr_eoi_04(state,stack)
     {var stack$0=end_line_comment(state,stack);
      return eps_eoi_check(state,stack$0)}
    function tr_eoi_05(state,stack)
     {var
       stack$0=eps_add_first_char_hash(state,stack),
       stack$1=eps_push_atom(state,stack$0);
      return eps_eoi_check(state,stack$1)}
    function tr_eoi_06(state,stack){return caml_call3(raise$0,state,1,2)}
    function tr_eoi_07(state,stack){return caml_call3(raise$0,state,1,3)}
    var
     transitions=
      [0,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_01,
       tr_02,
       tr_00,
       tr_01,
       tr_03,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_01,
       tr_00,
       tr_04,
       tr_05,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_06,
       tr_07,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_08,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_09,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_00,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_10,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_02,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_11,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_14,
       tr_12,
       tr_13,
       tr_15,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_12,
       tr_16,
       tr_17,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_18,
       tr_19,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_20,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_21,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_14,
       tr_12,
       tr_13,
       tr_15,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_12,
       tr_16,
       tr_17,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_18,
       tr_19,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_20,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_22,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_14,
       tr_12,
       tr_13,
       tr_15,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_13,
       tr_12,
       tr_16,
       tr_22,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_18,
       tr_19,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_20,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_21,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_12,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_24,
       tr_23,
       tr_23,
       tr_25,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_23,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_27,
       tr_28,
       tr_26,
       tr_27,
       tr_29,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_27,
       tr_26,
       tr_30,
       tr_31,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_32,
       tr_33,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_34,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_35,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_26,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_37,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_38,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_39,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_36,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_41,
       tr_40,
       tr_40,
       tr_42,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_43,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_44,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_40,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_41,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_46,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_47,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_45,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_49,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_50,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_52,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_53,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_55,
       tr_56,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_55,
       tr_54,
       tr_57,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_58,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_54,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_60,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_61,
       tr_62,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_63,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_60,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_61,
       tr_64,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_63,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_60,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_61,
       tr_62,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_35,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_59,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_65,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_59,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_66,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_67,
       tr_61,
       tr_61,
       tr_68,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_69,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_70,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_67,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_72,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_73,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_74,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_75,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_48,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_76,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_61,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_51,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_77,
       tr_78,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_77,
       tr_71,
       tr_72,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_73,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71,
       tr_71],
     transitions_eoi=
      [0,
       tr_eoi_00,
       tr_eoi_01,
       tr_eoi_02,
       tr_eoi_03,
       tr_eoi_03,
       tr_eoi_03,
       tr_eoi_04,
       tr_eoi_05,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_06,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07,
       tr_eoi_07];
    function feed(state,char$0,stack)
     {var idx=caml_call1(automaton_state$0,state) << 8 | char$0;
      return caml_call3
              (caml_check_bound(transitions,idx)[idx + 1],state,char$0,stack)}
    function feed_eoi(state,stack)
     {var
       _ay_=caml_call1(automaton_state$0,state),
       stack$0=
        caml_call2
         (caml_check_bound(transitions_eoi,_ay_)[_ay_ + 1],state,stack);
      caml_call1(set_error_state$0,state);
      return stack$0}
    var old_parser_approx_cont_states=_T_.slice();
    function old_parser_cont_state(state)
     {var match=context(state);
      if(0 === match)return 4;
      var
       _ax_=caml_call1(automaton_state$0,state),
       match$0=caml_check_bound(old_parser_approx_cont_states,_ax_)[_ax_ + 1],
       match$1=caml_call1(has_unclosed_paren$0,state);
      if(0 === match$0)if(0 !== match$1)return 3;
      return match$0}
    var
     Parsexp_Parser_automaton=
      [0,
       empty,
       empty$0,
       new_state$0,
       reset$1,
       positions$0,
       mode$0,
       offset$0,
       line$0,
       column$0,
       has_unclosed_paren$0,
       set_error_state$0,
       sexp_of_stack$0,
       sexps_of_stack$0,
       sexps_cst_of_stack$0,
       include$1,
       Parse_error$0,
       atom_buffer$0,
       Old_parser_cont_state$0,
       automaton_state$0,
       feed,
       feed_eoi,
       old_parser_cont_state];
    caml_register_global
     (106,Parsexp_Parser_automaton,"Parsexp__Parser_automaton");
    var Parsexp_Parsexp_intf=[0];
    caml_register_global(107,Parsexp_Parsexp_intf,"Parsexp__Parsexp_intf");
    var Positions=0,Cst=0;
    function feed_substring_unsafe(str,state,stack,i,stop)
     {var stack$0=stack,i$0=i;
      for(;;)
       {if(i$0 < stop)
         {var
           c=caml_bytes_unsafe_get(str,i$0),
           stack$1=feed(state,c,stack$0),
           i$1=i$0 + 1 | 0,
           stack$0=stack$1,
           i$0=i$1;
          continue}
        return stack$0}}
    function feed_subbytes_unsafe(str,state,stack,i,stop)
     {var stack$0=stack,i$0=i;
      for(;;)
       {if(i$0 < stop)
         {var
           c=caml_bytes_unsafe_get(str,i$0),
           stack$1=feed(state,c,stack$0),
           i$1=i$0 + 1 | 0,
           stack$0=stack$1,
           i$0=i$1;
          continue}
        return stack$0}}
    function feed_substring(state,str,pos,len,stack)
     {var str_len=caml_ml_string_length(str),_au_=pos < 0?1:0;
      if(_au_)
       var _av_=_au_;
      else
       var _aw_=len < 0?1:0,_av_=_aw_ || ((str_len - len | 0) < pos?1:0);
      if(_av_)caml_call1(Pervasives[1],cst_Parsexp_feed_substring);
      return feed_substring_unsafe(str,state,stack,pos,pos + len | 0)}
    function feed_subbytes(state,str,pos,len,stack)
     {var str_len=caml_ml_bytes_length(str),_ar_=pos < 0?1:0;
      if(_ar_)
       var _as_=_ar_;
      else
       var _at_=len < 0?1:0,_as_=_at_ || ((str_len - len | 0) < pos?1:0);
      if(_as_)caml_call1(Pervasives[1],cst_Parsexp_feed_subbytes);
      return feed_subbytes_unsafe(str,state,stack,pos,pos + len | 0)}
    function feed_string(state,str,stack)
     {return feed_substring_unsafe
              (str,state,stack,0,caml_ml_string_length(str))}
    function feed_bytes(state,str,stack)
     {return feed_subbytes_unsafe(str,state,stack,0,caml_ml_bytes_length(str))}
    var
     sexp_of_t$4=include$1[1],
     position$2=include$1[2],
     message$1=include$1[3];
    function report(ppf,filename,t)
     {var pos=caml_call1(position$2,t),msg=caml_call1(message$1,t);
      return caml_call6(Format[112],ppf,_U_,filename,pos[1],pos[2],msg)}
    function sexp_of_t$5(param)
     {var
       v_location=param[3],
       v_sub_sexp=param[2],
       v_user_exn=param[1],
       arg=caml_call2(sexp_of_option,sexp_of_range,v_location),
       bnds=[0,[1,[0,_V_,[0,arg,0]]],0],
       arg$0=caml_call1(Sexplib0_Sexp[2],v_sub_sexp),
       bnds$0=[0,[1,[0,_W_,[0,arg$0,0]]],bnds],
       arg$1=caml_call1(sexp_of_exn,v_user_exn),
       bnds$1=[0,[1,[0,_X_,[0,arg$1,0]]],bnds$0];
      return [1,bnds$1]}
    function user_exn(t){return t[1]}
    function sub_sexp(t){return t[2]}
    function location(t){return t[3]}
    function report$0(ppf,filename,t)
     {var _ap_=t[3];
      if(_ap_)
       var
        match=_ap_[1],
        end_pos=match[2],
        start_pos=match[1],
        line=start_pos[1],
        start=start_pos[2],
        stop=(start_pos[2] + end_pos[3] | 0) - start_pos[3] | 0;
      else
       var line=1,start=0,stop=0;
      var _aq_=caml_call1(Printexc[1],t[1]);
      return caml_call7(Format[112],ppf,_Y_,filename,line,start,stop,_aq_)}
    var Of_sexp_error$0=[0,sexp_of_t$5,user_exn,sub_sexp,location,report$0];
    function sexp_of_t$6(param)
     {if(0 === param[0])
       {var v0=param[1],v0$0=caml_call1(sexp_of_t$4,v0);
        return [1,[0,_Z_,[0,v0$0,0]]]}
      var v0$1=param[1],v0$2=caml_call1(Of_sexp_error$0[1],v0$1);
      return [1,[0,___,[0,v0$2,0]]]}
    function report$1(ppf,filename,t)
     {if(0 === t[0]){var e=t[1];return report(ppf,filename,e)}
      var e$0=t[1];
      return caml_call3(Of_sexp_error$0[5],ppf,filename,e$0)}
    var
     Conv_error=[0,sexp_of_t$6,report$1],
     Of_sexp_error$1=[248,cst_Parsexp_Of_sexp_error,caml_fresh_oo_id(0)];
    function _$_(param)
     {if(param[1] === Of_sexp_error$1)
       {var v0=param[2],v0$0=caml_call1(Of_sexp_error$0[1],v0);
        return [1,[0,_aa_,[0,v0$0,0]]]}
      throw [0,Assert_failure,_ab_]}
    caml_call3(Sexplib0_Sexp_conv[51][2],0,Of_sexp_error$1,_$_);
    function Make(Params)
     {var empty=Params[3],Stack=[0,empty];
      function create(pos,param)
       {return caml_call3(new_state$0,pos,Params[2],Params[1])}
      function position(t)
       {var _an_=caml_call1(offset$0,t),_ao_=caml_call1(column$0,t);
        return [0,caml_call1(line$0,t),_ao_,_an_]}
      function stop(state){return caml_call1(set_error_state$0,state)}
      var State=[0,create,reset$1,offset$0,line$0,column$0,position,stop];
      function feed_eoi$0(state,stack)
       {var _am_=feed_eoi(state,stack);
        return caml_call2(Params[4],state,_am_)}
      function parse_string_exn(str)
       {var state=caml_call2(State[1],0,0);
        return feed_eoi$0(state,feed_string(state,str,Stack[1]))}
      function parse_string(str)
       {try
         {var x=parse_string_exn(str)}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Parse_error$0){var e=exn[2];return [1,e]}
          throw exn}
        return [0,x]}
      return [0,
              State,
              Stack,
              feed,
              feed_eoi$0,
              feed_string,
              feed_substring,
              feed_bytes,
              feed_subbytes,
              parse_string,
              parse_string_exn]}
    function Make_eager(Params)
     {var empty=Params[2],Stack=[0,empty];
      function position(t)
       {var _ak_=caml_call1(offset$0,t),_al_=caml_call1(column$0,t);
        return [0,caml_call1(line$0,t),_al_,_ak_]}
      var
       Read_only=[0,offset$0,line$0,column$0,position],
       offset=Read_only[1],
       line=Read_only[2],
       column=Read_only[3],
       position$0=Read_only[4];
      function create(pos,opt,f)
       {if(opt)
         var sth=opt[1],no_sexp_is_error=sth;
        else
         var no_sexp_is_error=0;
        function got_sexp(state,stack)
         {var parsed_value=caml_call2(Params[3],state,stack);
          caml_call2(f,state,parsed_value);
          return Params[2]}
        return caml_call3
                (new_state$0,pos,[0,got_sexp,no_sexp_is_error],Params[1])}
      function stop(t){return caml_call1(set_error_state$0,t)}
      function old_parser_cont_state$0(t){return old_parser_cont_state(t)}
      function feed_eoi$0(state,stack){feed_eoi(state,stack);return 0}
      var
       Got_sexp=
        [248,
         cst_Parsexp_Make_eager_Params_Lexbuf_consumer_Got_sexp,
         caml_fresh_oo_id(0)];
      function got_sexp(state,parsed_value)
       {throw [0,Got_sexp,parsed_value,caml_call1(position$0,state)]}
      function create$0(param){return create(0,0,got_sexp)}
      function pos_of_lexbuf(lexbuf)
       {var p=lexbuf[12];return [0,p[2],p[4] - p[3] | 0,p[4]]}
      function update_lexbuf(lexbuf,pos)
       {var p=pos[3] - lexbuf[4] | 0;
        lexbuf[6] = p;
        lexbuf[5] = p;
        lexbuf[12] = [0,lexbuf[12][1],pos[1],pos[3] - pos[2] | 0,pos[3]];
        return 0}
      function feed_lexbuf(t,lexbuf,stack)
       {var stack$0=stack;
        for(;;)
         {var
           stack$1=
            feed_subbytes
             (t,lexbuf[2],lexbuf[6],lexbuf[3] - lexbuf[6] | 0,stack$0);
          lexbuf[6] = lexbuf[3];
          lexbuf[5] = lexbuf[3];
          if(lexbuf[9])return feed_eoi$0(t,stack$1);
          caml_call1(lexbuf[1],lexbuf);
          var stack$0=stack$1;
          continue}}
      function parse_gen(t,lexbuf)
       {caml_call2(reset$1,[0,pos_of_lexbuf(lexbuf)],t);
        try
         {feed_lexbuf(t,lexbuf,Stack[1])}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Got_sexp)
           {var pos=exn[3],parsed_value=exn[2];
            update_lexbuf(lexbuf,pos);
            return [0,parsed_value]}
          update_lexbuf(lexbuf,caml_call1(position$0,t));
          throw exn}
        update_lexbuf(lexbuf,caml_call1(position$0,t));
        return 0}
      function set_no_sexp_is_error(t,x)
       {var match=caml_call1(mode$0,t);
        if(typeof match === "number")throw [0,Assert_failure,_ac_];
        match[2] = x;
        return 0}
      function parse(t,lexbuf)
       {set_no_sexp_is_error(t,1);
        var match=parse_gen(t,lexbuf);
        if(match){var x=match[1];return x}
        return caml_call1(Pervasives[2],cst_Parsexp_parse_gen_None)}
      function parse_opt(t,lexbuf)
       {set_no_sexp_is_error(t,0);return parse_gen(t,lexbuf)}
      return [0,
              [0,
               reset$1,
               offset,
               line,
               column,
               position$0,
               stop,
               Read_only,
               create,
               old_parser_cont_state$0],
              Stack,
              feed,
              feed_eoi$0,
              feed_string,
              feed_substring,
              feed_bytes,
              feed_subbytes,
              [0,create$0,parse,parse_opt]]}
    var kind=1,mode$1=0;
    function make_value(param,stack){return caml_call1(sexp_of_stack$0,stack)}
    var Single=Make([0,kind,mode$1,empty,make_value]),kind$0=1,mode$2=1;
    function make_value$0(param,stack)
     {return caml_call1(sexps_of_stack$0,stack)}
    var Many=Make([0,kind$0,mode$2,empty,make_value$0]),kind$1=1;
    function make_value$1(param,stack)
     {return caml_call1(sexp_of_stack$0,stack)}
    var Eager=Make_eager([0,kind$1,empty,make_value$1]),kind$2=2,mode$3=0;
    function make_value$2(state,stack)
     {var _aj_=caml_call1(positions$0,state);
      return [0,caml_call1(sexp_of_stack$0,stack),_aj_]}
    var
     Single_and_positions=Make([0,kind$2,mode$3,empty,make_value$2]),
     kind$3=2,
     mode$4=1;
    function make_value$3(state,stack)
     {var _ai_=caml_call1(positions$0,state);
      return [0,caml_call1(sexps_of_stack$0,stack),_ai_]}
    var
     Many_and_positions=Make([0,kind$3,mode$4,empty,make_value$3]),
     kind$4=2;
    function make_value$4(state,stack)
     {var _ah_=caml_call1(positions$0,state);
      return [0,caml_call1(sexp_of_stack$0,stack),_ah_]}
    var
     Eager_and_positions=Make_eager([0,kind$4,empty,make_value$4]),
     kind$5=0,
     mode$5=0,
     empty$1=0;
    function make_value$5(state,param){return caml_call1(positions$0,state)}
    var
     Single_just_positions=Make([0,kind$5,mode$5,empty$1,make_value$5]),
     kind$6=0,
     mode$6=1,
     empty$2=0;
    function make_value$6(state,param){return caml_call1(positions$0,state)}
    var
     Many_just_positions=Make([0,kind$6,mode$6,empty$2,make_value$6]),
     kind$7=0,
     empty$3=0;
    function make_value$7(state,param){return caml_call1(positions$0,state)}
    var
     Eager_just_positions=Make_eager([0,kind$7,empty$3,make_value$7]),
     kind$8=3,
     mode$7=1;
    function make_value$8(param,stack)
     {return caml_call1(sexps_cst_of_stack$0,stack)}
    var Many_cst=Make([0,kind$8,mode$7,empty$0,make_value$8]),kind$9=3;
    function make_value$9(param,stack)
     {var match=caml_call1(sexps_cst_of_stack$0,stack);
      if(match)if(! match[2]){var sexp=match[1];return sexp}
      throw [0,Assert_failure,_ad_]}
    var Eager_cst=Make_eager([0,kind$9,empty$0,make_value$9]);
    function Make_conv(Mode,Parser,Parser_pos)
     {function reraise(positions,parsed_value,sub,exn)
       {var loc=caml_call3(Mode[2],positions,parsed_value,sub);
        throw [0,Of_sexp_error$1,[0,exn,sub,loc]]}
      function parse_string_exn(str,f)
       {var parsed_value=caml_call1(Parser[10],str);
        try
         {var x=caml_call2(Mode[1],parsed_value,f);return x}
        catch(_ag_)
         {_ag_ = caml_wrap_exception(_ag_);
          if(_ag_[1] === Sexplib0_Sexp[6])
           {var
             sub=_ag_[3],
             exn=_ag_[2],
             positions=caml_call1(Parser_pos[10],str);
            return reraise(positions,parsed_value,sub,exn)}
          throw _ag_}}
      function parse_string(str,f)
       {try
         {var x=parse_string_exn(str,f)}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Parse_error$0){var e=exn[2];return [1,[0,e]]}
          if(exn[1] === Of_sexp_error$1){var e$0=exn[2];return [1,[1,e$0]]}
          throw exn}
        return [0,x]}
      function conv_exn(param,f)
       {var positions=param[2],parsed_value=param[1];
        try
         {var x=caml_call2(Mode[1],parsed_value,f);return x}
        catch(_af_)
         {_af_ = caml_wrap_exception(_af_);
          if(_af_[1] === Sexplib0_Sexp[6])
           {var sub=_af_[3],exn=_af_[2];
            return reraise(positions,parsed_value,sub,exn)}
          throw _af_}}
      function conv(x,f)
       {try
         {var x$0=conv_exn(x,f)}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Of_sexp_error$1){var e=exn[2];return [1,e]}
          throw exn}
        return [0,x$0]}
      function conv_combine(result,f)
       {if(0 === result[0])
         {var x=result[1],r=conv(x,f);
          if(0 === r[0])return r;
          var e=r[1];
          return [1,[1,e]]}
        var e$0=result[1];
        return [1,[0,e$0]]}
      return [0,
              reraise,
              parse_string_exn,
              parse_string,
              conv_exn,
              conv,
              conv_combine]}
    function map(x,f){return caml_call1(f,x)}
    var Conv_single=Make_conv([0,map,find$0],Single,Single_just_positions);
    function map$0(x,f)
     {var _ae_=caml_call2(List[19],f,x);return caml_call1(List[9],_ae_)}
    var
     Conv_many=Make_conv([0,map$0,find$1],Many,Many_just_positions),
     Private=[0,0],
     Parsexp$0=
      [0,
       Positions,
       Cst,
       [0,sexp_of_t$4,position$2,message$1,report],
       Parse_error$0,
       Single,
       Many,
       Eager,
       Single_and_positions,
       Many_and_positions,
       Eager_and_positions,
       Single_just_positions,
       Many_just_positions,
       Eager_just_positions,
       Many_cst,
       Eager_cst,
       Of_sexp_error$0,
       Of_sexp_error$1,
       Conv_error,
       [0,
        Conv_single[3],
        Conv_single[2],
        Conv_single[5],
        Conv_single[4],
        Conv_single[6]],
       [0,Conv_many[3],Conv_many[2],Conv_many[5],Conv_many[4],Conv_many[6]],
       Private];
    caml_register_global(111,Parsexp$0,"Parsexp");
    return}
  (function(){return this}()));


//# 1 ".js/sexplib/sexplib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_get_1=runtime.caml_ba_get_1,
     caml_ba_set_1=runtime.caml_ba_set_1,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_new_string=runtime.caml_new_string,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call9(f,a0,a1,a2,a3,a4,a5,a6,a7,a8)
     {return f.length == 9
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8])}
    function caml_call10(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
     {return f.length == 10
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parser=caml_new_string("parser"),
     what=caml_new_string("sexp"),
     yylhs=
      caml_new_string
       ("\xff\xff\x01\0\x01\0\x06\0\x06\0\x06\0\x06\0\b\0\b\0\x05\0\x05\0\x02\0\x02\0\x02\0\x02\0\x07\0\x07\0\x07\0\x07\0\x04\0\x04\0\x03\0\x03\0\0\0\0\0\0\0\0\0"),
     yylen=
      caml_new_string
       ("\x02\0\x02\0\x01\0\x01\0\x02\0\x03\0\x01\0\x02\0\x03\0\x01\0\x02\0\x01\0\x02\0\x01\0\x02\0\x01\0\x01\0\x02\0\x02\0\x02\0\x01\0\x02\0\x01\0\x02\0\x02\0\x02\0\x02\0"),
     yydefred=
      caml_new_string
       ("\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x03\0\0\0\0\0\x17\0\0\0\x02\0\t\0\r\0\x18\0\0\0\x0b\0\x16\0\x19\0\x0f\0\0\0\x10\0\x14\0\x1a\0\0\0\x04\0\0\0\0\0\x07\0\x01\0\n\0\x0e\0\f\0\x15\0\x11\0\x12\0\x13\0\x05\0\b\0"),
     yydgoto=
      caml_new_string("\x05\0\n\0\x0f\0\x13\0\x18\0\x0b\0\x14\0\x15\0\r\0"),
     yysindex=
      caml_new_string
       ('(\0"\xff\x01\0\x06\0\x0b\0\0\0\0\0\0\0:\xff"\xff\0\0"\xff\0\0\0\0\0\0\0\0\x10\0\0\0\0\0\0\0\0\0\x15\0\0\0\0\0\0\0\x1a\0\0\0?\xff"\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'),
     yyrindex=
      caml_new_string
       ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
     yygindex=
      caml_new_string("\0\0\0\0\0\0\0\0\0\0\xfe\xff\x03\0\x05\0\x1d\0"),
     yytable=
      caml_new_string
       ("\x10\0\x0e\0\0\0\0\0\f\0\x11\0\x12\0\x1c\0\0\0\x19\0\0\0\x17\0\x1d\0\x1b\0\x1e\0\0\0 \0\0\0\0\0!\0\0\0\"\0\0\0\0\0#\0\0\0%\0\0\0#\0\0\0#\0'\0\x16\0\x16\0\x06\0\x07\0\b\0\x16\0\t\0\0\0\x1f\0\x01\0\x02\0\x03\0\x04\0\x1f\0\0\0\0\0\0\0\0\0$\0\0\0\0\0\0\0$\0\0\0$\0\x1f\0\x06\0\x07\0\b\0\x1a\0\t\0\x06\0\x07\0\b\0&\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x07\0\b\0\0\0\t\0\x06\0\x07\0\b\0\0\0\t\0\x06\0\x07\0\b\0\0\0\t\0\x06\0\x07\0\b\0\0\0\t\0\x06\0\x07\0\b\0\0\0\t\0\x06\0\x07\0\b\0\0\0\t\0"),
     yycheck=
      caml_new_string
       ("\x02\0\0\0\xff\xff\xff\xff\x01\0\x02\0\0\0\t\0\xff\xff\x04\0\xff\xff\0\0\t\0\b\0\x0b\0\xff\xff\0\0\xff\xff\xff\xff\x10\0\xff\xff\0\0\xff\xff\xff\xff\x15\0\xff\xff\0\0\xff\xff\x19\0\xff\xff\x1b\0\x1c\0\x03\0\x04\0\0\x01\x01\x01\x02\x01\b\0\x04\x01\xff\xff\x0b\0\x01\0\x02\0\x03\0\x04\0\x10\0\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\xff\xff\xff\xff\xff\xff\x19\0\xff\xff\x1b\0\x1c\0\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\xff\xff\x04\x01\0\x01\x01\x01\x02\x01\xff\xff\x04\x01\0\x01\x01\x01\x02\x01\xff\xff\x04\x01\0\x01\x01\x01\x02\x01\xff\xff\x04\x01\0\x01\x01\x01\x02\x01\xff\xff\x04\x01\0\x01\x01\x01\x02\x01\xff\xff\x04\x01"),
     yynames_const=caml_new_string("LPAREN\0RPAREN\0EOF\0HASH_SEMI\0"),
     yynames_block=caml_new_string("STRING\0"),
     zero=[0,0,0],
     origin=[0,1,1],
     cst_parser$0=caml_new_string("parser"),
     what$0=caml_new_string("sexp"),
     yylhs$0=
      caml_new_string
       ("\xff\xff\x06\0\x06\0\x06\0\b\0\b\0\t\0\t\0\n\0\n\0\x07\0\x07\0\x01\0\x02\0\x02\0\x0b\0\x0b\0\x05\0\x05\0\x03\0\x03\0\x04\0\0\0\0\0\0\0\0\0\0\0"),
     yylen$0=
      caml_new_string
       ("\x02\0\x01\0\x03\0\x01\0\x01\0\x03\0\0\0\x02\0\x01\0\x01\0\0\0\x02\0\x01\0\x01\0\x01\0\x01\0\x02\0\x02\0\x01\0\x02\0\x01\0\x02\0\x02\0\x02\0\x02\0\x02\0\x02\0"),
     yydefred$0=
      caml_new_string
       ("\0\0\0\0\0\0\0\0\n\0\0\0\0\0\x03\0\x01\0\x04\0\n\0\x06\0\x16\0\b\0\t\0\f\0\x0e\0\r\0\x17\0\x14\0\x0f\0\x18\0\0\0\x19\0\0\0\x12\0\x1a\0\0\0\0\0\0\0\x13\0\x10\0\x15\0\x0b\0\x11\0\x02\0\x05\0\x07\0"),
     yydgoto$0=
      caml_new_string
       ("\x06\0\x14\0\x12\0\x15\0\x17\0\x1a\0\r\0\x18\0\x0e\0\x1d\0\x0f\0\x16\0"),
     yysindex$0=
      caml_new_string
       ("%\0\t\xff\x01\0\x07\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x13\0\0\0\x19\0\0\0\0\0\x1f\0 \xff\t\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
     yyrindex$0=
      caml_new_string
       ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
     yygindex$0=
      caml_new_string
       ("\0\0\x02\0\0\0\0\0\0\0\0\0\xe3\xff\xfb\xff\xeb\xff\0\0\xea\xff\n\0"),
     yytable$0=
      caml_new_string
       ('$\0\x10\0!\0\f\0\x11\0\x1c\0!\0\x13\0%\0\x07\0\b\0\t\0\n\0\x19\0\x0b\0\x1b\0\0\0\0\0\0\0\x1e\0\0\0\0\0\0\0\0\0\x1f\0 \0\0\0\0\0\0\0\x1f\0\0\0"\0\x07\0\b\0\t\0\n\0#\0\x0b\0\x01\0\x02\0\x03\0\x04\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\b\0\t\0\n\0\0\0\x0b\0\x07\0\b\0\t\0\n\0\0\0\x0b\0\x07\0\b\0\t\0\n\0\0\0\x0b\0\x07\0\b\0\t\0\n\0\0\0\x0b\0\x07\0\b\0\t\0\n\0\0\0\x0b\0\x07\0\b\0\t\0\n\0\0\0\x0b\0'),
     yycheck$0=
      caml_new_string
       ("\x1d\0\0\0\x18\0\x01\0\x02\0\n\0\x1c\0\0\0\x1d\0\0\x01\x01\x01\x02\x01\x03\x01\0\0\x05\x01\x05\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\x16\0\0\0\xff\xff\xff\xff\xff\xff\x1b\0\xff\xff\0\0\0\x01\x01\x01\x02\x01\x03\x01\x04\x01\x05\x01\x01\0\x02\0\x03\0\x04\0\x05\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01\0\x01\x01\x01\x02\x01\x03\x01\xff\xff\x05\x01"),
     yynames_const$0=caml_new_string("LPAREN\0RPAREN\0EOF\0HASH_SEMI\0"),
     yynames_block$0=caml_new_string("STRING\0COMMENT\0"),
     cst_illegal_end_of_comment=caml_new_string("illegal end of comment"),
     cst_comment_tokens_in_unquoted_atom=
      caml_new_string("comment tokens in unquoted atom"),
     ocaml_lex_tables=
      [0,
       caml_new_string
        ("\0\0\xf4\xff\n\0+\x005\0\xfa\xff\xfb\xff\xfc\xff\x01\0\x06\0\x06\0\xff\xffV\0\xf8\xff\xf9\xff`\0\x81\0\x8b\0\xac\0\xb6\0\xdc\0\xe6\0\x07\x01\xf7\xff\x11\x012\x01<\x01]\x01g\x01\x88\x01\x92\x01\xb5\x01\xbf\x01\xe0\x01\xea\x01\x0b\x02%\0\xf6\xffP\0\xf8\xff\x17\x02\xff\xff\xf9\xff9\x02!\x02\xfc\xff\x07\0\x10\0\x11\0p\x02\xfb\xff\x90\x02\xfa\xffQ\0\xfa\xff\xfd\xffz\0\xff\xff\xa6\0\x82\x01\xfc\xff\xfb\xff\xad\x01\xfb\x01"),
       caml_new_string
        ("\xff\xff\xff\xff\n\0\n\0\n\0\xff\xff\xff\xff\xff\xff\x02\0\x01\0\xff\xff\xff\xff\n\0\xff\xff\xff\xff\t\0\n\0\t\0\t\0\t\0\t\0\t\0\n\0\xff\xff\t\0\n\0\t\0\t\0\t\0\t\0\t\0\n\0\n\0\t\0\t\0\t\0\xff\xff\xff\xff\b\0\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\xff\xff\x06\0\x01\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),
       caml_new_string
        ('\x02\0\0\0\x02\0\x02\0\x02\0\0\0\0\0\0\0\b\0\xff\xff\xff\xff\0\0\x02\0\0\0\0\0\x14\0\x02\0\x12\0\x12\0\x12\0\x14\0\x14\0\x02\0\0\0\x1d\0\x02\0\x1b\0\x1b\0\x1b\0\x1d\0\x1d\0\x02\0\x02\0"\0"\0"\0&\0\0\0&\0\0\0*\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\x008\0\0\0\0\x008\0\0\x008\x008\0\0\0\0\x008\x008\0'),
       caml_new_string
        ("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\x0b\0\xff\xff\t\0\n\0\xff\xff\t\0\x0b\x000\0\t\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0/\x000\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\x05\0\x04\0\0\0\0\0\t\0\0\0\x07\0\x06\0\xff\xff\0\0\xff\xff \0\0\0'\0/\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\b\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0)\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\x17\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\f\0\0\0\xff\xff9\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\x0e\0\0\0\xff\xff7\0;\0\0\0\xff\xff\0\0\xff\xff\x10\0\0\0\0\0\x03\0\0\0\xff\xff\xff\xff\xff\xff(\0\xff\xff\x13\0\xff\xff\0\0\x1f\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff?\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\x10\0\0\0\0\0\x16\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x13\0\0\x009\0\r\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\x007\0=\0\0\0\0\0\xff\xff:\0\xff\xff\x13\0\0\0\0\0\x0f\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x13\0\0\0\0\0\x0f\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0>\0\0\0\0\0\0\0\0\0\0\0\xff\xff\x11\0\xff\xff\x15\0\x01\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\x11\0\xff\xff\x15\0\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff:\0\0\0\0\0%\0\0\0\xff\xff\x11\0\xff\xff\x18\0\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\x11\0\xff\xff\x18\0\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\0\0\xff\xff6\0\xff\xff\0\0\xff\xff\x1a\0\xff\xff\0\0\x0f\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x1a\0\xff\xff\0\0\x11\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\x1a\0\xff\xff\0\0\x19\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x1a\0\xff\xff9\0\x1c\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\x007\0;\0\xff\xff\0\0\xff\xff\0\0\xff\xff\x18\0\xff\xff\0\0\x19\0\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x1a\0\xff\xff\xff\xff\x1c\0\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff#\0\x1c\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff \0\x1c\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\0\0\0\0<\0\0\0\xff\xff\0\0\xff\xff#\0\x1e\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff#\0\x1e\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff?\0\0\0\0\0/\0\0\0\0\0.\0\xff\xff\0\0\0\0\0\0>\0\0\0\xff\xff\0\0\xff\xff#\0\0\0\0\0\x1f\0\xff\xff\xff\xff\xff\xff\0\0\0\0-\0\0\0-\0\0\0!\0\xff\xff\0\0-\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff,\0,\0,\0,\0,\0,\0,\0,\0,\0,\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\0\0!\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0!\0\xff\xff\0\x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0-\0\0\0\0\0\0\0\xff\xff\0\0-\x003\x003\x003\x003\x003\x003\0\0\0\0\0\xff\xff\0\0\0\0-\0\0\0!\0\xff\xff-\0\0\0-\0\0\0\0\0\0\0+\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\x003\x003\x003\x003\x003\x003\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff4\x004\x004\x004\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\x004\x004\x004\x004\x004\x004\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),
       caml_new_string
        ('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\b\0\0\0\0\0\b\0\t\0\n\0.\0\t\0\x02\0\x02\0\xff\xff\x02\0\x02\0\xff\xff/\x000\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\t\0\xff\xff\0\0\0\0\x02\0\xff\xff\x02\0\x02\0\xff\xff$\0/\x000\0\x02\0\x02\0\x03\0\x03\0\xff\xff\x03\0\x03\0\xff\xff\xff\xff\0\0\xff\xff\xff\xff\x04\0\x04\0\xff\xff\x04\0\x04\0\xff\xff\xff\xff\x02\0\xff\xff$\0\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x03\0\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\x03\0\x04\0\xff\xff\x04\0\x04\0\xff\xff&\x005\0\xff\xff\x04\0\x04\0\f\0\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\x03\0\xff\xff\xff\xff\x0f\0\x0f\0\xff\xff\x0f\0\x0f\0\xff\xff\xff\xff\x04\0\xff\xff&\x005\x005\0\xff\xff\f\0\xff\xff\f\0\f\0\xff\xff\xff\xff\0\0\xff\xff\f\0\f\0\x0f\0$\0\x0f\0\x0f\x008\0\xff\xff\x02\0\xff\xff\x0f\0\x0f\0\x10\0\x10\0\xff\xff\x10\0\x10\0\xff\xff\xff\xff\f\0\xff\xff\xff\xff\x11\0\x11\0\xff\xff\x11\0\x11\0\xff\xff\xff\xff\x0f\x008\x008\0\xff\xff\xff\xff\xff\xff\x10\0\xff\xff\x10\0\x10\0\xff\xff\xff\xff\x03\0\xff\xff\x10\0\x10\0\x11\0&\0\x11\0\x11\0\xff\xff:\0\x04\0\xff\xff\x11\0\x11\0\x12\0\x12\0\xff\xff\x12\0\x12\0\xff\xff\xff\xff\x10\0\xff\xff\xff\xff\x13\0\x13\0\xff\xff\x13\0\x13\0\xff\xff\xff\xff\x11\0\xff\xff:\0:\0\xff\xff\xff\xff\x12\x005\0\x12\0\x12\0\xff\xff\xff\xff\f\0\xff\xff\x12\0\x12\0\x13\0\xff\xff\x13\0\x13\0\xff\xff\xff\xff\x0f\0\xff\xff\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x12\0\x14\0\x14\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x15\0\x15\0\x13\0\x15\0\x15\0\xff\xff\xff\xff8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x10\0\x14\0\x14\0\0\0\b\0\xff\xff\xff\xff\x14\0\x14\0\x15\0\x11\0\x15\0\x15\0\x02\0\xff\xff\xff\xff\xff\xff\x15\0\x15\0\x16\0\x16\0\xff\xff\x16\0\x16\0\xff\xff\xff\xff\x14\0\xff\xff\xff\xff\x18\0\x18\0\xff\xff\x18\0\x18\0\xff\xff\xff\xff\x15\0:\0\xff\xff\xff\xff$\0\xff\xff\x16\0\x12\0\x16\0\x16\0\x03\0\xff\xff\xff\xff\xff\xff\x16\0\x16\0\x18\0\x13\0\x18\0\x18\0\x04\0\xff\xff\xff\xff\xff\xff\x18\0\x18\0\x19\0\x19\0\xff\xff\x19\0\x19\0\xff\xff\xff\xff\x16\0\xff\xff\xff\xff\x1a\0\x1a\0\xff\xff\x1a\0\x1a\0\xff\xff\xff\xff\x18\0\xff\xff\xff\xff\xff\xff&\x005\0\x19\0\xff\xff\x19\0\x19\0\f\0\xff\xff\x14\0\xff\xff\x19\0\x19\0\x1a\0\xff\xff\x1a\0\x1a\0\x0f\0\xff\xff\x15\0\xff\xff\x1a\0\x1a\0\x1b\0\x1b\0\xff\xff\x1b\0\x1b\0\xff\xff\xff\xff\x19\0\xff\xff\xff\xff\x1c\0\x1c\0\xff\xff\x1c\0\x1c\0\xff\xff\xff\xff\x1a\0\xff\xff\xff\xff8\0\xff\xff\xff\xff\x1b\0\xff\xff\x1b\0\x1b\0\x10\0\xff\xff\x16\0\xff\xff\x1b\0\x1b\0\x1c\0\xff\xff\x1c\0\x1c\0\x11\0;\0\x18\0\xff\xff\x1c\0\x1c\0\x1d\0\x1d\0\xff\xff\x1d\0\x1d\0\xff\xff\xff\xff\x1b\0\xff\xff\xff\xff\x1e\0\x1e\0\xff\xff\x1e\0\x1e\0\xff\xff\xff\xff\x1c\0\xff\xff;\0;\0:\0\xff\xff\x1d\0\xff\xff\x1d\0\x1d\0\x12\0\xff\xff\x19\0\xff\xff\x1d\0\x1d\0\x1e\0\xff\xff\x1e\0\x1e\0\x13\0>\0\x1a\0\xff\xff\x1e\0\x1e\0\xff\xff\xff\xff\x1f\0\x1f\0\xff\xff\x1f\0\x1f\0\x1d\0\xff\xff\xff\xff\xff\xff\xff\xff \0 \0\xff\xff \0 \0\x1e\0\xff\xff>\0>\0\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\x1f\0\x1f\0\x1b\0\xff\xff\xff\xff\x14\0\x1f\0\x1f\0 \0\xff\xff \0 \0\x1c\0\xff\xff\xff\xff\x15\0 \0 \0!\0!\0\xff\xff!\0!\0\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff"\0"\0\xff\xff"\0"\0\xff\xff\xff\xff \0\xff\xff\xff\xff\xff\xff;\0\xff\xff!\0\xff\xff!\0!\0\x1d\0?\0\xff\xff\x16\0!\0!\0"\0\xff\xff"\0"\0\x1e\0\xff\xff\xff\xff\x18\0"\0"\0#\0#\0\xff\xff#\0#\0\xff\xff\xff\xff!\0\xff\xff?\0?\0\xff\xff\xff\xff(\0\xff\xff\xff\xff(\0"\0\xff\xff\xff\xff\xff\xff>\0\xff\xff#\0\xff\xff#\0#\0\xff\xff\xff\xff\x1f\0\x19\0#\0#\0\xff\xff\xff\xff(\0\xff\xff(\0\xff\xff \0\x1a\0\xff\xff(\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0(\0(\0(\0(\0(\0(\0(\0(\0(\0(\0,\0,\0,\0,\0,\0,\0,\0,\0,\0,\0\xff\xff!\0\x1b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"\0\x1c\0\xff\xff+\0+\0+\0+\0+\0+\0+\0+\0+\0+\0(\0\xff\xff\xff\xff\xff\xff?\0\xff\xff(\0+\0+\0+\0+\0+\0+\0\xff\xff\xff\xff;\0\xff\xff\xff\xff(\0\xff\xff#\0\x1d\0(\0\xff\xff(\0\xff\xff\xff\xff\xff\xff(\0\xff\xff\xff\xff\x1e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff+\0+\0+\0+\0+\0+\x001\x001\x001\x001\x001\x001\x001\x001\x001\x001\0\xff\xff\xff\xff\xff\xff>\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff \x003\x003\x003\x003\x003\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff!\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff3\x003\x003\x003\x003\x003\0\xff\xff\xff\xff\xff\xff\xff\xff?\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff#\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff(\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string(""),
       caml_new_string("")],
     cst_Sexplib_Sexp_subst_found_short_list_when_position_requested=
      caml_new_string
       ("Sexplib.Sexp.subst_found: short list when position requested"),
     cst_Sexplib_Sexp_subst_found_atom_when_position_requested=
      caml_new_string
       ("Sexplib.Sexp.subst_found: atom when position requested"),
     cst_Annotated_of_bigstring=caml_new_string("Annotated.of_bigstring"),
     cst$5=caml_new_string(" "),
     cst_Annotated_of_string=caml_new_string("Annotated.of_string"),
     cst$4=caml_new_string(" "),
     cst_additional_incomplete_data=
      caml_new_string("additional incomplete data"),
     cst$3=caml_new_string(" "),
     cst_of_bigstring=caml_new_string("of_bigstring"),
     cst$2=caml_new_string(" "),
     cst_of_string=caml_new_string("of_string"),
     cst$1=caml_new_string(" "),
     cst_Sexplib_Sexp_input_rev_sexps_reached_EOF_while_in_state=
      caml_new_string
       ("Sexplib.Sexp.input_rev_sexps: reached EOF while in state "),
     cst$0=caml_new_string(" "),
     cst_Sexplib_Sexp_parser_continuation_called_twice=
      caml_new_string("Sexplib.Sexp: parser continuation called twice"),
     cst_parse_pos_0=caml_new_string("parse: pos < 0"),
     cst_parse_len_0=caml_new_string("parse: len < 0"),
     cst_parse_pos_len_str_len=caml_new_string("parse: pos + len > str_len"),
     cst_Parsing_toplevel_whitespace=
      caml_new_string("Parsing_toplevel_whitespace"),
     cst_Parsing_nested_whitespace=
      caml_new_string("Parsing_nested_whitespace"),
     cst_Parsing_atom=caml_new_string("Parsing_atom"),
     cst_Parsing_list=caml_new_string("Parsing_list"),
     cst_Parsing_sexp_comment=caml_new_string("Parsing_sexp_comment"),
     cst_Parsing_block_comment=caml_new_string("Parsing_block_comment"),
     cst_Sexplib_Sexp_Parse_pos_create=
      caml_new_string("Sexplib.Sexp.Parse_pos.create: "),
     cst_text_line_1=caml_new_string("text_line < 1"),
     cst_text_char_0=caml_new_string("text_char < 0"),
     cst_global_offset_0=caml_new_string("global_offset < 0"),
     cst_buf_pos_0=caml_new_string("buf_pos < 0"),
     cst=caml_new_string("\n"),
     cst_tmp=caml_new_string("tmp"),
     cst_Sexplib_Pre_sexp_Annot_Conv_exn=
      caml_new_string("Sexplib__Pre_sexp.Annot.Conv_exn"),
     cst_Sexplib_Pre_sexp_Annot_Annot_sexp=
      caml_new_string("Sexplib__Pre_sexp.Annot.Annot_sexp"),
     cst_Sexplib_Pre_sexp_Parse_error=
      caml_new_string("Sexplib__Pre_sexp.Parse_error"),
     cst_Sexplib_Pre_sexp_Parser_output_Bare_sexp_Found=
      caml_new_string("Sexplib__Pre_sexp.Parser_output.Bare_sexp.Found"),
     cst_Sexplib_Pre_sexp_Parser_output_Annotated_sexp_Found=
      caml_new_string("Sexplib__Pre_sexp.Parser_output.Annotated_sexp.Found"),
     gen_load_sexp_loc=caml_new_string("Sexplib.Sexp.gen_load_sexp"),
     cst_Sexplib_Pre_sexp_Of_string_conv_exn_E=
      caml_new_string("Sexplib__Pre_sexp.Of_string_conv_exn.E"),
     unit=[1,0],
     cst$6=caml_new_string(""),
     cst$7=caml_new_string("#;"),
     cst_float_mat_of_sexp_not_enough_data=
      caml_new_string("float_mat_of_sexp: not enough data"),
     cst_float_mat_of_sexp_list_needed=
      caml_new_string("float_mat_of_sexp: list needed"),
     cst_float_mat_of_sexp_list_too_short=
      caml_new_string("float_mat_of_sexp: list too short"),
     cst_float_mat_of_sexp_too_much_data=
      caml_new_string("float_mat_of_sexp: too much data"),
     cst_float_vec_of_sexp_list_needed=
      caml_new_string("float_vec_of_sexp: list needed"),
     cst_bigstring_of_sexp_atom_needed=
      caml_new_string("bigstring_of_sexp: atom needed"),
     cst_Error_in_file=caml_new_string("Error in file "),
     cst_include$1=caml_new_string(":include"),
     cst_include$0=caml_new_string(":include"),
     cst_let$0=caml_new_string(":let"),
     cst_Empty_let_bodies_not_allowed=
      caml_new_string("Empty let bodies not allowed"),
     cst$8=caml_new_string(", "),
     cst$9=caml_new_string(", "),
     cst_Malformed_argument=caml_new_string("Malformed argument"),
     cst_concat=caml_new_string(":concat"),
     cst_include=caml_new_string(":include"),
     cst_let$1=caml_new_string(":let"),
     cst_use$0=caml_new_string(":use"),
     cst_Unexpected=caml_new_string("Unexpected "),
     cst_concat$0=caml_new_string(":concat"),
     cst_use$1=caml_new_string(":use"),
     cst_Undefined_variable=caml_new_string("Undefined variable"),
     cst$10=caml_new_string(", "),
     cst$11=caml_new_string(""),
     cst_let=caml_new_string(":let"),
     cst_use=caml_new_string(":use"),
     msg=
      caml_new_string
       ("Undefined variable (included files cannot reference variables from outside)"),
     cst_Atom_list_expected=caml_new_string("Atom list expected"),
     cst_Atom_expected=caml_new_string("Atom expected"),
     cst_Sexplib_Macro_Include_loop_detected=
      caml_new_string("Sexplib__Macro.Include_loop_detected"),
     cst_Sexplib_Macro_Macro_conv_error=
      caml_new_string("Sexplib__Macro.Macro_conv_error"),
     cst_Sexplib_Macro_Error_in_file=
      caml_new_string("Sexplib__Macro.Error_in_file"),
     cst_EOF_reading_index=caml_new_string("EOF reading index"),
     cst_empty_index=caml_new_string("empty index"),
     cst_double=caml_new_string("double '.'"),
     cst_EOF_after_escape=caml_new_string("EOF after escape"),
     cst_path_empty=caml_new_string("path empty"),
     cst_Path_parse=caml_new_string("Path.parse: "),
     cst_extract_rec=caml_new_string("extract_rec"),
     cst_extract_match=caml_new_string("extract_match"),
     cst_extract_match$0=caml_new_string("extract_match"),
     cst_Path_extract_match_unexpected_nested_list_in=
      caml_new_string("Path.extract_match: unexpected nested list in: "),
     cst_extract_pos=caml_new_string("extract_pos"),
     cst_extract_pos$0=caml_new_string("extract_pos"),
     Parsing=global_data.Parsing,
     Pervasives=global_data.Pervasives,
     List=global_data.List,
     Printf=global_data.Printf,
     Buffer=global_data.Buffer,
     Lexing=global_data.Lexing,
     Char=global_data.Char,
     Assert_failure=global_data.Assert_failure,
     include$1=global_data.Sexplib0__Sexp_conv,
     Format=global_data.Format,
     String=global_data.String,
     Bytes=global_data.Bytes,
     End_of_file=global_data.End_of_file,
     Parsexp_Parser_automaton=global_data.Parsexp__Parser_automaton,
     Parsexp_Positions=global_data.Parsexp__Positions,
     Sys_error=global_data.Sys_error,
     Random=global_data.Random,
     Sexplib0_Sexp=global_data.Sexplib0__Sexp,
     Parsexp=global_data.Parsexp,
     Bigarray=global_data.Bigarray,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Obj=global_data.Obj,
     Not_found=global_data.Not_found,
     Failure=global_data.Failure,
     Filename=global_data.Filename,
     Set=global_data.Set,
     Map=global_data.Map,
     Hashtbl=global_data.Hashtbl,
     Lazy=global_data.Lazy,
     Sexplib=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    caml_register_global(193,Sexplib,"Sexplib");
    var Sexplib_Type=[0];
    caml_register_global(194,Sexplib_Type,"Sexplib__Type");
    var
     yytransl_const=[0,258,259,0,260,0].slice(),
     yytransl_block=[0,257,0],
     _y_=[1,0],
     _a_=
      [0,
       [11,
        caml_new_string("Sexplib.Parser: failed to parse line "),
        [4,
         0,
         0,
         0,
         [11,
          caml_new_string(" char "),
          [4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]],
       caml_new_string("Sexplib.Parser: failed to parse line %d char %d: %s")],
     _C_=[0,[4,0,0,0,[12,58,[4,0,0,0,0]]],caml_new_string("%d:%d")],
     _G_=[0,caml_new_string("Atom")],
     _H_=[0,caml_new_string("List")],
     _I_=[0,caml_new_string("Sexp")],
     _J_=[0,caml_new_string("Comment")],
     _K_=[0,caml_new_string("Plain_comment")],
     _L_=[0,caml_new_string("Sexp_comment")],
     _F_=[1,0],
     _M_=
      [0,
       [11,
        caml_new_string("Sexplib.Parser: failed to parse line "),
        [4,
         0,
         0,
         0,
         [11,
          caml_new_string(" char "),
          [4,0,0,0,[11,caml_new_string(": "),[2,0,0]]]]]],
       caml_new_string("Sexplib.Parser: failed to parse line %d char %d: %s")],
     _N_=[0,259,260,0,261,0],
     _an_=
      [0,
       [11,
        caml_new_string("Sexplib.Lexer.scan_string: illegal escape at line "),
        [4,
         0,
         0,
         0,
         [11,
          caml_new_string(" char "),
          [4,0,0,0,[11,caml_new_string(": `\\"),[0,[0,[0,[12,39,0]]]]]]]]],
       caml_new_string
        ("Sexplib.Lexer.scan_string: illegal escape at line %d char %d: `\\%c%c%c'")],
     _ao_=
      [0,
       [11,
        caml_new_string
         ("Sexplib.Lexer.scan_string: unterminated string at line "),
        [4,0,0,0,[11,caml_new_string(" char "),[4,0,0,0,0]]]],
       caml_new_string
        ("Sexplib.Lexer.scan_string: unterminated string at line %d char %d")],
     _ap_=[0,caml_new_string("src/lexer.mll"),234,16],
     _aq_=
      [0,
       [11,
        caml_new_string
         ("Sexplib.Lexer.scan_block_comment: unterminated block comment at line "),
        [4,0,0,0,[11,caml_new_string(" char "),[4,0,0,0,0]]]],
       caml_new_string
        ("Sexplib.Lexer.scan_block_comment: unterminated block comment at line %d char %d")],
     _ar_=[0,caml_new_string("src/lexer.mll"),239,16],
     _am_=
      [0,
       [11,
        caml_new_string("Sexplib.Lexer.main: "),
        [2,
         0,
         [11,
          caml_new_string(" at line "),
          [4,0,0,0,[11,caml_new_string(" char "),[4,0,0,0,0]]]]]],
       caml_new_string("Sexplib.Lexer.main: %s at line %d char %d")],
     _aT_=[0,caml_new_string("sub_sexp")],
     _aU_=[0,caml_new_string("sexp")],
     _aV_=[0,caml_new_string("exc")],
     _aW_=[0,caml_new_string("Sexplib.Sexp.Of_string_conv_exn.E")],
     _aX_=[0,caml_new_string("src/pre_sexp.ml"),773,15],
     _aR_=
      [0,
       [2,0,[12,58,[4,0,0,0,[12,58,[4,0,0,0,0]]]]],
       caml_new_string("%s:%d:%d")],
     _aP_=
      [0,
       [2,
        0,
        [11,caml_new_string(": more than one S-expression in file "),[2,0,0]]],
       caml_new_string("%s: more than one S-expression in file %s")],
     _aQ_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": "),
         [2,
          0,
          [11,
           caml_new_string(" in state "),
           [2,0,[11,caml_new_string(" loading file "),[2,0,0]]]]]]],
       caml_new_string("%s: %s in state %s loading file %s")],
     _aO_=
      [0,
       [2,
        0,
        [11,
         caml_new_string(": EOF in "),
         [2,0,[11,caml_new_string(" while in state "),[2,0,0]]]]],
       caml_new_string("%s: EOF in %s while in state %s")],
     _aL_=
      [0,
       [11,
        caml_new_string("Sexplib.Sexp."),
        [2,
         0,
         [11,
          caml_new_string
           (": got multiple S-expressions where only one was expected."),
          0]]],
       caml_new_string
        ("Sexplib.Sexp.%s: got multiple S-expressions where only one was expected.")],
     _aM_=
      [0,
       [11,
        caml_new_string("Sexplib.Sexp."),
        [2,
         0,
         [11,
          caml_new_string(": S-expression followed by data at position "),
          [4,0,0,0,[11,caml_new_string("..."),0]]]]],
       caml_new_string
        ("Sexplib.Sexp.%s: S-expression followed by data at position %d...")],
     _aN_=
      [0,
       [11,
        caml_new_string("Sexplib.Sexp."),
        [2,
         0,
         [11,
          caml_new_string(": incomplete S-expression while in state "),
          [2,0,[11,caml_new_string(": "),[2,0,0]]]]]],
       caml_new_string
        ("Sexplib.Sexp.%s: incomplete S-expression while in state %s: %s")],
     _aJ_=[0,0],
     _aB_=[0,caml_new_string("buf_pos")],
     _aC_=[0,caml_new_string("global_offset")],
     _aD_=[0,caml_new_string("text_char")],
     _aE_=[0,caml_new_string("text_line")],
     _aF_=[0,caml_new_string("err_msg")],
     _aG_=[0,caml_new_string("Sexplib.Sexp.Parse_error")],
     _aH_=[0,caml_new_string("src/pre_sexp.ml"),268,13],
     _ay_=[0,caml_new_string("Result")],
     _az_=[0,caml_new_string("Error")],
     _av_=[0,caml_new_string("Sexplib.Sexp.Annotated.Conv_exn")],
     _aw_=[0,caml_new_string("src/pre_sexp.ml"),152,15],
     _at_=[0,1,[0,3,[0,5,[0,7,0]]]],
     _as_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_new_string("%s%06x%s")],
     _ax_=[0,0],
     _aI_=[0,0],
     _aY_=[0,0],
     _aZ_=[0,caml_new_string("src/sexp_with_layout.ml"),106,4],
     _bR_=
      [0,
       [11,
        caml_new_string("of_string failed on "),
        [2,0,[11,caml_new_string(" with "),[2,0,0]]]],
       caml_new_string("of_string failed on %s with %s")],
     _cc_=
      [0,[2,0,[11,caml_new_string(": "),[2,0,0]]],caml_new_string("%s: %s")],
     _cd_=
      [0,[2,0,[11,caml_new_string(": "),[2,0,0]]],caml_new_string("%s: %s")],
     _ca_=[0,caml_new_string("src/macro.ml"),425,13],
     _b__=[0,caml_new_string("src/macro.ml"),415,11],
     _b9_=
      [0,
       [11,
        caml_new_string("wrong number of sexps in "),
        [2,0,[11,caml_new_string(", expecting 1, got "),[4,0,0,0,0]]]],
       caml_new_string("wrong number of sexps in %s, expecting 1, got %d")],
     _b2_=
      [0,
       [11,caml_new_string("Unused variables: "),[2,0,0]],
       caml_new_string("Unused variables: %s")],
     _b3_=
      [0,
       [11,caml_new_string("Undeclared arguments in let: "),[2,0,0]],
       caml_new_string("Undeclared arguments in let: %s")],
     _b4_=
      [0,
       [11,caml_new_string("Duplicated let argument: "),[2,0,0]],
       caml_new_string("Duplicated let argument: %s")],
     _b5_=
      [0,
       [11,caml_new_string(" formal args are ["),[2,0,[12,93,0]]],
       caml_new_string(" formal args are [%s]")],
     _b6_=
      [0,
       [11,
        caml_new_string("Formal args of "),
        [2,0,[11,caml_new_string(" differ from supplied args,"),0]]],
       caml_new_string("Formal args of %s differ from supplied args,")],
     _b7_=[0,caml_new_string(":concat")],
     _b8_=
      [0,
       [11,caml_new_string("Malformed concat application: "),[2,0,0]],
       caml_new_string("Malformed concat application: %s")],
     _b0_=[0,caml_new_string("Result")],
     _b1_=[0,caml_new_string("Error")],
     _bY_=[0,caml_new_string("Result")],
     _bZ_=[0,caml_new_string("Error")],
     _bX_=
      [0,
       [11,caml_new_string("Error evaluating macros: "),[2,0,0]],
       caml_new_string("Error evaluating macros: %s")],
     _bT_=[0,caml_new_string("expanded")],
     _bU_=[0,caml_new_string("Sexplib.Macro.Macro_conv_error")],
     _bV_=[0,caml_new_string("src/macro.ml"),17,13],
     _bW_=[0,0],
     _cb_=[0,0],
     _ch_=
      [0,
       [11,caml_new_string("illegal character in index: "),[0,0]],
       caml_new_string("illegal character in index: %c")],
     _ci_=
      [0,
       [11,caml_new_string("'.' expected; got '"),[0,[12,39,0]]],
       caml_new_string("'.' expected; got '%c'")],
     _cg_=
      [0,
       [11,
        caml_new_string('Path.extract_rec: key "'),
        [2,0,[11,caml_new_string('" not found in: '),[2,0,0]]]],
       caml_new_string('Path.extract_rec: key "%s" not found in: %s')],
     _cf_=
      [0,
       [11,
        caml_new_string("Path."),
        [2,
         0,
         [11,
          caml_new_string(": illegal index "),
          [4,0,0,0,[11,caml_new_string(" in: "),[2,0,0]]]]]],
       caml_new_string("Path.%s: illegal index %d in: %s")],
     _ce_=
      [0,
       [11,
        caml_new_string("Path."),
        [2,0,[11,caml_new_string(": illegal atom: "),[2,0,0]]]],
       caml_new_string("Path.%s: illegal atom: %s")],
     yytablesize=286;
    function _b_(caml_parser_env)
     {var _gq_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_gq_]}
    function _c_(caml_parser_env)
     {var _gp_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_gp_]}
    function _d_(caml_parser_env)
     {var _go_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_go_]}
    function _e_(caml_parser_env)
     {var _gn_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_gn_]}
    function _f_(caml_parser_env){return 0}
    function _g_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);
      return caml_call1(List[9],_1)}
    function _h_(caml_parser_env){return 0}
    function _i_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);return _1}
    function _j_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);
      caml_call2(Parsing[14],caml_parser_env,0);
      return _1}
    function _k_(caml_parser_env)
     {var
       _1=caml_call2(Parsing[14],caml_parser_env,1),
       _2=caml_call2(Parsing[14],caml_parser_env,0);
      return [0,_2,_1]}
    function _l_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,0);return 0}
    function _m_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1,0]}
    function _n_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,1);return 0}
    function _o_(caml_parser_env){return 0}
    function _p_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,1);
      var _2=caml_call2(Parsing[14],caml_parser_env,0);
      return [0,_2]}
    function _q_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1]}
    function _r_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,1);
      caml_call2(Parsing[14],caml_parser_env,0);
      return 0}
    function _s_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,0);return 0}
    function _t_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,1);
      caml_call2(Parsing[14],caml_parser_env,0);
      return 0}
    function _u_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,0);return 0}
    function _v_(caml_parser_env)
     {var
       pos=caml_call1(Parsing[5],0),
       msg=caml_call4(Printf[4],_a_,pos[2],pos[4] - pos[3] | 0,what);
      return caml_call1(Pervasives[2],msg)}
    function _w_(caml_parser_env)
     {var _2=caml_call2(Parsing[14],caml_parser_env,1);
      return [1,caml_call1(List[9],_2)]}
    function _x_(caml_parser_env){return _y_}
    function _z_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1]}
    function _A_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return _1}
    function _B_(caml_parser_env)
     {caml_call2(Parsing[14],caml_parser_env,1);
      var _2=caml_call2(Parsing[14],caml_parser_env,0);
      return _2}
    var
     yyact=
      [0,
       function(param){return caml_call1(Pervasives[2],cst_parser)},
       _B_,
       _A_,
       _z_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       _h_,
       _g_,
       _f_,
       _e_,
       _d_,
       _c_,
       _b_],
     yytables=
      [0,
       yyact,
       yytransl_const,
       yytransl_block,
       yylhs,
       yylen,
       yydefred,
       yydgoto,
       yysindex,
       yyrindex,
       yygindex,
       yytablesize,
       yytable,
       yycheck,
       Parsing[16],
       yynames_const,
       yynames_block];
    function sexp(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables,1,lexfun,lexbuf)}
    function sexp_opt(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables,2,lexfun,lexbuf)}
    function sexps(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables,3,lexfun,lexbuf)}
    function rev_sexps(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables,4,lexfun,lexbuf)}
    var Sexplib_Parser=[0,sexp,sexp_opt,sexps,rev_sexps];
    caml_register_global(199,Sexplib_Parser,"Sexplib__Parser");
    function sexp_of_t(param)
     {var col=param[2],row=param[1];
      return [0,caml_call3(Printf[4],_C_,row,col)]}
    function add(t1,t2){return [0,t1[1] + t2[1] | 0,t1[2] + t2[2] | 0]}
    function sub(t1,t2){return [0,t1[1] - t2[1] | 0,t1[2] - t2[2] | 0]}
    function geq(t1,t2)
     {var
       c2=t2[2],
       r2=t2[1],
       c1=t1[2],
       r1=t1[1],
       _gm_=r1 === r2?c1 - c2 | 0:r1 - r2 | 0;
      return 0 <= _gm_?1:0}
    function of_lexing(param)
     {var pos_cnum=param[4],pos_bol=param[3],pos_lnum=param[2];
      return [0,pos_lnum,(pos_cnum - pos_bol | 0) + 1 | 0]}
    var
     _D_=[0,sexp_of_t,origin,of_lexing,sub,add,sub,geq],
     _E_=[0,sexp_of_t,zero,add,sub],
     Sexplib_Src_pos=[0,_E_,_D_];
    caml_register_global(200,Sexplib_Src_pos,"Sexplib__Src_pos");
    function map(t,f)
     {var _gl_=caml_call2(List[19],f,t);return caml_call1(List[9],_gl_)}
    function Make(Pos)
     {var T=[0],of_pos=Pos[1];
      function of_list(of_a,xs){return [1,map(xs,of_a)]}
      function of_t(param)
       {if(0 === param[0])
         {var v3=param[3],v2=param[2],v1=param[1],_gh_=0;
          if(v3)var x=v3[1],_gi_=[1,[0,[0,x],0]];else var _gi_=_F_;
          return [1,
                  [0,_G_,[0,caml_call1(of_pos,v1),[0,[0,v2],[0,_gi_,_gh_]]]]]}
        var
         v3$0=param[3],
         v2$0=param[2],
         v1$0=param[1],
         _gj_=[0,caml_call1(of_pos,v3$0),0],
         _gk_=[0,of_list(of_t_or_comment,v2$0),_gj_];
        return [1,[0,_H_,[0,caml_call1(of_pos,v1$0),_gk_]]]}
      function of_t_or_comment(param)
       {if(0 === param[0]){var t=param[1];return [1,[0,_I_,[0,of_t(t),0]]]}
        var c=param[1];
        return [1,[0,_J_,[0,of_comment(c),0]]]}
      function of_comment(param)
       {if(0 === param[0])
         {var v2=param[2],v1=param[1];
          return [1,[0,_K_,[0,caml_call1(of_pos,v1),[0,[0,v2],0]]]]}
        var
         v3=param[3],
         v2$0=param[2],
         v1$0=param[1],
         _gf_=[0,of_t(v3),0],
         _gg_=[0,of_list(of_comment,v2$0),_gf_];
        return [1,[0,_L_,[0,caml_call1(of_pos,v1$0),_gg_]]]}
      var
       To_sexp=[0,of_t,of_comment,of_t_or_comment],
       sexp_of_t=To_sexp[1],
       sexp_of_comment=To_sexp[2],
       sexp_of_t_or_comment=To_sexp[3];
      return [0,T,To_sexp,sexp_of_t,sexp_of_comment,sexp_of_t_or_comment]}
    var
     include=Make([0,_E_[1]]),
     sexp_of_t$0=include[3],
     sexp_of_comment=include[4],
     sexp_of_t_or_comment=include[5],
     Parsed=Make([0,_D_[1]]);
    function rel(outer_p,p){return caml_call2(_D_[4],p,outer_p)}
    function aux_t(outer_p,param)
     {if(0 === param[0])
       {var sopt=param[3],s=param[2],pos=param[1];
        return [0,rel(outer_p,pos),s,sopt]}
      var
       end_pos=param[3],
       tocs=param[2],
       start_pos=param[1],
       _gd_=rel(outer_p,end_pos),
       _ge_=map(tocs,function(toc){return aux_toc(start_pos,toc)});
      return [1,rel(outer_p,start_pos),_ge_,_gd_]}
    function aux_toc(outer_p,param)
     {if(0 === param[0]){var t=param[1];return [0,aux_t(outer_p,t)]}
      var c=param[1];
      return [1,aux_c(outer_p,c)]}
    function aux_c(outer_p,param)
     {if(0 === param[0])
       {var txt=param[2],pos=param[1];return [0,rel(outer_p,pos),txt]}
      var
       t=param[3],
       cs=param[2],
       pos$0=param[1],
       _gb_=aux_t(outer_p,t),
       _gc_=map(cs,function(c){return aux_c(outer_p,c)});
      return [1,rel(outer_p,pos$0),_gc_,_gb_]}
    function relativize(toc){return aux_toc(_D_[2],toc)}
    var Parsed$0=[0,Parsed[3],Parsed[4],Parsed[5]];
    function Make$0(_ga_){return [0]}
    var
     include$0=
      [0,
       Make$0,
       Parsed$0,
       sexp_of_t$0,
       sexp_of_comment,
       sexp_of_t_or_comment,
       relativize];
    caml_register_global(201,include$0,"Sexplib__Type_with_layout");
    var coerce=_D_[3];
    function start_pos(param)
     {return caml_call1(coerce,caml_call1(Parsing[5],0))}
    var
     yytransl_const$0=_N_.slice(),
     yytransl_block$0=[0,257,258,0],
     yytablesize$0=292;
    function _O_(caml_parser_env)
     {var _f$_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_f$_]}
    function _P_(caml_parser_env)
     {var _f__=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_f__]}
    function _Q_(caml_parser_env)
     {var _f9_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_f9_]}
    function _R_(caml_parser_env)
     {var _f8_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_f8_]}
    function _S_(caml_parser_env)
     {var _f7_=caml_call2(Parsing[14],caml_parser_env,0);
      throw [0,Parsing[12],_f7_]}
    function _T_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);
      return caml_call1(List[9],_1)}
    function _U_(caml_parser_env){return 0}
    function _V_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);
      return caml_call1(List[9],_1)}
    function _W_(caml_parser_env){return 0}
    function _X_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,1);return _1}
    function _Y_(caml_parser_env)
     {var
       _1=caml_call2(Parsing[14],caml_parser_env,1),
       _2=caml_call2(Parsing[14],caml_parser_env,0);
      return [0,_2,_1]}
    function _Z_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1,0]}
    function ___(caml_parser_env){return 0}
    function _$_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1]}
    function _aa_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return relativize(_1)}
    function _ab_(caml_parser_env)
     {var
       _1=caml_call2(Parsing[14],caml_parser_env,1),
       _2=caml_call2(Parsing[14],caml_parser_env,0);
      return [0,_2,_1]}
    function _ac_(caml_parser_env){return 0}
    function _ad_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [1,_1]}
    function _ae_(caml_parser_env)
     {var _1=caml_call2(Parsing[14],caml_parser_env,0);return [0,_1]}
    function _af_(caml_parser_env)
     {var
       _1=caml_call2(Parsing[14],caml_parser_env,1),
       _2=caml_call2(Parsing[14],caml_parser_env,0);
      return [0,_2,_1]}
    function _ag_(caml_parser_env){return 0}
    function _ah_(caml_parser_env)
     {var
       _2=caml_call2(Parsing[14],caml_parser_env,1),
       t=caml_call2(Parsing[14],caml_parser_env,0),
       cs=caml_call1(List[9],_2);
      return [1,start_pos(0),cs,t]}
    function _ai_(caml_parser_env)
     {var
       param=caml_call2(Parsing[14],caml_parser_env,0),
       pos_opt=param[2],
       x=param[1];
      if(pos_opt)
       var pos=pos_opt[1],pos$0=caml_call1(coerce,pos);
      else
       var pos$0=start_pos(0);
      return [0,pos$0,x]}
    function _aj_(caml_parser_env)
     {var
       pos=caml_call1(Parsing[5],0),
       msg=caml_call4(Printf[4],_M_,pos[2],pos[4] - pos[3] | 0,what$0);
      return caml_call1(Pervasives[2],msg)}
    function _ak_(caml_parser_env)
     {var
       _2=caml_call2(Parsing[14],caml_parser_env,1),
       ts=caml_call1(List[9],_2),
       p=caml_call1(Parsing[6],0),
       _f6_=caml_call1(coerce,[0,p[1],p[2],p[3],p[4] - 1 | 0]);
      return [1,start_pos(0),ts,_f6_]}
    function _al_(caml_parser_env)
     {var
       param=caml_call2(Parsing[14],caml_parser_env,0),
       y=param[2],
       x=param[1];
      if(y)
       var
        match=y[1],
        x$0=match[2],
        pos=match[1],
        y$0=[0,x$0],
        pos$0=caml_call1(coerce,pos),
        y$1=y$0;
      else
       var pos$1=start_pos(0),pos$0=pos$1,y$1=0;
      return [0,pos$0,x,y$1]}
    var
     yyact$0=
      [0,
       function(param){return caml_call1(Pervasives[2],cst_parser$0)},
       _al_,
       _ak_,
       _aj_,
       _ai_,
       _ah_,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       _ac_,
       _ab_,
       _aa_,
       _$_,
       ___,
       _Z_,
       _Y_,
       _X_,
       _W_,
       _V_,
       _U_,
       _T_,
       _S_,
       _R_,
       _Q_,
       _P_,
       _O_],
     yytables$0=
      [0,
       yyact$0,
       yytransl_const$0,
       yytransl_block$0,
       yylhs$0,
       yylen$0,
       yydefred$0,
       yydgoto$0,
       yysindex$0,
       yyrindex$0,
       yygindex$0,
       yytablesize$0,
       yytable$0,
       yycheck$0,
       Parsing[16],
       yynames_const$0,
       yynames_block$0];
    function sexp$0(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables$0,1,lexfun,lexbuf)}
    function sexp_opt$0(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables$0,2,lexfun,lexbuf)}
    function sexps$0(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables$0,3,lexfun,lexbuf)}
    function sexps_abs(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables$0,4,lexfun,lexbuf)}
    function rev_sexps$0(lexfun,lexbuf)
     {return caml_call4(Parsing[13],yytables$0,5,lexfun,lexbuf)}
    var
     Sexplib_Parser_with_layout=
      [0,sexp$0,sexp_opt$0,sexps$0,sexps_abs,rev_sexps$0];
    caml_register_global
     (202,Sexplib_Parser_with_layout,"Sexplib__Parser_with_layout");
    var lf=10;
    function found_newline(lexbuf)
     {var lex_curr_p=lexbuf[12];
      return function(diff)
       {lexbuf[12]
        =
        [0,
         lex_curr_p[1],
         lex_curr_p[2] + 1 | 0,
         lex_curr_p[4] - diff | 0,
         lex_curr_p[4]];
        return 0}}
    function lexeme_len(param)
     {var lex_start_pos=param[5],lex_curr_pos=param[6];
      return lex_curr_pos - lex_start_pos | 0}
    function main_failure(lexbuf,msg)
     {var
       match=caml_call1(Lexing[9],lexbuf),
       pos_cnum=match[4],
       pos_bol=match[3],
       pos_lnum=match[2],
       msg$0=caml_call4(Printf[4],_am_,msg,pos_lnum,pos_cnum - pos_bol | 0);
      return caml_call1(Pervasives[2],msg$0)}
    function Make$1(X)
     {function _f0_(buf,lexbuf)
       {a:
        for(;;)
         {var ocaml_lex_state=0;
          for(;;)
           {var
             ocaml_lex_state$0=
              caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state,lexbuf);
            if(11 < ocaml_lex_state$0 >>> 0)
             {caml_call1(lexbuf[1],lexbuf);
              var ocaml_lex_state=ocaml_lex_state$0;
              continue}
            switch(ocaml_lex_state$0)
             {case 0:caml_call1(found_newline(lexbuf),0);continue a;
              case 1:continue a;
              case 2:
               var text=caml_call3(Lexing[13],lexbuf,lexbuf[5],lexbuf[6]);
               return caml_call4(X[2][7],text,_f0_,buf,lexbuf);
              case 3:return X[2][1];
              case 4:return X[2][2];
              case 5:
               var pos=caml_call1(Lexing[9],lexbuf);
               caml_call2(X[1][4],buf,lexbuf);
               scan_string(buf,pos,lexbuf);
               var tok=caml_call2(X[2][6],pos,buf);
               caml_call1(X[1][5],buf);
               return tok;
              case 6:return X[2][5];
              case 7:
               var pos$0=caml_call1(Lexing[9],lexbuf);
               caml_call2(X[1][4],buf,lexbuf);
               var locs=[0,pos$0,0],locs$0=locs;
               b:
               for(;;)
                {var ocaml_lex_state$1=53;
                 for(;;)
                  {var
                    ocaml_lex_state$2=
                     caml_call3
                      (Lexing[17],ocaml_lex_tables,ocaml_lex_state$1,lexbuf);
                   if(5 < ocaml_lex_state$2 >>> 0)
                    {caml_call1(lexbuf[1],lexbuf);
                     var ocaml_lex_state$1=ocaml_lex_state$2;
                     continue}
                   switch(ocaml_lex_state$2)
                    {case 0:
                      caml_call2(X[1][4],buf,lexbuf);
                      caml_call1(found_newline(lexbuf),0);
                      continue b;
                     case 1:caml_call2(X[1][4],buf,lexbuf);continue b;
                     case 2:
                      caml_call2(X[1][4],buf,lexbuf);
                      var
                       cur=caml_call1(Lexing[10],lexbuf),
                       start=[0,cur[1],cur[2],cur[3],cur[4] - 1 | 0];
                      scan_string(buf,start,lexbuf);
                      continue b;
                     case 3:
                      caml_call2(X[1][4],buf,lexbuf);
                      var
                       cur$0=caml_call1(Lexing[10],lexbuf),
                       start$0=[0,cur$0[1],cur$0[2],cur$0[3],cur$0[4] - 2 | 0],
                       locs$1=[0,start$0,locs$0],
                       locs$0=locs$1;
                      continue b;
                     case 4:
                      caml_call2(X[1][4],buf,lexbuf);
                      if(! locs$0)throw [0,Assert_failure,_ap_];
                      var _f5_=locs$0[2];
                      if(_f5_){var locs$0=_f5_;continue b}
                      break;
                     default:
                      if(! locs$0)throw [0,Assert_failure,_ar_];
                      var
                       match=locs$0[1],
                       pos_cnum=match[4],
                       pos_bol=match[3],
                       pos_lnum=match[2],
                       msg=
                        caml_call3(Printf[4],_aq_,pos_lnum,pos_cnum - pos_bol | 0);
                      caml_call1(Pervasives[2],msg)}
                   var tok$0=caml_call4(X[2][8],pos$0,_f0_,buf,lexbuf);
                   caml_call1(X[1][5],buf);
                   return tok$0}}
              case 8:return main_failure(lexbuf,cst_illegal_end_of_comment);
              case 9:
               return main_failure(lexbuf,cst_comment_tokens_in_unquoted_atom);
              case 10:
               var str=caml_call3(Lexing[13],lexbuf,lexbuf[5],lexbuf[6]);
               return caml_call1(X[2][4],str);
              default:return X[2][3]}}}}
      function scan_string(buf,start,lexbuf)
       {a:
        for(;;)
         {var ocaml_lex_state=36;
          for(;;)
           {var
             ocaml_lex_state$0=
              caml_call3(Lexing[17],ocaml_lex_tables,ocaml_lex_state,lexbuf);
            if(9 < ocaml_lex_state$0 >>> 0)
             {caml_call1(lexbuf[1],lexbuf);
              var ocaml_lex_state=ocaml_lex_state$0;
              continue}
            switch(ocaml_lex_state$0)
             {case 0:caml_call2(X[1][4],buf,lexbuf);return 0;
              case 1:
               var len=lexeme_len(lexbuf) - 2 | 0;
               caml_call1(found_newline(lexbuf),len);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 2:
               var len$0=lexeme_len(lexbuf) - 3 | 0;
               caml_call1(found_newline(lexbuf),len$0);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 3:
               var c=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 1 | 0);
               if(110 <= c)
                if(117 <= c)
                 var switch$0=0;
                else
                 {var switcher=c - 110 | 0;
                  switch(switcher)
                   {case 0:var _f2_=10,switch$0=1;break;
                    case 4:var _f2_=13,switch$0=1;break;
                    case 6:var _f2_=9,switch$0=1;break;
                    default:var switch$0=0}}
               else
                if(98 === c)var _f2_=8,switch$0=1;else var switch$0=0;
               if(! switch$0)var _f2_=c;
               caml_call2(X[1][2],buf,_f2_);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 4:
               var
                c1=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 1 | 0),
                c2=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 2 | 0),
                c3=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 3 | 0),
                v=
                 ((100 * (c1 - 48 | 0) | 0) + (10 * (c2 - 48 | 0) | 0) | 0)
                 +
                 (c3 - 48 | 0)
                 |
                 0;
               if(255 < v)
                {var
                  match=caml_call1(Lexing[10],lexbuf),
                  pos_cnum=match[4],
                  pos_bol=match[3],
                  pos_lnum=match[2],
                  msg=
                   caml_call6
                    (Printf[4],
                     _an_,
                     pos_lnum,
                     (pos_cnum - pos_bol | 0) - 3 | 0,
                     c1,
                     c2,
                     c3);
                 caml_call1(Pervasives[2],msg)}
               var _f3_=caml_call1(Char[1],v);
               caml_call2(X[1][2],buf,_f3_);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 5:
               var
                d1=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 2 | 0),
                c2$0=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 3 | 0),
                val1=97 <= d1?d1 - 87 | 0:65 <= d1?d1 - 55 | 0:d1 - 48 | 0,
                val2=
                 97 <= c2$0
                  ?c2$0 - 87 | 0
                  :65 <= c2$0?c2$0 - 55 | 0:c2$0 - 48 | 0,
                v$0=(val1 * 16 | 0) + val2 | 0,
                _f4_=caml_call1(Char[1],v$0);
               caml_call2(X[1][2],buf,_f4_);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 6:
               var c$0=caml_call2(Lexing[15],lexbuf,lexbuf[5] + 1 | 0);
               caml_call2(X[1][2],buf,92);
               caml_call2(X[1][2],buf,c$0);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 7:
               caml_call1(found_newline(lexbuf),0);
               caml_call2(X[1][2],buf,lf);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              case 8:
               var ofs=lexbuf[5],len$1=lexbuf[6] - ofs | 0;
               caml_call4(X[1][3],buf,lexbuf[2],ofs,len$1);
               caml_call2(X[1][4],buf,lexbuf);
               continue a;
              default:
               var
                msg$0=
                 caml_call3(Printf[4],_ao_,start[2],start[4] - start[3] | 0);
               return caml_call1(Pervasives[2],msg$0)}}}}
      function main(buf)
       {if(buf)
         {var buf$0=buf[1];
          caml_call1(Buffer[8],buf$0);
          var buf$1=caml_call1(X[1][6],buf$0)}
        else
         var buf$1=caml_call1(X[1][1],64);
        return function(_f1_){return _f0_(buf$1,_f1_)}}
      return [0,main]}
    var
     create=Buffer[1],
     clear=Buffer[8],
     add_char=Buffer[10],
     add_subbytes=Buffer[17];
    function add_lexeme(param,_fZ_){return 0}
    function of_buffer(b){return b}
    var eof=2,lparen=0,rparen=1,hash_semi=3;
    function simple_string(x){return [0,x]}
    function quoted_string(param,buf){return [0,caml_call1(Buffer[2],buf)]}
    function block_comment(pos,main,buf,lexbuf)
     {return caml_call2(main,buf,lexbuf)}
    function comment(text,main,buf,lexbuf){return caml_call2(main,buf,lexbuf)}
    var
     Vanilla=
      Make$1
       ([0,
         [0,create,add_char,add_subbytes,add_lexeme,clear,of_buffer],
         [0,
          lparen,
          rparen,
          eof,
          simple_string,
          hash_semi,
          quoted_string,
          comment,
          block_comment]]);
    function create$0(n)
     {var _fY_=caml_call1(Buffer[1],n);
      return [0,caml_call1(Buffer[1],n),_fY_]}
    function of_buffer$0(contents)
     {return [0,contents,caml_call1(Buffer[1],64)]}
    function add_char$0(t,ch){return caml_call2(Buffer[10],t[1],ch)}
    function add_subbytes$0(t,str,ofs,len)
     {return caml_call4(Buffer[17],t[1],str,ofs,len)}
    function add_lexeme$0(t,lexbuf)
     {var _fX_=caml_call1(Lexing[5],lexbuf);
      return caml_call2(Buffer[14],t[2],_fX_)}
    function clear$0(t)
     {caml_call1(Buffer[8],t[2]);return caml_call1(Buffer[8],t[1])}
    var eof$0=2,lparen$0=0,rparen$0=1,hash_semi$0=3;
    function simple_string$0(x){return [0,[0,x,0]]}
    function quoted_string$0(pos,param)
     {var
       lexeme=param[2],
       contents=param[1],
       _fW_=[0,[0,pos,caml_call1(Buffer[2],lexeme)]];
      return [0,[0,caml_call1(Buffer[2],contents),_fW_]]}
    function block_comment$0(pos,param,_fV_,lexbuf)
     {var lexeme=_fV_[2];return [1,[0,caml_call1(Buffer[2],lexeme),[0,pos]]]}
    function comment$0(text,param,buf,lexbuf){return [1,[0,text,0]]}
    var
     With_layout=
      Make$1
       ([0,
         [0,
          create$0,
          add_char$0,
          add_subbytes$0,
          add_lexeme$0,
          clear$0,
          of_buffer$0],
         [0,
          lparen$0,
          rparen$0,
          eof$0,
          simple_string$0,
          hash_semi$0,
          quoted_string$0,
          comment$0,
          block_comment$0]]),
     main=Vanilla[1],
     main$0=With_layout[1],
     Sexplib_Lexer=[0,main,main$0];
    caml_register_global(207,Sexplib_Lexer,"Sexplib__Lexer");
    var
     equal=Sexplib0_Sexp[3],
     compare=Sexplib0_Sexp[4],
     Not_found_s=Sexplib0_Sexp[5],
     Of_sexp_error=Sexplib0_Sexp[6],
     message=Sexplib0_Sexp[7],
     default_indent=Sexplib0_Sexp[8],
     pp_hum=Sexplib0_Sexp[9],
     pp_hum_indent=Sexplib0_Sexp[10],
     pp_mach=Sexplib0_Sexp[11],
     pp=Sexplib0_Sexp[12],
     to_string_hum=Sexplib0_Sexp[13],
     to_string_mach=Sexplib0_Sexp[14],
     to_string=Sexplib0_Sexp[15],
     of_float_style=Sexplib0_Sexp[16],
     of_int_style=Sexplib0_Sexp[17],
     Private=Sexplib0_Sexp[18],
     size=Private[1],
     buffer=Private[2],
     to_buffer=Private[3],
     to_buffer_hum=Private[4],
     to_buffer_mach=Private[5],
     to_buffer_gen=Private[6],
     mach_maybe_esc_str=Private[7],
     must_escape=Private[8],
     esc_str=Private[9],
     Sexplib$0=0,
     Conv=0;
    function with_new_buffer(oc,f)
     {var buf=caml_call1(buffer,0);
      caml_call1(f,buf);
      return caml_call2(Buffer[21],oc,buf)}
    function output_hum(oc,sexp)
     {return with_new_buffer
              (oc,function(buf){return caml_call3(to_buffer_hum,buf,0,sexp)})}
    function output_hum_indent(indent,oc,sexp)
     {return with_new_buffer
              (oc,
               function(buf)
                {return caml_call3(to_buffer_hum,buf,[0,indent],sexp)})}
    function output(oc,sexp)
     {return with_new_buffer
              (oc,function(buf){return caml_call2(to_buffer_mach,buf,sexp)})}
    var prng=[0,0];
    function temp_file_name(prefix,suffix)
     {var _fU_=prng[1];
      if(_fU_)
       var v=_fU_[1],rand_state=v;
      else
       {var ret=caml_call1(Random[11][2],0);
        prng[1] = [0,ret];
        var rand_state=ret}
      var rnd=caml_call1(Random[11][4],rand_state) & 16777215;
      return caml_call4(Printf[4],_as_,prefix,rnd,suffix)}
    function open_temp_file(opt,prefix,suffix)
     {if(opt)var sth=opt[1],perm=sth;else var perm=438;
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(prefix,suffix);
          try
           {var oc=caml_call3(Pervasives[50],_at_,perm,name),_fT_=[0,name,oc];
            return _fT_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1e3 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var Tmp_file=[0,prng,temp_file_name,open_temp_file];
    function save_of_output(perm,output_function,file,sexp)
     {var
       match=caml_call3(Tmp_file[3],perm,file,cst_tmp),
       oc=match[2],
       tmp_name=match[1];
      try
       {caml_call2(output_function,oc,sexp);caml_call1(Pervasives[64],oc)}
      catch(e)
       {e = caml_wrap_exception(e);
        caml_call1(Pervasives[65],oc);
        try {runtime.caml_sys_remove(tmp_name)}catch(_fS_){}
        throw e}
      return runtime.caml_sys_rename(tmp_name,file)}
    function output_sexp_nl(do_output,oc,sexp)
     {caml_call2(do_output,oc,sexp);return caml_call2(Pervasives[54],oc,cst)}
    function save_hum(perm,file,sexp)
     {return save_of_output
              (perm,
               function(_fQ_,_fR_)
                {return output_sexp_nl(output_hum,_fQ_,_fR_)},
               file,
               sexp)}
    function save(perm,file,sexp)
     {return save_of_output(perm,output,file,sexp)}
    function output_sexps_nl(do_output,oc,sexps)
     {function _fO_(_fP_){return output_sexp_nl(do_output,oc,_fP_)}
      return caml_call2(List[15],_fO_,sexps)}
    function save_sexps_hum(perm,file,sexps)
     {return save_of_output
              (perm,
               function(_fM_,_fN_)
                {return output_sexps_nl(output_hum,_fM_,_fN_)},
               file,
               sexps)}
    function save_sexps(perm,file,sexps)
     {return save_of_output
              (perm,
               function(_fK_,_fL_){return output_sexps_nl(output,_fK_,_fL_)},
               file,
               sexps)}
    function scan_sexp(buf,lexbuf){return sexp(caml_call1(main,buf),lexbuf)}
    function scan_sexp_opt(buf,lexbuf)
     {return sexp_opt(caml_call1(main,buf),lexbuf)}
    function scan_sexps(buf,lexbuf){return sexps(caml_call1(main,buf),lexbuf)}
    function scan_rev_sexps(buf,lexbuf)
     {return rev_sexps(caml_call1(main,buf),lexbuf)}
    function get_main_buf(buf)
     {if(buf)
       var buf$0=buf[1],buf$1=buf$0;
      else
       var buf$1=caml_call1(Buffer[1],128);
      return caml_call1(main,[0,buf$1])}
    function scan_fold_sexps(buf,f,acc,lexbuf)
     {var main=get_main_buf(buf),acc$0=acc;
      for(;;)
       {var match=sexp_opt(main,lexbuf);
        if(match)
         {var sexp=match[1],acc$1=caml_call2(f,acc$0,sexp),acc$0=acc$1;
          continue}
        return acc$0}}
    function scan_iter_sexps(buf,f,lexbuf)
     {var _fJ_=0;
      return scan_fold_sexps
              (buf,
               function(param,sexp){return caml_call1(f,sexp)},
               _fJ_,
               lexbuf)}
    function scan_sexps_conv(buf,f,lexbuf)
     {function coll(acc,sexp){return [0,caml_call1(f,sexp),acc]}
      var _fI_=scan_fold_sexps(buf,coll,0,lexbuf);
      return caml_call1(List[9],_fI_)}
    var
     Conv_exn=
      [248,cst_Sexplib_Pre_sexp_Annot_Conv_exn,caml_fresh_oo_id(0)];
    function _au_(param)
     {if(param[1] === Conv_exn)
       {var exn=param[3],loc=param[2];
        return [1,[0,_av_,[0,[0,loc],[0,caml_call1(include$1[49],exn),0]]]]}
      throw [0,Assert_failure,_aw_]}
    caml_call3(include$1[51][2],_ax_,Conv_exn,_au_);
    function get_sexp(param)
     {var sexp=0 === param[0]?param[2]:param[3];return sexp}
    function get_range(param){var range=param[1];return range}
    function sexp_of_conv(sexp_of_a,param)
     {if(1025039613 <= param[1])
       {var a=param[2];return [1,[0,_ay_,[0,caml_call1(sexp_of_a,a),0]]]}
      var match=param[2],t=match[2],exn=match[1],_fH_=[0,get_sexp(t),0];
      return [1,[0,_az_,[0,[1,[0,caml_call1(include$1[49],exn),_fH_]],0]]]}
    var
     Annot_sexp=
      [248,cst_Sexplib_Pre_sexp_Annot_Annot_sexp,caml_fresh_oo_id(0)];
    function find_sexp(annot_sexp,sexp)
     {function loop(annot_sexp)
       {var sub_sexp=0 === annot_sexp[0]?annot_sexp[2]:annot_sexp[3];
        if(sexp === sub_sexp)throw [0,Annot_sexp,annot_sexp];
        if(0 === annot_sexp[0])return 0;
        var annots=annot_sexp[2];
        return caml_call2(List[15],loop,annots)}
      try
       {loop(annot_sexp);var _fG_=0;return _fG_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Annot_sexp){var res=exn[2];return [0,res]}
        throw exn}}
    var
     Annot=
      [0,Conv_exn,get_sexp,get_range,sexp_of_conv,Annot_sexp,find_sexp];
    function create$1(opt,_fE_,_fD_,_fC_,param)
     {if(opt)var sth=opt[1],text_line=sth;else var text_line=1;
      if(_fE_)var sth$0=_fE_[1],text_char=sth$0;else var text_char=0;
      if(_fD_)var sth$1=_fD_[1],buf_pos=sth$1;else var buf_pos=0;
      if(_fC_)var sth$2=_fC_[1],global_offset=sth$2;else var global_offset=0;
      function fail(msg)
       {var
         _fF_=
          caml_call2(Pervasives[16],cst_Sexplib_Sexp_Parse_pos_create,msg);
        return caml_call1(Pervasives[2],_fF_)}
      return 1 <= text_line
              ?0 <= text_char
                ?0 <= global_offset
                  ?0 <= buf_pos
                    ?[0,text_line,text_char,global_offset,buf_pos]
                    :fail(cst_buf_pos_0)
                  :fail(cst_global_offset_0)
                :fail(cst_text_char_0)
              :fail(cst_text_line_1)}
    function with_buf_pos(t,buf_pos){return [0,t[1],t[2],t[3],buf_pos]}
    var Parse_pos=[0,create$1,with_buf_pos];
    function to_string$0(param)
     {switch(param)
       {case 0:return cst_Parsing_toplevel_whitespace;
        case 1:return cst_Parsing_nested_whitespace;
        case 2:return cst_Parsing_atom;
        case 3:return cst_Parsing_list;
        case 4:return cst_Parsing_sexp_comment;
        default:return cst_Parsing_block_comment}}
    var
     Cont_state=[0,to_string$0],
     Parse_error=[248,cst_Sexplib_Pre_sexp_Parse_error,caml_fresh_oo_id(0)];
    function _aA_(param)
     {if(param[1] === Parse_error)
       {var
         pe=param[2],
         match=pe[2],
         ppos=match[2][1],
         _fy_=[0,[1,[0,_aB_,[0,caml_call1(include$1[10],ppos[4]),0]]],0],
         _fz_=[0,[1,[0,_aC_,[0,caml_call1(include$1[10],ppos[3]),0]]],_fy_],
         _fA_=[0,[1,[0,_aD_,[0,caml_call1(include$1[10],ppos[2]),0]]],_fz_],
         _fB_=[0,[1,[0,_aE_,[0,caml_call1(include$1[10],ppos[1]),0]]],_fA_];
        return [1,[0,_aG_,[0,[1,[0,[1,[0,_aF_,[0,[0,pe[1]],0]]],_fB_]],0]]]}
      throw [0,Assert_failure,_aH_]}
    caml_call3(include$1[51][2],_aI_,Parse_error,_aA_);
    function annotate_sexp(sexp,iter)
     {if(0 === sexp[0])
       {var
         start_pos=caml_call2(Parsexp_Positions[17][3],iter,0),
         end_pos=caml_call2(Parsexp_Positions[17][3],iter,0);
        return [0,[0,start_pos,end_pos],sexp]}
      var l=sexp[1],start_pos$0=caml_call2(Parsexp_Positions[17][3],iter,0);
      function _fw_(sexp){return annotate_sexp(sexp,iter)}
      var
       _fx_=caml_call2(List[19],_fw_,l),
       annot=caml_call1(List[9],_fx_),
       end_pos$0=caml_call2(Parsexp_Positions[17][3],iter,0);
      return [1,[0,start_pos$0,end_pos$0],annot,sexp]}
    var
     Found=
      [248,
       cst_Sexplib_Pre_sexp_Parser_output_Bare_sexp_Found,
       caml_fresh_oo_id(0)];
    function raise_found(state,sexp){throw [0,Found,sexp]}
    var
     Found$0=
      [248,
       cst_Sexplib_Pre_sexp_Parser_output_Annotated_sexp_Found,
       caml_fresh_oo_id(0)];
    function raise_found$0(state,param)
     {var
       positions=param[2],
       sexp=param[1],
       annot=
        annotate_sexp(sexp,caml_call1(Parsexp_Positions[17][1],positions));
      throw [0,Found$0,annot]}
    var
     Parser_output=
      [0,
       [0,Parsexp[7],Found,raise_found],
       [0,Parsexp[10],Found$0,raise_found$0]];
    function Make_parser(T)
     {function parse_pos_of_state(state,buf_pos)
       {var
         _fu_=caml_call1(T[1][1][2],state),
         _fv_=caml_call1(T[1][1][4],state);
        return [0,caml_call1(T[1][1][3],state),_fv_,_fu_,buf_pos]}
      function check_str_bounds(pos,len,str)
       {if(pos < 0)caml_call1(Pervasives[1],cst_parse_pos_0);
        if(len < 0)caml_call1(Pervasives[1],cst_parse_len_0);
        var str_len=caml_call1(T[4],str),pos_len=pos + len | 0;
        if(str_len < pos_len)
         caml_call1(Pervasives[1],cst_parse_pos_len_str_len);
        return pos_len - 1 | 0}
      function handle_parsexp_error(state,pos,e)
       {var
         msg=caml_call1(Parsexp_Parser_automaton[15][3],e),
         match=caml_call1(Parsexp_Parser_automaton[15][4],e);
        if(434889564 <= match)
         {var
           parse_state=[0,parse_pos_of_state(state,pos)],
           parse_error=[0,msg,[0,925483562,parse_state]];
          throw [0,Parse_error,parse_error]}
        return caml_call1(Pervasives[2],msg)}
      function mk_cont_state(state,stack)
       {var used_ref=[0,0];
        function parse_fun(pos,len,str)
         {return used_ref[1]
                  ?caml_call1
                    (Pervasives[2],
                     cst_Sexplib_Sexp_parser_continuation_called_twice)
                  :(used_ref[1] = 1,run_feed_loop(state,stack,pos,len,str))}
        var cont_state=caml_call1(T[1][1][9],state);
        return [1,cont_state,parse_fun]}
      function run_feed_loop(state,stack,pos,len,str)
       {var
         max_pos=check_str_bounds(pos,len,str),
         previous_offset=caml_call1(T[1][1][2],state);
        try
         {var stack$0=caml_call5(T[5],state,stack,str,max_pos,pos)}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === T[2])
           {var
             result=exn[2],
             offset=caml_call1(T[1][1][2],state),
             next_pos=pos + (offset - previous_offset | 0) | 0;
            return [0,result,parse_pos_of_state(state,next_pos)]}
          if(exn[1] === Parsexp_Parser_automaton[16])
           {var err=exn[2];
            return handle_parsexp_error
                    (state,
                     pos
                     +
                     (caml_call1(T[1][1][2],state) - previous_offset | 0)
                     |
                     0,
                     err)}
          throw exn}
        return mk_cont_state(state,stack$0)}
      function parse(opt,len,str)
       {if(opt)
         var sth=opt[1],parse_pos=sth;
        else
         var parse_pos=caml_call5(Parse_pos[1],0,0,0,0,0);
        var
         text_line=parse_pos[1],
         text_char=parse_pos[2],
         global_offset=parse_pos[3],
         buf_pos=parse_pos[4],
         pos=[0,text_line,text_char,global_offset],
         state=caml_call3(T[1][1][8],[0,pos],_aJ_,T[3]),
         stack=T[1][2][1];
        if(len)
         var x=len[1],len$0=x;
        else
         var len$0=caml_call1(T[4],str) - buf_pos | 0;
        return run_feed_loop(state,stack,buf_pos,len$0,str)}
      return [0,parse]}
    var
     include$2=Parser_output[1],
     Impl=include$2[1],
     Found$1=include$2[2],
     raise_found$1=include$2[3],
     length=caml_ml_string_length;
    function unsafe_feed_loop(state,stack,str,max_pos,pos)
     {var stack$0=stack,pos$0=pos;
      for(;;)
       {if(pos$0 <= max_pos)
         {var
           stack$1=
            caml_call3
             (Parser_output[1][1][3],
              state,
              caml_bytes_unsafe_get(str,pos$0),
              stack$0),
           pos$1=pos$0 + 1 | 0,
           stack$0=stack$1,
           pos$0=pos$1;
          continue}
        return stack$0}}
    var
     String_single_sexp=
      Make_parser([0,Impl,Found$1,raise_found$1,length,unsafe_feed_loop]),
     parse_str=String_single_sexp[1],
     parse=String_single_sexp[1],
     include$3=Parser_output[2],
     Impl$0=include$3[1],
     Found$2=include$3[2],
     raise_found$2=include$3[3],
     length$0=caml_ml_string_length;
    function unsafe_feed_loop$0(state,stack,str,max_pos,pos)
     {var stack$0=stack,pos$0=pos;
      for(;;)
       {if(pos$0 <= max_pos)
         {var
           stack$1=
            caml_call3
             (Parser_output[2][1][3],
              state,
              caml_bytes_unsafe_get(str,pos$0),
              stack$0),
           pos$1=pos$0 + 1 | 0,
           stack$0=stack$1,
           pos$0=pos$1;
          continue}
        return stack$0}}
    var
     String_single_annot=
      Make_parser
       ([0,Impl$0,Found$2,raise_found$2,length$0,unsafe_feed_loop$0]),
     parse_str_annot=String_single_annot[1],
     include$4=Parser_output[1],
     Impl$1=include$4[1],
     Found$3=include$4[2],
     raise_found$3=include$4[3],
     length$1=caml_ba_dim_1;
    function unsafe_feed_loop$1(state,stack,str,max_pos,pos)
     {var stack$0=stack,pos$0=pos;
      for(;;)
       {if(pos$0 <= max_pos)
         {var
           _ft_=caml_ba_get_1(str,pos$0),
           stack$1=caml_call3(Parser_output[1][1][3],state,_ft_,stack$0),
           pos$1=pos$0 + 1 | 0,
           stack$0=stack$1,
           pos$0=pos$1;
          continue}
        return stack$0}}
    var
     Bigstring_single_sexp=
      Make_parser
       ([0,Impl$1,Found$3,raise_found$3,length$1,unsafe_feed_loop$1]),
     parse_bigstring=Bigstring_single_sexp[1],
     include$5=Parser_output[2],
     Impl$2=include$5[1],
     Found$4=include$5[2],
     raise_found$4=include$5[3],
     length$2=caml_ba_dim_1;
    function unsafe_feed_loop$2(state,stack,str,max_pos,pos)
     {var stack$0=stack,pos$0=pos;
      for(;;)
       {if(pos$0 <= max_pos)
         {var
           _fs_=caml_ba_get_1(str,pos$0),
           stack$1=caml_call3(Parser_output[2][1][3],state,_fs_,stack$0),
           pos$1=pos$0 + 1 | 0,
           stack$0=stack$1,
           pos$0=pos$1;
          continue}
        return stack$0}}
    var
     Bigstring_single_annot=
      Make_parser
       ([0,Impl$2,Found$4,raise_found$4,length$2,unsafe_feed_loop$2]),
     _aK_=Bigstring_single_annot[1];
    function mk_this_parse(parse_pos,my_parse)
     {return function(pos,len,str)
       {if(parse_pos)
         {var parse_pos$0=parse_pos[1];
          parse_pos$0[4] = pos;
          var parse_pos$1=parse_pos$0}
        else
         var parse_pos$1=caml_call5(Parse_pos[1],0,0,[0,pos],0,0);
        return caml_call3(my_parse,[0,parse_pos$1],[0,len],str)}}
    function feed_end_of_input(this_parse,ws_buf)
     {var match=caml_call3(this_parse,0,1,ws_buf);
      if(0 === match[0]){var sexp=match[1];return [0,sexp]}
      var cont_state=match[1];
      return [1,cont_state]}
    function gen_input_sexp(my_parse,parse_pos,ic)
     {var buf=caml_create_bytes(1);
      function loop(this_parse)
       {var this_parse$0=this_parse;
        for(;;)
         {try
           {var c=caml_call1(Pervasives[70],ic)}
          catch(_fr_)
           {_fr_ = caml_wrap_exception(_fr_);
            if(_fr_ === End_of_file)
             {var match=feed_end_of_input(this_parse$0,cst$0);
              if(0 === match[0]){var sexp=match[1];return sexp}
              throw End_of_file}
            throw _fr_}
          caml_bytes_set(buf,0,c);
          var match$0=caml_call3(this_parse$0,0,1,caml_call1(Bytes[42],buf));
          if(0 === match$0[0]){var sexp$0=match$0[1];return sexp$0}
          var this_parse$1=match$0[2],this_parse$0=this_parse$1;
          continue}}
      return loop(mk_this_parse(parse_pos,my_parse))}
    function input_sexp(parse_pos,ic)
     {return gen_input_sexp(parse,parse_pos,ic)}
    function gen_input_rev_sexps(my_parse,ws_buf,parse_pos,opt,ic)
     {if(opt)var sth=opt[1],buf=sth;else var buf=caml_create_bytes(8192);
      var
       rev_sexps_ref=[0,0],
       buf_len=caml_ml_bytes_length(buf),
       len$3=caml_call4(Pervasives[72],ic,buf,0,buf_len),
       this_parse$2=mk_this_parse(parse_pos,my_parse),
       this_parse=this_parse$2,
       pos=0,
       len=len$3;
      for(;;)
       {if(0 < len)
         {var match=caml_call3(this_parse,pos,len,caml_call1(Bytes[42],buf));
          if(0 === match[0])
           {var parse_pos$0=match[2],sexp=match[1],buf_pos=parse_pos$0[4];
            rev_sexps_ref[1] = [0,sexp,rev_sexps_ref[1]];
            var
             n_parsed=buf_pos - pos | 0,
             this_parse$0=mk_this_parse([0,parse_pos$0],my_parse);
            if(n_parsed === len)
             {var
               len$0=caml_call4(Pervasives[72],ic,buf,0,buf_len),
               this_parse=this_parse$0,
               pos=0,
               len=len$0;
              continue}
            var
             len$1=len - n_parsed | 0,
             this_parse=this_parse$0,
             pos=buf_pos,
             len=len$1;
            continue}
          var
           this_parse$1=match[2],
           len$2=caml_call4(Pervasives[72],ic,buf,0,buf_len),
           this_parse=this_parse$1,
           pos=0,
           len=len$2;
          continue}
        var match$0=feed_end_of_input(this_parse,ws_buf);
        if(0 === match$0[0])
         {var sexp$0=match$0[1];return [0,sexp$0,rev_sexps_ref[1]]}
        var _fo_=match$0[1];
        if(0 === _fo_)return rev_sexps_ref[1];
        var
         _fp_=caml_call1(Cont_state[1],_fo_),
         _fq_=
          caml_call2
           (Pervasives[16],
            cst_Sexplib_Sexp_input_rev_sexps_reached_EOF_while_in_state,
            _fp_);
        return caml_call1(Pervasives[2],_fq_)}}
    function input_rev_sexps(parse_pos,buf,ic)
     {return gen_input_rev_sexps(parse,cst$1,parse_pos,buf,ic)}
    function input_sexps(parse_pos,buf,ic)
     {var _fn_=input_rev_sexps(parse_pos,buf,ic);
      return caml_call1(List[9],_fn_)}
    function of_string_bigstring(loc,my_parse,ws_buf,get_len,get_sub,str)
     {var match=caml_call3(my_parse,0,0,str);
      if(0 === match[0])
       {var
         parse_pos=match[2],
         sexp=match[1],
         match$0=caml_call3(my_parse,[0,parse_pos],0,str);
        if(0 === match$0[0])
         {var _fj_=caml_call2(Format[115],_aL_,loc);
          return caml_call1(Pervasives[2],_fj_)}
        if(0 === match$0[1])return sexp;
        var _fk_=caml_call3(Format[115],_aM_,loc,parse_pos[4]);
        return caml_call1(Pervasives[2],_fk_)}
      var this_parse=match[2],match$1=feed_end_of_input(this_parse,ws_buf);
      if(0 === match$1[0]){var sexp$0=match$1[1];return sexp$0}
      var
       cont_state=match$1[1],
       cont_state_str=caml_call1(Cont_state[1],cont_state),
       _fl_=caml_call3(get_sub,str,0,caml_call1(get_len,str)),
       _fm_=caml_call4(Format[115],_aN_,loc,cont_state_str,_fl_);
      return caml_call1(Pervasives[2],_fm_)}
    function of_string(str)
     {return of_string_bigstring
              (cst_of_string,parse,cst$2,caml_ml_string_length,String[4],str)}
    function get_bstr_sub_str(bstr,pos,len)
     {var str=caml_create_bytes(len),_fh_=len - 1 | 0,_fg_=0;
      if(! (_fh_ < 0))
       {var i=_fg_;
        for(;;)
         {caml_bytes_set(str,i,caml_ba_get_1(bstr,pos + i | 0));
          var _fi_=i + 1 | 0;
          if(_fh_ !== i){var i=_fi_;continue}
          break}}
      return caml_call1(Bytes[42],str)}
    var bstr_ws_buf=caml_call3(Bigarray[19][1],Bigarray[13],Bigarray[15],1);
    caml_ba_set_1(bstr_ws_buf,0,32);
    function of_bigstring(bstr)
     {return of_string_bigstring
              (cst_of_bigstring,
               parse_bigstring,
               bstr_ws_buf,
               caml_ba_dim_1,
               get_bstr_sub_str,
               bstr)}
    function gen_load_rev_sexps(input_rev_sexps,buf,file)
     {var ic=caml_call1(Pervasives[67],file);
      try
       {var sexps=caml_call3(input_rev_sexps,0,buf,ic);
        caml_call1(Pervasives[81],ic);
        return sexps}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        caml_call1(Pervasives[82],ic);
        throw exc}}
    function load_rev_sexps(buf,file)
     {return gen_load_rev_sexps(input_rev_sexps,buf,file)}
    function load_sexps(buf,file)
     {var _ff_=load_rev_sexps(buf,file);return caml_call1(List[9],_ff_)}
    function gen_load_sexp(my_parse,opt,_e$_,file)
     {if(opt)var sth=opt[1],strict=sth;else var strict=1;
      if(_e$_)
       var sth$0=_e$_[1],buf=sth$0;
      else
       var buf=caml_create_bytes(8192);
      var
       buf_len=caml_ml_bytes_length(buf),
       ic=caml_call1(Pervasives[67],file);
      function loop(this_parse)
       {var this_parse$0=this_parse;
        for(;;)
         {var len=caml_call4(Pervasives[72],ic,buf,0,buf_len);
          if(0 === len)
           {var match=feed_end_of_input(this_parse$0,cst$3);
            if(0 === match[0]){var sexp=match[1];return sexp}
            var
             cont_state=match[1],
             _fa_=caml_call1(Cont_state[1],cont_state),
             _fb_=caml_call4(Format[115],_aO_,gen_load_sexp_loc,file,_fa_);
            return caml_call1(Pervasives[2],_fb_)}
          var
           match$0=
            caml_call3(this_parse$0,0,len,caml_call1(Bytes[42],buf));
          if(0 === match$0[0])
           {var parse_pos=match$0[2],sexp$0=match$0[1],buf_pos=parse_pos[4];
            if(strict)
             {var
               this_parse$3=mk_this_parse([0,parse_pos],my_parse),
               len$2=len - buf_pos | 0,
               this_parse$1=this_parse$3,
               pos=buf_pos,
               len$0=len$2;
              for(;;)
               {var
                 match$1=
                  caml_call3(this_parse$1,pos,len$0,caml_call1(Bytes[42],buf));
                if(0 === match$1[0])
                 {var
                   _fc_=
                    caml_call3(Format[115],_aP_,gen_load_sexp_loc,file);
                  return caml_call1(Pervasives[2],_fc_)}
                var
                 this_parse$2=match$1[2],
                 cont_state$0=match$1[1],
                 len$1=caml_call4(Pervasives[72],ic,buf,0,buf_len);
                if(0 < len$1)
                 {var this_parse$1=this_parse$2,pos=0,len$0=len$1;continue}
                if(0 === cont_state$0)return sexp$0;
                var
                 _fd_=caml_call1(Cont_state[1],cont_state$0),
                 _fe_=
                  caml_call5
                   (Format[115],
                    _aQ_,
                    gen_load_sexp_loc,
                    cst_additional_incomplete_data,
                    _fd_,
                    file);
                return caml_call1(Pervasives[2],_fe_)}}
            return sexp$0}
          var this_parse$4=match$0[2],this_parse$0=this_parse$4;
          continue}}
      try
       {var sexp=loop(mk_this_parse(0,my_parse));
        caml_call1(Pervasives[81],ic);
        return sexp}
      catch(exc)
       {exc = caml_wrap_exception(exc);
        caml_call1(Pervasives[82],ic);
        throw exc}}
    function load_sexp(strict,buf,file)
     {return gen_load_sexp(parse,strict,buf,file)}
    var
     Conv_exn$0=Annot[1],
     get_sexp$0=Annot[2],
     get_range$0=Annot[3],
     sexp_of_conv$0=Annot[4],
     Annot_sexp$0=Annot[5],
     find_sexp$0=Annot[6];
    function input_rev_sexps$0(parse_pos,buf,ic)
     {return gen_input_rev_sexps(parse_str_annot,cst$4,parse_pos,buf,ic)}
    function input_sexp$0(parse_pos,ic)
     {return gen_input_sexp(parse_str_annot,parse_pos,ic)}
    function input_sexps$0(parse_pos,buf,ic)
     {var _e__=input_rev_sexps$0(parse_pos,buf,ic);
      return caml_call1(List[9],_e__)}
    function of_string$0(str)
     {return of_string_bigstring
              (cst_Annotated_of_string,
               parse_str_annot,
               cst$5,
               caml_ml_string_length,
               String[4],
               str)}
    function of_bigstring$0(bstr)
     {return of_string_bigstring
              (cst_Annotated_of_bigstring,
               _aK_,
               bstr_ws_buf,
               caml_ba_dim_1,
               get_bstr_sub_str,
               bstr)}
    function load_rev_sexps$0(buf,file)
     {return gen_load_rev_sexps(input_rev_sexps$0,buf,file)}
    function load_sexps$0(buf,file)
     {var _e9_=load_rev_sexps$0(buf,file);return caml_call1(List[9],_e9_)}
    function load_sexp$0(strict,buf,file)
     {return gen_load_sexp(parse_str_annot,strict,buf,file)}
    function conv(f,annot_sexp)
     {var sexp=caml_call1(get_sexp$0,annot_sexp);
      try
       {var _e8_=[0,1025039613,caml_call1(f,sexp)];return _e8_}
      catch(e)
       {e = caml_wrap_exception(e);
        if(e[1] === Of_sexp_error)
         {var
           bad_sexp=e[3],
           exc=e[2],
           match=caml_call2(find_sexp$0,annot_sexp,bad_sexp);
          if(match)
           {var bad_annot_sexp=match[1];
            return [0,106380200,[0,exc,bad_annot_sexp]]}
          throw e}
        throw e}}
    function get_conv_exn(file,exc,annot_sexp)
     {var
       range=caml_call1(get_range$0,annot_sexp),
       match=range[1],
       col=match[2],
       line=match[1],
       loc=caml_call4(Format[115],_aR_,file,line,col),
       _e7_=caml_call1(get_sexp$0,annot_sexp);
      return [0,Of_sexp_error,[0,Annot[1],loc,exc],_e7_]}
    var
     Annotated=
      [0,
       Conv_exn$0,
       get_sexp$0,
       get_range$0,
       sexp_of_conv$0,
       Annot_sexp$0,
       find_sexp$0,
       parse_str_annot,
       _aK_,
       input_rev_sexps$0,
       input_sexp$0,
       input_sexps$0,
       of_string$0,
       of_bigstring$0,
       load_rev_sexps$0,
       load_sexps$0,
       load_sexp$0,
       conv,
       get_conv_exn];
    function load_sexp_conv(opt,_e3_,file,f)
     {if(opt)var sth=opt[1],strict=sth;else var strict=1;
      if(_e3_)
       var sth$0=_e3_[1],buf=sth$0;
      else
       var buf=caml_create_bytes(8192);
      var sexp=load_sexp([0,strict],[0,buf],file);
      try
       {var _e5_=[0,1025039613,caml_call1(f,sexp)];return _e5_}
      catch(_e6_)
       {_e6_ = caml_wrap_exception(_e6_);
        if(_e6_[1] === Of_sexp_error)
         {var _e4_=caml_call3(Annotated[16],[0,strict],[0,buf],file);
          return caml_call2(Annotated[17],f,_e4_)}
        throw _e6_}}
    function raise_conv_exn(file,param)
     {if(1025039613 <= param[1]){var res=param[2];return res}
      var match=param[2],annot_sexp=match[2],exc=match[1];
      throw caml_call3(Annotated[18],file,exc,annot_sexp)}
    function load_sexp_conv_exn(strict,buf,file,f)
     {return raise_conv_exn(file,load_sexp_conv(strict,buf,file,f))}
    function load_sexps_conv(opt,file,f)
     {if(opt)var sth=opt[1],buf=sth;else var buf=caml_create_bytes(8192);
      var rev_sexps=load_rev_sexps([0,buf],file);
      try
       {var
         _e1_=function(sexp){return [0,1025039613,caml_call1(f,sexp)]},
         _e2_=caml_call2(List[19],_e1_,rev_sexps);
        return _e2_}
      catch(e)
       {e = caml_wrap_exception(e);
        if(e[1] === Of_sexp_error)
         {var rev_annot_sexps=caml_call2(Annotated[14],[0,buf],file);
          if(rev_annot_sexps)
           {var
             _e0_=
              function(annot_sexp)
               {return caml_call2(Annotated[17],f,annot_sexp)};
            return caml_call2(List[19],_e0_,rev_annot_sexps)}
          throw e}
        throw e}}
    function load_sexps_conv_exn(opt,file,f)
     {if(opt)var sth=opt[1],buf=sth;else var buf=caml_create_bytes(8192);
      var rev_sexps=load_rev_sexps([0,buf],file);
      try
       {var _eZ_=caml_call2(List[19],f,rev_sexps);return _eZ_}
      catch(e)
       {e = caml_wrap_exception(e);
        if(e[1] === Of_sexp_error)
         {var rev_annot_sexps=caml_call2(Annotated[14],[0,buf],file);
          if(rev_annot_sexps)
           {var
             _eY_=
              function(annot_sexp)
               {return raise_conv_exn
                        (file,caml_call2(Annotated[17],f,annot_sexp))};
            return caml_call2(List[19],_eY_,rev_annot_sexps)}
          throw e}
        throw e}}
    function gen_of_string_conv(of_string,annot_of_string,str,f)
     {var sexp=caml_call1(of_string,str);
      try
       {var _eW_=[0,1025039613,caml_call1(f,sexp)];return _eW_}
      catch(_eX_)
       {_eX_ = caml_wrap_exception(_eX_);
        if(_eX_[1] === Of_sexp_error)
         {var _eV_=caml_call1(annot_of_string,str);
          return caml_call2(Annotated[17],f,_eV_)}
        throw _eX_}}
    function of_string_conv(str,f)
     {return gen_of_string_conv(of_string,Annotated[12],str,f)}
    function of_bigstring_conv(bstr,f)
     {return gen_of_string_conv(of_bigstring,Annotated[13],bstr,f)}
    var E=[248,cst_Sexplib_Pre_sexp_Of_string_conv_exn_E,caml_fresh_oo_id(0)];
    function _aS_(param)
     {if(param[1] === E)
       {var
         osce=param[2],
         _eU_=[0,[1,[0,_aU_,[0,osce[2],0]]],[0,[1,[0,_aT_,[0,osce[3],0]]],0]];
        return [1,
                [0,
                 _aW_,
                 [0,
                  [1,
                   [0,
                    [1,[0,_aV_,[0,caml_call1(include$1[49],osce[1]),0]]],
                    _eU_]],
                  0]]]}
      throw [0,Assert_failure,_aX_]}
    caml_call3(include$1[51][2],_aY_,E,_aS_);
    var Of_string_conv_exn=[0,E];
    function gen_of_string_conv_exn(of_string,str,f)
     {var sexp=caml_call1(of_string,str);
      try
       {var _eT_=caml_call1(f,sexp);return _eT_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Of_sexp_error)
         {var sub_sexp=exn[3],exc=exn[2];
          throw [0,Of_string_conv_exn[1],[0,exc,sexp,sub_sexp]]}
        throw exn}}
    function of_string_conv_exn(str,f)
     {return gen_of_string_conv_exn(of_string,str,f)}
    function of_bigstring_conv_exn(bstr,f)
     {return gen_of_string_conv_exn(of_bigstring,bstr,f)}
    function is_unit(param){if(1 === param[0])if(! param[1])return 1;return 0}
    function search_physical(sexp,contained)
     {if(sexp === contained)return 398750242;
      if(0 === sexp[0])return -358247754;
      var lst=sexp[1],i=0,param=lst;
      for(;;)
       {if(param)
         {var t=param[2],h=param[1],res=search_physical(h,contained);
          if(typeof res === "number")
           if(! (398750242 <= res)){var i$0=i + 1 | 0,i=i$0,param=t;continue}
          return [0,4003188,[0,i,res]]}
        return -358247754}}
    function subst_found(sexp,subst,param)
     {if(typeof param === "number")return subst;
      var match=param[2],found=match[2],pos=match[1];
      if(0 === sexp[0])
       return caml_call1
               (Pervasives[2],
                cst_Sexplib_Sexp_subst_found_atom_when_position_requested);
      var lst=sexp[1],acc=0,pos$0=pos,param$0=lst;
      for(;;)
       {if(param$0)
         {var t=param$0[2],h=param$0[1];
          if(0 === pos$0)
           {var _eS_=[0,subst_found(h,subst,found),t];
            return [1,caml_call2(List[12],acc,_eS_)]}
          var
           pos$1=pos$0 - 1 | 0,
           acc$0=[0,h,acc],
           acc=acc$0,
           pos$0=pos$1,
           param$0=t;
          continue}
        return caml_call1
                (Pervasives[2],
                 cst_Sexplib_Sexp_subst_found_short_list_when_position_requested)}}
    var
     include$6=
      [0,
       Sexplib$0,
       Conv,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       size,
       buffer,
       to_buffer,
       to_buffer_hum,
       to_buffer_mach,
       to_buffer_gen,
       mach_maybe_esc_str,
       must_escape,
       esc_str,
       with_new_buffer,
       output_hum,
       output_hum_indent,
       output,
       output,
       Tmp_file,
       save_of_output,
       output_sexp_nl,
       save_hum,
       save,
       save,
       output_sexps_nl,
       save_sexps_hum,
       save_sexps,
       save_sexps,
       scan_sexp,
       scan_sexp_opt,
       scan_sexps,
       scan_rev_sexps,
       get_main_buf,
       scan_fold_sexps,
       scan_iter_sexps,
       scan_sexps_conv,
       Annot,
       Parse_pos,
       Cont_state,
       Parse_error,
       Parser_output,
       Make_parser,
       String_single_sexp,
       parse_str,
       parse,
       String_single_annot,
       parse_str_annot,
       Bigstring_single_sexp,
       parse_bigstring,
       Bigstring_single_annot,
       _aK_,
       mk_this_parse,
       feed_end_of_input,
       gen_input_sexp,
       input_sexp,
       gen_input_rev_sexps,
       input_rev_sexps,
       input_sexps,
       of_string_bigstring,
       of_string,
       get_bstr_sub_str,
       bstr_ws_buf,
       of_bigstring,
       gen_load_rev_sexps,
       load_rev_sexps,
       load_sexps,
       gen_load_sexp_loc,
       gen_load_sexp,
       load_sexp,
       Annotated,
       load_sexp_conv,
       raise_conv_exn,
       load_sexp_conv_exn,
       load_sexps_conv,
       load_sexps_conv_exn,
       gen_of_string_conv,
       of_string_conv,
       of_bigstring_conv,
       Of_string_conv_exn,
       gen_of_string_conv_exn,
       of_string_conv_exn,
       of_bigstring_conv_exn,
       unit,
       is_unit,
       search_physical,
       subst_found];
    caml_register_global(220,include$6,"Sexplib__Pre_sexp");
    function iter(t,f){return caml_call2(List[15],f,t)}
    function map$0(t,f)
     {var _eR_=caml_call2(List[19],f,t);return caml_call1(List[9],_eR_)}
    var
     List$0=[0,iter,map$0],
     sexp_of_pos=_E_[1],
     Lexer=[0,main$0],
     Parser=0,
     Rel_pos=0,
     Abs_pos=0;
    function return$0(a,putc,st){return a}
    function bind(m,f,putc,st)
     {return caml_call3(f,caml_call2(m,putc,st),putc,st)}
    function run(putc,m){return caml_call2(m,putc,[0,_E_[2],_D_[2],0,0])}
    function emit_char(putc,st,c)
     {var match=st[2],col=match[2],row=match[1];
      caml_call1(putc,c);
      return 10 === c
              ?(st[2] = [0,1 + row | 0,1],0)
              :(st[2] = [0,row,1 + col | 0],0)}
    function emit_string(putc,st,str)
     {var n=caml_ml_string_length(str),_eP_=n - 1 | 0,_eO_=0;
      if(! (_eP_ < 0))
       {var i=_eO_;
        for(;;)
         {emit_char(putc,st,caml_string_get(str,i));
          var _eQ_=i + 1 | 0;
          if(_eP_ !== i){var i=_eQ_;continue}
          break}}
      return 0}
    function emit_chars(putc,st,c,n)
     {return emit_string(putc,st,caml_call2(String[1],n,c))}
    function advance(putc,anchor,st,delta,unescaped_atom,line_comment)
     {var
       _eJ_=st[1],
       _eK_=caml_call2(_D_[5],anchor,delta),
       new_pos=caml_call2(_D_[5],_eK_,_eJ_);
      if(unescaped_atom)
       {var _eL_=st[3];
        if(_eL_)
         var
          match=_eL_[1],
          prev_unescaped=match[2],
          immed_after=match[1],
          _eM_=caml_equal(new_pos,immed_after),
          prev_unescaped$0=_eM_?prev_unescaped:_eM_,
          prev_unescaped$1=prev_unescaped$0;
        else
         var prev_unescaped$1=0;
        var
         need_to_leave_room_between_two_unescaped_atoms_lest_they_become_one=
          prev_unescaped$1}
      else
       var
        need_to_leave_room_between_two_unescaped_atoms_lest_they_become_one=
         unescaped_atom;
      var
       need_to_clear_line_comment=new_pos[1] === st[4]?1:0,
       _eN_=1 - caml_call2(_D_[7],new_pos,st[2]),
       need_to_reposition=
        _eN_
        ||
        need_to_clear_line_comment
        ||
        need_to_leave_room_between_two_unescaped_atoms_lest_they_become_one;
      if(need_to_reposition)
       var
        new_row=1 + st[2][1] | 0,
        row_delta=new_row - new_pos[1] | 0,
        row_delta$0=row_delta,
        new_pos$0=[0,new_row,new_pos[2]];
      else
       var row_delta$0=0,new_pos$0=new_pos;
      if(st[2][1] < new_pos$0[1])
       {var n=new_pos$0[1] - st[2][1] | 0;emit_chars(putc,st,10,n)}
      if(st[2][2] < new_pos$0[2])
       {var n$0=new_pos$0[2] - st[2][2] | 0;emit_chars(putc,st,32,n$0)}
      if(caml_equal(new_pos$0,st[2]))
       {if(line_comment)st[4] = st[2][1];
        st[1] = [0,st[1][1] + row_delta$0 | 0,st[1][2]];
        return 0}
      throw [0,Assert_failure,_aZ_]}
    function render_t(putc,anchor,st,t)
     {if(0 === t[0])
       {var fmt_text=t[3],text=t[2],delta=t[1];
        if(fmt_text)
         {var _eH_=fmt_text[1];
          if(caml_string_notequal(_eH_,cst$6))
           var fmt_text$0=_eH_,switch$0=1;
          else
           var switch$0=0}
        else
         var switch$0=0;
        if(! switch$0)var fmt_text$0=caml_call1(mach_maybe_esc_str,text);
        var unescaped=34 !== caml_string_get(fmt_text$0,0)?1:0;
        advance(putc,anchor,st,delta,unescaped,0);
        emit_string(putc,st,fmt_text$0);
        st[3] = [0,[0,st[2],unescaped]];
        return 0}
      var end_delta=t[3],tocs=t[2],start_delta=t[1];
      advance(putc,anchor,st,start_delta,0,0);
      var child_anchor=caml_call2(_D_[6],st[2],st[1]);
      emit_char(putc,st,40);
      function _eI_(toc){return render_toc(putc,child_anchor,st,toc)}
      caml_call2(List$0[1],tocs,_eI_);
      advance(putc,anchor,st,end_delta,0,0);
      emit_char(putc,st,41);
      return 0}
    function render_c(putc,anchor,st,param)
     {if(0 === param[0])
       {var
         text=param[2],
         delta=param[1],
         _eE_=0 < caml_ml_string_length(text)?1:0,
         line_comment=_eE_?59 === caml_string_get(text,0)?1:0:_eE_;
        advance(putc,anchor,st,delta,0,line_comment);
        return emit_string(putc,st,text)}
      var t=param[3],cs=param[2],delta$0=param[1];
      advance(putc,anchor,st,delta$0,0,0);
      emit_string(putc,st,cst$7);
      function _eF_(_eG_){return render_c(putc,anchor,st,_eG_)}
      caml_call2(List$0[1],cs,_eF_);
      return render_t(putc,anchor,st,t)}
    function render_toc(putc,anchor,st,param)
     {if(0 === param[0]){var t=param[1];return render_t(putc,anchor,st,t)}
      var c=param[1];
      return render_c(putc,anchor,st,c)}
    function render(asexp,putc,st){return render_toc(putc,_D_[2],st,asexp)}
    var
     Render=
      [0,
       Rel_pos,
       Abs_pos,
       return$0,
       bind,
       run,
       emit_char,
       emit_string,
       emit_chars,
       advance,
       render_t,
       render_toc,
       render_c,
       render,
       render];
    function forget_t$0(counter,t,k)
     {if(0 === t[0]){var x=t[2];return caml_call1(k,[0,x])}
      var tocs=t[2];
      function _eD_(xs){return caml_call1(k,[1,xs])}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return forget_tocs$0(counter$0,tocs,_eD_)}
      return caml_trampoline_return(forget_tocs$0,[0,tocs,_eD_])}
    function forget_tocs$0(counter,tocs,k)
     {if(tocs)
       {var
         tocs$0=tocs[2],
         toc=tocs[1],
         _eC_=
          function(param)
           {if(param)
             {var x=param[1];
              return forget_tocs
                      (tocs$0,function(xs){return caml_call1(k,[0,x,xs])})}
            return forget_tocs(tocs$0,k)};
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return forget_toc$0(counter$0,toc,_eC_)}
        return caml_trampoline_return(forget_toc$0,[0,toc,_eC_])}
      return caml_call1(k,0)}
    function forget_toc$0(counter,toc,k)
     {if(0 === toc[0])
       {var t=toc[1],_eB_=function(x){return caml_call1(k,[0,x])};
        if(counter < 50)
         {var counter$0=counter + 1 | 0;return forget_t$0(counter$0,t,_eB_)}
        return caml_trampoline_return(forget_t$0,[0,t,_eB_])}
      return caml_call1(k,0)}
    function forget_t(t,k){return caml_trampoline(forget_t$0(0,t,k))}
    function forget_tocs(tocs,k)
     {return caml_trampoline(forget_tocs$0(0,tocs,k))}
    function forget_toc(toc,k){return caml_trampoline(forget_toc$0(0,toc,k))}
    var Cps=[0,forget_t,forget_toc,forget_tocs];
    function t(x){function _eA_(y){return y}return caml_call2(Cps[1],x,_eA_)}
    function t_or_comment(x)
     {function _ez_(y){return y}return caml_call2(Cps[2],x,_ez_)}
    function t_or_comments(x)
     {function _ey_(y){return y}return caml_call2(Cps[3],x,_ey_)}
    var
     Forget=[0,Cps,t,t_or_comment,t_or_comments],
     Sexplib_Sexp_with_layout=
      [0,
       List$0,
       Make$0,
       Parsed$0,
       sexp_of_t$0,
       sexp_of_comment,
       sexp_of_t_or_comment,
       relativize,
       sexp_of_pos,
       Lexer,
       Parser,
       Render,
       Forget];
    caml_register_global
     (221,Sexplib_Sexp_with_layout,"Sexplib__Sexp_with_layout");
    var
     _a0_=
      [0,
       sexp_of_pos,
       sexp_of_t$0,
       sexp_of_comment,
       sexp_of_t_or_comment,
       [0,Forget[2],Forget[3],Forget[4]],
       [0,Render[3],Render[4],Render[14],Render[5]],
       [0,sexp$0,sexp_opt$0,sexps$0,rev_sexps$0,sexps_abs],
       Lexer];
    function _a1_(_ex_){return _ex_}
    function _a2_(_ew_){return _ew_}
    var
     _a3_=
      [0,
       Annotated[4],
       Annotated[1],
       Annotated[2],
       Annotated[3],
       Annotated[6],
       Annotated[7],
       Annotated[8],
       Annotated[10],
       Annotated[11],
       Annotated[9],
       Annotated[16],
       Annotated[15],
       Annotated[14],
       Annotated[12],
       Annotated[13],
       Annotated[17],
       Annotated[18]],
     Sexplib_Sexp=
      [0,
       compare,
       default_indent,
       size,
       scan_sexp,
       scan_sexps,
       scan_rev_sexps,
       scan_sexp_opt,
       scan_iter_sexps,
       scan_fold_sexps,
       scan_sexps_conv,
       Parse_pos,
       Cont_state,
       _a3_,
       Parse_error,
       parse,
       parse_bigstring,
       input_sexp,
       input_sexps,
       input_rev_sexps,
       load_sexp,
       load_sexps,
       load_rev_sexps,
       load_sexp_conv,
       load_sexp_conv_exn,
       load_sexps_conv,
       load_sexps_conv_exn,
       output_hum,
       output_hum_indent,
       output,
       output,
       save_hum,
       save,
       save,
       save_sexps_hum,
       save_sexps,
       save_sexps,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       Of_string_conv_exn,
       of_string,
       of_string_conv,
       of_string_conv_exn,
       of_bigstring,
       of_bigstring_conv,
       of_bigstring_conv_exn,
       to_string_hum,
       to_string_mach,
       to_string,
       to_buffer_hum,
       to_buffer_mach,
       to_buffer,
       to_buffer_gen,
       unit,
       is_unit,
       _a2_,
       _a1_,
       search_physical,
       subst_found,
       _a0_];
    caml_register_global(222,Sexplib_Sexp,"Sexplib__Sexp");
    var Sexplib_Sexp_intf=[0];
    caml_register_global(223,Sexplib_Sexp_intf,"Sexplib__Sexp_intf");
    var
     _a8_=include$1[5],
     _a9_=include$1[6],
     _a__=include$1[7],
     _ba_=include$1[9],
     _bb_=include$1[10],
     _bc_=include$1[11],
     _bd_=include$1[12],
     _be_=include$1[13],
     _bf_=include$1[14],
     _bg_=include$1[15],
     _bh_=include$1[16],
     _bi_=include$1[17],
     _bl_=include$1[20],
     _bm_=include$1[21],
     _bn_=include$1[22],
     _bs_=include$1[27],
     _bu_=include$1[29],
     _bv_=include$1[30],
     _bw_=include$1[31],
     _by_=include$1[33],
     _bz_=include$1[34],
     _bA_=include$1[35],
     _bB_=include$1[36],
     _bC_=include$1[37],
     _bD_=include$1[38],
     _bE_=include$1[39],
     _bF_=include$1[40],
     _bG_=include$1[41],
     _bJ_=include$1[44],
     _bK_=include$1[45],
     _bL_=include$1[46],
     _bO_=include$1[49],
     _bQ_=include$1[51],
     _a4_=include$1[1],
     _a5_=include$1[2],
     _a6_=include$1[3],
     _a7_=include$1[4],
     _a$_=include$1[8],
     _bj_=include$1[18],
     _bk_=include$1[19],
     _bo_=include$1[23],
     _bp_=include$1[24],
     _bq_=include$1[25],
     _br_=include$1[26],
     _bt_=include$1[28],
     _bx_=include$1[32],
     _bH_=include$1[42],
     _bI_=include$1[43],
     _bM_=include$1[47],
     _bN_=include$1[48],
     _bP_=include$1[50];
    function sexp_of_float_vec(vec)
     {var lst_ref=[0,0],_et_=caml_ba_dim_1(vec);
      if(! (_et_ < 1))
       {var i=_et_;
        for(;;)
         {var _eu_=lst_ref[1];
          lst_ref[1] = [0,caml_call1(_bc_,caml_ba_get_1(vec,i)),_eu_];
          var _ev_=i - 1 | 0;
          if(1 !== i){var i=_ev_;continue}
          break}}
      return [1,lst_ref[1]]}
    function sexp_of_bigstring(bstr)
     {var
       n=caml_ba_dim_1(bstr),
       str=caml_create_bytes(n),
       _er_=n - 1 | 0,
       _eq_=0;
      if(! (_er_ < 0))
       {var i=_eq_;
        for(;;)
         {caml_bytes_set(str,i,caml_ba_get_1(bstr,i));
          var _es_=i + 1 | 0;
          if(_er_ !== i){var i=_es_;continue}
          break}}
      return [0,caml_call1(Bytes[42],str)]}
    function sexp_of_float32_vec(vec){return sexp_of_float_vec(vec)}
    function sexp_of_float64_vec(vec){return sexp_of_float_vec(vec)}
    function sexp_of_vec(vec){return sexp_of_float_vec(vec)}
    function sexp_of_float_mat(mat)
     {var m=caml_ba_dim_1(mat),n=runtime.caml_ba_dim_2(mat),lst_ref=[0,0];
      if(! (n < 1))
       {var col=n;
        for(;;)
         {var vec=caml_call2(Bigarray[20][5],mat,col);
          if(! (m < 1))
           {var row=m;
            for(;;)
             {var _eo_=lst_ref[1];
              lst_ref[1] = [0,caml_call1(_bc_,caml_ba_get_1(vec,row)),_eo_];
              var _ep_=row - 1 | 0;
              if(1 !== row){var row=_ep_;continue}
              break}}
          var _en_=col - 1 | 0;
          if(1 !== col){var col=_en_;continue}
          break}}
      var _el_=lst_ref[1],_em_=[0,caml_call1(_bb_,n),_el_];
      return [1,[0,caml_call1(_bb_,m),_em_]]}
    function sexp_of_float32_mat(mat){return sexp_of_float_mat(mat)}
    function sexp_of_float64_mat(mat){return sexp_of_float_mat(mat)}
    function sexp_of_mat(mat){return sexp_of_float_mat(mat)}
    function bigstring_of_sexp(sexp)
     {if(0 === sexp[0])
       {var
         str=sexp[1],
         len=caml_ml_string_length(str),
         bstr=caml_call3(Bigarray[19][1],Bigarray[13],Bigarray[15],len),
         _ej_=len - 1 | 0,
         _ei_=0;
        if(! (_ej_ < 0))
         {var i=_ei_;
          for(;;)
           {caml_ba_set_1(bstr,i,caml_string_get(str,i));
            var _ek_=i + 1 | 0;
            if(_ej_ !== i){var i=_ek_;continue}
            break}}
        return bstr}
      return caml_call2(_bs_,cst_bigstring_of_sexp_atom_needed,sexp)}
    function float_vec_of_sexp(empty_float_vec,create_float_vec,sexp)
     {if(0 === sexp[0])
       return caml_call2(_bs_,cst_float_vec_of_sexp_list_needed,sexp);
      var _eh_=sexp[1];
      if(_eh_)
       {var
         len=caml_call1(List[1],_eh_),
         res=caml_call1(create_float_vec,len),
         i=1,
         param=_eh_;
        for(;;)
         {if(param)
           {var t=param[2],h=param[1];
            caml_ba_set_1(res,i,caml_call1(_bA_,h));
            var i$0=i + 1 | 0,i=i$0,param=t;
            continue}
          return res}}
      return empty_float_vec}
    var
     create_float32_vec=caml_call2(Bigarray[19][1],Bigarray[1],Bigarray[16]),
     create_float64_vec=caml_call2(Bigarray[19][1],Bigarray[2],Bigarray[16]),
     empty_float32_vec=caml_call1(create_float32_vec,0),
     empty_float64_vec=caml_call1(create_float64_vec,0);
    function float32_vec_of_sexp(_eg_)
     {return float_vec_of_sexp(empty_float32_vec,create_float32_vec,_eg_)}
    function float64_vec_of_sexp(_ef_)
     {return float_vec_of_sexp(empty_float64_vec,create_float64_vec,_ef_)}
    function vec_of_sexp(_ee_)
     {return float_vec_of_sexp(empty_float64_vec,create_float64_vec,_ee_)}
    function check_too_much_data(sexp,data,res)
     {return 0 === data
              ?res
              :caml_call2(_bs_,cst_float_mat_of_sexp_too_much_data,sexp)}
    function float_mat_of_sexp(create_float_mat,sexp)
     {if(0 === sexp[0])
       return caml_call2(_bs_,cst_float_mat_of_sexp_list_needed,sexp);
      var _ec_=sexp[1];
      if(_ec_)
       {var _ed_=_ec_[2];
        if(_ed_)
         {var
           data=_ed_[2],
           sn=_ed_[1],
           sm=_ec_[1],
           m=caml_call1(_bz_,sm),
           n=caml_call1(_bz_,sn),
           res=caml_call2(create_float_mat,m,n);
          if(0 !== m)
           if(0 !== n)
            {var col=1,data$0=data;
             a:
             for(;;)
              {var vec=caml_call2(Bigarray[20][5],res,col),row=1,param=data$0;
               for(;;)
                {if(param)
                  {var t=param[2],h=param[1];
                   caml_ba_set_1(vec,row,caml_call1(_bA_,h));
                   if(row === m)
                    {if(col === n)return check_too_much_data(sexp,t,res);
                     var col$0=col + 1 | 0,col=col$0,data$0=t;
                     continue a}
                   var row$0=row + 1 | 0,row=row$0,param=t;
                   continue}
                 return caml_call2
                         (_bs_,cst_float_mat_of_sexp_not_enough_data,sexp)}}}
          return check_too_much_data(sexp,data,res)}}
      return caml_call2(_bs_,cst_float_mat_of_sexp_list_too_short,sexp)}
    var
     create_float32_mat=caml_call2(Bigarray[20][1],Bigarray[1],Bigarray[16]),
     create_float64_mat=caml_call2(Bigarray[20][1],Bigarray[2],Bigarray[16]);
    function float32_mat_of_sexp(_eb_)
     {return float_mat_of_sexp(create_float32_mat,_eb_)}
    function float64_mat_of_sexp(_ea_)
     {return float_mat_of_sexp(create_float64_mat,_ea_)}
    function mat_of_sexp(_d$_)
     {return float_mat_of_sexp(create_float64_mat,_d$_)}
    function string_of_of_sexp_of(to_sexp,x)
     {return caml_call1(to_string,caml_call1(to_sexp,x))}
    function of_string_of_of_sexp(of_sexp,s)
     {try
       {var sexp=of_string(s),_d__=caml_call1(of_sexp,sexp);return _d__}
      catch(e)
       {e = caml_wrap_exception(e);
        var
         _d8_=caml_call2(to_string_hum,0,caml_call1(_bO_,e)),
         _d9_=caml_call3(Printf[4],_bR_,s,_d8_);
        return caml_call1(Pervasives[2],_d9_)}}
    var
     Sexplib_Conv=
      [0,
       _a4_,
       _a5_,
       _a6_,
       _a7_,
       _a8_,
       _a9_,
       _a__,
       _a$_,
       _ba_,
       _bb_,
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       _bh_,
       _bi_,
       _bj_,
       _bk_,
       _bl_,
       _bm_,
       _bn_,
       _bo_,
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       _bu_,
       _bv_,
       _bw_,
       _bx_,
       _by_,
       _bz_,
       _bA_,
       _bB_,
       _bC_,
       _bD_,
       _bE_,
       _bF_,
       _bG_,
       _bH_,
       _bI_,
       _bJ_,
       _bK_,
       _bL_,
       _bM_,
       _bN_,
       _bO_,
       _bP_,
       _bQ_,
       sexp_of_bigstring,
       sexp_of_float32_vec,
       sexp_of_float64_vec,
       sexp_of_vec,
       sexp_of_float32_mat,
       sexp_of_float64_mat,
       sexp_of_mat,
       string_of_of_sexp_of,
       bigstring_of_sexp,
       float32_vec_of_sexp,
       float64_vec_of_sexp,
       vec_of_sexp,
       float32_mat_of_sexp,
       float64_mat_of_sexp,
       mat_of_sexp,
       of_string_of_of_sexp];
    caml_register_global(224,Sexplib_Conv,"Sexplib__Conv");
    var
     Of_sexp_error$0=Sexplib0_Sexp_conv_error[1],
     tuple_of_size_n_expected=Sexplib0_Sexp_conv_error[2],
     stag_no_args=Sexplib0_Sexp_conv_error[3],
     stag_incorrect_n_args=Sexplib0_Sexp_conv_error[4],
     stag_takes_args=Sexplib0_Sexp_conv_error[5],
     nested_list_invalid_sum=Sexplib0_Sexp_conv_error[6],
     empty_list_invalid_sum=Sexplib0_Sexp_conv_error[7],
     unexpected_stag=Sexplib0_Sexp_conv_error[8],
     record_only_pairs_expected=Sexplib0_Sexp_conv_error[9],
     record_superfluous_fields=Sexplib0_Sexp_conv_error[10],
     record_duplicate_fields=Sexplib0_Sexp_conv_error[11],
     record_extra_fields=Sexplib0_Sexp_conv_error[12],
     record_get_undefined_loop=Sexplib0_Sexp_conv_error[13],
     record_undefined_elements=Sexplib0_Sexp_conv_error[14],
     record_list_instead_atom=Sexplib0_Sexp_conv_error[15],
     record_poly_field_value=Sexplib0_Sexp_conv_error[16],
     No_variant_match=Sexplib0_Sexp_conv_error[17],
     no_variant_match=Sexplib0_Sexp_conv_error[18],
     no_matching_variant_found=Sexplib0_Sexp_conv_error[19],
     ptag_no_args=Sexplib0_Sexp_conv_error[20],
     ptag_incorrect_n_args=Sexplib0_Sexp_conv_error[21],
     ptag_takes_args=Sexplib0_Sexp_conv_error[22],
     nested_list_invalid_poly_var=Sexplib0_Sexp_conv_error[23],
     empty_list_invalid_poly_var=Sexplib0_Sexp_conv_error[24],
     silly_type=Sexplib0_Sexp_conv_error[25],
     empty_type=Sexplib0_Sexp_conv_error[26],
     Sexplib_Conv_error=
      [0,
       Of_sexp_error$0,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       silly_type,
       empty_type];
    caml_register_global(226,Sexplib_Conv_error,"Sexplib__Conv_error");
    function register(exc,exc_name)
     {function _d6_(exc){return [0,exc_name]}
      var _d7_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_d7_,_d6_)}
    function register1(make_exc,exc_name,sexp_of_arg1)
     {var exc=caml_call1(make_exc,0);
      function _d4_(exc)
       {var sexp1=caml_call1(sexp_of_arg1,exc[2]);
        return [1,[0,[0,exc_name],[0,sexp1,0]]]}
      var _d5_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_d5_,_d4_)}
    function register2(make_exc,exc_name,sexp_of_arg1,sexp_of_arg2)
     {var exc=caml_call2(make_exc,0,0);
      function _d2_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]);
        return [1,[0,[0,exc_name],[0,sexp1,[0,sexp2,0]]]]}
      var _d3_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_d3_,_d2_)}
    function register3
     (make_exc,exc_name,sexp_of_arg1,sexp_of_arg2,sexp_of_arg3)
     {var exc=caml_call3(make_exc,0,0,0);
      function _d0_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]);
        return [1,[0,[0,exc_name],[0,sexp1,[0,sexp2,[0,sexp3,0]]]]]}
      var _d1_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_d1_,_d0_)}
    function register4
     (make_exc,exc_name,sexp_of_arg1,sexp_of_arg2,sexp_of_arg3,sexp_of_arg4)
     {var exc=caml_call4(make_exc,0,0,0,0);
      function _dY_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]);
        return [1,[0,[0,exc_name],[0,sexp1,[0,sexp2,[0,sexp3,[0,sexp4,0]]]]]]}
      var _dZ_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dZ_,_dY_)}
    function register5
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5)
     {var exc=caml_call5(make_exc,0,0,0,0,0);
      function _dW_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,sexp1,[0,sexp2,[0,sexp3,[0,sexp4,[0,sexp5,0]]]]]]]}
      var _dX_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dX_,_dW_)}
    function register6
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5,
      sexp_of_arg6)
     {var exc=caml_call6(make_exc,0,0,0,0,0,0);
      function _dU_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]),
         sexp6=caml_call1(sexp_of_arg6,repr[7]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,sexp1,[0,sexp2,[0,sexp3,[0,sexp4,[0,sexp5,[0,sexp6,0]]]]]]]]}
      var _dV_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dV_,_dU_)}
    function register7
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5,
      sexp_of_arg6,
      sexp_of_arg7)
     {var exc=caml_call7(make_exc,0,0,0,0,0,0,0);
      function _dS_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]),
         sexp6=caml_call1(sexp_of_arg6,repr[7]),
         sexp7=caml_call1(sexp_of_arg7,repr[8]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,
                  sexp1,
                  [0,
                   sexp2,
                   [0,sexp3,[0,sexp4,[0,sexp5,[0,sexp6,[0,sexp7,0]]]]]]]]]}
      var _dT_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dT_,_dS_)}
    function register8
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5,
      sexp_of_arg6,
      sexp_of_arg7,
      sexp_of_arg8)
     {var exc=caml_call8(make_exc,0,0,0,0,0,0,0,0);
      function _dQ_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]),
         sexp6=caml_call1(sexp_of_arg6,repr[7]),
         sexp7=caml_call1(sexp_of_arg7,repr[8]),
         sexp8=caml_call1(sexp_of_arg8,repr[9]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,
                  sexp1,
                  [0,
                   sexp2,
                   [0,
                    sexp3,
                    [0,sexp4,[0,sexp5,[0,sexp6,[0,sexp7,[0,sexp8,0]]]]]]]]]]}
      var _dR_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dR_,_dQ_)}
    function register9
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5,
      sexp_of_arg6,
      sexp_of_arg7,
      sexp_of_arg8,
      sexp_of_arg9)
     {var exc=caml_call9(make_exc,0,0,0,0,0,0,0,0,0);
      function _dO_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]),
         sexp6=caml_call1(sexp_of_arg6,repr[7]),
         sexp7=caml_call1(sexp_of_arg7,repr[8]),
         sexp8=caml_call1(sexp_of_arg8,repr[9]),
         sexp9=caml_call1(sexp_of_arg9,repr[10]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,
                  sexp1,
                  [0,
                   sexp2,
                   [0,
                    sexp3,
                    [0,
                     sexp4,
                     [0,sexp5,[0,sexp6,[0,sexp7,[0,sexp8,[0,sexp9,0]]]]]]]]]]]}
      var _dP_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dP_,_dO_)}
    function register10
     (make_exc,
      exc_name,
      sexp_of_arg1,
      sexp_of_arg2,
      sexp_of_arg3,
      sexp_of_arg4,
      sexp_of_arg5,
      sexp_of_arg6,
      sexp_of_arg7,
      sexp_of_arg8,
      sexp_of_arg9,
      sexp_of_arg10)
     {var exc=caml_call10(make_exc,0,0,0,0,0,0,0,0,0,0);
      function _dM_(repr)
       {var
         sexp1=caml_call1(sexp_of_arg1,repr[2]),
         sexp2=caml_call1(sexp_of_arg2,repr[3]),
         sexp3=caml_call1(sexp_of_arg3,repr[4]),
         sexp4=caml_call1(sexp_of_arg4,repr[5]),
         sexp5=caml_call1(sexp_of_arg5,repr[6]),
         sexp6=caml_call1(sexp_of_arg6,repr[7]),
         sexp7=caml_call1(sexp_of_arg7,repr[8]),
         sexp8=caml_call1(sexp_of_arg8,repr[9]),
         sexp9=caml_call1(sexp_of_arg9,repr[10]),
         sexp10=caml_call1(sexp_of_arg10,repr[11]);
        return [1,
                [0,
                 [0,exc_name],
                 [0,
                  sexp1,
                  [0,
                   sexp2,
                   [0,
                    sexp3,
                    [0,
                     sexp4,
                     [0,
                      sexp5,
                      [0,sexp6,[0,sexp7,[0,sexp8,[0,sexp9,[0,sexp10,0]]]]]]]]]]]]}
      var _dN_=caml_call1(Obj[21],exc);
      return caml_call3(_bQ_[2],0,_dN_,_dM_)}
    var
     Sexplib_Exn_magic=
      [0,
       register,
       register1,
       register2,
       register3,
       register4,
       register5,
       register6,
       register7,
       register8,
       register9,
       register10];
    caml_register_global(228,Sexplib_Exn_magic,"Sexplib__Exn_magic");
    var
     Include_loop_detected=
      [248,cst_Sexplib_Macro_Include_loop_detected,caml_fresh_oo_id(0)],
     Macro_conv_error=
      [248,cst_Sexplib_Macro_Macro_conv_error,caml_fresh_oo_id(0)];
    function _bS_(param)
     {if(param[1] === Macro_conv_error)
       {var match=param[4],expanded=match[2],unexpanded=param[3],exn=param[2];
        return [1,
                [0,
                 _bU_,
                 [0,
                  [1,
                   [0,
                    caml_call1(_bO_,exn),
                    [0,unexpanded,[0,[1,[0,_bT_,[0,expanded,0]]],0]]]],
                  0]]]}
      throw [0,Assert_failure,_bV_]}
    caml_call3(_bQ_[2],_bW_,Macro_conv_error,_bS_);
    function macro_error(err,t)
     {return [0,Of_sexp_error,[0,Failure,caml_call2(Format[115],_bX_,err)],t]}
    function sexp_of_conv$1(sexp_of_a,param)
     {if(1025039613 <= param[1])
       {var a=param[2];return [1,[0,_bY_,[0,caml_call1(sexp_of_a,a),0]]]}
      var match=param[2],sexp=match[2],exn=match[1];
      return [1,
              [0,_bZ_,[0,[1,[0,caml_call1(include$1[49],exn),[0,sexp,0]]],0]]]}
    function sexp_of_annot_conv(sexp_of_a,param)
     {if(1025039613 <= param[1])
       {var a=param[2];return [1,[0,_b0_,[0,caml_call1(sexp_of_a,a),0]]]}
      var
       match=param[2],
       annotated_sexp=match[2],
       exn=match[1],
       _dL_=[0,caml_call1(_a3_[3],annotated_sexp),0];
      return [1,[0,_b1_,[0,[1,[0,caml_call1(include$1[49],exn),_dL_]],0]]]}
    var length$3=List[1],fold_left=List[20],mem=List[31],assq=List[40];
    function iter$0(x,f){return caml_call2(List[15],f,x)}
    var rev_append=List[12],rev=List[9],assoc=List[38];
    function map$1(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           tl=param$0[2],
           hd=param$0[1],
           acc$0=[0,caml_call1(f,hd),acc],
           acc=acc$0,
           param$0=tl;
          continue}
        return caml_call1(List[9],acc)}}
    function concat_map(param,f)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           tl=param$0[2],
           hd=param$0[1],
           _dK_=caml_call1(f,hd),
           acc$0=caml_call2(List[12],_dK_,acc),
           acc=acc$0,
           param$0=tl;
          continue}
        return caml_call1(List[9],acc)}}
    function find_map(f,xs)
     {var xs$0=xs;
      for(;;)
       {if(xs$0)
         {var xs$1=xs$0[2],x=xs$0[1],match=caml_call1(f,x);
          if(match){var x$0=match[1];return [0,x$0]}
          var xs$0=xs$1;
          continue}
        return 0}}
    var
     include$7=caml_call1(Set[1],[0,String[33]]),
     empty=include$7[1],
     is_empty=include$7[2],
     mem$0=include$7[3],
     add$0=include$7[4],
     diff=include$7[9],
     elements=include$7[21];
    function add_list(set,xs)
     {return caml_call3
              (fold_left,
               function(vars,v){return caml_call2(add$0,v,vars)},
               set,
               xs)}
    var Bindings=caml_call1(Map[1],[0,String[33]]);
    function find_arg(result,trail)
     {try
       {var _dI_=find_arg(caml_call2(assq,result,trail),trail);return _dI_}
      catch(_dJ_)
       {_dJ_ = caml_wrap_exception(_dJ_);
        if(_dJ_ === Not_found)return result;
        throw _dJ_}}
    function atom(t)
     {if(0 === t[0]){var str=t[1];return str}
      throw macro_error(cst_Atom_expected,t)}
    function atoms(t)
     {if(0 === t[0])throw macro_error(cst_Atom_list_expected,t);
      var ts=t[1];
      return map$1(ts,atom)}
    function free_variables_gen(raise_if_any,ts)
     {function free_in_list(bound,ts,acc)
       {var bound$0=bound,ts$0=ts,acc$0=acc;
        for(;;)
         {if(ts$0)
           {var _dD_=ts$0[1];
            if(1 === _dD_[0])
             {var _dE_=_dD_[1];
              if(_dE_)
               {var _dF_=_dE_[1];
                if(0 === _dF_[0])
                 if(! caml_string_notequal(_dF_[1],cst_let))
                  {var _dG_=_dE_[2];
                   if(_dG_)
                    {var _dH_=_dG_[2];
                     if(_dH_)
                      {var
                        ts$2=ts$0[2],
                        def=_dH_[2],
                        vs=_dH_[1],
                        v=_dG_[1],
                        acc$2=free_in_list(add_list(bound$0,atoms(vs)),def,acc$0),
                        bound$1=caml_call2(add$0,atom(v),bound$0),
                        bound$0=bound$1,
                        ts$0=ts$2,
                        acc$0=acc$2;
                       continue}}}}}
            var
             ts$1=ts$0[2],
             acc$1=free(bound$0,_dD_,acc$0),
             ts$0=ts$1,
             acc$0=acc$1;
            continue}
          return acc$0}}
      function free(bound,t,acc)
       {if(0 === t[0])return acc;
        var _dA_=t[1];
        if(_dA_)
         {var _dB_=_dA_[1];
          if(0 === _dB_[0])
           if(! caml_string_notequal(_dB_[1],cst_use))
            {var _dC_=_dA_[2];
             if(_dC_)
              {var args=_dC_[2],v=_dC_[1];
               if(caml_call2(mem$0,atom(v),bound))
                var acc$0=acc;
               else
                {if(raise_if_any)throw macro_error(msg,v);
                 var acc$0=caml_call2(add$0,atom(v),acc)}
               return caml_call3
                       (fold_left,
                        function(acc,t){return free(bound,t,acc)},
                        acc$0,
                        args)}}}
        return free_in_list(bound,_dA_,acc)}
      return free_in_list(empty,ts,empty)}
    function expand_local_macros_exn(trail,ts)
     {if(trail)
       var
        ref=trail[1],
        add_result=
         function(arg,result){ref[1] = [0,[0,result,arg],ref[1]];return 0};
      else
       var add_result=function(param,_dz_){return 0};
      function expand_list(defs,ts,acc)
       {var defs$0=defs,ts$0=ts,acc$0=acc;
        a:
        for(;;)
         {if(ts$0)
           {var _dq_=ts$0[1];
            if(1 === _dq_[0])
             {var _dr_=_dq_[1];
              if(_dr_)
               {var _ds_=_dr_[1];
                if(0 === _ds_[0])
                 if(! caml_string_notequal(_ds_[1],cst_let$0))
                  {var _dt_=_dr_[2];
                   if(_dt_)
                    {var _du_=_dt_[2];
                     if(_du_)
                      {var ts$2=ts$0[2],def=_du_[2],args=_du_[1],v=_dt_[1];
                       if(0 === def)
                        throw macro_error(cst_Empty_let_bodies_not_allowed,_dq_);
                       var
                        v$0=atom(v),
                        xs$0=atoms(args),
                        free=free_variables_gen(0,def),
                        args_set=add_list(empty,xs$0),
                        unused=caml_call2(diff,args_set,free);
                       if(1 - caml_call1(is_empty,unused))
                        {var
                          _dv_=caml_call1(elements,unused),
                          _dw_=caml_call2(String[7],cst$8,_dv_);
                         throw macro_error(caml_call2(Format[115],_b2_,_dw_),_dq_)}
                       var undeclared=caml_call2(diff,free,args_set);
                       if(1 - caml_call1(is_empty,undeclared))
                        {var
                          _dx_=caml_call1(elements,undeclared),
                          _dy_=caml_call2(String[7],cst$9,_dx_);
                         throw macro_error(caml_call2(Format[115],_b3_,_dy_),_dq_)}
                       var param=xs$0;
                       for(;;)
                        {if(param)
                          {var xs=param[2],x=param[1];
                           if(! caml_call2(List[31],x,xs)){var param=xs;continue}
                           var match=[0,x]}
                         else
                          var match=0;
                         if(match)
                          {var dup=match[1];
                           throw macro_error(caml_call2(Format[115],_b4_,dup),_dq_)}
                         var
                          defs$1=caml_call3(Bindings[4],v$0,[0,xs$0,def],defs$0),
                          defs$0=defs$1,
                          ts$0=ts$2;
                         continue a}}}}}}
            var
             ts$1=ts$0[2],
             acc$1=caml_call2(rev_append,expand(defs$0,_dq_),acc$0),
             ts$0=ts$1,
             acc$0=acc$1;
            continue}
          return caml_call1(rev,acc$0)}}
      function expand(defs,t)
       {if(0 === t[0])
         {var _dc_=t[1];
          if(caml_string_notequal(_dc_,cst_concat))
           if(caml_string_notequal(_dc_,cst_include))
            if(caml_string_notequal(_dc_,cst_let$1))
             if(caml_string_notequal(_dc_,cst_use$0))return [0,t,0];
          throw macro_error(caml_call2(Pervasives[16],cst_Unexpected,_dc_),t)}
        var _dd_=t[1];
        if(_dd_)
         {var _de_=_dd_[1];
          if(0 === _de_[0])
           {var _df_=_de_[1];
            if(! caml_string_notequal(_df_,cst_concat$0))
             {var ts$0=_dd_[2],ts$1=expand_list(defs,ts$0,0);
              try
               {var ts$2=map$1(ts$1,atom)}
              catch(_dp_)
               {var
                 appl=[1,[0,_b7_,ts$1]],
                 _dl_=caml_call1(to_string,appl),
                 error=caml_call2(Format[115],_b8_,_dl_);
                throw macro_error(error,t)}
              var result$0=[0,caml_call2(String[7],cst$11,ts$2)];
              add_result(t,result$0);
              return [0,result$0,0]}
            if(! caml_string_notequal(_df_,cst_use$1))
             {var _dg_=_dd_[2];
              if(_dg_)
               {var
                 args=_dg_[2],
                 v=_dg_[1],
                 split_arg=
                  function(arg)
                   {if(1 === arg[0])
                     {var _dn_=arg[1];
                      if(_dn_)
                       {var _do_=_dn_[1];
                        if(0 === _do_[0])
                         {var def=_dn_[2],v=_do_[1];return [0,v,def]}}}
                    throw macro_error(cst_Malformed_argument,arg)},
                 evaluate_and_bind=
                  function(arg_defs,param)
                   {var def=param[2],v=param[1],def$0=expand_list(defs,def,0);
                    return caml_call3(Bindings[4],v,[0,0,def$0],arg_defs)};
                try
                 {var _dh_=atom(v),match=caml_call2(Bindings[27],_dh_,defs)}
                catch(_dm_)
                 {_dm_ = caml_wrap_exception(_dm_);
                  if(_dm_ === Not_found)
                   throw macro_error(cst_Undefined_variable,v);
                  throw _dm_}
                var
                 body=match[2],
                 formal_args=match[1],
                 args$0=map$1(args,split_arg),
                 arg_names=
                  map$1(args$0,function(param){var v=param[1];return v});
                if(runtime.caml_notequal(arg_names,formal_args))
                 {var
                   _di_=caml_call2(String[7],cst$10,formal_args),
                   _dj_=atom(v),
                   _dk_=caml_call2(Pervasives[86],_b6_,_b5_);
                  throw macro_error(caml_call3(Format[115],_dk_,_dj_,_di_),t)}
                var
                 defs$0=
                  caml_call3(fold_left,evaluate_and_bind,Bindings[1],args$0);
                return expand_list(defs$0,body,0)}}}}
        var ts=expand_list(defs,_dd_,0),result=[1,ts];
        add_result(t,result);
        return [0,result,0]}
      return expand_list(Bindings[1],ts,0)}
    function expand_local_macros(ts)
     {try
       {var _db_=[0,1025039613,expand_local_macros_exn(0,ts)];return _db_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Of_sexp_error)
         {var t=exn[3],e=exn[2];return [0,106380200,[0,e,t]]}
        throw exn}}
    function Loader(S)
     {var M=S[1];
      function make_absolute_path(with_respect_to,file)
       {if(caml_call1(Filename[5],file))
         {var _da_=caml_call1(Filename[13],with_respect_to);
          return caml_call2(Filename[4],_da_,file)}
        return file}
      function load_all_includes(file)
       {var file_contents=[0,0];
        function load(visited,file)
         {if(caml_call2(mem,file,visited))
           throw [0,Include_loop_detected,file];
          function _c5_(_c$_){return _c$_[1]}
          if(caml_call2(mem,file,map$1(file_contents[1],_c5_)))
           return caml_call1(M[1],0);
          function _c6_(ts)
           {file_contents[1] = [0,[0,file,ts],file_contents[1]];
            var _c8_=[0,file,visited];
            function _c9_(_c__){return load_includes(_c8_,file,_c__)}
            return caml_call2(M[3][1],ts,_c9_)}
          var _c7_=caml_call1(S[2],file);
          return caml_call2(M[2][1],_c7_,_c6_)}
        function load_includes(visited,file,param)
         {if(0 === param[0])return caml_call1(M[1],0);
          var _cZ_=param[1];
          if(_cZ_)
           {var _c0_=_cZ_[1];
            if(0 === _c0_[0])
             if(! caml_string_notequal(_c0_[1],cst_include$0))
              {var _c2_=_cZ_[2];
               if(_c2_)
                {var _c3_=_c2_[1];
                 if(0 === _c3_[0])
                  if(! _c2_[2])
                   {var
                     include_file=_c3_[1],
                     include_file$0=make_absolute_path(file,include_file);
                    return load(visited,include_file$0)}}}}
          function _c1_(_c4_){return load_includes(visited,file,_c4_)}
          return caml_call2(M[3][1],_cZ_,_c1_)}
        function _cX_(param){return caml_call1(M[1],file_contents[1])}
        var _cY_=load(0,file);
        return caml_call2(M[2][1],_cY_,_cX_)}
      function load_all_annotated_includes(file_contents)
       {function _cU_(param)
         {var file=param[1];
          function _cV_(ts){return caml_call1(M[1],[0,file,ts])}
          var _cW_=caml_call1(S[3],file);
          return caml_call2(M[2][1],_cW_,_cV_)}
        return caml_call2(M[3][2],file_contents,_cU_)}
      function find_annotated(bad_sexp,annot_file_contents)
       {return find_map
                (function(param)
                  {var annot_sexps=param[2],file=param[1];
                   return find_map
                           (function(annot_sexp)
                             {var match=caml_call2(_a3_[5],annot_sexp,bad_sexp);
                              if(match)
                               {var annot_sexp$0=match[1];return [0,[0,file,annot_sexp$0]]}
                              return 0},
                            annot_sexps)},
                 annot_file_contents)}
      function expand_and_convert(multiple,mode,file,f)
       {var trail=[0,0];
        if(781119164 <= mode[1])
         var file_contents=mode[2],file_contents$0=file_contents;
        else
         var
          annot_file_contents$0=mode[2],
          file_contents$0=
           map$1
            (annot_file_contents$0,
             function(param)
              {var annot_sexps=param[2],file=param[1];
               return [0,file,map$1(annot_sexps,_a3_[3])]});
        function load_and_inline(file)
         {function _cS_(_cT_){return inline_includes(file,_cT_)}
          var ts=concat_map(caml_call2(assoc,file,file_contents$0),_cS_);
          free_variables_gen(1,ts);
          return ts}
        function inline_includes(current_file,t)
         {if(0 === t[0])return [0,t,0];
          var _cN_=t[1];
          if(_cN_)
           {var _cO_=_cN_[1];
            if(0 === _cO_[0])
             if(! caml_string_notequal(_cO_[1],cst_include$1))
              {var _cP_=_cN_[2];
               if(_cP_)
                {var _cQ_=_cP_[1];
                 if(0 === _cQ_[0])
                  if(! _cP_[2])
                   {var include_file=_cQ_[1];
                    return load_and_inline
                            (make_absolute_path(current_file,include_file))}}}}
          var
           ts=
            concat_map
             (_cN_,function(_cR_){return inline_includes(current_file,_cR_)}),
           result=[1,ts];
          if(! (781119164 <= mode[1]))trail[1] = [0,[0,result,t],trail[1]];
          return [0,result,0]}
        function map_results(ts,f)
         {if(multiple)return map$1(ts,f);
          if(ts)if(! ts[2]){var t=ts[1];return [0,caml_call1(f,t),0]}
          var
           _cL_=caml_call1(length$3,ts),
           _cM_=caml_call3(Format[115],_b9_,file,_cL_);
          return caml_call1(Pervasives[2],_cM_)}
        if(781119164 <= mode[1])
         {var ts=expand_local_macros_exn(0,load_and_inline(file));
          return map_results
                  (ts,function(t){return [0,1025039613,caml_call1(f,t)]})}
        var annot_file_contents=mode[2];
        function locate_error(f)
         {try
           {var _cK_=[0,1025039613,caml_call1(f,0)];return _cK_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Of_sexp_error)
             {var
               bad_sexp=e[3],
               exc=e[2],
               unexpanded_bad_sexp=find_arg(bad_sexp,trail[1]),
               match=find_annotated(unexpanded_bad_sexp,annot_file_contents);
              if(match)
               {var
                 match$0=match[1],
                 unexpanded_bad_annot_sexp=match$0[2],
                 file=match$0[1],
                 exc$0=caml_call3(_a3_[17],file,exc,unexpanded_bad_annot_sexp);
                if(exc$0[1] === Of_sexp_error)
                 var
                  unexpanded_bad_sexp$0=exc$0[3],
                  inner_exc=exc$0[2],
                  exc$1=
                   caml_equal(bad_sexp,unexpanded_bad_sexp$0)
                    ?exc$0
                    :[0,
                      Macro_conv_error,
                      inner_exc,
                      unexpanded_bad_sexp$0,
                      [0,-103870151,bad_sexp]],
                  exc$2=exc$1;
                else
                 var exc$2=exc$0;
                return [0,106380200,[0,exc$2,unexpanded_bad_annot_sexp]]}
              throw e}
            throw e}}
        function inline_and_expand(param)
         {return expand_local_macros_exn([0,trail],load_and_inline(file))}
        var e=locate_error(inline_and_expand);
        if(1025039613 <= e[1])
         {var ts$0=e[2];
          return map_results
                  (ts$0,
                   function(t)
                    {return locate_error
                             (function(param){return caml_call1(f,t)})})}
        return [0,e,0]}
      function load(multiple,file,f)
       {function _cE_(file_contents)
         {try
           {var
             _cI_=
              expand_and_convert(multiple,[0,781119164,file_contents],file,f),
             _cJ_=caml_call1(M[1],_cI_);
            return _cJ_}
          catch(original_exn)
           {original_exn = caml_wrap_exception(original_exn);
            if(original_exn[1] === Of_sexp_error)
             {var
               _cG_=
                function(annotated_file_contents)
                 {var
                   xs=
                    expand_and_convert
                     (multiple,[0,-629057502,annotated_file_contents],file,f);
                  function f$0(param){return 1025039613 <= param[1]?0:1}
                  if(caml_call2(List[28],f$0,xs))return caml_call1(M[1],xs);
                  throw original_exn},
               _cH_=load_all_annotated_includes(file_contents);
              return caml_call2(M[2][1],_cH_,_cG_)}
            throw original_exn}}
        var _cF_=load_all_includes(file);
        return caml_call2(M[2][1],_cF_,_cE_)}
      function load_sexps_conv(file,f){return load(1,file,f)}
      function load_sexp_conv(file,f)
       {function _cC_(param)
         {if(param)if(! param[2]){var a=param[1];return caml_call1(M[1],a)}
          throw [0,Assert_failure,_b__]}
        var _cD_=load(0,file,f);
        return caml_call2(M[2][1],_cD_,_cC_)}
      return [0,
              M,
              make_absolute_path,
              load_all_includes,
              load_all_annotated_includes,
              find_annotated,
              expand_and_convert,
              load,
              load_sexps_conv,
              load_sexp_conv]}
    var
     Error_in_file=
      [248,cst_Sexplib_Macro_Error_in_file,caml_fresh_oo_id(0)];
    function _b$_(param)
     {if(param[1] === Error_in_file)
       {var exn=param[3],file=param[2],_cB_=[0,caml_call1(_bO_,exn),0];
        return [1,
                [0,[0,caml_call2(Pervasives[16],cst_Error_in_file,file)],_cB_]]}
      throw [0,Assert_failure,_ca_]}
    caml_call3(_bQ_[2],_cb_,Error_in_file,_b$_);
    function add_error_location(file,error)
     {if(error[1] === Parse_error)
       {var e=error[2],err_msg=caml_call3(Format[115],_cc_,file,e[1]);
        return [0,Parse_error,[0,err_msg,e[2]]]}
      if(error[1] === Failure)
       {var e$0=error[2];
        return [0,Failure,caml_call3(Format[115],_cd_,file,e$0)]}
      return [0,Error_in_file,file,error]}
    function return$1(a){return a}
    var Monad_infix=[0,function(a,f){return caml_call1(f,a)}];
    function load_sexps$1(file)
     {try
       {var _cA_=load_sexps(0,file);return _cA_}
      catch(e){e = caml_wrap_exception(e);throw add_error_location(file,e)}}
    function load_annotated_sexps(file)
     {try
       {var _cz_=caml_call2(_a3_[12],0,file);return _cz_}
      catch(e){e = caml_wrap_exception(e);throw add_error_location(file,e)}}
    var
     Simple_loader=
      Loader
       ([0,
         [0,return$1,Monad_infix,[0,iter$0,map$1]],
         load_sexps$1,
         load_annotated_sexps]);
    function id(a){return a}
    var load_sexp_conv$0=Simple_loader[9];
    function load_sexp_conv_exn$0(file,f)
     {var match=caml_call2(load_sexp_conv$0,file,f);
      if(1025039613 <= match[1]){var a=match[2];return a}
      var match$0=match[2],exn=match$0[1];
      throw exn}
    function load_sexp$1(file){return load_sexp_conv_exn$0(file,id)}
    var load_sexps_conv$0=Simple_loader[8];
    function load_sexps_conv_exn$0(file,f)
     {var results=caml_call2(load_sexps_conv$0,file,f);
      return map$1
              (results,
               function(param)
                {if(1025039613 <= param[1]){var a=param[2];return a}
                 var match=param[2],exn=match[1];
                 throw exn})}
    function load_sexps$2(file){return load_sexps_conv_exn$0(file,id)}
    var
     Sexplib_Macro=
      [0,
       sexp_of_conv$1,
       sexp_of_annot_conv,
       load_sexp$1,
       load_sexps$2,
       load_sexp_conv$0,
       load_sexps_conv$0,
       load_sexp_conv_exn$0,
       load_sexps_conv_exn$0,
       expand_local_macros,
       function(_cx_){var _cy_=Loader(_cx_);return [0,_cy_[9],_cy_[8]]},
       add_error_location];
    caml_register_global(234,Sexplib_Macro,"Sexplib__Macro");
    function illegal_atom(loc,sexp)
     {var
       _cv_=caml_call1(to_string,sexp),
       _cw_=caml_call3(Format[115],_ce_,loc,_cv_);
      return caml_call1(Pervasives[2],_cw_)}
    function extract_pos_lst(loc,sexp,ix,param)
     {var acc=0,n=ix,param$0=param;
      for(;;)
       {if(param$0)
         {var t=param$0[2],h=param$0[1];
          if(0 === n)
           {var
             subst=
              function(param)
               {if(param)
                 {var x=param[1];return caml_call2(List[12],acc,[0,x,t])}
                return caml_call2(List[12],acc,t)};
            return [0,subst,h]}
          var n$0=n - 1 | 0,acc$0=[0,h,acc],acc=acc$0,n=n$0,param$0=t;
          continue}
        var
         sexp_str=caml_call1(to_string,sexp),
         _cu_=caml_call4(Format[115],_cf_,loc,ix,sexp_str);
        return caml_call1(Pervasives[2],_cu_)}}
    function extract_pos(n,sexp)
     {if(0 === sexp[0])return illegal_atom(cst_extract_pos,sexp);
      var
       lst=sexp[1],
       match=extract_pos_lst(cst_extract_pos$0,sexp,n,lst),
       el=match[2],
       subst=match[1];
      return [0,function(x){return [1,caml_call1(subst,x)]},el]}
    function extract_match(tag,arg_ix,sexp)
     {if(0 === sexp[0])return illegal_atom(cst_extract_match,sexp);
      var _cr_=sexp[1];
      if(_cr_)
       {var _cs_=_cr_[1];
        if(0 === _cs_[0])
         {var args=_cr_[2],str=_cs_[1];
          if(caml_string_equal(str,tag))
           {var
             match=extract_pos_lst(cst_extract_match$0,[1,args],arg_ix,args),
             el=match[2],
             subst=match[1];
            return [0,
                    function(maybe_x)
                     {return [1,[0,_cs_,caml_call1(subst,maybe_x)]]},
                    el]}}}
      var
       sexp_str=caml_call1(to_string,sexp),
       _ct_=
        caml_call2
         (Pervasives[16],
          cst_Path_extract_match_unexpected_nested_list_in,
          sexp_str);
      return caml_call1(Pervasives[2],_ct_)}
    function extract_rec(key,sexp)
     {if(0 === sexp[0])return illegal_atom(cst_extract_rec,sexp);
      var lst=sexp[1],acc=0,param=lst;
      for(;;)
       {if(param)
         {var _cm_=param[1];
          if(1 === _cm_[0])
           {var _cn_=_cm_[1];
            if(_cn_)
             {var _co_=_cn_[1];
              if(0 === _co_[0])
               {var _cp_=_cn_[2];
                if(_cp_)
                 if(! _cp_[2])
                  {var rest=param[2],v=_cp_[1],str=_co_[1];
                   if(caml_string_equal(str,key))
                    {var
                      subst=
                       function(x)
                        {return [1,
                                 caml_call2(List[12],acc,[0,[1,[0,_co_,[0,x,0]]],rest])]};
                     return [0,subst,v]}}}}}
          var param$0=param[2],acc$0=[0,_cm_,acc],acc=acc$0,param=param$0;
          continue}
        var
         sexp_str=caml_call1(to_string,sexp),
         _cq_=caml_call3(Format[115],_cg_,key,sexp_str);
        return caml_call1(Pervasives[2],_cq_)}}
    function id$0(x){return x}
    function subst_option(param,rest)
     {var
       el=param[2],
       sup_subst=param[1],
       match=subst_path(el,rest),
       sub_el=match[2],
       sub_subst=match[1];
      function subst(x)
       {return caml_call1(sup_subst,[0,caml_call1(sub_subst,x)])}
      return [0,subst,sub_el]}
    function subst_path(sexp,param)
     {if(param)
       {var _cl_=param[1];
        switch(_cl_[0])
         {case 0:
           var t=param[2],n=_cl_[1];
           return subst_option(extract_pos(n,sexp),t);
          case 1:
           var t$0=param[2],arg_ix=_cl_[2],tag=_cl_[1];
           return subst_option(extract_match(tag,arg_ix,sexp),t$0);
          default:
           var
            rest=param[2],
            key=_cl_[1],
            match=extract_rec(key,sexp),
            el=match[2],
            rec_subst=match[1],
            match$0=subst_path(el,rest),
            sub_el=match$0[2],
            sub_subst=match$0[1],
            subst=
             function(x){return caml_call1(rec_subst,caml_call1(sub_subst,x))};
           return [0,subst,sub_el]}}
      return [0,id$0,sexp]}
    function implode(param)
     {var
       len=caml_call1(List[1],param),
       str=caml_create_bytes(len),
       ix=0,
       param$0=param;
      for(;;)
       {if(param$0)
         {var t=param$0[2],h=param$0[1];
          caml_bytes_set(str,ix,h);
          var ix$0=ix + 1 | 0,ix=ix$0,param$0=t;
          continue}
        return caml_call1(Bytes[42],str)}}
    function fail_parse(msg)
     {var _ck_=caml_call2(Pervasives[16],cst_Path_parse,msg);
      return caml_call1(Pervasives[2],_ck_)}
    function parse$0(str)
     {var len=caml_ml_string_length(str);
      if(0 === len)return fail_parse(cst_path_empty);
      var acc=0,dot_ix=0;
      a:
      for(;;)
       {var c=caml_string_get(str,dot_ix);
        if(46 === c)
         {var ix=dot_ix + 1 | 0;
          if(ix === len)return caml_call1(List[9],acc);
          var acc$0=acc,str_acc=0,ix$0=ix;
          for(;;)
           {if(ix$0 === len)
             {var _cj_=[0,[2,implode(caml_call1(List[9],str_acc))],0];
              return caml_call2(List[12],acc$0,_cj_)}
            var c$0=caml_string_get(str,ix$0),switcher=c$0 - 91 | 0;
            if(1 < switcher >>> 0)
             {if(-45 === switcher)
               {if(0 === str_acc)fail_parse(cst_double);
                var
                 path_el=[2,implode(caml_call1(List[9],str_acc))],
                 ix$1=ix$0 + 1 | 0,
                 acc$1=[0,path_el,acc$0],
                 acc$0=acc$1,
                 str_acc=0,
                 ix$0=ix$1;
                continue}
              var
               ix$2=ix$0 + 1 | 0,
               str_acc$0=[0,c$0,str_acc],
               str_acc=str_acc$0,
               ix$0=ix$2;
              continue}
            if(0 === switcher)
             {var ix$6=ix$0 + 1 | 0,index_acc=0,ix$3=ix$6;
              for(;;)
               {if(ix$3 === len)return fail_parse(cst_EOF_reading_index);
                var c$1=caml_string_get(str,ix$3);
                if(58 <= c$1)
                 {if(93 === c$1)
                   {if(index_acc)
                     {var
                       index_acc$0=index_acc[1],
                       path_el$0=
                        0 === str_acc
                         ?[0,index_acc$0]
                         :[1,implode(caml_call1(List[9],str_acc)),index_acc$0],
                       dot_ix$0=ix$3 + 1 | 0;
                      if(dot_ix$0 === len)
                       return caml_call2(List[12],acc$0,[0,path_el$0,0]);
                      var acc$2=[0,path_el$0,acc$0],acc=acc$2,dot_ix=dot_ix$0;
                      continue a}
                    return fail_parse(cst_empty_index)}}
                else
                 if(48 <= c$1)
                  {if(index_acc)
                    {var
                      index_acc$1=index_acc[1],
                      index_acc$2=[0,((10 * index_acc$1 | 0) + c$1 | 0) - 48 | 0],
                      ix$4=ix$3 + 1 | 0,
                      index_acc=index_acc$2,
                      ix$3=ix$4;
                     continue}
                   var
                    ix$5=ix$3 + 1 | 0,
                    index_acc$3=[0,c$1 - 48 | 0],
                    index_acc=index_acc$3,
                    ix$3=ix$5;
                   continue}
                return fail_parse(caml_call2(Format[115],_ch_,c$1))}}
            var ix1=ix$0 + 1 | 0;
            if(ix1 === len)return fail_parse(cst_EOF_after_escape);
            var
             ix$7=ix$0 + 1 | 0,
             str_acc$1=[0,caml_string_get(str,ix1),str_acc],
             str_acc=str_acc$1,
             ix$0=ix$7;
            continue}}
        return fail_parse(caml_call2(Format[115],_ci_,c))}}
    function get_subst(path,match,sexp)
     {if(path)
       var path$0=path[1],path$1=path$0;
      else
       if(match)var str=match[1],path$1=parse$0(str);else var path$1=0;
      return subst_path(sexp,path$1)}
    function get(path,str,sexp){return get_subst(path,str,sexp)[2]}
    function replace(path,str,sexp,subst)
     {var match=get_subst(path,str,sexp),subst_fun=match[1];
      return caml_call1(subst_fun,subst)}
    function replace_no_path(str,sexp,subst)
     {return replace(0,[0,str],sexp,subst)}
    var
     Sexplib_Path=
      [0,
       parse$0,
       get,
       replace,
       replace_no_path,
       subst_path,
       extract_pos,
       extract_match,
       extract_rec];
    caml_register_global(235,Sexplib_Path,"Sexplib__Path");
    var
     create$2=Hashtbl[1],
     clear$1=Hashtbl[2],
     reset=Hashtbl[3],
     copy=Hashtbl[4],
     add$1=Hashtbl[5],
     find=Hashtbl[6],
     find_opt=Hashtbl[7],
     find_all=Hashtbl[8],
     mem$1=Hashtbl[9],
     remove=Hashtbl[10],
     replace$0=Hashtbl[11],
     iter$1=Hashtbl[12],
     filter_map_inplace=Hashtbl[13],
     fold=Hashtbl[14],
     length$4=Hashtbl[15],
     randomize=Hashtbl[16],
     is_randomized=Hashtbl[17],
     stats=Hashtbl[18],
     Make$2=Hashtbl[19],
     MakeSeeded=Hashtbl[20],
     hash=Hashtbl[21],
     seeded_hash=Hashtbl[22],
     hash_param=Hashtbl[23],
     seeded_hash_param=Hashtbl[24],
     Hashtbl$0=
      [0,
       create$2,
       clear$1,
       reset,
       copy,
       add$1,
       find,
       find_opt,
       find_all,
       mem$1,
       remove,
       replace$0,
       iter$1,
       filter_map_inplace,
       fold,
       length$4,
       randomize,
       is_randomized,
       stats,
       Make$2,
       MakeSeeded,
       hash,
       seeded_hash,
       hash_param,
       seeded_hash_param,
       _bn_,
       _bL_],
     Undefined=Lazy[1],
     force_val=Lazy[2],
     from_fun=Lazy[3],
     from_val=Lazy[4],
     is_val=Lazy[5],
     lazy_from_fun=Lazy[6],
     lazy_from_val=Lazy[7],
     lazy_is_val=Lazy[8],
     Lazy$0=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       lazy_from_fun,
       lazy_from_val,
       lazy_is_val,
       _bF_,
       _bh_],
     Sexplib_Std=
      [0,
       Hashtbl$0,
       Lazy$0,
       0,
       _a8_,
       _bu_,
       _a9_,
       _bv_,
       _a__,
       _bw_,
       _ba_,
       _by_,
       _bb_,
       _bz_,
       _bc_,
       _bA_,
       _bd_,
       _bB_,
       _be_,
       _bC_,
       _bf_,
       _bD_,
       _bg_,
       _bE_,
       _bh_,
       _bF_,
       _bi_,
       _bG_,
       _bl_,
       _bJ_,
       _bm_,
       _bK_,
       _bO_];
    caml_register_global(238,Sexplib_Std,"Sexplib__Std");
    return}
  (function(){return this}()));


//# 1 ".index.eobjs/datastructures.cmo.js"
(function(joo_global_object)
   {"use strict";
     /*<<?>>*/ var runtime=joo_global_object.jsoo_runtime;
     /*<<?>>*/ function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
     /*<<?>>*/ function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
     /*<<?>>*/ function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     CCFQueue=global_data.CCFQueue,
     CCList=global_data.CCList,
     CCSet=global_data.CCSet,
     CCMap=global_data.CCMap,
     Pervasives=global_data.Pervasives,
     CCString=global_data.CCString,
     CCInt=global_data.CCInt,
     make=CCString[1],
     copy=CCString[2],
     sub=CCString[3],
     fill=CCString[4],
     concat=CCString[5],
     trim=CCString[6],
     escaped=CCString[7],
     index=CCString[8],
     index_opt=CCString[9],
     rindex=CCString[10],
     rindex_opt=CCString[11],
     index_from=CCString[12],
     index_from_opt=CCString[13],
     rindex_from=CCString[14],
     rindex_from_opt=CCString[15],
     contains=CCString[16],
     contains_from=CCString[17],
     rcontains_from=CCString[18],
     uppercase=CCString[19],
     lowercase=CCString[20],
     capitalize=CCString[21],
     uncapitalize=CCString[22],
     equal=CCString[23],
     compare=CCString[24],
     is_empty=CCString[25],
     hash=CCString[26],
     init=CCString[27],
     rev=CCString[28],
     pad=CCString[29],
     of_char=CCString[30],
     of_gen=CCString[31],
     of_seq=CCString[32],
     of_klist=CCString[33],
     of_list=CCString[34],
     of_array=CCString[35],
     to_array=CCString[36],
     find=CCString[37],
     find_all=CCString[38],
     find_all_l=CCString[39],
     mem=CCString[40],
     rfind=CCString[41],
     replace=CCString[42],
     is_sub=CCString[43],
     repeat=CCString[44],
     prefix=CCString[45],
     suffix=CCString[46],
     chop_prefix=CCString[47],
     chop_suffix=CCString[48],
     take=CCString[49],
     drop=CCString[50],
     take_drop=CCString[51],
     lines=CCString[52],
     lines_gen=CCString[53],
     concat_gen=CCString[54],
     unlines=CCString[55],
     unlines_gen=CCString[56],
     set=CCString[57],
     iter=CCString[58],
     iteri=CCString[59],
     map=CCString[60],
     mapi=CCString[61],
     filter_map=CCString[62],
     filter=CCString[63],
     flat_map=CCString[64],
     for_all=CCString[65],
     exists=CCString[66],
     length=CCString[67],
     blit=CCString[68],
     fold=CCString[69],
     to_gen=CCString[70],
     to_seq=CCString[71],
     to_klist=CCString[72],
     to_list=CCString[73],
     pp_buf=CCString[74],
     pp=CCString[75],
     drop_while=CCString[76],
     rdrop_while=CCString[77],
     ltrim=CCString[78],
     rtrim=CCString[79],
     map2=CCString[80],
     iter2=CCString[81],
     iteri2=CCString[82],
     fold2=CCString[83],
     for_all2=CCString[84],
     exists2=CCString[85],
     capitalize_ascii=CCString[86],
     uncapitalize_ascii=CCString[87],
     uppercase_ascii=CCString[88],
     lowercase_ascii=CCString[89],
     equal_caseless=CCString[90],
     Find=CCString[91],
     Split=CCString[92],
     split_on_char=CCString[93],
     split=CCString[94],
     compare_versions=CCString[95],
     compare_natural=CCString[96],
     edit_distance=CCString[97],
     Sub=CCString[98];
    function sexp_of_t(t)
     { /*<<datastructures.ml 12 20>>*/ return [0,t] /*<<datastructures.ml 12 39>>*/ }
    var
     CCString$0=
      [0,
       make,
       copy,
       sub,
       fill,
       concat,
       trim,
       escaped,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       equal,
       compare,
       is_empty,
       hash,
       init,
       rev,
       pad,
       of_char,
       of_gen,
       of_seq,
       of_klist,
       of_list,
       of_array,
       to_array,
       find,
       find_all,
       find_all_l,
       mem,
       rfind,
       replace,
       is_sub,
       repeat,
       prefix,
       suffix,
       chop_prefix,
       chop_suffix,
       take,
       drop,
       take_drop,
       lines,
       lines_gen,
       concat_gen,
       unlines,
       unlines_gen,
       set,
       iter,
       iteri,
       map,
       mapi,
       filter_map,
       filter,
       flat_map,
       for_all,
       exists,
       length,
       blit,
       fold,
       to_gen,
       to_seq,
       to_klist,
       to_list,
       pp_buf,
       pp,
       drop_while,
       rdrop_while,
       ltrim,
       rtrim,
       map2,
       iter2,
       iteri2,
       fold2,
       for_all2,
       exists2,
       capitalize_ascii,
       uncapitalize_ascii,
       uppercase_ascii,
       lowercase_ascii,
       equal_caseless,
       Find,
       Split,
       split_on_char,
       split,
       compare_versions,
       compare_natural,
       edit_distance,
       Sub,
       sexp_of_t],
     compare$0=CCInt[1],
     equal$0=CCInt[2],
     hash$0=CCInt[3],
     sign=CCInt[4],
     neg=CCInt[5],
     pow=CCInt[6],
     floor_div=CCInt[7],
     rem=CCInt[8],
     random=CCInt[9],
     random_small=CCInt[10],
     random_range=CCInt[11],
     pp$0=CCInt[12],
     to_string=CCInt[13],
     of_string=CCInt[14],
     pp_binary=CCInt[15],
     to_string_binary=CCInt[16],
     min=CCInt[17],
     max=CCInt[18],
     range_by=CCInt[19],
     range=CCInt[20],
     range$0=CCInt[21],
     Infix=CCInt[22],
     mod=CCInt[36],
     land=CCInt[37],
     lor=CCInt[38],
     lxor=CCInt[39],
     lnot=CCInt[40],
     lsl=CCInt[41],
     lsr=CCInt[42],
     asr=CCInt[43],
     _a_=CCInt[23],
     _b_=CCInt[24],
     _c_=CCInt[25],
     _d_=CCInt[26],
     _e_=CCInt[27],
     _f_=CCInt[28],
     _g_=CCInt[29],
     _h_=CCInt[30],
     _i_=CCInt[31],
     _j_=CCInt[32],
     _k_=CCInt[33],
     _l_=CCInt[34],
     _m_=CCInt[35];
    function sexp_of_t$0(t)
     { /*<<datastructures.ml 18 20>>*/  /*<<datastructures.ml 18 20>>*/ var
       _B_=
        Pervasives[21];
       /*<<datastructures.ml 18 38>>*/ return [0,
               /*<<datastructures.ml 18 38>>*/ caml_call1(_B_,t)] /*<<datastructures.ml 18 55>>*/ }
    var
     CCInt$0=
      [0,
       compare$0,
       equal$0,
       hash$0,
       sign,
       neg,
       pow,
       floor_div,
       rem,
       random,
       random_small,
       random_range,
       pp$0,
       to_string,
       of_string,
       pp_binary,
       to_string_binary,
       min,
       max,
       range_by,
       range,
       range$0,
       Infix,
       _a_,
       _b_,
       _c_,
       _d_,
       _e_,
       _f_,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _m_,
       mod,
       land,
       lor,
       lxor,
       lnot,
       lsl,
       lsr,
       asr,
       sexp_of_t$0];
    function CCMapMake(Key)
     {var
       include=caml_call1(CCMap[1],[0,Key[1]]),
       empty=include[1],
       is_empty=include[2],
       mem=include[3],
       add=include[4],
       singleton=include[5],
       remove=include[6],
       merge=include[7],
       compare=include[8],
       equal=include[9],
       iter=include[10],
       fold=include[11],
       for_all=include[12],
       exists=include[13],
       filter=include[14],
       partition=include[15],
       cardinal=include[16],
       bindings=include[17],
       min_binding=include[18],
       max_binding=include[19],
       choose=include[20],
       split=include[21],
       find=include[22],
       find_last=include[23],
       find_last_opt=include[24],
       map=include[25],
       mapi=include[26],
       get=include[27],
       get_or=include[28],
       update=include[29],
       choose_opt=include[30],
       min_binding_opt=include[31],
       max_binding_opt=include[32],
       find_opt=include[33],
       find_first=include[34],
       find_first_opt=include[35],
       merge_safe=include[36],
       union=include[37],
       of_seq=include[38],
       add_seq=include[39],
       to_seq=include[40],
       of_list=include[41],
       add_list=include[42],
       keys=include[43],
       values=include[44],
       to_list=include[45],
       pp=include[46];
      function sexp_of_t(sexp_of_value,t)
       { /*<<datastructures.ml 26 4>>*/  /*<<datastructures.ml 26 4>>*/ var
         _w_=
          0;
         /*<<datastructures.ml 26 4>>*/ function _x_(key,value,atm_lis)
         { /*<<datastructures.ml 29 11>>*/ var
            /*<<datastructures.ml 29 11>>*/ _y_=0,
            /*<<datastructures.ml 29 36>>*/ _z_=
            [0,
              /*<<datastructures.ml 29 36>>*/ caml_call1(sexp_of_value,value),
             _y_],
            /*<<datastructures.ml 29 36>>*/ _A_=Key[2];
           /*<<datastructures.ml 29 17>>*/ return [0,
                  [1,
                   [0, /*<<datastructures.ml 29 17>>*/ caml_call1(_A_,key),_z_]],
                  atm_lis] /*<<datastructures.ml 29 67>>*/ }
         /*<<datastructures.ml 27 6>>*/ return [1,
                 /*<<datastructures.ml 27 6>>*/ caml_call3(fold,_x_,t,_w_)] /*<<datastructures.ml 30 14>>*/ }
      return [0,
              empty,
              is_empty,
              mem,
              add,
              singleton,
              remove,
              merge,
              compare,
              equal,
              iter,
              fold,
              for_all,
              exists,
              filter,
              partition,
              cardinal,
              bindings,
              min_binding,
              max_binding,
              choose,
              split,
              find,
              find_last,
              find_last_opt,
              map,
              mapi,
              get,
              get_or,
              update,
              choose_opt,
              min_binding_opt,
              max_binding_opt,
              find_opt,
              find_first,
              find_first_opt,
              merge_safe,
              union,
              of_seq,
              add_seq,
              to_seq,
              of_list,
              add_list,
              keys,
              values,
              to_list,
              pp,
              sexp_of_t]}
    function CCSetMake(Key)
     {var
       include=caml_call1(CCSet[1],[0,Key[1]]),
       empty=include[1],
       is_empty=include[2],
       mem=include[3],
       add=include[4],
       singleton=include[5],
       remove=include[6],
       union=include[7],
       inter=include[8],
       diff=include[9],
       compare=include[10],
       equal=include[11],
       subset=include[12],
       iter=include[13],
       map=include[14],
       fold=include[15],
       for_all=include[16],
       exists=include[17],
       filter=include[18],
       partition=include[19],
       cardinal=include[20],
       elements=include[21],
       min_elt=include[22],
       max_elt=include[23],
       choose=include[24],
       split=include[25],
       find=include[26],
       min_elt_opt=include[27],
       max_elt_opt=include[28],
       choose_opt=include[29],
       find_opt=include[30],
       find_first=include[31],
       find_first_opt=include[32],
       find_last=include[33],
       find_last_opt=include[34],
       of_seq=include[35],
       add_seq=include[36],
       to_seq=include[37],
       of_list=include[38],
       add_list=include[39],
       to_list=include[40],
       pp=include[41];
      function sexp_of_t(t)
       { /*<<datastructures.ml 38 4>>*/  /*<<datastructures.ml 38 4>>*/ var
         _t_=
          0;
         /*<<datastructures.ml 38 4>>*/ function _u_(value,atm_lis)
         { /*<<datastructures.ml 38 37>>*/  /*<<datastructures.ml 38 37>>*/ var
           _v_=
            Key[2];
           /*<<datastructures.ml 38 37>>*/ return [0,
                   /*<<datastructures.ml 38 37>>*/ caml_call1(_v_,value),
                  atm_lis] /*<<datastructures.ml 38 67>>*/ }
         /*<<datastructures.ml 38 9>>*/ return [1,
                 /*<<datastructures.ml 38 9>>*/ caml_call3(fold,_u_,t,_t_)] /*<<datastructures.ml 38 74>>*/ }
      return [0,
              empty,
              is_empty,
              mem,
              add,
              singleton,
              remove,
              union,
              inter,
              diff,
              compare,
              equal,
              subset,
              iter,
              map,
              fold,
              for_all,
              exists,
              filter,
              partition,
              cardinal,
              elements,
              min_elt,
              max_elt,
              choose,
              split,
              find,
              min_elt_opt,
              max_elt_opt,
              choose_opt,
              find_opt,
              find_first,
              find_first_opt,
              find_last,
              find_last_opt,
              of_seq,
              add_seq,
              to_seq,
              of_list,
              add_list,
              to_list,
              pp,
              sexp_of_t]}
    var
     empty=CCFQueue[1],
     is_empty$0=CCFQueue[2],
     singleton=CCFQueue[3],
     doubleton=CCFQueue[4],
     Empty=CCFQueue[5],
     cons=CCFQueue[6],
     snoc=CCFQueue[7],
     take_front=CCFQueue[8],
     take_front_exn=CCFQueue[9],
     take_front_l=CCFQueue[10],
     take_front_while=CCFQueue[11],
     take_back=CCFQueue[12],
     take_back_exn=CCFQueue[13],
     take_back_l=CCFQueue[14],
     take_back_while=CCFQueue[15],
     first=CCFQueue[16],
     last=CCFQueue[17],
     first_exn=CCFQueue[18],
     last_exn=CCFQueue[19],
     nth=CCFQueue[20],
     nth_exn=CCFQueue[21],
     tail=CCFQueue[22],
     init$0=CCFQueue[23],
     append=CCFQueue[24],
     rev$0=CCFQueue[25],
     map$0=CCFQueue[26],
     size=CCFQueue[28],
     fold$0=CCFQueue[29],
     iter$0=CCFQueue[30],
     equal$1=CCFQueue[31],
     of_list$0=CCFQueue[32],
     to_list$0=CCFQueue[33],
     add_seq_front=CCFQueue[34],
     add_seq_back=CCFQueue[35],
     to_seq$0=CCFQueue[36],
     of_seq$0=CCFQueue[37],
     to_klist$0=CCFQueue[38],
     of_klist$0=CCFQueue[39],
     pp$1=CCFQueue[42],
     _n_=CCFQueue[27],
     _o_=CCFQueue[40],
     _p_=CCFQueue[41];
    function sexp_of_t$1(sexp_of_value,t)
     { /*<<datastructures.ml 45 4>>*/ var
        /*<<datastructures.ml 45 4>>*/ _q_=CCFQueue[33],
        /*<<datastructures.ml 45 48>>*/ _r_=
         /*<<datastructures.ml 45 48>>*/ caml_call1(_q_,t),
        /*<<datastructures.ml 45 48>>*/ _s_=CCList[33];
       /*<<datastructures.ml 45 22>>*/ return [1,
               /*<<datastructures.ml 45 22>>*/ caml_call2
               (_s_,sexp_of_value,_r_)] /*<<datastructures.ml 45 69>>*/ }
    var
     CCFQueueWithSexp=
      [0,
       empty,
       is_empty$0,
       singleton,
       doubleton,
       Empty,
       cons,
       snoc,
       take_front,
       take_front_exn,
       take_front_l,
       take_front_while,
       take_back,
       take_back_exn,
       take_back_l,
       take_back_while,
       first,
       last,
       first_exn,
       last_exn,
       nth,
       nth_exn,
       tail,
       init$0,
       append,
       rev$0,
       map$0,
       _n_,
       size,
       fold$0,
       iter$0,
       equal$1,
       of_list$0,
       to_list$0,
       add_seq_front,
       add_seq_back,
       to_seq$0,
       of_seq$0,
       to_klist$0,
       of_klist$0,
       _o_,
       _p_,
       pp$1,
       sexp_of_t$1],
     Datastructures=
      [0,CCString$0,CCInt$0,CCMapMake,CCSetMake,CCFQueueWithSexp];
    runtime.caml_register_global(7,Datastructures,"Datastructures");
    return /*<<?>>*/ }
  (function(){return this}()));


//# 1 ".index.eobjs/op_set.cmo.js"
(function(joo_global_object)
   {"use strict";
     /*<<?>>*/ var
     runtime=joo_global_object.jsoo_runtime,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_new_string=runtime.caml_new_string,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal;
     /*<<?>>*/ function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
     /*<<?>>*/ function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
     /*<<?>>*/ function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
     /*<<?>>*/ function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_next_value=caml_new_string("next value"),
     cst_next_conflict=caml_new_string("next conflict"),
     cst_obj_key=caml_new_string("obj key"),
     cst_child_id$0=caml_new_string("child id"),
     cst_child_id=caml_new_string("child id"),
     cst$2=caml_new_string(""),
     cst$3=caml_new_string("_"),
     root_op=
      [0,caml_new_string(""),4,caml_new_string(""),0,caml_new_string(""),0,0],
     cst$1=caml_new_string(""),
     cst_head$0=caml_new_string("_head"),
     cst$0=caml_new_string(":"),
     cst_head=caml_new_string("_head"),
     cst=caml_new_string(":"),
     cst_key=caml_new_string("key"),
     cst_op_value=caml_new_string("op.value"),
     cst_actor_map=caml_new_string("actor_map"),
     cst_states=caml_new_string("states"),
     cst_del=caml_new_string("del"),
     cst_Del=caml_new_string("Del"),
     cst_Ins=caml_new_string("Ins"),
     cst_Link=caml_new_string("Link"),
     cst_MakeList=caml_new_string("MakeList"),
     cst_MakeMap=caml_new_string("MakeMap"),
     cst_MakeText=caml_new_string("MakeText"),
     cst_Set=caml_new_string("Set"),
     cst_ins=caml_new_string("ins"),
     cst_link=caml_new_string("link"),
     cst_makeList=caml_new_string("makeList"),
     cst_makeMap=caml_new_string("makeMap"),
     cst_makeText=caml_new_string("makeText"),
     cst_set=caml_new_string("set"),
     cst_del$0=caml_new_string("del"),
     cst_Del$0=caml_new_string("Del"),
     cst_Ins$0=caml_new_string("Ins"),
     cst_Link$0=caml_new_string("Link"),
     cst_MakeList$0=caml_new_string("MakeList"),
     cst_MakeMap$0=caml_new_string("MakeMap"),
     cst_MakeText$0=caml_new_string("MakeText"),
     cst_Set$0=caml_new_string("Set"),
     cst_ins$0=caml_new_string("ins"),
     cst_link$0=caml_new_string("link"),
     cst_makeList$0=caml_new_string("makeList"),
     cst_makeMap$0=caml_new_string("makeMap"),
     cst_makeText$0=caml_new_string("makeText"),
     cst_set$0=caml_new_string("set"),
     cst_Op_set_Inconsistent_reuse_of_sequence=
      caml_new_string("Op_set.Inconsistent_reuse_of_sequence"),
     cst_Op_set_Not_supported=caml_new_string("Op_set.Not_supported"),
     cst_Op_set_Modification_of_unknown_object=
      caml_new_string("Op_set.Modification_of_unknown_object"),
     cst_Op_set_Duplicate_list_element_id=
      caml_new_string("Op_set.Duplicate_list_element_id"),
     cst_Op_set_Unknown_object_type=
      caml_new_string("Op_set.Unknown_object_type"),
     cst_Op_set_Unknown_action_type=
      caml_new_string("Op_set.Unknown_action_type"),
     cst_Op_set_Missing_index_for_list_element=
      caml_new_string("Op_set.Missing_index_for_list_element"),
     cst_Op_set_Accessing_unefined_element_index=
      caml_new_string("Op_set.Accessing_unefined_element_index"),
     root_id=caml_new_string("00000000-0000-0000-0000-000000000000"),
     tp_loc=caml_new_string("op_set.ml.OpSetBackend.action"),
     String=global_data.String,
     CCOpt=global_data.CCOpt,
     CCList=global_data.CCList,
     CCFQueue=global_data.CCFQueue,
     Datastructures=global_data.Datastructures,
     Invalid_argument=global_data.Invalid_argument,
     Sexplib_Conv=global_data.Sexplib__Conv,
     Sexplib0_Sexp_conv=global_data.Sexplib0__Sexp_conv,
     Str=global_data.Str,
     Pervasives=global_data.Pervasives,
     List=global_data.List,
     Not_found=global_data.Not_found,
     Sexplib0_Sexp_conv_error=global_data.Sexplib0__Sexp_conv_error,
     Sexplib_Sexp=global_data.Sexplib__Sexp,
     Format=global_data.Format,
     CCSet=global_data.CCSet,
     _w_=[0,caml_new_string("Value")],
     _x_=[0,caml_new_string("obj")],
     _y_=[0,caml_new_string("Link")],
     _bd_=[0,[0,1,0]],
     _bc_=[0,caml_new_string("_head")],
     _be_=[0,caml_new_string("diffs")],
     _bf_=[0,caml_new_string("deps")],
     _bg_=[0,caml_new_string("clock")],
     _bh_=[0,caml_new_string("can_redo")],
     _bi_=[0,caml_new_string("can_undo")],
     _bb_=[0,caml_new_string("next")],
     _a$_=[0,caml_new_string("value")],
     _ba_=[0,caml_new_string("done_")],
     _a6_=[0,caml_new_string("KeyValue")],
     _a7_=[0,caml_new_string("ValueValue")],
     _a8_=[0,caml_new_string("EntryValue")],
     _a9_=[0,caml_new_string("ElemValue")],
     _a__=[0,caml_new_string("ConflictValue")],
     _a1_=[0,caml_new_string("Keys")],
     _a2_=[0,caml_new_string("Values")],
     _a3_=[0,caml_new_string("Entries")],
     _a4_=[0,caml_new_string("Elems")],
     _a5_=[0,caml_new_string("Conflicts")],
     _a0_=[0,1],
     _aZ_=[0,1],
     _aY_=[0,0],
     _aX_=[0,0,0],
     _aW_=[0,0],
     _aV_=[0,0],
     _aU_=[0,0],
     _aS_=[0,0],
     _aT_=[0,0],
     _aI_=[0,caml_new_string("undo_local")],
     _aJ_=[0,caml_new_string("queue")],
     _aK_=[0,caml_new_string("redo_stack")],
     _aL_=[0,caml_new_string("undo_stack")],
     _aM_=[0,caml_new_string("undo_pos")],
     _aN_=[0,caml_new_string("deps")],
     _aO_=[0,caml_new_string("clock")],
     _aP_=[0,caml_new_string("by_object")],
     _aQ_=[0,caml_new_string("history")],
     _aR_=[0,caml_new_string("states")],
     _az_=[0,caml_new_string("conflicts")],
     _aA_=[0,caml_new_string("elem_id")],
     _aB_=[0,caml_new_string("index")],
     _aC_=[0,caml_new_string("link")],
     _aD_=[0,caml_new_string("value")],
     _aE_=[0,caml_new_string("key")],
     _aF_=[0,caml_new_string("action")],
     _aG_=[0,caml_new_string("type_")],
     _aH_=[0,caml_new_string("obj")],
     _aw_=[0,caml_new_string("DiffCreate")],
     _ax_=[0,caml_new_string("DiffSet")],
     _ay_=[0,caml_new_string("DiffInsert")],
     _at_=[0,caml_new_string("DiffMap")],
     _au_=[0,caml_new_string("DiffList")],
     _av_=[0,caml_new_string("DiffText")],
     _an_=[0,caml_new_string("_insertion")],
     _ao_=[0,caml_new_string("_elem_ids")],
     _ap_=[0,caml_new_string("_inbound")],
     _aq_=[0,caml_new_string("_init")],
     _ar_=[0,caml_new_string("_following")],
     _as_=[0,caml_new_string("_max_elem")],
     _ab_=[0,caml_new_string("StrPath")],
     _ac_=[0,caml_new_string("IntPath")],
     _ad_=[0,caml_new_string("path")],
     _ae_=[0,caml_new_string("conflicts")],
     _af_=[0,caml_new_string("index")],
     _ag_=[0,caml_new_string("link")],
     _ah_=[0,caml_new_string("obj")],
     _ai_=[0,caml_new_string("value")],
     _aj_=[0,caml_new_string("key")],
     _ak_=[0,caml_new_string("elem_id__key")],
     _al_=[0,caml_new_string("action")],
     _am_=[0,caml_new_string("_type")],
     ___=[0,caml_new_string("link")],
     _$_=[0,caml_new_string("value")],
     _aa_=[0,caml_new_string("actor")],
     _X_=[0,caml_new_string("Map")],
     _Y_=[0,caml_new_string("Text")],
     _Z_=[0,caml_new_string("List")],
     _T_=[0,caml_new_string("Create")],
     _U_=[0,caml_new_string("Insert")],
     _V_=[0,caml_new_string("Remove")],
     _W_=[0,caml_new_string("Set")],
     _R_=[0,caml_new_string("allDeps")],
     _S_=[0,caml_new_string("change")],
     _N_=[0,caml_new_string("ops")],
     _O_=[0,caml_new_string("deps")],
     _P_=[0,caml_new_string("seq")],
     _Q_=[0,caml_new_string("actor")],
     _L_=[0,caml_new_string("elem")],
     _M_=[0,caml_new_string("actor")],
     _G_=[0,caml_new_string("value")],
     _H_=[0,caml_new_string("elem")],
     _I_=[0,caml_new_string("obj")],
     _J_=[0,caml_new_string("action")],
     _K_=[0,caml_new_string("key")],
     _z_=[0,caml_new_string("value")],
     _A_=[0,caml_new_string("elem")],
     _B_=[0,caml_new_string("obj")],
     _C_=[0,caml_new_string("seq")],
     _D_=[0,caml_new_string("actor")],
     _E_=[0,caml_new_string("action")],
     _F_=[0,caml_new_string("key")],
     _t_=[0,caml_new_string("TypedValue")],
     _u_=[0,caml_new_string("obj_id")],
     _v_=[0,caml_new_string("LinkValue")],
     _q_=[0,caml_new_string("BoolValue")],
     _r_=[0,caml_new_string("StrValue")],
     _s_=[0,caml_new_string("NumberValue")],
     _j_=[0,caml_new_string("MakeMap")],
     _k_=[0,caml_new_string("MakeList")],
     _l_=[0,caml_new_string("MakeText")],
     _m_=[0,caml_new_string("Ins")],
     _n_=[0,caml_new_string("Set")],
     _o_=[0,caml_new_string("Del")],
     _p_=[0,caml_new_string("Link")],
     _a_=
      [0,
       [11,caml_new_string("DEBUG: "),[2,0,[12,32,[15,[12,10,[10,0]]]]]],
       caml_new_string("DEBUG: %s %a\n%!")],
     Inconsistent_reuse_of_sequence=
      [248,cst_Op_set_Inconsistent_reuse_of_sequence,caml_fresh_oo_id(0)],
     Not_supported=[248,cst_Op_set_Not_supported,caml_fresh_oo_id(0)],
     Modification_of_unknown_object=
      [248,cst_Op_set_Modification_of_unknown_object,caml_fresh_oo_id(0)],
     Duplicate_list_element_id=
      [248,cst_Op_set_Duplicate_list_element_id,caml_fresh_oo_id(0)],
     Unknown_object_type=
      [248,cst_Op_set_Unknown_object_type,caml_fresh_oo_id(0)],
     Unknown_action_type=
      [248,cst_Op_set_Unknown_action_type,caml_fresh_oo_id(0)],
     Missing_index_for_list_element=
      [248,cst_Op_set_Missing_index_for_list_element,caml_fresh_oo_id(0)],
     Accessing_unefined_element_index=
      [248,cst_Op_set_Accessing_unefined_element_index,caml_fresh_oo_id(0)];
    function log(msg,conv,sexp)
     { /*<<op_set.ml 20 59>>*/  /*<<op_set.ml 20 59>>*/ var
       _mg_=
         /*<<op_set.ml 20 59>>*/ caml_call1(conv,sexp);
       /*<<op_set.ml 20 59>>*/ return  /*<<op_set.ml 20 59>>*/ caml_call4
              (Format[113],_a_,msg,Sexplib_Sexp[37],_mg_) /*<<op_set.ml 20 70>>*/ }
    var
     _b_=Datastructures[1],
     ActorMap=caml_call1(Datastructures[3],[0,_b_[24],_b_[99]]),
     _c_=Datastructures[2],
     SeqMap=caml_call1(Datastructures[3],[0,_c_[1],_c_[44]]),
     _d_=Datastructures[1],
     ObjectIdMap=caml_call1(Datastructures[3],[0,_d_[24],_d_[99]]),
     ObjectIdSet=caml_call1(CCSet[1],[0,Datastructures[1][24]]),
     _e_=Datastructures[1],
     ElemIdMap=caml_call1(Datastructures[3],[0,_e_[24],_e_[99]]),
     _f_=Datastructures[1],
     KeyMap=caml_call1(Datastructures[3],[0,_f_[24],_f_[99]]),
     KeySet=caml_call1(CCSet[1],[0,Datastructures[1][24]]),
     _g_=Datastructures[1],
     OpMap=caml_call1(Datastructures[3],[0,_g_[24],_g_[99]]),
     _h_=Datastructures[1],
     DiffMap=caml_call1(Datastructures[3],[0,_h_[24],_h_[99]]),
     _i_=Datastructures[1],
     ChildMap=caml_call1(Datastructures[3],[0,_i_[24],_i_[99]]),
     sexp_of_actor=Sexplib_Conv[7],
     sexp_of_seq=Sexplib_Conv[10],
     sexp_of_obj_id=Sexplib_Conv[7],
     sexp_of_key=Sexplib_Conv[7];
    function action_of_sexp(sexp)
     { /*<<op_set.ml 45 2>>*/ if(0 === sexp[0])
       {var
         _ma_=sexp[1],
         _mb_=caml_string_compare(_ma_,cst_del),
         switch$0=
          0 <= _mb_
           ?0 < _mb_
             ?caml_string_notequal(_ma_,cst_ins)
               ?caml_string_notequal(_ma_,cst_link)
                 ?caml_string_notequal(_ma_,cst_makeList)
                   ?caml_string_notequal(_ma_,cst_makeMap)
                     ?caml_string_notequal(_ma_,cst_makeText)
                       ?caml_string_notequal(_ma_,cst_set)?7:4
                       :2
                     :0
                   :1
                 :6
               :3
             :5
           :caml_string_notequal(_ma_,cst_Del)
             ?caml_string_notequal(_ma_,cst_Ins)
               ?caml_string_notequal(_ma_,cst_Link)
                 ?caml_string_notequal(_ma_,cst_MakeList)
                   ?caml_string_notequal(_ma_,cst_MakeMap)
                     ?caml_string_notequal(_ma_,cst_MakeText)
                       ?caml_string_notequal(_ma_,cst_Set)?7:4
                       :2
                     :0
                   :1
                 :6
               :3
             :5;
         /*<<op_set.ml 54 2>>*/ switch(switch$0)
         {case 0: /*<<op_set.ml 45 2>>*/ return 0;
          case 1: /*<<op_set.ml 45 2>>*/ return 1;
          case 2: /*<<op_set.ml 45 2>>*/ return 2;
          case 3: /*<<op_set.ml 45 2>>*/ return 3;
          case 4: /*<<op_set.ml 45 2>>*/ return 4;
          case 5: /*<<op_set.ml 45 2>>*/ return 5;
          case 6: /*<<op_set.ml 45 2>>*/ return 6
          }}
      else
       {var _mc_=sexp[1];
        if(! _mc_)
         return  /*<<op_set.ml 45 2>>*/ caml_call2
                 (Sexplib0_Sexp_conv_error[7],tp_loc,sexp);
        var _md_=_mc_[1];
        if(0 !== _md_[0])
         return  /*<<op_set.ml 45 2>>*/ caml_call2
                 (Sexplib0_Sexp_conv_error[6],tp_loc,sexp);
        var
         _me_=_md_[1],
         _mf_=caml_string_compare(_me_,cst_del$0),
         switch$1=
          0 <= _mf_
           ?0 < _mf_
             ?caml_string_notequal(_me_,cst_ins$0)
               ?caml_string_notequal(_me_,cst_link$0)
                 ?caml_string_notequal(_me_,cst_makeList$0)
                   ?caml_string_notequal(_me_,cst_makeMap$0)
                     ?caml_string_notequal(_me_,cst_makeText$0)
                       ?caml_string_notequal(_me_,cst_set$0)?7:4
                       :2
                     :0
                   :1
                 :6
               :3
             :5
           :caml_string_notequal(_me_,cst_Del$0)
             ?caml_string_notequal(_me_,cst_Ins$0)
               ?caml_string_notequal(_me_,cst_Link$0)
                 ?caml_string_notequal(_me_,cst_MakeList$0)
                   ?caml_string_notequal(_me_,cst_MakeMap$0)
                     ?caml_string_notequal(_me_,cst_MakeText$0)
                       ?caml_string_notequal(_me_,cst_Set$0)?7:4
                       :2
                     :0
                   :1
                 :6
               :3
             :5;
        switch(switch$1)
         {case 0:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 1:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 2:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 3:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 4:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 5:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp);
          case 6:
            /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
                   (Sexplib0_Sexp_conv_error[3],tp_loc,sexp)
          }}
       /*<<op_set.ml 45 2>>*/ return  /*<<op_set.ml 45 2>>*/ caml_call2
              (Sexplib0_Sexp_conv_error[8],tp_loc,sexp) /*<<op_set.ml 46 19>>*/ }
    function sexp_of_action(param)
     { /*<<op_set.ml 45 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 45 16>>*/ return _j_;
        case 1: /*<<op_set.ml 45 24>>*/ return _k_;
        case 2: /*<<op_set.ml 45 35>>*/ return _l_;
        case 3: /*<<op_set.ml 45 46>>*/ return _m_;
        case 4: /*<<op_set.ml 45 52>>*/ return _n_;
        case 5: /*<<op_set.ml 45 58>>*/ return _o_;
        default: /*<<op_set.ml 45 64>>*/ return _p_} /*<<op_set.ml 46 19>>*/ }
    function sexp_of_op_val(param)
     { /*<<op_set.ml 48 2>>*/ switch(param[0])
       {case 0:
          /*<<op_set.ml 48 16>>*/ var
           /*<<op_set.ml 48 16>>*/ v0=param[1],
           /*<<op_set.ml 48 16>>*/ _l9_=Sexplib_Conv[6],
           /*<<op_set.ml 48 16>>*/ v0$0=
            /*<<op_set.ml 48 16>>*/ caml_call1(_l9_,v0);
          /*<<op_set.ml 48 16>>*/ return [1,[0,_q_,[0,v0$0,0]]];
        case 1:
          /*<<op_set.ml 48 34>>*/ var
           /*<<op_set.ml 48 34>>*/ v0$1=param[1],
           /*<<op_set.ml 48 34>>*/ _l__=Sexplib_Conv[7],
           /*<<op_set.ml 48 34>>*/ v0$2=
            /*<<op_set.ml 48 34>>*/ caml_call1(_l__,v0$1);
          /*<<op_set.ml 48 34>>*/ return [1,[0,_r_,[0,v0$2,0]]];
        default:
          /*<<op_set.ml 48 55>>*/ var
           /*<<op_set.ml 48 55>>*/ v0$3=param[1],
           /*<<op_set.ml 48 55>>*/ _l$_=Sexplib_Conv[11],
           /*<<op_set.ml 48 55>>*/ v0$4=
            /*<<op_set.ml 48 55>>*/ caml_call1(_l$_,v0$3);
          /*<<op_set.ml 48 55>>*/ return [1,[0,_s_,[0,v0$4,0]]]} /*<<op_set.ml 49 22>>*/ }
    function sexp_of_materialized(param)
     { /*<<op_set.ml 51 2>>*/ if(0 === param[0])
       { /*<<op_set.ml 51 22>>*/ var
          /*<<op_set.ml 51 22>>*/ v0=param[1],
          /*<<op_set.ml 51 22>>*/ v0$0=
           /*<<op_set.ml 51 22>>*/ sexp_of_op_val(v0);
         /*<<op_set.ml 51 22>>*/ return [1,[0,_t_,[0,v0$0,0]]]}
       /*<<op_set.ml 51 43>>*/ var
        /*<<op_set.ml 51 43>>*/ v_obj_id=param[1],
        /*<<op_set.ml 51 43>>*/ bnds=0,
        /*<<op_set.ml 51 43>>*/ _l8_=Sexplib_Conv[7],
        /*<<op_set.ml 51 59>>*/ arg=
         /*<<op_set.ml 51 59>>*/ caml_call1(_l8_,v_obj_id),
        /*<<op_set.ml 51 59>>*/ bnds$0=[0,[1,[0,_u_,[0,arg,0]]],bnds];
       /*<<op_set.ml 51 59>>*/ return [1,[0,_v_,bnds$0]] /*<<op_set.ml 52 22>>*/ }
    function sexp_of_value(param)
     { /*<<op_set.ml 54 2>>*/ if(0 === param[0])
       { /*<<op_set.ml 54 15>>*/ var
          /*<<op_set.ml 54 15>>*/ v0=param[1],
          /*<<op_set.ml 54 15>>*/ v0$0=
           /*<<op_set.ml 54 15>>*/ sexp_of_op_val(v0);
         /*<<op_set.ml 54 15>>*/ return [1,[0,_w_,[0,v0$0,0]]]}
       /*<<op_set.ml 54 31>>*/ var
        /*<<op_set.ml 54 31>>*/ v_obj=param[1],
        /*<<op_set.ml 54 31>>*/ bnds=0,
        /*<<op_set.ml 54 42>>*/ arg=
         /*<<op_set.ml 54 42>>*/ sexp_of_value(v_obj),
        /*<<op_set.ml 54 42>>*/ bnds$0=[0,[1,[0,_x_,[0,arg,0]]],bnds];
       /*<<op_set.ml 54 42>>*/ return [1,[0,_y_,bnds$0]] /*<<op_set.ml 54 74>>*/ }
    function sexp_of_elem_id(param)
     { /*<<op_set.ml 56 2>>*/ var
        /*<<op_set.ml 56 2>>*/ v1=param[2],
        /*<<op_set.ml 56 2>>*/ v0=param[1],
        /*<<op_set.ml 56 17>>*/ v0$0=
         /*<<op_set.ml 56 17>>*/ caml_call1(sexp_of_key,v0),
        /*<<op_set.ml 56 17>>*/ _l7_=Sexplib_Conv[17],
        /*<<op_set.ml 56 29>>*/ v1$0=
         /*<<op_set.ml 56 29>>*/ caml_call2(_l7_,sexp_of_value,v1);
       /*<<op_set.ml 56 29>>*/ return [1,[0,v0$0,[0,v1$0,0]]] /*<<op_set.ml 56 56>>*/ }
    var empty=0;
    function insert_index(index,k,v,t)
     { /*<<op_set.ml 64 41>>*/ return  /*<<op_set.ml 64 41>>*/ caml_call3
              (CCList[116],index,[0,k,v],t) /*<<op_set.ml 64 76>>*/ }
    function index_of(k,t)
     { /*<<op_set.ml 67 6>>*/ function _l5_(param)
       { /*<<op_set.ml 67 28>>*/  /*<<op_set.ml 67 28>>*/ var itmk=param[1];
         /*<<op_set.ml 67 28>>*/ return  /*<<op_set.ml 67 28>>*/ caml_call2
                (String[34],itmk,k) /*<<op_set.ml 67 66>>*/ }
       /*<<op_set.ml 67 6>>*/ var
        /*<<op_set.ml 67 6>>*/ _l6_=CCList[93],
        /*<<op_set.ml 67 12>>*/ match=
         /*<<op_set.ml 67 12>>*/ caml_call2(_l6_,_l5_,t);
       /*<<op_set.ml 67 12>>*/ if(match)
       {var match$0=match[1],idx=match$0[1];return [0,idx]}
       /*<<op_set.ml 69 16>>*/ return 0 /*<<op_set.ml 69 20>>*/ }
    function key_of(idx,t)
     { /*<<op_set.ml 72 6>>*/ var
        /*<<op_set.ml 72 6>>*/ _l4_=CCList[113],
        /*<<op_set.ml 72 12>>*/ match=
         /*<<op_set.ml 72 12>>*/ caml_call2(_l4_,t,idx);
       /*<<op_set.ml 72 12>>*/ if(match)
       {var match$0=match[1],key=match$0[1];return [0,key]}
       /*<<op_set.ml 74 16>>*/ return 0 /*<<op_set.ml 74 20>>*/ }
    function set_value(k,v,t)
     { /*<<op_set.ml 77 12>>*/  /*<<op_set.ml 77 12>>*/ var
       match=
         /*<<op_set.ml 77 12>>*/ index_of(k,t);
       /*<<op_set.ml 77 12>>*/ if(match)
       { /*<<op_set.ml 78 20>>*/  /*<<op_set.ml 78 20>>*/ var idx=match[1];
         /*<<op_set.ml 78 20>>*/ return  /*<<op_set.ml 78 20>>*/ caml_call3
                (CCList[115],idx,[0,k,v],t)}
       /*<<op_set.ml 79 16>>*/ throw Not_found /*<<op_set.ml 79 31>>*/ }
    function remove_index(index,t)
     { /*<<op_set.ml 81 37>>*/ return  /*<<op_set.ml 81 37>>*/ caml_call2
              (CCList[117],index,t) /*<<op_set.ml 81 65>>*/ }
    var
     SkipList=
      [0,empty,insert_index,index_of,key_of,set_value,remove_index];
    function sexp_of_op(param)
     { /*<<op_set.ml 84 2>>*/ var
        /*<<op_set.ml 84 2>>*/ v_value=param[7],
        /*<<op_set.ml 84 2>>*/ v_elem=param[6],
        /*<<op_set.ml 84 2>>*/ v_obj=param[5],
        /*<<op_set.ml 84 2>>*/ v_seq=param[4],
        /*<<op_set.ml 84 2>>*/ v_actor=param[3],
        /*<<op_set.ml 84 2>>*/ v_action=param[2],
        /*<<op_set.ml 84 2>>*/ v_key=param[1],
        /*<<op_set.ml 84 2>>*/ bnds=0,
        /*<<op_set.ml 84 2>>*/ _l1_=Sexplib_Conv[17],
        /*<<op_set.ml 91 20>>*/ arg=
         /*<<op_set.ml 91 20>>*/ caml_call2(_l1_,sexp_of_op_val,v_value),
        /*<<op_set.ml 91 20>>*/ bnds$0=[0,[1,[0,_z_,[0,arg,0]]],bnds],
        /*<<op_set.ml 91 20>>*/ _l2_=Sexplib_Conv[10],
        /*<<op_set.ml 91 20>>*/ _l3_=Sexplib_Conv[17],
        /*<<op_set.ml 90 16>>*/ arg$0=
         /*<<op_set.ml 90 16>>*/ caml_call2(_l3_,_l2_,v_elem),
        /*<<op_set.ml 90 16>>*/ bnds$1=[0,[1,[0,_A_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 89 6>>*/ arg$1=
         /*<<op_set.ml 89 6>>*/ caml_call1(sexp_of_obj_id,v_obj),
        /*<<op_set.ml 89 6>>*/ bnds$2=[0,[1,[0,_B_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 88 6>>*/ arg$2=
         /*<<op_set.ml 88 6>>*/ caml_call1(sexp_of_seq,v_seq),
        /*<<op_set.ml 88 6>>*/ bnds$3=[0,[1,[0,_C_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 87 6>>*/ arg$3=
         /*<<op_set.ml 87 6>>*/ caml_call1(sexp_of_actor,v_actor),
        /*<<op_set.ml 87 6>>*/ bnds$4=[0,[1,[0,_D_,[0,arg$3,0]]],bnds$3],
        /*<<op_set.ml 86 6>>*/ arg$4=
         /*<<op_set.ml 86 6>>*/ sexp_of_action(v_action),
        /*<<op_set.ml 86 6>>*/ bnds$5=[0,[1,[0,_E_,[0,arg$4,0]]],bnds$4],
        /*<<op_set.ml 85 6>>*/ arg$5=
         /*<<op_set.ml 85 6>>*/ caml_call1(sexp_of_key,v_key),
        /*<<op_set.ml 85 6>>*/ bnds$6=[0,[1,[0,_F_,[0,arg$5,0]]],bnds$5];
       /*<<op_set.ml 85 6>>*/ return [1,bnds$6] /*<<op_set.ml 92 22>>*/ }
    function sexp_of_change_op(param)
     { /*<<op_set.ml 94 2>>*/ var
        /*<<op_set.ml 94 2>>*/ v_value=param[5],
        /*<<op_set.ml 94 2>>*/ v_elem=param[4],
        /*<<op_set.ml 94 2>>*/ v_obj=param[3],
        /*<<op_set.ml 94 2>>*/ v_action=param[2],
        /*<<op_set.ml 94 2>>*/ v_key=param[1],
        /*<<op_set.ml 94 2>>*/ bnds=0,
        /*<<op_set.ml 94 2>>*/ _lX_=Sexplib_Conv[17],
        /*<<op_set.ml 99 20>>*/ arg=
         /*<<op_set.ml 99 20>>*/ caml_call2(_lX_,sexp_of_op_val,v_value),
        /*<<op_set.ml 99 20>>*/ bnds$0=[0,[1,[0,_G_,[0,arg,0]]],bnds],
        /*<<op_set.ml 99 20>>*/ _lY_=Sexplib_Conv[10],
        /*<<op_set.ml 99 20>>*/ _lZ_=Sexplib_Conv[17],
        /*<<op_set.ml 98 16>>*/ arg$0=
         /*<<op_set.ml 98 16>>*/ caml_call2(_lZ_,_lY_,v_elem),
        /*<<op_set.ml 98 16>>*/ bnds$1=[0,[1,[0,_H_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 97 6>>*/ arg$1=
         /*<<op_set.ml 97 6>>*/ caml_call1(sexp_of_obj_id,v_obj),
        /*<<op_set.ml 97 6>>*/ bnds$2=[0,[1,[0,_I_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 96 6>>*/ arg$2=
         /*<<op_set.ml 96 6>>*/ sexp_of_action(v_action),
        /*<<op_set.ml 96 6>>*/ bnds$3=[0,[1,[0,_J_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 96 6>>*/ _l0_=Sexplib_Conv[17],
        /*<<op_set.ml 95 15>>*/ arg$3=
         /*<<op_set.ml 95 15>>*/ caml_call2(_l0_,sexp_of_key,v_key),
        /*<<op_set.ml 95 15>>*/ bnds$4=[0,[1,[0,_K_,[0,arg$3,0]]],bnds$3];
       /*<<op_set.ml 95 15>>*/ return [1,bnds$4] /*<<op_set.ml 100 22>>*/ }
    function sexp_of_lamport_op(param)
     { /*<<op_set.ml 102 2>>*/ var
        /*<<op_set.ml 102 2>>*/ v_elem=param[2],
        /*<<op_set.ml 102 2>>*/ v_actor=param[1],
        /*<<op_set.ml 102 2>>*/ bnds=0,
        /*<<op_set.ml 102 2>>*/ _lW_=Sexplib_Conv[10],
        /*<<op_set.ml 102 35>>*/ arg=
         /*<<op_set.ml 102 35>>*/ caml_call1(_lW_,v_elem),
        /*<<op_set.ml 102 35>>*/ bnds$0=[0,[1,[0,_L_,[0,arg,0]]],bnds],
        /*<<op_set.ml 102 21>>*/ arg$0=
         /*<<op_set.ml 102 21>>*/ caml_call1(sexp_of_actor,v_actor),
        /*<<op_set.ml 102 21>>*/ bnds$1=[0,[1,[0,_M_,[0,arg$0,0]]],bnds$0];
       /*<<op_set.ml 102 21>>*/ return [1,bnds$1] /*<<op_set.ml 102 66>>*/ }
    function lamport_compare(op1,op2)
     { /*<<op_set.ml 105 4>>*/ if(op1[2] < op2[2])return -1;
       /*<<op_set.ml 106 9>>*/ if(op2[2] < op1[2])return 1;
       /*<<op_set.ml 107 9>>*/ var
        /*<<op_set.ml 107 9>>*/ _lS_=op2[1],
        /*<<op_set.ml 107 9>>*/ _lT_=op1[1];
       /*<<op_set.ml 107 12>>*/ if
       ( /*<<op_set.ml 107 12>>*/ runtime.caml_string_lessthan(_lT_,_lS_))
       return -1;
       /*<<op_set.ml 107 9>>*/ var
        /*<<op_set.ml 108 9>>*/ _lU_=op2[1],
        /*<<op_set.ml 108 9>>*/ _lV_=op1[1];
       /*<<op_set.ml 108 12>>*/ return  /*<<op_set.ml 108 12>>*/ runtime.caml_string_greaterthan
               (_lV_,_lU_)
              ?1
              :0 /*<<op_set.ml 109 10>>*/ }
    function get_op_elem(op)
     { /*<<op_set.ml 117 4>>*/  /*<<op_set.ml 117 4>>*/ var _lR_=op[6];
       /*<<op_set.ml 117 4>>*/ if(_lR_)
       { /*<<op_set.ml 118 18>>*/  /*<<op_set.ml 118 18>>*/ var idx=_lR_[1];
         /*<<op_set.ml 118 18>>*/ return idx}
       /*<<op_set.ml 119 14>>*/ throw Accessing_unefined_element_index /*<<op_set.ml 119 52>>*/ }
    function compare(op1,op2)
     { /*<<op_set.ml 127 44>>*/ var
        /*<<op_set.ml 127 44>>*/ _lP_=
         /*<<op_set.ml 127 44>>*/ get_op_elem(op1),
        /*<<op_set.ml 127 44>>*/ lop1=[0,op1[3],_lP_],
        /*<<op_set.ml 128 44>>*/ _lQ_=
         /*<<op_set.ml 128 44>>*/ get_op_elem(op2),
        /*<<op_set.ml 128 44>>*/ lop2=[0,op1[3],_lQ_];
       /*<<op_set.ml 128 44>>*/ return  /*<<op_set.ml 128 44>>*/ lamport_compare
              (lop1,lop2) /*<<op_set.ml 129 33>>*/ }
    var
     include=caml_call1(Datastructures[4],[0,compare,sexp_of_op]),
     empty$0=include[1],
     is_empty=include[2],
     mem=include[3],
     add=include[4],
     singleton=include[5],
     remove=include[6],
     union=include[7],
     inter=include[8],
     diff=include[9],
     compare$0=include[10],
     equal=include[11],
     subset=include[12],
     iter=include[13],
     map=include[14],
     fold=include[15],
     for_all=include[16],
     exists=include[17],
     filter=include[18],
     partition=include[19],
     cardinal=include[20],
     elements=include[21],
     min_elt=include[22],
     max_elt=include[23],
     choose=include[24],
     split=include[25],
     find=include[26],
     min_elt_opt=include[27],
     max_elt_opt=include[28],
     choose_opt=include[29],
     find_opt=include[30],
     find_first=include[31],
     find_first_opt=include[32],
     find_last=include[33],
     find_last_opt=include[34],
     of_seq=include[35],
     add_seq=include[36],
     to_seq=include[37],
     of_list=include[38],
     add_list=include[39],
     to_list=include[40],
     pp=include[41],
     sexp_of_t=include[42],
     OpSet=
      [0,
       empty$0,
       is_empty,
       mem,
       add,
       singleton,
       remove,
       union,
       inter,
       diff,
       compare$0,
       equal,
       subset,
       iter,
       map,
       fold,
       for_all,
       exists,
       filter,
       partition,
       cardinal,
       elements,
       min_elt,
       max_elt,
       choose,
       split,
       find,
       min_elt_opt,
       max_elt_opt,
       choose_opt,
       find_opt,
       find_first,
       find_first_opt,
       find_last,
       find_last_opt,
       of_seq,
       add_seq,
       to_seq,
       of_list,
       add_list,
       to_list,
       pp,
       sexp_of_t];
    function sexp_of_change(param)
     { /*<<op_set.ml 135 2>>*/ var
        /*<<op_set.ml 135 2>>*/ v_ops=param[4],
        /*<<op_set.ml 135 2>>*/ v_deps=param[3],
        /*<<op_set.ml 135 2>>*/ v_seq=param[2],
        /*<<op_set.ml 135 2>>*/ v_actor=param[1],
        /*<<op_set.ml 135 2>>*/ bnds=0,
        /*<<op_set.ml 135 2>>*/ _lN_=Sexplib_Conv[20],
        /*<<op_set.ml 140 21>>*/ arg=
         /*<<op_set.ml 140 21>>*/ caml_call2(_lN_,sexp_of_change_op,v_ops),
        /*<<op_set.ml 140 21>>*/ bnds$0=[0,[1,[0,_N_,[0,arg,0]]],bnds],
        /*<<op_set.ml 140 21>>*/ _lO_=ActorMap[47],
        /*<<op_set.ml 139 16>>*/ arg$0=
         /*<<op_set.ml 139 16>>*/ caml_call2(_lO_,sexp_of_seq,v_deps),
        /*<<op_set.ml 139 16>>*/ bnds$1=[0,[1,[0,_O_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 137 6>>*/ arg$1=
         /*<<op_set.ml 137 6>>*/ caml_call1(sexp_of_seq,v_seq),
        /*<<op_set.ml 137 6>>*/ bnds$2=[0,[1,[0,_P_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 136 6>>*/ arg$2=
         /*<<op_set.ml 136 6>>*/ caml_call1(sexp_of_actor,v_actor),
        /*<<op_set.ml 136 6>>*/ bnds$3=[0,[1,[0,_Q_,[0,arg$2,0]]],bnds$2];
       /*<<op_set.ml 136 6>>*/ return [1,bnds$3] /*<<op_set.ml 141 22>>*/ }
    function sexp_of_state(param)
     { /*<<op_set.ml 143 2>>*/ var
        /*<<op_set.ml 143 2>>*/ v_allDeps=param[2],
        /*<<op_set.ml 143 2>>*/ v_change=param[1],
        /*<<op_set.ml 143 2>>*/ bnds=0,
        /*<<op_set.ml 143 2>>*/ _lM_=ActorMap[47],
        /*<<op_set.ml 143 45>>*/ arg=
         /*<<op_set.ml 143 45>>*/ caml_call2(_lM_,sexp_of_seq,v_allDeps),
        /*<<op_set.ml 143 45>>*/ bnds$0=[0,[1,[0,_R_,[0,arg,0]]],bnds],
        /*<<op_set.ml 143 16>>*/ arg$0=
         /*<<op_set.ml 143 16>>*/ sexp_of_change(v_change),
        /*<<op_set.ml 143 16>>*/ bnds$1=[0,[1,[0,_S_,[0,arg$0,0]]],bnds$0];
       /*<<op_set.ml 143 16>>*/ return [1,bnds$1] /*<<op_set.ml 143 77>>*/ }
    function sexp_of_edit_action(param)
     { /*<<op_set.ml 145 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 145 21>>*/ return _T_;
        case 1: /*<<op_set.ml 145 28>>*/ return _U_;
        case 2: /*<<op_set.ml 145 37>>*/ return _V_;
        default: /*<<op_set.ml 145 46>>*/ return _W_} /*<<op_set.ml 145 72>>*/ }
    function sexp_of_edit_type(param)
     { /*<<op_set.ml 147 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 147 19>>*/ return _X_;
        case 1: /*<<op_set.ml 147 23>>*/ return _Y_;
        default: /*<<op_set.ml 147 30>>*/ return _Z_} /*<<op_set.ml 147 57>>*/ }
    function sexp_of_conflict(param)
     { /*<<op_set.ml 149 2>>*/ var
        /*<<op_set.ml 149 2>>*/ v_link=param[3],
        /*<<op_set.ml 149 2>>*/ v_value=param[2],
        /*<<op_set.ml 149 2>>*/ v_actor=param[1],
        /*<<op_set.ml 149 2>>*/ bnds=0,
        /*<<op_set.ml 149 2>>*/ _lJ_=Sexplib_Conv[6],
        /*<<op_set.ml 149 2>>*/ _lK_=Sexplib_Conv[17],
        /*<<op_set.ml 149 66>>*/ arg=
         /*<<op_set.ml 149 66>>*/ caml_call2(_lK_,_lJ_,v_link),
        /*<<op_set.ml 149 66>>*/ bnds$0=[0,[1,[0,___,[0,arg,0]]],bnds],
        /*<<op_set.ml 149 66>>*/ _lL_=Sexplib_Conv[17],
        /*<<op_set.ml 149 47>>*/ arg$0=
         /*<<op_set.ml 149 47>>*/ caml_call2(_lL_,sexp_of_op_val,v_value),
        /*<<op_set.ml 149 47>>*/ bnds$1=[0,[1,[0,_$_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 149 19>>*/ arg$1=
         /*<<op_set.ml 149 19>>*/ caml_call1(sexp_of_actor,v_actor),
        /*<<op_set.ml 149 19>>*/ bnds$2=[0,[1,[0,_aa_,[0,arg$1,0]]],bnds$1];
       /*<<op_set.ml 149 19>>*/ return [1,bnds$2] /*<<op_set.ml 150 22>>*/ }
    function sexp_of_edit(param)
     { /*<<op_set.ml 152 2>>*/ var
        /*<<op_set.ml 152 2>>*/ v_path=param[10],
        /*<<op_set.ml 152 2>>*/ v_conflicts=param[9],
        /*<<op_set.ml 152 2>>*/ v_index=param[8],
        /*<<op_set.ml 152 2>>*/ v_link=param[7],
        /*<<op_set.ml 152 2>>*/ v_obj=param[6],
        /*<<op_set.ml 152 2>>*/ v_value=param[5],
        /*<<op_set.ml 152 2>>*/ v_key=param[4],
        /*<<op_set.ml 152 2>>*/ v_elem_id_key=param[3],
        /*<<op_set.ml 152 2>>*/ v_action=param[2],
        /*<<op_set.ml 152 2>>*/ v_type=param[1],
        /*<<op_set.ml 152 2>>*/ bnds=0;
       /*<<op_set.ml 152 2>>*/ function _ls_(param)
       { /*<<op_set.ml 162 12>>*/ if(901025494 <= param[1])
         { /*<<op_set.ml 162 12>>*/ var
            /*<<op_set.ml 162 12>>*/ v0=param[2],
            /*<<op_set.ml 162 12>>*/ _lG_=0;
           /*<<op_set.ml 162 12>>*/ return [1,
                  [0,
                   _ab_,
                   [0,
                     /*<<op_set.ml 162 12>>*/ caml_call1(sexp_of_key,v0),
                    _lG_]]]}
         /*<<op_set.ml 162 12>>*/ var
          /*<<op_set.ml 162 12>>*/ v0$0=param[2],
          /*<<op_set.ml 162 12>>*/ _lH_=0,
          /*<<op_set.ml 162 12>>*/ _lI_=Sexplib_Conv[10];
         /*<<op_set.ml 162 12>>*/ return [1,
                [0,
                 _ac_,
                 [0, /*<<op_set.ml 162 12>>*/ caml_call1(_lI_,v0$0),_lH_]]] /*<<op_set.ml 162 52>>*/ }
       /*<<op_set.ml 152 2>>*/ var
        /*<<op_set.ml 152 2>>*/ _lt_=Sexplib_Conv[20],
        /*<<op_set.ml 162 12>>*/ _lu_=
         /*<<op_set.ml 162 12>>*/ caml_call1(_lt_,_ls_),
        /*<<op_set.ml 162 12>>*/ _lv_=Sexplib_Conv[17],
        /*<<op_set.ml 162 53>>*/ arg=
         /*<<op_set.ml 162 53>>*/ caml_call2(_lv_,_lu_,v_path),
        /*<<op_set.ml 162 53>>*/ bnds$0=[0,[1,[0,_ad_,[0,arg,0]]],bnds],
        /*<<op_set.ml 162 53>>*/ _lw_=Sexplib_Conv[20],
        /*<<op_set.ml 161 17>>*/ _lx_=
         /*<<op_set.ml 161 17>>*/ caml_call1(_lw_,sexp_of_conflict),
        /*<<op_set.ml 161 17>>*/ _ly_=Sexplib_Conv[17],
        /*<<op_set.ml 161 31>>*/ arg$0=
         /*<<op_set.ml 161 31>>*/ caml_call2(_ly_,_lx_,v_conflicts),
        /*<<op_set.ml 161 31>>*/ bnds$1=[0,[1,[0,_ae_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 161 31>>*/ _lz_=Sexplib_Conv[10],
        /*<<op_set.ml 161 31>>*/ _lA_=Sexplib_Conv[17],
        /*<<op_set.ml 160 17>>*/ arg$1=
         /*<<op_set.ml 160 17>>*/ caml_call2(_lA_,_lz_,v_index),
        /*<<op_set.ml 160 17>>*/ bnds$2=[0,[1,[0,_af_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 160 17>>*/ _lB_=Sexplib_Conv[6],
        /*<<op_set.ml 159 6>>*/ arg$2=
         /*<<op_set.ml 159 6>>*/ caml_call1(_lB_,v_link),
        /*<<op_set.ml 159 6>>*/ bnds$3=[0,[1,[0,_ag_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 158 6>>*/ arg$3=
         /*<<op_set.ml 158 6>>*/ caml_call1(sexp_of_obj_id,v_obj),
        /*<<op_set.ml 158 6>>*/ bnds$4=[0,[1,[0,_ah_,[0,arg$3,0]]],bnds$3],
        /*<<op_set.ml 158 6>>*/ _lC_=Sexplib_Conv[17],
        /*<<op_set.ml 157 19>>*/ arg$4=
         /*<<op_set.ml 157 19>>*/ caml_call2(_lC_,sexp_of_value,v_value),
        /*<<op_set.ml 157 19>>*/ bnds$5=[0,[1,[0,_ai_,[0,arg$4,0]]],bnds$4],
        /*<<op_set.ml 157 19>>*/ _lD_=Sexplib_Conv[7],
        /*<<op_set.ml 157 19>>*/ _lE_=Sexplib_Conv[17],
        /*<<op_set.ml 156 18>>*/ arg$5=
         /*<<op_set.ml 156 18>>*/ caml_call2(_lE_,_lD_,v_key),
        /*<<op_set.ml 156 18>>*/ bnds$6=[0,[1,[0,_aj_,[0,arg$5,0]]],bnds$5],
        /*<<op_set.ml 156 18>>*/ _lF_=Sexplib_Conv[17],
        /*<<op_set.ml 155 24>>*/ arg$6=
         /*<<op_set.ml 155 24>>*/ caml_call2(_lF_,sexp_of_key,v_elem_id_key),
        /*<<op_set.ml 155 24>>*/ bnds$7=[0,[1,[0,_ak_,[0,arg$6,0]]],bnds$6],
        /*<<op_set.ml 154 6>>*/ arg$7=
         /*<<op_set.ml 154 6>>*/ sexp_of_edit_action(v_action),
        /*<<op_set.ml 154 6>>*/ bnds$8=[0,[1,[0,_al_,[0,arg$7,0]]],bnds$7],
        /*<<op_set.ml 153 6>>*/ arg$8=
         /*<<op_set.ml 153 6>>*/ sexp_of_edit_type(v_type),
        /*<<op_set.ml 153 6>>*/ bnds$9=[0,[1,[0,_am_,[0,arg$8,0]]],bnds$8];
       /*<<op_set.ml 153 6>>*/ return [1,bnds$9] /*<<op_set.ml 163 22>>*/ }
    function sexp_of_obj_aux(param)
     { /*<<op_set.ml 167 2>>*/ var
        /*<<op_set.ml 167 2>>*/ v_insertion=param[6],
        /*<<op_set.ml 167 2>>*/ v_elem_ids=param[5],
        /*<<op_set.ml 167 2>>*/ v_inbound=param[4],
        /*<<op_set.ml 167 2>>*/ v_init=param[3],
        /*<<op_set.ml 167 2>>*/ v_following=param[2],
        /*<<op_set.ml 167 2>>*/ v_max_elem=param[1],
        /*<<op_set.ml 167 2>>*/ bnds=0,
        /*<<op_set.ml 167 2>>*/ _ll_=ElemIdMap[47],
        /*<<op_set.ml 173 21>>*/ arg=
         /*<<op_set.ml 173 21>>*/ caml_call2(_ll_,sexp_of_op,v_insertion),
        /*<<op_set.ml 173 21>>*/ bnds$0=[0,[1,[0,_an_,[0,arg,0]]],bnds],
        /*<<op_set.ml 173 21>>*/ _lm_=Sexplib0_Sexp_conv[23],
        /*<<op_set.ml 172 6>>*/ arg$0=
         /*<<op_set.ml 172 6>>*/ caml_call1(_lm_,v_elem_ids),
        /*<<op_set.ml 172 6>>*/ bnds$1=[0,[1,[0,_ao_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 172 6>>*/ _ln_=OpSet[42],
        /*<<op_set.ml 171 6>>*/ arg$1=
         /*<<op_set.ml 171 6>>*/ caml_call1(_ln_,v_inbound),
        /*<<op_set.ml 171 6>>*/ bnds$2=[0,[1,[0,_ap_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 170 6>>*/ arg$2=
         /*<<op_set.ml 170 6>>*/ sexp_of_op(v_init),
        /*<<op_set.ml 170 6>>*/ bnds$3=[0,[1,[0,_aq_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 170 6>>*/ _lo_=Sexplib_Conv[20],
        /*<<op_set.ml 169 18>>*/ _lp_=
         /*<<op_set.ml 169 18>>*/ caml_call1(_lo_,sexp_of_op),
        /*<<op_set.ml 169 18>>*/ _lq_=KeyMap[47],
        /*<<op_set.ml 169 26>>*/ arg$3=
         /*<<op_set.ml 169 26>>*/ caml_call2(_lq_,_lp_,v_following),
        /*<<op_set.ml 169 26>>*/ bnds$4=[0,[1,[0,_ar_,[0,arg$3,0]]],bnds$3],
        /*<<op_set.ml 169 26>>*/ _lr_=Sexplib_Conv[10],
        /*<<op_set.ml 168 6>>*/ arg$4=
         /*<<op_set.ml 168 6>>*/ caml_call1(_lr_,v_max_elem),
        /*<<op_set.ml 168 6>>*/ bnds$5=[0,[1,[0,_as_,[0,arg$4,0]]],bnds$4];
       /*<<op_set.ml 168 6>>*/ return [1,bnds$5] /*<<op_set.ml 174 22>>*/ }
    function sexp_of_obj(param)
     { /*<<op_set.ml 176 2>>*/ var
        /*<<op_set.ml 176 2>>*/ v1=param[2],
        /*<<op_set.ml 176 2>>*/ v0=param[1],
        /*<<op_set.ml 176 2>>*/ _li_=Sexplib_Conv[20],
        /*<<op_set.ml 176 13>>*/ _lj_=
         /*<<op_set.ml 176 13>>*/ caml_call1(_li_,sexp_of_op),
        /*<<op_set.ml 176 13>>*/ _lk_=KeyMap[47],
        /*<<op_set.ml 176 21>>*/ v0$0=
         /*<<op_set.ml 176 21>>*/ caml_call2(_lk_,_lj_,v0),
        /*<<op_set.ml 176 13>>*/ v1$0=
         /*<<op_set.ml 176 13>>*/ sexp_of_obj_aux(v1);
       /*<<op_set.ml 176 13>>*/ return [1,[0,v0$0,[0,v1$0,0]]] /*<<op_set.ml 176 60>>*/ }
    function sexp_of_diff_type(param)
     { /*<<op_set.ml 178 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 178 19>>*/ return _at_;
        case 1: /*<<op_set.ml 178 27>>*/ return _au_;
        default: /*<<op_set.ml 178 38>>*/ return _av_} /*<<op_set.ml 178 69>>*/ }
    function sexp_of_diff_action(param)
     { /*<<op_set.ml 180 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 180 21>>*/ return _aw_;
        case 1: /*<<op_set.ml 180 32>>*/ return _ax_;
        default: /*<<op_set.ml 180 42>>*/ return _ay_} /*<<op_set.ml 180 75>>*/ }
    function sexp_of_diff(param)
     { /*<<op_set.ml 182 2>>*/ var
        /*<<op_set.ml 182 2>>*/ v_conflicts=param[9],
        /*<<op_set.ml 182 2>>*/ v_elem_id=param[8],
        /*<<op_set.ml 182 2>>*/ v_index=param[7],
        /*<<op_set.ml 182 2>>*/ v_link=param[6],
        /*<<op_set.ml 182 2>>*/ v_value=param[5],
        /*<<op_set.ml 182 2>>*/ v_key=param[4],
        /*<<op_set.ml 182 2>>*/ v_action=param[3],
        /*<<op_set.ml 182 2>>*/ v_type=param[2],
        /*<<op_set.ml 182 2>>*/ v_obj=param[1],
        /*<<op_set.ml 182 2>>*/ bnds=0,
        /*<<op_set.ml 182 2>>*/ _k8_=Sexplib_Conv[20],
        /*<<op_set.ml 191 17>>*/ _k9_=
         /*<<op_set.ml 191 17>>*/ caml_call1(_k8_,sexp_of_conflict),
        /*<<op_set.ml 191 17>>*/ _k__=Sexplib_Conv[17],
        /*<<op_set.ml 191 31>>*/ arg=
         /*<<op_set.ml 191 31>>*/ caml_call2(_k__,_k9_,v_conflicts),
        /*<<op_set.ml 191 31>>*/ bnds$0=[0,[1,[0,_az_,[0,arg,0]]],bnds],
        /*<<op_set.ml 191 31>>*/ _k$_=Sexplib_Conv[7],
        /*<<op_set.ml 191 31>>*/ _la_=Sexplib_Conv[17],
        /*<<op_set.ml 190 22>>*/ arg$0=
         /*<<op_set.ml 190 22>>*/ caml_call2(_la_,_k$_,v_elem_id),
        /*<<op_set.ml 190 22>>*/ bnds$1=[0,[1,[0,_aA_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 190 22>>*/ _lb_=Sexplib_Conv[10],
        /*<<op_set.ml 190 22>>*/ _lc_=Sexplib_Conv[17],
        /*<<op_set.ml 189 17>>*/ arg$1=
         /*<<op_set.ml 189 17>>*/ caml_call2(_lc_,_lb_,v_index),
        /*<<op_set.ml 189 17>>*/ bnds$2=[0,[1,[0,_aB_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 189 17>>*/ _ld_=Sexplib_Conv[6],
        /*<<op_set.ml 189 17>>*/ _le_=Sexplib_Conv[17],
        /*<<op_set.ml 188 17>>*/ arg$2=
         /*<<op_set.ml 188 17>>*/ caml_call2(_le_,_ld_,v_link),
        /*<<op_set.ml 188 17>>*/ bnds$3=[0,[1,[0,_aC_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 188 17>>*/ _lf_=Sexplib_Conv[17],
        /*<<op_set.ml 187 20>>*/ arg$3=
         /*<<op_set.ml 187 20>>*/ caml_call2(_lf_,sexp_of_op_val,v_value),
        /*<<op_set.ml 187 20>>*/ bnds$4=[0,[1,[0,_aD_,[0,arg$3,0]]],bnds$3],
        /*<<op_set.ml 187 20>>*/ _lg_=Sexplib_Conv[17],
        /*<<op_set.ml 186 15>>*/ arg$4=
         /*<<op_set.ml 186 15>>*/ caml_call2(_lg_,sexp_of_key,v_key),
        /*<<op_set.ml 186 15>>*/ bnds$5=[0,[1,[0,_aE_,[0,arg$4,0]]],bnds$4],
        /*<<op_set.ml 185 6>>*/ arg$5=
         /*<<op_set.ml 185 6>>*/ sexp_of_diff_action(v_action),
        /*<<op_set.ml 185 6>>*/ bnds$6=[0,[1,[0,_aF_,[0,arg$5,0]]],bnds$5],
        /*<<op_set.ml 184 6>>*/ arg$6=
         /*<<op_set.ml 184 6>>*/ sexp_of_diff_type(v_type),
        /*<<op_set.ml 184 6>>*/ bnds$7=[0,[1,[0,_aG_,[0,arg$6,0]]],bnds$6],
        /*<<op_set.ml 184 6>>*/ _lh_=Sexplib_Conv[7],
        /*<<op_set.ml 183 6>>*/ arg$7=
         /*<<op_set.ml 183 6>>*/ caml_call1(_lh_,v_obj),
        /*<<op_set.ml 183 6>>*/ bnds$8=[0,[1,[0,_aH_,[0,arg$7,0]]],bnds$7];
       /*<<op_set.ml 183 6>>*/ return [1,bnds$8] /*<<op_set.ml 192 22>>*/ }
    var sexp_of_child=Sexplib_Conv[7];
    function sexp_of_context(param)
     { /*<<op_set.ml 196 2>>*/ var
        /*<<op_set.ml 196 2>>*/ v1=param[2],
        /*<<op_set.ml 196 2>>*/ v0=param[1],
        /*<<op_set.ml 196 2>>*/ _k2_=Sexplib_Conv[20],
        /*<<op_set.ml 196 17>>*/ _k3_=
         /*<<op_set.ml 196 17>>*/ caml_call1(_k2_,sexp_of_diff),
        /*<<op_set.ml 196 17>>*/ _k4_=DiffMap[47],
        /*<<op_set.ml 196 27>>*/ v0$0=
         /*<<op_set.ml 196 27>>*/ caml_call2(_k4_,_k3_,v0),
        /*<<op_set.ml 196 27>>*/ _k5_=Sexplib_Conv[20],
        /*<<op_set.ml 196 39>>*/ _k6_=
         /*<<op_set.ml 196 39>>*/ caml_call1(_k5_,sexp_of_child),
        /*<<op_set.ml 196 39>>*/ _k7_=ChildMap[47],
        /*<<op_set.ml 196 50>>*/ v1$0=
         /*<<op_set.ml 196 50>>*/ caml_call2(_k7_,_k6_,v1);
       /*<<op_set.ml 196 50>>*/ return [1,[0,v0$0,[0,v1$0,0]]] /*<<op_set.ml 197 22>>*/ }
    function sexp_of_t$0(param)
     { /*<<op_set.ml 199 2>>*/ var
        /*<<op_set.ml 199 2>>*/ v_undo_local=param[10],
        /*<<op_set.ml 199 2>>*/ v_queue=param[9],
        /*<<op_set.ml 199 2>>*/ v_redo_stack=param[8],
        /*<<op_set.ml 199 2>>*/ v_undo_stack=param[7],
        /*<<op_set.ml 199 2>>*/ v_undo_pos=param[6],
        /*<<op_set.ml 199 2>>*/ v_deps=param[5],
        /*<<op_set.ml 199 2>>*/ v_clock=param[4],
        /*<<op_set.ml 199 2>>*/ v_by_object=param[3],
        /*<<op_set.ml 199 2>>*/ v_history=param[2],
        /*<<op_set.ml 199 2>>*/ v_states=param[1],
        /*<<op_set.ml 199 2>>*/ bnds=0,
        /*<<op_set.ml 199 2>>*/ _kQ_=Sexplib0_Sexp_conv[23],
        /*<<op_set.ml 214 6>>*/ arg=
         /*<<op_set.ml 214 6>>*/ caml_call1(_kQ_,v_undo_local),
        /*<<op_set.ml 214 6>>*/ bnds$0=[0,[1,[0,_aI_,[0,arg,0]]],bnds],
        /*<<op_set.ml 214 6>>*/ _kR_=Datastructures[5][43],
        /*<<op_set.ml 213 20>>*/ arg$0=
         /*<<op_set.ml 213 20>>*/ caml_call2(_kR_,sexp_of_change,v_queue),
        /*<<op_set.ml 213 20>>*/ bnds$1=[0,[1,[0,_aJ_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 213 20>>*/ _kS_=Sexplib0_Sexp_conv[23],
        /*<<op_set.ml 212 6>>*/ arg$1=
         /*<<op_set.ml 212 6>>*/ caml_call1(_kS_,v_redo_stack),
        /*<<op_set.ml 212 6>>*/ bnds$2=[0,[1,[0,_aK_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 212 6>>*/ _kT_=Sexplib0_Sexp_conv[23],
        /*<<op_set.ml 211 6>>*/ arg$2=
         /*<<op_set.ml 211 6>>*/ caml_call1(_kT_,v_undo_stack),
        /*<<op_set.ml 211 6>>*/ bnds$3=[0,[1,[0,_aL_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 211 6>>*/ _kU_=Sexplib_Conv[10],
        /*<<op_set.ml 210 6>>*/ arg$3=
         /*<<op_set.ml 210 6>>*/ caml_call1(_kU_,v_undo_pos),
        /*<<op_set.ml 210 6>>*/ bnds$4=[0,[1,[0,_aM_,[0,arg$3,0]]],bnds$3],
        /*<<op_set.ml 210 6>>*/ _kV_=ActorMap[47],
        /*<<op_set.ml 209 16>>*/ arg$4=
         /*<<op_set.ml 209 16>>*/ caml_call2(_kV_,sexp_of_seq,v_deps),
        /*<<op_set.ml 209 16>>*/ bnds$5=[0,[1,[0,_aN_,[0,arg$4,0]]],bnds$4],
        /*<<op_set.ml 209 16>>*/ _kW_=ActorMap[47],
        /*<<op_set.ml 206 12>>*/ arg$5=
         /*<<op_set.ml 206 12>>*/ caml_call2(_kW_,sexp_of_seq,v_clock),
        /*<<op_set.ml 206 12>>*/ bnds$6=[0,[1,[0,_aO_,[0,arg$5,0]]],bnds$5],
        /*<<op_set.ml 206 12>>*/ _kX_=ObjectIdMap[47],
        /*<<op_set.ml 204 21>>*/ arg$6=
         /*<<op_set.ml 204 21>>*/ caml_call2(_kX_,sexp_of_obj,v_by_object),
        /*<<op_set.ml 204 21>>*/ bnds$7=[0,[1,[0,_aP_,[0,arg$6,0]]],bnds$6],
        /*<<op_set.ml 204 21>>*/ _kY_=Sexplib_Conv[20],
        /*<<op_set.ml 203 22>>*/ arg$7=
         /*<<op_set.ml 203 22>>*/ caml_call2(_kY_,sexp_of_change,v_history),
        /*<<op_set.ml 203 22>>*/ bnds$8=[0,[1,[0,_aQ_,[0,arg$7,0]]],bnds$7],
        /*<<op_set.ml 203 22>>*/ _kZ_=Sexplib_Conv[20],
        /*<<op_set.ml 201 8>>*/ _k0_=
         /*<<op_set.ml 201 8>>*/ caml_call1(_kZ_,sexp_of_state),
        /*<<op_set.ml 201 8>>*/ _k1_=ActorMap[47],
        /*<<op_set.ml 201 19>>*/ arg$8=
         /*<<op_set.ml 201 19>>*/ caml_call2(_k1_,_k0_,v_states),
        /*<<op_set.ml 201 19>>*/ bnds$9=[0,[1,[0,_aR_,[0,arg$8,0]]],bnds$8];
       /*<<op_set.ml 201 19>>*/ return [1,bnds$9] /*<<op_set.ml 215 22>>*/ }
    function states(t)
     { /*<<op_set.ml 221 6>>*/ var
        /*<<op_set.ml 221 6>>*/ _kM_=t[1],
        /*<<op_set.ml 221 6>>*/ _kN_=Sexplib_Conv[20],
        /*<<op_set.ml 221 39>>*/ _kO_=
         /*<<op_set.ml 221 39>>*/ caml_call1(_kN_,sexp_of_state),
        /*<<op_set.ml 221 39>>*/ _kP_=ActorMap[47];
       /*<<op_set.ml 221 19>>*/ return  /*<<op_set.ml 221 19>>*/ log
              (cst_states,
                /*<<op_set.ml 221 19>>*/ caml_call1(_kP_,_kO_),
               _kM_) /*<<op_set.ml 221 77>>*/ }
    function seq_actor_map(m)
     { /*<<op_set.ml 223 26>>*/ var
        /*<<op_set.ml 223 26>>*/ _kK_=Sexplib_Conv[10],
        /*<<op_set.ml 223 26>>*/ _kL_=ActorMap[47];
       /*<<op_set.ml 223 42>>*/ return  /*<<op_set.ml 223 42>>*/ log
              (cst_actor_map,
                /*<<op_set.ml 223 42>>*/ caml_call1(_kL_,_kK_),
               m) /*<<op_set.ml 223 76>>*/ }
    var LLog=[0,states,seq_actor_map];
    function get_obj_aux(t,obj_id)
     { /*<<op_set.ml 227 29>>*/ var
        /*<<op_set.ml 227 29>>*/ _kF_=t[3],
        /*<<op_set.ml 227 29>>*/ _kG_=ObjectIdMap[27],
        /*<<op_set.ml 227 43>>*/ _kH_=
         /*<<op_set.ml 227 43>>*/ caml_call2(_kG_,obj_id,_kF_);
       /*<<op_set.ml 227 43>>*/ function _kI_(_kJ_){ /*<<?>>*/ return _kJ_[2]}
       /*<<op_set.ml 227 43>>*/ return  /*<<op_set.ml 227 43>>*/ caml_call2
              (CCOpt[1],_kI_,_kH_) /*<<op_set.ml 227 79>>*/ }
    function get_obj_aux_exn(t,obj_id)
     { /*<<op_set.ml 229 47>>*/  /*<<op_set.ml 229 47>>*/ var
       _kE_=
         /*<<op_set.ml 229 47>>*/ get_obj_aux(t,obj_id);
       /*<<op_set.ml 229 47>>*/ return  /*<<op_set.ml 229 47>>*/ caml_call1
              (CCOpt[20],_kE_) /*<<op_set.ml 229 69>>*/ }
    function get_op_value_as_string_exn(param)
     { /*<<op_set.ml 231 35>>*/ if(1 === param[0])
       { /*<<op_set.ml 232 20>>*/  /*<<op_set.ml 232 20>>*/ var s=param[1];
         /*<<op_set.ml 232 20>>*/ return s}
       /*<<op_set.ml 233 37>>*/ throw [0,Invalid_argument,cst_op_value] /*<<op_set.ml 233 72>>*/ }
    function get_obj_action(t,obj_id)
     { /*<<op_set.ml 235 32>>*/ return  /*<<op_set.ml 235 32>>*/ get_obj_aux_exn
                (t,obj_id)
               [3]
              [2] /*<<op_set.ml 235 71>>*/ }
    function causaly_ready(t,change)
     { /*<<op_set.ml 243 4>>*/  /*<<op_set.ml 243 4>>*/ var _kw_=change[3];
       /*<<op_set.ml 243 4>>*/ function _kx_(param)
       { /*<<op_set.ml 244 36>>*/ if(param)
         { /*<<op_set.ml 245 23>>*/  /*<<op_set.ml 245 23>>*/ var
           seq=
            param[1];
           /*<<op_set.ml 245 23>>*/ return [0,seq - 1 | 0]}
         /*<<op_set.ml 246 19>>*/ return 0 /*<<op_set.ml 246 25>>*/ }
       /*<<op_set.ml 243 4>>*/ var
        /*<<op_set.ml 243 4>>*/ _ky_=change[1],
        /*<<op_set.ml 243 4>>*/ _kz_=ActorMap[29],
        /*<<op_set.ml 243 4>>*/ _kA_=
         /*<<op_set.ml 243 4>>*/ caml_call3(_kz_,_ky_,_kx_,_kw_);
       /*<<op_set.ml 243 4>>*/ function _kB_(depActor,depSeq)
       { /*<<op_set.ml 248 11>>*/ var
          /*<<op_set.ml 248 11>>*/ _kC_=t[4],
          /*<<op_set.ml 248 11>>*/ _kD_=ActorMap[33],
          /*<<op_set.ml 248 17>>*/ match=
           /*<<op_set.ml 248 17>>*/ caml_call2(_kD_,depActor,_kC_);
         /*<<op_set.ml 248 17>>*/ if(match)
         { /*<<op_set.ml 249 30>>*/  /*<<op_set.ml 249 30>>*/ var
           depClock=
            match[1];
           /*<<op_set.ml 249 30>>*/ return depSeq <= depClock?1:0}
         /*<<op_set.ml 250 21>>*/ return 0 <= depSeq?1:0 /*<<op_set.ml 250 32>>*/ }
       /*<<op_set.ml 243 4>>*/ return  /*<<op_set.ml 243 4>>*/ caml_call2
              (ActorMap[12],_kB_,_kA_) /*<<op_set.ml 250 34>>*/ }
    function transitive_deps(t,baseDeps)
     { /*<<op_set.ml 259 4>>*/  /*<<op_set.ml 259 4>>*/ var _kk_=ActorMap[1];
       /*<<op_set.ml 259 4>>*/ function _kl_(depActor,depSeq,deps)
       { /*<<op_set.ml 261 8>>*/ if(0 < depSeq)
         { /*<<op_set.ml 263 10>>*/ var
            /*<<op_set.ml 263 10>>*/ _km_=t[1],
            /*<<op_set.ml 263 10>>*/ _kn_=ActorMap[33],
            /*<<op_set.ml 263 16>>*/ match=
             /*<<op_set.ml 263 16>>*/ caml_call2(_kn_,depActor,_km_);
           /*<<op_set.ml 263 16>>*/ if(match)
           { /*<<op_set.ml 264 27>>*/ var
              /*<<op_set.ml 264 27>>*/ states=match[1],
              /*<<op_set.ml 264 27>>*/ _ko_=depSeq - 1 | 0,
              /*<<op_set.ml 264 27>>*/ _kp_=List[8],
              /*<<op_set.ml 265 18>>*/ match$0=
               /*<<op_set.ml 265 18>>*/ caml_call2(_kp_,states,_ko_);
             /*<<op_set.ml 265 18>>*/ if(match$0)
             { /*<<op_set.ml 267 16>>*/ var
                /*<<op_set.ml 267 16>>*/ state=match$0[1],
                /*<<op_set.ml 267 16>>*/ _kq_=state[2],
                /*<<op_set.ml 267 16>>*/ _kr_=
                function(param,l,match)
                 { /*<<op_set.ml 269 20>>*/ if(l)
                   {var _ku_=l[1];
                    if(match)
                     { /*<<op_set.ml 270 40>>*/ var
                        /*<<op_set.ml 270 40>>*/ r=match[1],
                        /*<<op_set.ml 270 40>>*/ _kv_=Datastructures[2][18];
                       /*<<op_set.ml 270 45>>*/ return [0,
                               /*<<op_set.ml 270 45>>*/ caml_call2(_kv_,_ku_,r)]}
                     /*<<op_set.ml 271 38>>*/ return [0,_ku_]}
                  if(match)
                   { /*<<op_set.ml 272 38>>*/  /*<<op_set.ml 272 38>>*/ var
                     r$0=
                      match[1];
                     /*<<op_set.ml 272 38>>*/ return [0,r$0]}
                   /*<<op_set.ml 273 36>>*/ throw [0,Invalid_argument,cst_key] /*<<op_set.ml 273 66>>*/ },
                /*<<op_set.ml 267 16>>*/ _ks_=ActorMap[7],
                /*<<op_set.ml 267 16>>*/ _kt_=
                 /*<<op_set.ml 267 16>>*/ caml_call3(_ks_,_kr_,deps,_kq_);
               /*<<op_set.ml 267 16>>*/ return  /*<<op_set.ml 267 16>>*/ caml_call3
                      (ActorMap[4],depActor,depSeq,_kt_)}
             /*<<op_set.ml 276 22>>*/ return deps}
           /*<<op_set.ml 277 20>>*/ return deps}
         /*<<op_set.ml 261 28>>*/ return deps /*<<op_set.ml 277 24>>*/ }
       /*<<op_set.ml 259 4>>*/ return  /*<<op_set.ml 259 4>>*/ caml_call3
              (ActorMap[11],_kl_,baseDeps,_kk_) /*<<op_set.ml 278 29>>*/ }
    function apply_make(t,op)
     { /*<<op_set.ml 281 4>>*/ switch(op[2])
       {case 0:
          /*<<op_set.ml 284 10>>*/ var
           /*<<op_set.ml 284 10>>*/ e=[0,0,0,0,0,0,op[5],0,0,0,0],
           /*<<op_set.ml 284 10>>*/ o=
           [0,0,KeyMap[1],op,OpSet[1],0,ElemIdMap[1]],
          match=[0,e,o];
         break;
        case 1:
          /*<<op_set.ml 328 10>>*/ var
           /*<<op_set.ml 328 10>>*/ e$0=[0,2,0,0,0,0,op[5],0,0,0,0],
           /*<<op_set.ml 328 10>>*/ o$0=
           [0,0,KeyMap[1],op,OpSet[1],_aS_,ElemIdMap[1]],
          match=[0,e$0,o$0];
         break;
        case 2:
          /*<<op_set.ml 306 10>>*/ var
           /*<<op_set.ml 306 10>>*/ e$1=[0,1,0,0,0,0,op[5],0,0,0,0],
           /*<<op_set.ml 306 10>>*/ o$1=
           [0,0,KeyMap[1],op,OpSet[1],_aT_,ElemIdMap[1]],
          match=[0,e$1,o$1];
         break;
        default: /*<<op_set.ml 349 13>>*/ throw Not_supported}
       /*<<op_set.ml 352 6>>*/ var
       obj_aux=match[2],
       edit=match[1],
       _kg_=t[3],
       _kh_=[0,KeyMap[1],obj_aux],
       _ki_=op[5],
       _kj_=ObjectIdMap[4],
        /*<<op_set.ml 352 6>>*/ by_object=
         /*<<op_set.ml 352 6>>*/ caml_call3(_kj_,_ki_,_kh_,_kg_);
       /*<<op_set.ml 352 6>>*/ return [0,
              [0,t[1],t[2],by_object,t[4],t[5],t[6],t[7],t[8],t[9],t[10]],
              [0,edit,0]] /*<<op_set.ml 354 32>>*/ }
    function apply_insert(t,op)
     { /*<<op_set.ml 357 51>>*/ var
        /*<<op_set.ml 357 51>>*/ _jR_=
         /*<<op_set.ml 357 51>>*/ get_op_elem(op),
        /*<<op_set.ml 357 51>>*/ _jS_=Datastructures[2][13],
        /*<<op_set.ml 357 35>>*/ _jT_=
         /*<<op_set.ml 357 35>>*/ caml_call1(_jS_,_jR_),
        /*<<op_set.ml 357 35>>*/ _jU_=Pervasives[16],
        /*<<op_set.ml 357 29>>*/ _jV_=
         /*<<op_set.ml 357 29>>*/ caml_call2(_jU_,cst,_jT_),
        /*<<op_set.ml 357 29>>*/ _jW_=op[3],
        /*<<op_set.ml 357 29>>*/ _jX_=Pervasives[16],
        /*<<op_set.ml 357 18>>*/ elem_id=
         /*<<op_set.ml 357 18>>*/ caml_call2(_jX_,_jW_,_jV_),
        /*<<op_set.ml 357 18>>*/ _jY_=t[3],
        /*<<op_set.ml 357 18>>*/ _jZ_=op[5],
        /*<<op_set.ml 357 18>>*/ _j0_=ObjectIdMap[33],
        /*<<op_set.ml 358 12>>*/ match=
         /*<<op_set.ml 358 12>>*/ caml_call2(_j0_,_jZ_,_jY_);
       /*<<op_set.ml 358 12>>*/ if(match)
       {var
         match$0=match[1],
         obj_aux=match$0[2],
         _j1_=obj_aux[6],
         _j2_=ElemIdMap[3];
         /*<<op_set.ml 360 11>>*/ if
         ( /*<<op_set.ml 360 11>>*/ caml_call2(_j2_,elem_id,_j1_))
         throw Duplicate_list_element_id;
         /*<<op_set.ml 364 4>>*/ var
          /*<<op_set.ml 364 4>>*/ _j3_=t[3],
          /*<<op_set.ml 364 4>>*/ _j4_=
          function(param)
           { /*<<op_set.ml 366 8>>*/ if(param)
             { /*<<op_set.ml 369 16>>*/ var
               match=param[1],
               obj_aux=match[2],
               obj=match[1],
               _j7_=obj_aux[2],
               _j8_=
                function(param)
                 { /*<<op_set.ml 370 18>>*/ if(param)
                   { /*<<op_set.ml 371 32>>*/ var
                      /*<<op_set.ml 371 32>>*/ l=param[1],
                      /*<<op_set.ml 371 32>>*/ _ke_=[0,op,0],
                      /*<<op_set.ml 371 32>>*/ _kf_=List[11];
                     /*<<op_set.ml 371 37>>*/ return [0,
                             /*<<op_set.ml 371 37>>*/ caml_call2(_kf_,l,_ke_)]}
                   /*<<op_set.ml 371 68>>*/ return [0,[0,op,0]] /*<<op_set.ml 371 78>>*/ },
               _j9_=op[1],
               _j__=KeyMap[29],
                /*<<op_set.ml 369 16>>*/ following=
                 /*<<op_set.ml 369 16>>*/ caml_call3(_j__,_j9_,_j8_,_j7_),
                /*<<op_set.ml 369 16>>*/ _j$_=obj_aux[1],
                /*<<op_set.ml 374 34>>*/ _ka_=
                 /*<<op_set.ml 374 34>>*/ get_op_elem(op),
                /*<<op_set.ml 374 34>>*/ _kb_=Pervasives[5],
                /*<<op_set.ml 374 30>>*/ max_elem=
                 /*<<op_set.ml 374 30>>*/ caml_call2(_kb_,_ka_,_j$_),
                /*<<op_set.ml 374 30>>*/ _kc_=obj_aux[6],
                /*<<op_set.ml 374 30>>*/ _kd_=ElemIdMap[4],
                /*<<op_set.ml 375 31>>*/ insertion=
                 /*<<op_set.ml 375 31>>*/ caml_call3(_kd_,elem_id,op,_kc_);
               /*<<op_set.ml 375 31>>*/ return [0,
                      [0,
                       obj,
                       [0,
                        max_elem,
                        following,
                        obj_aux[3],
                        obj_aux[4],
                        obj_aux[5],
                        insertion]]]}
             /*<<op_set.ml 377 20>>*/ return 0 /*<<op_set.ml 377 25>>*/ },
          /*<<op_set.ml 364 4>>*/ _j5_=op[5],
          /*<<op_set.ml 364 4>>*/ _j6_=ObjectIdMap[29],
          /*<<op_set.ml 365 6>>*/ by_object=
           /*<<op_set.ml 365 6>>*/ caml_call3(_j6_,_j5_,_j4_,_j3_),
          /*<<op_set.ml 365 6>>*/ t$0=
          [0,t[1],t[2],by_object,t[4],t[5],t[6],t[7],t[8],t[9],t[10]];
         /*<<op_set.ml 365 6>>*/ return [0,t$0,0]}
       /*<<op_set.ml 363 14>>*/ throw Modification_of_unknown_object /*<<op_set.ml 381 11>>*/ }
    function get_conflicts(ops)
     { /*<<op_set.ml 384 4>>*/ if(ops)
       { /*<<op_set.ml 386 8>>*/ var
          /*<<op_set.ml 386 8>>*/ ops_rest=ops[2],
          /*<<op_set.ml 386 8>>*/ _jP_=
          function(conflicts,op)
           { /*<<op_set.ml 388 12>>*/ var
              /*<<op_set.ml 388 12>>*/ link=6 <= op[2]?1:0,
              /*<<op_set.ml 389 12>>*/ conf=[0,op[3],op[7],[0,link]];
             /*<<op_set.ml 389 12>>*/ function _jQ_(cs)
             { /*<<op_set.ml 392 33>>*/ return  /*<<op_set.ml 392 33>>*/ caml_call2
                      (Pervasives[25],cs,[0,conf,0]) /*<<op_set.ml 392 44>>*/ }
             /*<<op_set.ml 389 12>>*/ return  /*<<op_set.ml 389 12>>*/ caml_call2
                    (CCOpt[1],_jQ_,conflicts) /*<<op_set.ml 392 55>>*/ };
         /*<<op_set.ml 386 8>>*/ return  /*<<op_set.ml 386 8>>*/ caml_call3
                (CCList[10],_jP_,_aU_,ops_rest)}
       /*<<op_set.ml 394 12>>*/ return 0 /*<<op_set.ml 394 16>>*/ }
    function get_path(t,obj_id,path)
     {var obj_id$0=obj_id,path$0=path;
       /*<<op_set.ml 401 4>>*/ for(;;)
       { /*<<op_set.ml 401 4>>*/  /*<<op_set.ml 401 4>>*/ var _jz_=String[34];
         /*<<op_set.ml 401 7>>*/ if
         ( /*<<op_set.ml 401 7>>*/ caml_call2(_jz_,obj_id$0,root_id))
         return path$0;
         /*<<op_set.ml 401 4>>*/ var
          /*<<op_set.ml 403 6>>*/ _jA_=t[3],
          /*<<op_set.ml 403 6>>*/ _jB_=ObjectIdMap[27],
          /*<<op_set.ml 403 12>>*/ match=
           /*<<op_set.ml 403 12>>*/ caml_call2(_jB_,obj_id$0,_jA_);
         /*<<op_set.ml 403 12>>*/ if(match)
         { /*<<op_set.ml 406 14>>*/ var
           match$0=match[1],
           obj_aux=match$0[2],
           _jC_=obj_aux[4],
           _jD_=OpSet[29],
            /*<<op_set.ml 406 14>>*/ match$1=
             /*<<op_set.ml 406 14>>*/ caml_call1(_jD_,_jC_);
           /*<<op_set.ml 406 14>>*/ if(match$1)
           { /*<<op_set.ml 408 22>>*/ var
              /*<<op_set.ml 408 22>>*/ ref=match$1[1],
              /*<<op_set.ml 408 22>>*/ _jE_=t[3],
              /*<<op_set.ml 408 22>>*/ _jF_=ref[5],
              /*<<op_set.ml 408 22>>*/ _jG_=ObjectIdMap[27],
              /*<<op_set.ml 409 16>>*/ match$2=
               /*<<op_set.ml 409 16>>*/ caml_call2(_jG_,_jF_,_jE_);
             /*<<op_set.ml 409 16>>*/ if(match$2)
             {var
               match$3=match$2[1],
               obj_aux$0=match$3[2],
               switcher=obj_aux$0[3][2] - 1 | 0;
              if(1 < switcher >>> 0)
               { /*<<op_set.ml 421 16>>*/ var
                  /*<<op_set.ml 421 16>>*/ _jH_=
                   /*<<op_set.ml 421 16>>*/ function(ref)
                    { /*<<?>>*/ return function(p)
                      { /*<<op_set.ml 422 39>>*/ return [0,[0,901025494,ref[1]],p] /*<<op_set.ml 422 60>>*/ }}
                   (ref),
                  /*<<op_set.ml 421 16>>*/ _jI_=CCOpt[1],
                  /*<<op_set.ml 422 18>>*/ path$1=
                   /*<<op_set.ml 422 18>>*/ caml_call2(_jI_,_jH_,path$0),
                  /*<<op_set.ml 422 18>>*/ obj_id$1=ref[5],
                 obj_id$0=obj_id$1,
                 path$0=path$1;
                continue}
               /*<<op_set.ml 413 37>>*/ var
                /*<<op_set.ml 413 37>>*/ _jJ_=obj_aux$0[5],
                /*<<op_set.ml 413 37>>*/ _jK_=CCOpt[20],
                /*<<op_set.ml 414 31>>*/ elem_ids=
                 /*<<op_set.ml 414 31>>*/ caml_call1(_jK_,_jJ_),
                /*<<op_set.ml 414 31>>*/ _jL_=ref[1],
                /*<<op_set.ml 414 31>>*/ _jM_=SkipList[3],
                /*<<op_set.ml 415 22>>*/ match$4=
                 /*<<op_set.ml 415 22>>*/ caml_call2(_jM_,_jL_,elem_ids);
               /*<<op_set.ml 415 22>>*/ if(match$4)
               { /*<<op_set.ml 419 22>>*/ var
                 index=match$4[1],
                 _jN_=
                  function(index)
                    { /*<<?>>*/ return function(p)
                      { /*<<op_set.ml 419 43>>*/ return [0,[0,-695801324,index],p] /*<<op_set.ml 419 62>>*/ }}
                   (index),
                 _jO_=CCOpt[1],
                  /*<<op_set.ml 419 22>>*/ path$2=
                   /*<<op_set.ml 419 22>>*/ caml_call2(_jO_,_jN_,path$0),
                  /*<<op_set.ml 419 22>>*/ obj_id$2=ref[5],
                 obj_id$0=obj_id$2,
                 path$0=path$2;
                continue}
               /*<<op_set.ml 416 26>>*/ return 0}
             /*<<op_set.ml 410 20>>*/ return 0}
           /*<<op_set.ml 407 18>>*/ return 0}
         /*<<op_set.ml 404 16>>*/ return 0} /*<<op_set.ml 422 73>>*/ }
    function patch_list(t,obj_id,index,elem_id_key,action,ops)
     { /*<<op_set.ml 426 4>>*/ var
        /*<<op_set.ml 426 4>>*/ _i7_=t[3],
        /*<<op_set.ml 426 4>>*/ _i8_=ObjectIdMap[27],
        /*<<op_set.ml 427 23>>*/ _i9_=
         /*<<op_set.ml 427 23>>*/ caml_call2(_i8_,obj_id,_i7_),
        /*<<op_set.ml 427 23>>*/ _i__=CCOpt[20],
        /*<<op_set.ml 427 23>>*/ match=
         /*<<op_set.ml 427 23>>*/ caml_call1(_i__,_i9_),
        /*<<op_set.ml 427 23>>*/ obj_aux=match[2],
        /*<<op_set.ml 427 23>>*/ type=2 === obj_aux[3][2]?1:2;
       /*<<op_set.ml 430 4>>*/ function _i$_(ops)
       { /*<<op_set.ml 430 46>>*/ return  /*<<op_set.ml 430 46>>*/ caml_call2
                (CCList[113],ops,0) /*<<op_set.ml 430 66>>*/ }
       /*<<op_set.ml 430 4>>*/ var
        /*<<op_set.ml 430 4>>*/ _ja_=CCOpt[11],
        /*<<op_set.ml 430 19>>*/ first_op=
         /*<<op_set.ml 430 19>>*/ caml_call2(_ja_,_i$_,ops),
        /*<<op_set.ml 431 33>>*/ _jb_=
         /*<<op_set.ml 431 33>>*/ get_obj_aux_exn(t,obj_id)[5],
        /*<<op_set.ml 431 33>>*/ _jc_=CCOpt[20],
        /*<<op_set.ml 431 19>>*/ elem_ids=
         /*<<op_set.ml 431 19>>*/ caml_call1(_jc_,_jb_);
       /*<<op_set.ml 431 19>>*/ function _jd_(fop)
       { /*<<op_set.ml 432 50>>*/ return fop[7] /*<<op_set.ml 432 59>>*/ }
       /*<<op_set.ml 431 19>>*/ var
        /*<<op_set.ml 431 19>>*/ _je_=CCOpt[11],
        /*<<op_set.ml 432 16>>*/ value=
         /*<<op_set.ml 432 16>>*/ caml_call2(_je_,_jd_,first_op);
       /*<<op_set.ml 432 16>>*/ function _jf_(v)
       { /*<<op_set.ml 433 36>>*/ return [0,v] /*<<op_set.ml 433 43>>*/ }
       /*<<op_set.ml 432 16>>*/ var
        /*<<op_set.ml 432 16>>*/ _jg_=CCOpt[1],
        /*<<op_set.ml 433 16>>*/ value$0=
         /*<<op_set.ml 433 16>>*/ caml_call2(_jg_,_jf_,value),
        /*<<op_set.ml 434 15>>*/ path=
         /*<<op_set.ml 434 15>>*/ get_path(t,obj_id,_aV_),
        /*<<op_set.ml 434 15>>*/ edit=
        [0,type,action,0,0,0,obj_id,0,[0,index],0,path];
       /*<<op_set.ml 434 15>>*/ if(first_op)
       { /*<<op_set.ml 449 22>>*/  /*<<op_set.ml 449 22>>*/ var
         fop=
          first_op[1];
         /*<<op_set.ml 449 22>>*/ if(6 === fop[2])
          /*<<op_set.ml 450 10>>*/ var
           /*<<op_set.ml 450 10>>*/ _jh_=fop[7],
           /*<<op_set.ml 450 10>>*/ _ji_=CCOpt[20],
           /*<<op_set.ml 451 35>>*/ _jj_=
           [0,[1,[0, /*<<op_set.ml 451 35>>*/ caml_call1(_ji_,_jh_)]]],
           /*<<op_set.ml 451 35>>*/ _jk_=
           [0,
            edit[1],
            edit[2],
            edit[3],
            edit[4],
            edit[5],
            edit[6],
            1,
            edit[8],
            edit[9],
            edit[10]],
          edit$0=_jk_,
          value$1=_jj_,
          switch$0=1;
        else
         var switch$0=0}
      else
       var switch$0=0;
       /*<<op_set.ml 54 2>>*/ if(! switch$0)var edit$0=edit,value$1=value$0;
       /*<<op_set.ml 454 4>>*/ switch(action)
       {case 0: /*<<op_set.ml 468 18>>*/ throw Unknown_action_type;
        case 1:
          /*<<op_set.ml 457 10>>*/ var
           /*<<op_set.ml 457 10>>*/ _jl_=CCOpt[20],
           /*<<op_set.ml 458 40>>*/ _jm_=
            /*<<op_set.ml 458 40>>*/ caml_call1(_jl_,first_op)[1],
           /*<<op_set.ml 458 40>>*/ _jn_=SkipList[2],
           /*<<op_set.ml 458 12>>*/ elem_ids$0=
            /*<<op_set.ml 458 12>>*/ caml_call4
            (_jn_,index,_jm_,value$1,elem_ids),
          match$0=
           [0,
            elem_ids$0,
            [0,
             edit$0[1],
             edit$0[2],
             [0,elem_id_key],
             edit$0[4],
             value$1,
             edit$0[6],
             edit$0[7],
             edit$0[8],
             edit$0[9],
             edit$0[10]]];
         break;
        case 2:
          /*<<op_set.ml 467 18>>*/ var
           /*<<op_set.ml 467 18>>*/ _jv_=SkipList[6],
          match$0=
           [0,
             /*<<op_set.ml 467 19>>*/ caml_call2(_jv_,index,elem_ids),
            edit$0];
         break;
        default:
          /*<<op_set.ml 463 10>>*/ var
           /*<<op_set.ml 463 10>>*/ _jw_=CCOpt[20],
           /*<<op_set.ml 464 31>>*/ _jx_=
            /*<<op_set.ml 464 31>>*/ caml_call1(_jw_,first_op)[1],
           /*<<op_set.ml 464 31>>*/ _jy_=SkipList[5],
           /*<<op_set.ml 464 12>>*/ elem_ids$2=
            /*<<op_set.ml 464 12>>*/ caml_call3(_jy_,_jx_,value$1,elem_ids),
          match$0=
           [0,
            elem_ids$2,
            [0,
             edit$0[1],
             edit$0[2],
             edit$0[3],
             edit$0[4],
             value$1,
             edit$0[6],
             edit$0[7],
             edit$0[8],
             edit$0[9],
             edit$0[10]]]}
       /*<<op_set.ml 432 16>>*/ var edit$1=match$0[2],elem_ids$1=match$0[1];
      if(ops)
       {var ops$0=ops[1],_jo_=List[1];
         /*<<op_set.ml 472 22>>*/ if
         (1 <  /*<<op_set.ml 472 22>>*/ caml_call1(_jo_,ops$0))
          /*<<op_set.ml 473 10>>*/ var
           /*<<op_set.ml 473 10>>*/ _jp_=edit$1[10],
           /*<<op_set.ml 473 32>>*/ _jq_=
            /*<<op_set.ml 473 32>>*/ get_conflicts(ops$0),
           /*<<op_set.ml 473 32>>*/ _jr_=
           [0,
            edit$1[1],
            edit$1[2],
            edit$1[3],
            edit$1[4],
            edit$1[5],
            edit$1[6],
            edit$1[7],
            edit$1[8],
            _jq_,
            _jp_],
          edit$2=_jr_,
          switch$1=1;
        else
         var switch$1=0}
      else
       var switch$1=0;
      if(! switch$1)var edit$2=edit$1;
       /*<<op_set.ml 432 16>>*/  /*<<op_set.ml 476 4>>*/ var _js_=t[3];
       /*<<op_set.ml 476 4>>*/ function _jt_(param)
       { /*<<op_set.ml 478 8>>*/ if(param)
         {var match=param[1],obj_aux=match[2],obj_map=match[1];
          return [0,
                  [0,
                   obj_map,
                   [0,
                    obj_aux[1],
                    obj_aux[2],
                    obj_aux[3],
                    obj_aux[4],
                    [0,elem_ids$1],
                    obj_aux[6]]]]}
         /*<<op_set.ml 481 20>>*/ throw Not_found /*<<op_set.ml 481 36>>*/ }
       /*<<op_set.ml 476 4>>*/ var
        /*<<op_set.ml 476 4>>*/ _ju_=ObjectIdMap[29],
        /*<<op_set.ml 477 6>>*/ by_object=
         /*<<op_set.ml 477 6>>*/ caml_call3(_ju_,obj_id,_jt_,_js_);
       /*<<op_set.ml 477 6>>*/ return [0,
              [0,t[1],t[2],by_object,t[4],t[5],t[6],t[7],t[8],t[9],t[10]],
              [0,edit$2,0]] /*<<op_set.ml 484 32>>*/ }
    function is_concurrent(t,op1,op2)
     { /*<<op_set.ml 489 4>>*/ var
        /*<<op_set.ml 489 4>>*/ seq1=op1[4],
        /*<<op_set.ml 489 4>>*/ actor1=op1[3],
        /*<<op_set.ml 489 4>>*/ seq2=op2[4],
        /*<<op_set.ml 489 4>>*/ actor2=op2[3],
        /*<<op_set.ml 489 4>>*/ _iR_=seq1 - 1 | 0,
        /*<<op_set.ml 489 4>>*/ _iS_=t[1],
        /*<<op_set.ml 489 4>>*/ _iT_=ActorMap[22],
        /*<<op_set.ml 492 18>>*/ _iU_=
         /*<<op_set.ml 492 18>>*/ caml_call2(_iT_,actor1,_iS_),
        /*<<op_set.ml 492 18>>*/ _iV_=CCList[4],
        /*<<op_set.ml 492 6>>*/ clock1=
         /*<<op_set.ml 492 6>>*/ caml_call2(_iV_,_iU_,_iR_)[2],
        /*<<op_set.ml 492 6>>*/ _iW_=seq2 - 1 | 0,
        /*<<op_set.ml 492 6>>*/ _iX_=t[1],
        /*<<op_set.ml 492 6>>*/ _iY_=ActorMap[22],
        /*<<op_set.ml 495 18>>*/ _iZ_=
         /*<<op_set.ml 495 18>>*/ caml_call2(_iY_,actor2,_iX_),
        /*<<op_set.ml 495 18>>*/ _i0_=CCList[4],
        /*<<op_set.ml 495 6>>*/ clock2=
         /*<<op_set.ml 495 6>>*/ caml_call2(_i0_,_iZ_,_iW_)[2],
        /*<<op_set.ml 495 6>>*/ _i1_=0,
        /*<<op_set.ml 495 6>>*/ _i2_=ActorMap[28],
        /*<<op_set.ml 497 4>>*/ _i3_=
         /*<<op_set.ml 497 4>>*/ caml_call3(_i2_,actor2,clock1,_i1_) < seq2
         ?1
         :0;
       /*<<op_set.ml 497 4>>*/ if(_i3_)
       var
        _i4_=0,
        _i5_=ActorMap[28],
        _i6_=
          /*<<op_set.ml 498 7>>*/ caml_call3(_i5_,actor1,clock2,_i4_) < seq1
          ?1
          :0;
      else
       var _i6_=_i3_;
       /*<<op_set.ml 478 8>>*/ return _i6_ /*<<op_set.ml 498 54>>*/ }
    function get_field_ops(t,obj_id,key)
     { /*<<op_set.ml 501 4>>*/ var
        /*<<op_set.ml 501 4>>*/ _iP_=t[3],
        /*<<op_set.ml 501 4>>*/ _iQ_=ObjectIdMap[27],
        /*<<op_set.ml 501 10>>*/ match=
         /*<<op_set.ml 501 10>>*/ caml_call2(_iQ_,obj_id,_iP_);
       /*<<op_set.ml 501 10>>*/ if(match)
       {var match$0=match[1],obj_map=match$0[1];
        return caml_call3(KeyMap[28],key,obj_map,0)}
       /*<<op_set.ml 503 14>>*/ return 0 /*<<op_set.ml 503 16>>*/ }
    function get_parent(t,obj_id,key)
     { /*<<op_set.ml 506 4>>*/ if(key)
       {var key$0=key[1],_iF_=String[34];
         /*<<op_set.ml 508 20>>*/ if
         ( /*<<op_set.ml 508 20>>*/ caml_call2(_iF_,key$0,cst_head))
         return 0;
         /*<<op_set.ml 511 8>>*/ var
          /*<<op_set.ml 511 8>>*/ _iG_=
          function(param)
           { /*<<op_set.ml 513 14>>*/  /*<<op_set.ml 513 14>>*/ var
             obj_aux=
              param[2];
             /*<<op_set.ml 513 14>>*/ function _iL_(op)
             { /*<<op_set.ml 514 61>>*/ return op[1] /*<<op_set.ml 514 67>>*/ }
             /*<<op_set.ml 513 14>>*/ var
              /*<<op_set.ml 513 14>>*/ _iM_=obj_aux[6],
              /*<<op_set.ml 513 14>>*/ _iN_=ElemIdMap[27],
              /*<<op_set.ml 514 10>>*/ _iO_=
               /*<<op_set.ml 514 10>>*/ caml_call2(_iN_,key$0,_iM_);
             /*<<op_set.ml 514 10>>*/ return  /*<<op_set.ml 514 10>>*/ caml_call2
                    (CCOpt[34][1],_iO_,_iL_) /*<<op_set.ml 514 67>>*/ },
          /*<<op_set.ml 511 8>>*/ _iH_=t[3],
          /*<<op_set.ml 511 8>>*/ _iI_=ObjectIdMap[27],
          /*<<op_set.ml 512 10>>*/ _iJ_=
           /*<<op_set.ml 512 10>>*/ caml_call2(_iI_,obj_id,_iH_),
          /*<<op_set.ml 512 10>>*/ _iK_=CCOpt[34][2],
          /*<<op_set.ml 512 10>>*/ insertion=
           /*<<op_set.ml 512 10>>*/ caml_call2(_iK_,_iJ_,_iG_);
         /*<<op_set.ml 512 10>>*/ if(insertion)
         { /*<<op_set.ml 518 20>>*/  /*<<op_set.ml 518 20>>*/ var
           k=
            insertion[1];
           /*<<op_set.ml 518 20>>*/ return [0,k]}
         /*<<op_set.ml 517 18>>*/ throw Missing_index_for_list_element}
       /*<<op_set.ml 507 14>>*/ return 0 /*<<op_set.ml 518 28>>*/ }
    function insertions_after(t,obj_id,parent_id,child_id)
     { /*<<op_set.ml 522 4>>*/ if(child_id)
       {var child_id$0=child_id[1],_h8_=58,_h9_=Datastructures[1][16];
         /*<<op_set.ml 526 13>>*/ if
         ( /*<<op_set.ml 526 13>>*/ caml_call2(_h9_,child_id$0,_h8_))
          /*<<op_set.ml 527 12>>*/ var
           /*<<op_set.ml 527 12>>*/ _h__=58,
           /*<<op_set.ml 527 12>>*/ _h$_=Datastructures[1][93],
           /*<<op_set.ml 527 24>>*/ parts=
            /*<<op_set.ml 527 24>>*/ caml_call2(_h$_,_h__,child_id$0),
           /*<<op_set.ml 527 24>>*/ _ia_=0,
           /*<<op_set.ml 527 24>>*/ _ib_=CCList[4],
           /*<<op_set.ml 528 24>>*/ actor=
            /*<<op_set.ml 528 24>>*/ caml_call2(_ib_,parts,_ia_),
           /*<<op_set.ml 528 24>>*/ _ic_=1,
           /*<<op_set.ml 528 24>>*/ _id_=CCList[4],
           /*<<op_set.ml 529 37>>*/ elem=
            /*<<op_set.ml 529 37>>*/ runtime.caml_int_of_string
            ( /*<<op_set.ml 529 37>>*/ caml_call2(_id_,parts,_ic_)),
          _ie_=[0,[0,actor,elem]];
        else
         var _ie_=0;
        var child_key=_ie_}
      else
       var child_key=0;
       /*<<op_set.ml 535 12>>*/  /*<<op_set.ml 535 12>>*/ var
       match=
         /*<<op_set.ml 535 12>>*/ get_obj_aux(t,obj_id);
       /*<<op_set.ml 535 12>>*/ if(match)
       { /*<<op_set.ml 536 24>>*/  /*<<op_set.ml 536 24>>*/ var
         obj_aux=
          match[1];
         /*<<op_set.ml 536 24>>*/ if(parent_id)
          /*<<op_set.ml 540 12>>*/ var
           /*<<op_set.ml 540 12>>*/ parent_id$0=parent_id[1],
           /*<<op_set.ml 540 12>>*/ _if_=0,
           /*<<op_set.ml 540 12>>*/ _ig_=obj_aux[2],
           /*<<op_set.ml 540 12>>*/ _ih_=KeyMap[28],
          _ii_=
            /*<<op_set.ml 540 12>>*/ caml_call3(_ih_,parent_id$0,_ig_,_if_);
        else
         var _ii_=0;
         /*<<op_set.ml 536 24>>*/ var following=_ii_}
      else
       var following=0;
       /*<<op_set.ml 543 4>>*/ function _ij_(op)
       { /*<<op_set.ml 544 24>>*/ return 3 === op[2]?1:0 /*<<op_set.ml 544 69>>*/ }
       /*<<op_set.ml 543 4>>*/ var
        /*<<op_set.ml 543 4>>*/ _ik_=CCList[39],
        /*<<op_set.ml 543 4>>*/ _il_=
         /*<<op_set.ml 543 4>>*/ caml_call2(_ik_,_ij_,following);
       /*<<op_set.ml 543 4>>*/ function _im_(op)
       { /*<<op_set.ml 547 11>>*/ if(child_key)
         { /*<<op_set.ml 550 15>>*/ var
            /*<<op_set.ml 550 15>>*/ child_key$0=child_key[1],
            /*<<op_set.ml 551 41>>*/ _iD_=
             /*<<op_set.ml 551 41>>*/ get_op_elem(op),
            /*<<op_set.ml 551 41>>*/ _iE_=[0,op[3],_iD_];
           /*<<op_set.ml 550 15>>*/ return  /*<<op_set.ml 550 15>>*/ lamport_compare
                   (_iE_,child_key$0)
                  <
                  0
                  ?1
                  :0}
         /*<<op_set.ml 548 21>>*/ return 1 /*<<op_set.ml 553 18>>*/ }
       /*<<op_set.ml 543 4>>*/ var
        /*<<op_set.ml 543 4>>*/ _in_=CCList[39],
        /*<<op_set.ml 543 4>>*/ _io_=
         /*<<op_set.ml 543 4>>*/ caml_call2(_in_,_im_,_il_);
       /*<<op_set.ml 543 4>>*/ function _ip_(op1,op2)
       { /*<<op_set.ml 557 38>>*/ var
          /*<<op_set.ml 557 38>>*/ _iA_=
           /*<<op_set.ml 557 38>>*/ get_op_elem(op2),
          /*<<op_set.ml 557 38>>*/ _iB_=[0,op2[3],_iA_],
          /*<<op_set.ml 556 38>>*/ _iC_=
           /*<<op_set.ml 556 38>>*/ get_op_elem(op1);
         /*<<op_set.ml 556 38>>*/ return  /*<<op_set.ml 556 38>>*/ lamport_compare
                ([0,op1[3],_iC_],_iB_) /*<<op_set.ml 557 54>>*/ }
       /*<<op_set.ml 543 4>>*/ var
        /*<<op_set.ml 543 4>>*/ _iq_=CCList[27],
        /*<<op_set.ml 543 4>>*/ _ir_=
         /*<<op_set.ml 543 4>>*/ caml_call2(_iq_,_ip_,_io_),
        /*<<op_set.ml 543 4>>*/ _is_=CCList[5],
        /*<<op_set.ml 543 4>>*/ _it_=
         /*<<op_set.ml 543 4>>*/ caml_call1(_is_,_ir_);
       /*<<op_set.ml 543 4>>*/ function _iu_(op)
       { /*<<op_set.ml 560 42>>*/ var
          /*<<op_set.ml 560 42>>*/ _iv_=
           /*<<op_set.ml 560 42>>*/ get_op_elem(op),
          /*<<op_set.ml 560 42>>*/ _iw_=Pervasives[21],
          /*<<op_set.ml 560 28>>*/ _ix_=
           /*<<op_set.ml 560 28>>*/ caml_call1(_iw_,_iv_),
          /*<<op_set.ml 560 28>>*/ _iy_=Pervasives[16],
          /*<<op_set.ml 560 22>>*/ _iz_=
           /*<<op_set.ml 560 22>>*/ caml_call2(_iy_,cst$0,_ix_);
         /*<<op_set.ml 560 22>>*/ return  /*<<op_set.ml 560 22>>*/ caml_call2
                (Pervasives[16],op[3],_iz_) /*<<op_set.ml 560 58>>*/ }
       /*<<op_set.ml 543 4>>*/ return  /*<<op_set.ml 543 4>>*/ caml_call2
              (CCList[33],_iu_,_it_) /*<<op_set.ml 560 60>>*/ }
    function get_previous(t,obj_id,key)
     { /*<<op_set.ml 565 4>>*/ var
        /*<<op_set.ml 565 4>>*/ _hT_=[0,key],
        /*<<op_set.ml 565 20>>*/ parent_id=
         /*<<op_set.ml 565 20>>*/ get_parent(t,obj_id,_hT_),
        /*<<op_set.ml 565 20>>*/ _hU_=0,
        /*<<op_set.ml 566 19>>*/ children=
         /*<<op_set.ml 566 19>>*/ insertions_after(t,obj_id,parent_id,_hU_),
        /*<<op_set.ml 566 19>>*/ _hV_=CCList[1];
       /*<<op_set.ml 567 7>>*/ if
       (0 <  /*<<op_set.ml 567 7>>*/ caml_call1(_hV_,children))
       { /*<<op_set.ml 567 50>>*/ var
         _hW_=CCList[2],
          /*<<op_set.ml 567 50>>*/ _hX_=
           /*<<op_set.ml 567 50>>*/ caml_call1(_hW_,children),
          /*<<op_set.ml 567 50>>*/ _hY_=String[34];
         /*<<op_set.ml 567 37>>*/ if
         ( /*<<op_set.ml 567 37>>*/ caml_call2(_hY_,_hX_,key))
         { /*<<op_set.ml 568 6>>*/ if(parent_id)
           if(! caml_string_notequal(parent_id[1],cst_head$0))return 0;
           /*<<op_set.ml 568 55>>*/ return parent_id}}
       /*<<op_set.ml 572 6>>*/ function _hZ_(child)
       { /*<<op_set.ml 574 40>>*/ return  /*<<op_set.ml 574 40>>*/ caml_call2
                (String[34],child,key) /*<<op_set.ml 574 62>>*/ }
       /*<<op_set.ml 572 6>>*/ var
        /*<<op_set.ml 572 6>>*/ _h0_=CCList[93],
        /*<<op_set.ml 574 10>>*/ match=
         /*<<op_set.ml 574 10>>*/ caml_call2(_h0_,_hZ_,children);
       /*<<op_set.ml 574 10>>*/ if(match)
       {var match$0=match[1],idx=match$0[1];
        if(0 === idx)
         var _h1_=0;
        else
          /*<<op_set.ml 577 38>>*/ var
           /*<<op_set.ml 577 38>>*/ _h2_=idx - 1 | 0,
           /*<<op_set.ml 577 38>>*/ _h3_=CCList[4],
          _h1_=[0, /*<<op_set.ml 577 43>>*/ caml_call2(_h3_,children,_h2_)];
        var prev_id=_h1_}
      else
        /*<<op_set.ml 578 18>>*/ var
         /*<<op_set.ml 578 18>>*/ _h4_=CCList[87],
        prev_id= /*<<op_set.ml 578 18>>*/ caml_call1(_h4_,children);
       /*<<op_set.ml 578 42>>*/ function loop(children,prev_id)
       { /*<<?>>*/ var prev_id$0=prev_id;
         /*<<op_set.ml 581 8>>*/ for(;;)
         { /*<<op_set.ml 581 8>>*/ var
            /*<<op_set.ml 581 8>>*/ _h5_=0,
            /*<<op_set.ml 581 23>>*/ children$0=
             /*<<op_set.ml 581 23>>*/ insertions_after
             (t,obj_id,prev_id$0,_h5_),
            /*<<op_set.ml 581 23>>*/ _h6_=CCList[32];
           /*<<op_set.ml 582 11>>*/ if
           ( /*<<op_set.ml 582 11>>*/ caml_call1(_h6_,children$0))
           return prev_id$0;
           /*<<op_set.ml 581 8>>*/ var
            /*<<op_set.ml 583 13>>*/ _h7_=CCList[87],
            /*<<op_set.ml 583 27>>*/ prev_id$1=
             /*<<op_set.ml 583 27>>*/ caml_call1(_h7_,children$0),
           prev_id$0=prev_id$1;
          continue} /*<<op_set.ml 583 53>>*/ }
       /*<<op_set.ml 578 42>>*/ return  /*<<op_set.ml 578 42>>*/ loop
              (children,prev_id) /*<<op_set.ml 585 27>>*/ }
    function update_list_element(t,obj_id,elem_id_key)
     { /*<<op_set.ml 588 14>>*/ var
        /*<<op_set.ml 588 14>>*/ ops=
         /*<<op_set.ml 588 14>>*/ get_field_ops(t,obj_id,elem_id_key),
        /*<<op_set.ml 588 14>>*/ _hM_=t[3],
        /*<<op_set.ml 588 14>>*/ _hN_=ObjectIdMap[22],
        /*<<op_set.ml 589 25>>*/ match=
         /*<<op_set.ml 589 25>>*/ caml_call2(_hN_,obj_id,_hM_)[2],
        /*<<op_set.ml 589 25>>*/ elem_ids=match[5],
        /*<<op_set.ml 589 25>>*/ _hO_=CCOpt[20],
        /*<<op_set.ml 590 19>>*/ elem_ids$0=
         /*<<op_set.ml 590 19>>*/ caml_call1(_hO_,elem_ids),
        /*<<op_set.ml 590 19>>*/ _hP_=SkipList[3],
        /*<<op_set.ml 591 16>>*/ index=
         /*<<op_set.ml 591 16>>*/ caml_call2(_hP_,elem_id_key,elem_ids$0);
       /*<<op_set.ml 591 16>>*/ if(index)
       { /*<<op_set.ml 594 8>>*/ var
          /*<<op_set.ml 594 8>>*/ index$0=index[1],
          /*<<op_set.ml 594 8>>*/ _hQ_=CCList[32];
         /*<<op_set.ml 594 11>>*/ return  /*<<op_set.ml 594 11>>*/ caml_call1
                 (_hQ_,ops)
                ? /*<<op_set.ml 595 10>>*/ patch_list
                  (t,obj_id,index$0,elem_id_key,2,0)
                : /*<<op_set.ml 596 13>>*/ patch_list
                  (t,obj_id,index$0,elem_id_key,3,[0,ops])}
       /*<<op_set.ml 588 14>>*/  /*<<op_set.ml 599 8>>*/ var _hR_=CCList[32];
       /*<<op_set.ml 599 11>>*/ if
       ( /*<<op_set.ml 599 11>>*/ caml_call1(_hR_,ops))
       return [0,t,0];
       /*<<op_set.ml 601 10>>*/ function loop(prev_id)
       { /*<<?>>*/ var prev_id$0=prev_id;
         /*<<op_set.ml 602 12>>*/ for(;;)
         { /*<<op_set.ml 602 18>>*/  /*<<op_set.ml 602 18>>*/ var
           match=
             /*<<op_set.ml 602 18>>*/ get_previous(t,obj_id,prev_id$0);
           /*<<op_set.ml 602 18>>*/ if(match)
           { /*<<op_set.ml 605 20>>*/ var
             prev_id$1=match[1],
             _hS_=SkipList[3],
              /*<<op_set.ml 605 20>>*/ match$0=
               /*<<op_set.ml 605 20>>*/ caml_call2(_hS_,prev_id$1,elem_ids$0);
             /*<<op_set.ml 605 20>>*/ if(match$0)
             { /*<<op_set.ml 606 30>>*/  /*<<op_set.ml 606 30>>*/ var
               index=
                match$0[1];
               /*<<op_set.ml 606 30>>*/ return index}
             /*<<op_set.ml 605 20>>*/ var prev_id$0=prev_id$1;
            continue}
           /*<<op_set.ml 603 22>>*/ return -1} /*<<op_set.ml 607 38>>*/ }
       /*<<op_set.ml 610 22>>*/  /*<<op_set.ml 610 22>>*/ var
       index$1=
         /*<<op_set.ml 610 22>>*/ loop(elem_id_key);
       /*<<op_set.ml 610 22>>*/ return  /*<<op_set.ml 610 22>>*/ patch_list
              (t,obj_id,index$1 + 1 | 0,elem_id_key,1,[0,ops]) /*<<op_set.ml 611 72>>*/ }
    function update_map_key(t,obj_id,key)
     { /*<<op_set.ml 614 14>>*/ var
        /*<<op_set.ml 614 14>>*/ ops=
         /*<<op_set.ml 614 14>>*/ get_field_ops(t,obj_id,key),
        /*<<op_set.ml 615 15>>*/ path=
         /*<<op_set.ml 615 15>>*/ get_path(t,obj_id,_aW_),
        /*<<op_set.ml 615 15>>*/ _hG_=CCList[32];
       /*<<op_set.ml 617 9>>*/ if
       ( /*<<op_set.ml 617 9>>*/ caml_call1(_hG_,ops))
       var edit=[0,0,2,0,[0,key],0,obj_id,0,0,0,path];
      else
        /*<<op_set.ml 629 8>>*/ var
         /*<<op_set.ml 629 8>>*/ _hH_=CCList[2],
         /*<<op_set.ml 629 18>>*/ fst=
          /*<<op_set.ml 629 18>>*/ caml_call1(_hH_,ops),
         /*<<op_set.ml 629 18>>*/ _hI_=fst[7],
         /*<<op_set.ml 629 18>>*/ _hJ_=
         function(s)
          { /*<<op_set.ml 630 40>>*/ return [0,s] /*<<op_set.ml 630 47>>*/ },
         /*<<op_set.ml 629 18>>*/ _hK_=CCOpt[1],
         /*<<op_set.ml 630 20>>*/ value=
          /*<<op_set.ml 630 20>>*/ caml_call2(_hK_,_hJ_,_hI_),
         /*<<op_set.ml 630 20>>*/ _hL_=CCList[1],
         /*<<op_set.ml 632 13>>*/ conflicts=
         1 <  /*<<op_set.ml 632 13>>*/ caml_call1(_hL_,ops)
          ? /*<<op_set.ml 632 40>>*/ get_conflicts(ops)
          :0,
        edit=[0,0,3,0,[0,key],value,obj_id,6 === fst[2]?1:0,0,conflicts,path];
       /*<<op_set.ml 645 4>>*/ return [0,t,[0,edit,0]] /*<<op_set.ml 645 15>>*/ }
    function apply_assign(t,op,is_top_level)
     { /*<<op_set.ml 649 4>>*/ var
        /*<<op_set.ml 649 4>>*/ _gy_=t[3],
        /*<<op_set.ml 649 4>>*/ _gz_=op[5],
        /*<<op_set.ml 649 4>>*/ _gA_=ObjectIdMap[3];
       /*<<op_set.ml 649 11>>*/ if
       ( /*<<op_set.ml 649 11>>*/ caml_call2(_gA_,_gz_,_gy_))
       { /*<<op_set.ml 652 6>>*/  /*<<op_set.ml 652 6>>*/ var _gB_=t[10];
         /*<<op_set.ml 652 6>>*/ if(_gB_)
         { /*<<op_set.ml 654 25>>*/  /*<<op_set.ml 654 25>>*/ var
           uloc=
            _gB_[1];
           /*<<op_set.ml 654 25>>*/ if(is_top_level)
            /*<<op_set.ml 655 12>>*/ var
             /*<<op_set.ml 655 12>>*/ _gC_=t[3],
             /*<<op_set.ml 655 12>>*/ _gD_=op[5],
             /*<<op_set.ml 655 12>>*/ _gE_=ObjectIdMap[22],
             /*<<op_set.ml 655 35>>*/ match=
              /*<<op_set.ml 655 35>>*/ caml_call2(_gE_,_gD_,_gC_),
             /*<<op_set.ml 655 35>>*/ obj_map=match[1],
             /*<<op_set.ml 655 35>>*/ _gF_=0,
             /*<<op_set.ml 655 35>>*/ _gG_=op[1],
             /*<<op_set.ml 655 35>>*/ _gH_=KeyMap[28],
             /*<<op_set.ml 657 14>>*/ _gI_=
              /*<<op_set.ml 657 14>>*/ caml_call3(_gH_,_gG_,obj_map,_gF_),
             /*<<op_set.ml 657 14>>*/ _gJ_=
             function(op)
              { /*<<op_set.ml 659 21>>*/  /*<<op_set.ml 659 21>>*/ var
                _hC_=
                 op[7];
                /*<<op_set.ml 659 21>>*/ function _hD_(v)
                { /*<<op_set.ml 662 50>>*/ return [0,v] /*<<op_set.ml 662 57>>*/ }
                /*<<op_set.ml 659 21>>*/ var
                 /*<<op_set.ml 659 21>>*/ _hE_=CCOpt[1],
                 /*<<op_set.ml 662 30>>*/ _hF_=
                  /*<<op_set.ml 662 30>>*/ caml_call2(_hE_,_hD_,_hC_);
                /*<<op_set.ml 662 30>>*/ return [0,op[2],op[5],op[1],_hF_] /*<<op_set.ml 662 69>>*/ },
             /*<<op_set.ml 657 14>>*/ _gK_=CCList[33],
             /*<<op_set.ml 657 14>>*/ undo_ops=
              /*<<op_set.ml 657 14>>*/ caml_call2(_gK_,_gJ_,_gI_),
             /*<<op_set.ml 657 14>>*/ _gL_=CCList[32],
             /*<<op_set.ml 665 17>>*/ undo_ops$0=
              /*<<op_set.ml 665 17>>*/ caml_call1(_gL_,undo_ops)
              ?[0,[0,5,op[5],op[1],0],0]
              :undo_ops,
             /*<<op_set.ml 669 12>>*/ _gM_=[0,uloc,[0,undo_ops$0,0]],
             /*<<op_set.ml 669 12>>*/ _gN_=CCList[7],
             /*<<op_set.ml 669 23>>*/ uloc$0=
              /*<<op_set.ml 669 23>>*/ caml_call1(_gN_,_gM_),
             /*<<op_set.ml 669 23>>*/ _gO_=
             [0,t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],[0,uloc$0]],
            t$0=_gO_,
            switch$0=1;
          else
           var switch$0=0}
        else
         var switch$0=0;
         /*<<op_set.ml 54 2>>*/ if(! switch$0)var t$0=t;
         /*<<op_set.ml 652 6>>*/ var
          /*<<op_set.ml 673 6>>*/ _gP_=t$0[3],
          /*<<op_set.ml 673 6>>*/ _gQ_=op[5],
          /*<<op_set.ml 673 6>>*/ _gR_=ObjectIdMap[22],
          /*<<op_set.ml 674 25>>*/ match$0=
           /*<<op_set.ml 674 25>>*/ caml_call2(_gR_,_gQ_,_gP_),
          /*<<op_set.ml 674 25>>*/ obj_map$0=match$0[1],
          /*<<op_set.ml 674 25>>*/ _gS_=0,
          /*<<op_set.ml 674 25>>*/ _gT_=op[1],
          /*<<op_set.ml 674 25>>*/ _gU_=KeyMap[28],
          /*<<op_set.ml 675 19>>*/ refs=
           /*<<op_set.ml 675 19>>*/ caml_call3(_gU_,_gT_,obj_map$0,_gS_),
          /*<<op_set.ml 675 19>>*/ _gV_=
          function(param,ref)
           { /*<<op_set.ml 677 10>>*/ var
              /*<<op_set.ml 677 10>>*/ rem=param[2],
              /*<<op_set.ml 677 10>>*/ over=param[1];
             /*<<op_set.ml 678 15>>*/ return  /*<<op_set.ml 678 15>>*/ is_concurrent
                     (t$0,ref,op)
                    ?[0,over,[0,ref,rem]]
                    :[0,[0,ref,over],rem] /*<<op_set.ml 679 37>>*/ },
          /*<<op_set.ml 675 19>>*/ _gW_=CCList[10],
          /*<<op_set.ml 676 8>>*/ match$1=
           /*<<op_set.ml 676 8>>*/ caml_call3(_gW_,_gV_,_aX_,refs),
          /*<<op_set.ml 676 8>>*/ remaining=match$1[2],
          /*<<op_set.ml 676 8>>*/ overwritten=match$1[1],
          /*<<op_set.ml 676 8>>*/ _gX_=
          function(op)
           { /*<<op_set.ml 685 28>>*/ return 6 <= op[2]?1:0 /*<<op_set.ml 685 74>>*/ },
          /*<<op_set.ml 676 8>>*/ _gY_=CCList[39],
          /*<<op_set.ml 684 8>>*/ overwritten_links=
           /*<<op_set.ml 684 8>>*/ caml_call2(_gY_,_gX_,overwritten),
          /*<<op_set.ml 684 8>>*/ _gZ_=
          function(t,op)
           { /*<<op_set.ml 691 12>>*/  /*<<op_set.ml 691 12>>*/ var _hq_=t[3];
             /*<<op_set.ml 691 12>>*/ function _hr_(param)
             { /*<<op_set.ml 694 16>>*/ if(param)
               { /*<<op_set.ml 699 38>>*/ var
                 match=param[1],
                 obj_aux=match[2],
                 obj_map=match[1],
                 _hx_=obj_aux[6],
                 _hy_=obj_aux[5],
                 _hz_=obj_aux[4],
                 _hA_=OpSet[6],
                  /*<<op_set.ml 699 38>>*/ _hB_=
                   /*<<op_set.ml 699 38>>*/ caml_call2(_hA_,op,_hz_);
                 /*<<op_set.ml 699 38>>*/ return [0,
                        [0,
                         obj_map,
                         [0,obj_aux[1],obj_aux[2],obj_aux[3],_hB_,_hy_,_hx_]]]}
               /*<<op_set.ml 700 28>>*/ throw Not_found /*<<op_set.ml 700 44>>*/ }
             /*<<op_set.ml 691 12>>*/ var
              /*<<op_set.ml 691 12>>*/ _hs_=op[7],
              /*<<op_set.ml 691 12>>*/ _ht_=CCOpt[20],
              /*<<op_set.ml 693 44>>*/ _hu_=
               /*<<op_set.ml 693 44>>*/ caml_call1(_ht_,_hs_),
              /*<<op_set.ml 693 16>>*/ _hv_=
               /*<<op_set.ml 693 16>>*/ get_op_value_as_string_exn(_hu_),
              /*<<op_set.ml 693 16>>*/ _hw_=ObjectIdMap[29],
              /*<<op_set.ml 692 14>>*/ by_object=
               /*<<op_set.ml 692 14>>*/ caml_call3(_hw_,_hv_,_hr_,_hq_);
             /*<<op_set.ml 692 14>>*/ return [0,
                    t[1],
                    t[2],
                    by_object,
                    t[4],
                    t[5],
                    t[6],
                    t[7],
                    t[8],
                    t[9],
                    t[10]] /*<<op_set.ml 703 30>>*/ },
          /*<<op_set.ml 684 8>>*/ _g0_=CCList[10],
          /*<<op_set.ml 689 8>>*/ t$1=
           /*<<op_set.ml 689 8>>*/ caml_call3(_g0_,_gZ_,t$0,overwritten_links);
         /*<<op_set.ml 689 8>>*/ if(6 <= op[2])
          /*<<op_set.ml 709 12>>*/ var
           /*<<op_set.ml 709 12>>*/ _g1_=t$1[3],
           /*<<op_set.ml 709 12>>*/ _g2_=
           function(param)
            { /*<<op_set.ml 712 16>>*/ if(param)
              { /*<<op_set.ml 716 50>>*/ var
                match=param[1],
                obj_aux=match[2],
                obj_map=match[1],
                _hl_=obj_aux[6],
                _hm_=obj_aux[5],
                _hn_=obj_aux[4],
                _ho_=OpSet[4],
                 /*<<op_set.ml 716 50>>*/ _hp_=
                  /*<<op_set.ml 716 50>>*/ caml_call2(_ho_,op,_hn_);
                /*<<op_set.ml 716 50>>*/ return [0,
                       [0,
                        obj_map,
                        [0,obj_aux[1],obj_aux[2],obj_aux[3],_hp_,_hm_,_hl_]]]}
              /*<<op_set.ml 718 28>>*/ throw Not_found /*<<op_set.ml 718 44>>*/ },
           /*<<op_set.ml 709 12>>*/ _g3_=op[7],
           /*<<op_set.ml 709 12>>*/ _g4_=CCOpt[20],
           /*<<op_set.ml 711 44>>*/ _g5_=
            /*<<op_set.ml 711 44>>*/ caml_call1(_g4_,_g3_),
           /*<<op_set.ml 711 16>>*/ _g6_=
            /*<<op_set.ml 711 16>>*/ get_op_value_as_string_exn(_g5_),
           /*<<op_set.ml 711 16>>*/ _g7_=ObjectIdMap[29],
           /*<<op_set.ml 710 14>>*/ by_object=
            /*<<op_set.ml 710 14>>*/ caml_call3(_g7_,_g6_,_g2_,_g1_),
          t$2=
           [0,
            t$1[1],
            t$1[2],
            by_object,
            t$1[4],
            t$1[5],
            t$1[6],
            t$1[7],
            t$1[8],
            t$1[9],
            t$1[10]];
        else
         var t$2=t$1;
        if(5 === op[2])
         var remaining$0=remaining;
        else
          /*<<op_set.ml 727 15>>*/ var
           /*<<op_set.ml 727 15>>*/ _hh_=[0,op,0],
           /*<<op_set.ml 727 15>>*/ _hi_=CCList[36],
          remaining$0=
            /*<<op_set.ml 727 15>>*/ caml_call2(_hi_,remaining,_hh_);
         /*<<op_set.ml 652 6>>*/ var
          /*<<op_set.ml 729 6>>*/ _g8_=
          function(op1,op2)
           { /*<<op_set.ml 731 40>>*/ return  /*<<op_set.ml 731 40>>*/ caml_call2
                    (String[33],op1[3],op2[3]) /*<<op_set.ml 731 74>>*/ },
          /*<<op_set.ml 729 6>>*/ _g9_=CCList[27],
          /*<<op_set.ml 730 8>>*/ _g__=
           /*<<op_set.ml 730 8>>*/ caml_call2(_g9_,_g8_,remaining$0),
          /*<<op_set.ml 730 8>>*/ _g$_=CCList[5],
          /*<<op_set.ml 730 8>>*/ remaining$1=
           /*<<op_set.ml 730 8>>*/ caml_call1(_g$_,_g__),
          /*<<op_set.ml 730 8>>*/ _ha_=t$2[3],
          /*<<op_set.ml 730 8>>*/ _hb_=
          function(param)
           { /*<<op_set.ml 737 10>>*/ if(param)
             {var
               match=param[1],
               obj_aux=match[2],
               obj_map=match[1],
               _hj_=op[1],
               _hk_=ObjectIdMap[4];
               /*<<op_set.ml 739 22>>*/ return [0,
                      [0,
                        /*<<op_set.ml 739 22>>*/ caml_call3
                        (_hk_,_hj_,remaining$1,obj_map),
                       obj_aux]]}
             /*<<op_set.ml 740 22>>*/ throw Not_found /*<<op_set.ml 740 38>>*/ },
          /*<<op_set.ml 730 8>>*/ _hc_=op[5],
          /*<<op_set.ml 730 8>>*/ _hd_=ObjectIdMap[29],
          /*<<op_set.ml 736 8>>*/ by_object$0=
           /*<<op_set.ml 736 8>>*/ caml_call3(_hd_,_hc_,_hb_,_ha_),
          /*<<op_set.ml 736 8>>*/ t$3=
          [0,
           t$2[1],
           t$2[2],
           by_object$0,
           t$2[4],
           t$2[5],
           t$2[6],
           t$2[7],
           t$2[8],
           t$2[9],
           t$2[10]],
          /*<<op_set.ml 736 8>>*/ _he_=t$3[3],
          /*<<op_set.ml 736 8>>*/ _hf_=op[5],
          /*<<op_set.ml 736 8>>*/ _hg_=ObjectIdMap[22],
          /*<<op_set.ml 745 13>>*/ obj_type=
           /*<<op_set.ml 745 13>>*/ caml_call2(_hg_,_hf_,_he_)[2][3][2],
          /*<<op_set.ml 745 13>>*/ switcher=obj_type - 1 | 0;
         /*<<op_set.ml 745 13>>*/ return 1 < switcher >>> 0
                ? /*<<op_set.ml 749 13>>*/ update_map_key(t$3,op[5],op[1])
                : /*<<op_set.ml 748 31>>*/ update_list_element
                  (t$3,op[5],op[1])}
       /*<<op_set.ml 650 6>>*/ throw Modification_of_unknown_object /*<<op_set.ml 749 43>>*/ }
    function apply_ops(t,ops)
     { /*<<op_set.ml 752 4>>*/  /*<<op_set.ml 752 4>>*/ var
       _gm_=
        [0,t,0,ObjectIdSet[1]];
       /*<<op_set.ml 752 4>>*/ function _gn_(param,op)
       { /*<<op_set.ml 754 8>>*/ var
          /*<<op_set.ml 754 8>>*/ new_objs=param[3],
          /*<<op_set.ml 754 8>>*/ all_diffs=param[2],
          /*<<op_set.ml 754 8>>*/ t=param[1],
          /*<<op_set.ml 754 8>>*/ _gp_=op[2];
         /*<<op_set.ml 754 8>>*/ if(3 === _gp_)
         { /*<<op_set.ml 761 29>>*/ var
            /*<<op_set.ml 761 29>>*/ match=
             /*<<op_set.ml 761 29>>*/ apply_insert(t,op),
            /*<<op_set.ml 761 29>>*/ diffs=match[2],
            /*<<op_set.ml 761 29>>*/ t$0=match[1],
            /*<<op_set.ml 761 29>>*/ _gq_=List[11];
           /*<<op_set.ml 762 18>>*/ return [0,
                  t$0,
                   /*<<op_set.ml 762 18>>*/ caml_call2(_gq_,all_diffs,diffs),
                  new_objs]}
        if(4 <= _gp_)
         { /*<<op_set.ml 764 14>>*/ var
            /*<<op_set.ml 764 14>>*/ _gr_=op[5],
            /*<<op_set.ml 764 14>>*/ _gs_=ObjectIdSet[3],
            /*<<op_set.ml 765 39>>*/ _gt_=
            1
            -
             /*<<op_set.ml 765 39>>*/ caml_call2(_gs_,_gr_,new_objs),
            /*<<op_set.ml 765 16>>*/ match$0=
             /*<<op_set.ml 765 16>>*/ apply_assign(t,op,_gt_),
            /*<<op_set.ml 765 16>>*/ diffs$0=match$0[2],
            /*<<op_set.ml 765 16>>*/ t$1=match$0[1],
            /*<<op_set.ml 765 16>>*/ _gu_=List[11];
           /*<<op_set.ml 767 18>>*/ return [0,
                  t$1,
                   /*<<op_set.ml 767 18>>*/ caml_call2(_gu_,all_diffs,diffs$0),
                  new_objs]}
         /*<<op_set.ml 754 8>>*/ var
          /*<<op_set.ml 757 14>>*/ _gv_=op[5],
          /*<<op_set.ml 757 14>>*/ _gw_=ObjectIdSet[4],
          /*<<op_set.ml 757 29>>*/ new_objs$0=
           /*<<op_set.ml 757 29>>*/ caml_call2(_gw_,_gv_,new_objs),
          /*<<op_set.ml 758 29>>*/ match$1=
           /*<<op_set.ml 758 29>>*/ apply_make(t,op),
          /*<<op_set.ml 758 29>>*/ diffs$1=match$1[2],
          /*<<op_set.ml 758 29>>*/ t$2=match$1[1],
          /*<<op_set.ml 758 29>>*/ _gx_=List[11];
         /*<<op_set.ml 759 18>>*/ return [0,
                t$2,
                 /*<<op_set.ml 759 18>>*/ caml_call2(_gx_,all_diffs,diffs$1),
                new_objs$0] /*<<op_set.ml 767 58>>*/ }
       /*<<op_set.ml 752 4>>*/ var
        /*<<op_set.ml 752 4>>*/ _go_=List[20],
        /*<<op_set.ml 753 6>>*/ match=
         /*<<op_set.ml 753 6>>*/ caml_call3(_go_,_gn_,_gm_,ops),
        /*<<op_set.ml 753 6>>*/ all_diffs=match[2],
        /*<<op_set.ml 753 6>>*/ t$0=match[1];
       /*<<op_set.ml 753 6>>*/ return [0,t$0,all_diffs] /*<<op_set.ml 770 18>>*/ }
    function apply_change(t,change)
     { /*<<op_set.ml 774 4>>*/  /*<<op_set.ml 774 4>>*/ var _fu_=LLog[1];
       /*<<op_set.ml 774 4>>*/  /*<<op_set.ml 774 4>>*/ caml_call1(_fu_,t);
       /*<<op_set.ml 774 4>>*/ var
        /*<<op_set.ml 774 4>>*/ _fv_=0,
        /*<<op_set.ml 774 4>>*/ _fw_=t[1],
        /*<<op_set.ml 774 4>>*/ _fx_=change[1],
        /*<<op_set.ml 774 4>>*/ _fy_=ActorMap[28],
        /*<<op_set.ml 775 16>>*/ prior=
         /*<<op_set.ml 775 16>>*/ caml_call3(_fy_,_fx_,_fw_,_fv_),
        /*<<op_set.ml 775 16>>*/ _fz_=List[1],
        /*<<op_set.ml 776 21>>*/ _fA_=
         /*<<op_set.ml 776 21>>*/ caml_call1(_fz_,prior);
       /*<<op_set.ml 776 21>>*/ if(change[2] <= _fA_)
       { /*<<op_set.ml 777 6>>*/ var
          /*<<op_set.ml 777 6>>*/ _fB_=change[2] - 1 | 0,
          /*<<op_set.ml 777 6>>*/ _fC_=List[8],
          /*<<op_set.ml 777 12>>*/ match=
           /*<<op_set.ml 777 12>>*/ caml_call2(_fC_,prior,_fB_);
         /*<<op_set.ml 777 12>>*/ if(match)
         { /*<<op_set.ml 779 24>>*/ var
            /*<<op_set.ml 779 24>>*/ state=match[1],
            /*<<op_set.ml 779 24>>*/ _fD_=state[1];
           /*<<op_set.ml 779 24>>*/ if
           ( /*<<op_set.ml 779 24>>*/ runtime.caml_equal(_fD_,change))
           { /*<<op_set.ml 782 10>>*/ debugger;
             /*<<op_set.ml 782 10>>*/ 0;
             /*<<op_set.ml 782 10>>*/ throw Inconsistent_reuse_of_sequence}}
         /*<<op_set.ml 784 13>>*/ return [0,t,0]}
       /*<<op_set.ml 774 4>>*/ var
        /*<<op_set.ml 786 6>>*/ _fE_=change[3],
        /*<<op_set.ml 786 6>>*/ _fF_=change[2] - 1 | 0,
        /*<<op_set.ml 786 6>>*/ _fG_=change[1],
        /*<<op_set.ml 786 6>>*/ _fH_=ActorMap[4],
        /*<<op_set.ml 787 8>>*/ _fI_=
         /*<<op_set.ml 787 8>>*/ caml_call3(_fH_,_fG_,_fF_,_fE_),
        /*<<op_set.ml 787 8>>*/ allDeps=
         /*<<op_set.ml 787 8>>*/ transitive_deps(t,_fI_),
        /*<<op_set.ml 787 8>>*/ _fJ_=[0,[0,change,allDeps],0],
        /*<<op_set.ml 787 8>>*/ _fK_=List[11],
        /*<<op_set.ml 790 22>>*/ new_prior=
         /*<<op_set.ml 790 22>>*/ caml_call2(_fK_,prior,_fJ_),
        /*<<op_set.ml 790 22>>*/ _fL_=t[10],
        /*<<op_set.ml 790 22>>*/ _fM_=t[9],
        /*<<op_set.ml 790 22>>*/ _fN_=t[8],
        /*<<op_set.ml 790 22>>*/ _fO_=t[7],
        /*<<op_set.ml 790 22>>*/ _fP_=t[6],
        /*<<op_set.ml 790 22>>*/ _fQ_=t[5],
        /*<<op_set.ml 790 22>>*/ _fR_=t[4],
        /*<<op_set.ml 790 22>>*/ _fS_=t[3],
        /*<<op_set.ml 790 22>>*/ _fT_=t[2],
        /*<<op_set.ml 790 22>>*/ _fU_=t[1],
        /*<<op_set.ml 790 22>>*/ _fV_=change[1],
        /*<<op_set.ml 790 22>>*/ _fW_=ActorMap[4],
        /*<<op_set.ml 791 30>>*/ t$0=
        [0,
          /*<<op_set.ml 791 30>>*/ caml_call3(_fW_,_fV_,new_prior,_fU_),
         _fT_,
         _fS_,
         _fR_,
         _fQ_,
         _fP_,
         _fO_,
         _fN_,
         _fM_,
         _fL_],
        /*<<op_set.ml 791 30>>*/ _fX_=change[4];
       /*<<op_set.ml 791 30>>*/ function _fY_(ch_op)
       { /*<<op_set.ml 797 12>>*/ var
          /*<<op_set.ml 797 12>>*/ _gl_=ch_op[1],
          /*<<op_set.ml 797 12>>*/ _gf_=ch_op[5],
          /*<<op_set.ml 797 12>>*/ _gg_=ch_op[4],
          /*<<op_set.ml 797 12>>*/ _gh_=ch_op[3],
          /*<<op_set.ml 797 12>>*/ _gi_=change[2],
          /*<<op_set.ml 797 12>>*/ _gj_=change[1],
          /*<<op_set.ml 797 12>>*/ _gk_=ch_op[2];
         /*<<op_set.ml 797 12>>*/ if(_gl_)
          /*<<op_set.ml 800 51>>*/ var
           /*<<op_set.ml 800 51>>*/ k=_gl_[1],
          k$0=k;
        else
         var k$0=cst$1;
        return [0,k$0,_gk_,_gj_,_gi_,_gh_,_gg_,_gf_] /*<<op_set.ml 803 34>>*/ }
       /*<<op_set.ml 791 30>>*/ var
        /*<<op_set.ml 791 30>>*/ _fZ_=CCList[33],
        /*<<op_set.ml 795 8>>*/ ops=
         /*<<op_set.ml 795 8>>*/ caml_call2(_fZ_,_fY_,_fX_),
        /*<<op_set.ml 806 21>>*/ match$0=
         /*<<op_set.ml 806 21>>*/ apply_ops(t$0,ops),
        /*<<op_set.ml 806 21>>*/ diffs=match$0[2],
        /*<<op_set.ml 806 21>>*/ t$1=match$0[1],
        /*<<op_set.ml 806 21>>*/ _f0_=t$1[5];
       /*<<op_set.ml 806 21>>*/ function _f1_(depActor,depSeq)
       { /*<<op_set.ml 810 12>>*/ var
          /*<<op_set.ml 810 12>>*/ _gd_=0,
          /*<<op_set.ml 810 12>>*/ _ge_=ActorMap[28];
         /*<<op_set.ml 810 21>>*/ return  /*<<op_set.ml 810 21>>*/ caml_call3
                 (_ge_,depActor,allDeps,_gd_)
                <
                depSeq
                ?1
                :0 /*<<op_set.ml 810 64>>*/ }
       /*<<op_set.ml 806 21>>*/ var
        /*<<op_set.ml 806 21>>*/ _f2_=ActorMap[14],
        /*<<op_set.ml 808 8>>*/ _f3_=
         /*<<op_set.ml 808 8>>*/ caml_call2(_f2_,_f1_,_f0_),
        /*<<op_set.ml 808 8>>*/ _f4_=change[2],
        /*<<op_set.ml 808 8>>*/ _f5_=change[1],
        /*<<op_set.ml 808 8>>*/ _f6_=ActorMap[4],
        /*<<op_set.ml 808 8>>*/ remaining_deps=
         /*<<op_set.ml 808 8>>*/ caml_call3(_f6_,_f5_,_f4_,_f3_),
        /*<<op_set.ml 808 8>>*/ _f7_=LLog[2];
       /*<<op_set.ml 814 6>>*/  /*<<op_set.ml 814 6>>*/ caml_call1
       (_f7_,remaining_deps);
       /*<<op_set.ml 806 21>>*/ var
        /*<<op_set.ml 814 6>>*/ _f8_=t$1[4],
        /*<<op_set.ml 814 6>>*/ _f9_=change[2],
        /*<<op_set.ml 814 6>>*/ _f__=change[1],
        /*<<op_set.ml 814 6>>*/ _f$_=ActorMap[4],
        /*<<op_set.ml 815 18>>*/ clock=
         /*<<op_set.ml 815 18>>*/ caml_call3(_f$_,_f__,_f9_,_f8_),
        /*<<op_set.ml 815 18>>*/ _ga_=[0,change,0],
        /*<<op_set.ml 815 18>>*/ _gb_=t$1[2],
        /*<<op_set.ml 815 18>>*/ _gc_=List[11],
        /*<<op_set.ml 816 20>>*/ history=
         /*<<op_set.ml 816 20>>*/ caml_call2(_gc_,_gb_,_ga_);
       /*<<op_set.ml 816 20>>*/ return [0,
              [0,
               t$1[1],
               history,
               t$1[3],
               clock,
               remaining_deps,
               t$1[6],
               t$1[7],
               t$1[8],
               t$1[9],
               t$1[10]],
              diffs] /*<<op_set.ml 817 60>>*/ }
    function apply_queued_ops(t,diffs)
     {var t$0=t,diffs$0=diffs;
       /*<<op_set.ml 832 4>>*/ for(;;)
       { /*<<op_set.ml 832 4>>*/ var
          /*<<op_set.ml 832 4>>*/ _fg_=t$0[9],
          /*<<op_set.ml 832 4>>*/ _fh_=[0,t$0,diffs$0,Datastructures[5][1]],
          /*<<op_set.ml 832 4>>*/ _fi_=
          function(param,change)
           { /*<<op_set.ml 834 8>>*/ var
              /*<<op_set.ml 834 8>>*/ queue=param[3],
              /*<<op_set.ml 834 8>>*/ diffs=param[2],
              /*<<op_set.ml 834 8>>*/ t=param[1];
             /*<<op_set.ml 835 13>>*/ if
             ( /*<<op_set.ml 835 13>>*/ causaly_ready(t,change))
             { /*<<op_set.ml 836 26>>*/ var
                /*<<op_set.ml 836 26>>*/ match=
                 /*<<op_set.ml 836 26>>*/ apply_change(t,change),
                /*<<op_set.ml 836 26>>*/ diff=match[2],
                /*<<op_set.ml 836 26>>*/ t$0=match[1],
                /*<<op_set.ml 836 26>>*/ _fq_=[0,diffs,[0,diff,0]],
                /*<<op_set.ml 836 26>>*/ _fr_=CCList[7];
               /*<<op_set.ml 837 16>>*/ return [0,
                      t$0,
                       /*<<op_set.ml 837 16>>*/ caml_call1(_fr_,_fq_),
                      queue]}
             /*<<op_set.ml 834 8>>*/ var
              /*<<op_set.ml 838 15>>*/ _fs_=t[9],
              /*<<op_set.ml 838 15>>*/ _ft_=CCFQueue[7];
             /*<<op_set.ml 838 26>>*/ return [0,
                    t,
                    diffs,
                     /*<<op_set.ml 838 26>>*/ caml_call2(_ft_,_fs_,change)] /*<<op_set.ml 838 57>>*/ },
          /*<<op_set.ml 832 4>>*/ _fj_=CCFQueue[29],
          /*<<op_set.ml 833 6>>*/ match=
           /*<<op_set.ml 833 6>>*/ caml_call3(_fj_,_fi_,_fh_,_fg_),
          /*<<op_set.ml 833 6>>*/ queue=match[3],
          /*<<op_set.ml 833 6>>*/ diffs$1=match[2],
          /*<<op_set.ml 833 6>>*/ t$1=match[1],
          /*<<op_set.ml 833 6>>*/ _fk_=t$1[9],
          /*<<op_set.ml 833 6>>*/ _fl_=CCFQueue[28],
          /*<<op_set.ml 842 41>>*/ _fm_=
           /*<<op_set.ml 842 41>>*/ caml_call1(_fl_,_fk_),
          /*<<op_set.ml 842 41>>*/ _fn_=CCFQueue[28],
          /*<<op_set.ml 842 19>>*/ _fo_=
           /*<<op_set.ml 842 19>>*/ caml_call1(_fn_,queue),
          /*<<op_set.ml 842 19>>*/ _fp_=Datastructures[2][2];
         /*<<op_set.ml 842 7>>*/ if
         ( /*<<op_set.ml 842 7>>*/ caml_call2(_fp_,_fo_,_fm_))
         return [0,t$1,diffs$1];
         /*<<op_set.ml 832 4>>*/ var
          /*<<op_set.ml 843 9>>*/ t$2=
          [0,
           t$1[1],
           t$1[2],
           t$1[3],
           t$1[4],
           t$1[5],
           t$1[6],
           t$1[7],
           t$1[8],
           queue,
           t$1[10]],
         t$0=t$2,
         diffs$0=diffs$1;
        continue} /*<<op_set.ml 843 46>>*/ }
    function push_undo_history(t)
     { /*<<op_set.ml 846 4>>*/ var
        /*<<op_set.ml 846 4>>*/ _e9_=0,
        /*<<op_set.ml 846 4>>*/ _e__=t[10],
        /*<<op_set.ml 846 4>>*/ _e$_=CCOpt[20],
        /*<<op_set.ml 849 9>>*/ _fa_=
        [0, /*<<op_set.ml 849 9>>*/ caml_call1(_e$_,_e__),_e9_],
        /*<<op_set.ml 849 9>>*/ _fb_=t[7],
        /*<<op_set.ml 849 9>>*/ _fc_=t[6],
        /*<<op_set.ml 849 9>>*/ _fd_=CCList[77],
        /*<<op_set.ml 848 8>>*/ _fe_=
         /*<<op_set.ml 848 8>>*/ caml_call2(_fd_,_fc_,_fb_),
        /*<<op_set.ml 848 8>>*/ _ff_=CCList[36],
        /*<<op_set.ml 847 6>>*/ undo_stack=
         /*<<op_set.ml 847 6>>*/ caml_call2(_ff_,_fe_,_fa_);
       /*<<op_set.ml 847 6>>*/ return [0,
              t[1],
              t[2],
              t[3],
              t[4],
              t[5],
              t[6] + 1 | 0,
              undo_stack,
              0,
              t[9],
              0] /*<<op_set.ml 852 78>>*/ }
    function add_change(init,change,isUndoable)
     { /*<<op_set.ml 855 4>>*/ var
        /*<<op_set.ml 855 4>>*/ _e4_=init[10],
        /*<<op_set.ml 855 4>>*/ _e5_=init[9],
        /*<<op_set.ml 855 4>>*/ _e6_=CCFQueue[7],
        /*<<op_set.ml 855 27>>*/ _e7_=
         /*<<op_set.ml 855 27>>*/ caml_call2(_e6_,_e5_,change),
        /*<<op_set.ml 855 27>>*/ t=
        [0,
         init[1],
         init[2],
         init[3],
         init[4],
         init[5],
         init[6],
         init[7],
         init[8],
         _e7_,
         _e4_];
       /*<<op_set.ml 855 27>>*/ if(isUndoable)
       { /*<<op_set.ml 857 6>>*/ var
          /*<<op_set.ml 857 6>>*/ t$0=
          [0,t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],_aY_],
          /*<<op_set.ml 857 6>>*/ _e8_=0,
          /*<<op_set.ml 858 21>>*/ match=
           /*<<op_set.ml 858 21>>*/ apply_queued_ops(t$0,_e8_),
          /*<<op_set.ml 858 21>>*/ diffs=match[2],
          /*<<op_set.ml 858 21>>*/ t$1=match[1],
          /*<<op_set.ml 859 14>>*/ t$2=
           /*<<op_set.ml 859 14>>*/ push_undo_history(t$1);
         /*<<op_set.ml 859 14>>*/ return [0,t$2,diffs]}
       /*<<op_set.ml 861 9>>*/ return  /*<<op_set.ml 861 9>>*/ apply_queued_ops
              (t,0) /*<<op_set.ml 861 30>>*/ }
    function init(param)
     { /*<<op_set.ml 864 4>>*/ var
        /*<<op_set.ml 864 4>>*/ root_obj=
        [0,KeyMap[1],[0,0,KeyMap[1],root_op,OpSet[1],0,ElemIdMap[1]]],
        /*<<op_set.ml 864 4>>*/ _eU_=0,
        /*<<op_set.ml 864 4>>*/ _eV_=CCFQueue[1],
        /*<<op_set.ml 864 4>>*/ _eW_=0,
        /*<<op_set.ml 864 4>>*/ _eX_=0,
        /*<<op_set.ml 864 4>>*/ _eY_=0,
        /*<<op_set.ml 864 4>>*/ _eZ_=ActorMap[1],
        /*<<op_set.ml 864 4>>*/ _e0_=ActorMap[1],
        /*<<op_set.ml 864 4>>*/ _e1_=ObjectIdMap[1],
        /*<<op_set.ml 864 4>>*/ _e2_=ObjectIdMap[4],
        /*<<op_set.ml 884 17>>*/ _e3_=
         /*<<op_set.ml 884 17>>*/ caml_call3(_e2_,root_id,root_obj,_e1_);
       /*<<op_set.ml 884 17>>*/ return [0,
              ActorMap[1],
              0,
              _e3_,
              _e0_,
              _eZ_,
              _eY_,
              _eX_,
              _eW_,
              _eV_,
              _eU_] /*<<op_set.ml 891 24>>*/ }
    function get_missing_changes(t,have_deps)
     { /*<<op_set.ml 896 19>>*/ var
        /*<<op_set.ml 896 19>>*/ all_deps=
         /*<<op_set.ml 896 19>>*/ transitive_deps(t,have_deps),
        /*<<op_set.ml 896 19>>*/ _eG_=t[1];
       /*<<op_set.ml 896 19>>*/ function _eH_(actor,states)
       { /*<<op_set.ml 899 8>>*/ var
          /*<<op_set.ml 899 8>>*/ _eR_=0,
          /*<<op_set.ml 899 8>>*/ _eS_=ActorMap[28],
          /*<<op_set.ml 899 20>>*/ _eT_=
           /*<<op_set.ml 899 20>>*/ caml_call3(_eS_,actor,all_deps,_eR_);
         /*<<op_set.ml 899 20>>*/ return  /*<<op_set.ml 899 20>>*/ caml_call2
                (CCList[78],_eT_,states) /*<<op_set.ml 899 70>>*/ }
       /*<<op_set.ml 896 19>>*/ var
        /*<<op_set.ml 896 19>>*/ _eI_=ActorMap[26],
        /*<<op_set.ml 897 4>>*/ _eJ_=
         /*<<op_set.ml 897 4>>*/ caml_call2(_eI_,_eH_,_eG_),
        /*<<op_set.ml 897 4>>*/ _eK_=ActorMap[44],
        /*<<op_set.ml 897 4>>*/ _eL_=
         /*<<op_set.ml 897 4>>*/ caml_call1(_eK_,_eJ_),
        /*<<op_set.ml 897 4>>*/ _eM_=CCList[146],
        /*<<op_set.ml 897 4>>*/ _eN_=
         /*<<op_set.ml 897 4>>*/ caml_call1(_eM_,_eL_),
        /*<<op_set.ml 897 4>>*/ _eO_=CCList[57],
        /*<<op_set.ml 897 4>>*/ _eP_=
         /*<<op_set.ml 897 4>>*/ caml_call1(_eO_,_eN_);
       /*<<op_set.ml 897 4>>*/ function _eQ_(state)
       { /*<<op_set.ml 902 32>>*/ return state[1] /*<<op_set.ml 902 44>>*/ }
       /*<<op_set.ml 897 4>>*/ return  /*<<op_set.ml 897 4>>*/ caml_call2
              (CCList[33],_eQ_,_eP_) /*<<op_set.ml 902 45>>*/ }
    function get_changes_for_actor(t,opt,for_actor)
     { /*<<op_set.ml 905 4>>*/ if(opt)
        /*<<op_set.ml 904 44>>*/ var
         /*<<op_set.ml 904 44>>*/ sth=opt[1],
        after_seq=sth;
      else
       var after_seq=0;
       /*<<op_set.ml 905 4>>*/  /*<<op_set.ml 905 4>>*/ var _es_=t[1];
       /*<<op_set.ml 905 4>>*/ function _et_(actor,states)
       { /*<<op_set.ml 905 41>>*/ return  /*<<op_set.ml 905 41>>*/ caml_call2
                (String[34],actor,for_actor) /*<<op_set.ml 905 69>>*/ }
       /*<<op_set.ml 905 4>>*/ var
        /*<<op_set.ml 905 4>>*/ _eu_=ActorMap[14],
        /*<<op_set.ml 905 4>>*/ _ev_=
         /*<<op_set.ml 905 4>>*/ caml_call2(_eu_,_et_,_es_);
       /*<<op_set.ml 905 4>>*/ function _ew_(states)
       { /*<<op_set.ml 906 35>>*/ return  /*<<op_set.ml 906 35>>*/ caml_call2
                (CCList[78],after_seq,states) /*<<op_set.ml 906 63>>*/ }
       /*<<op_set.ml 905 4>>*/ var
        /*<<op_set.ml 905 4>>*/ _ex_=ActorMap[25],
        /*<<op_set.ml 905 4>>*/ _ey_=
         /*<<op_set.ml 905 4>>*/ caml_call2(_ex_,_ew_,_ev_),
        /*<<op_set.ml 905 4>>*/ _ez_=ActorMap[44],
        /*<<op_set.ml 905 4>>*/ _eA_=
         /*<<op_set.ml 905 4>>*/ caml_call1(_ez_,_ey_),
        /*<<op_set.ml 905 4>>*/ _eB_=CCList[146],
        /*<<op_set.ml 905 4>>*/ _eC_=
         /*<<op_set.ml 905 4>>*/ caml_call1(_eB_,_eA_),
        /*<<op_set.ml 905 4>>*/ _eD_=CCList[57],
        /*<<op_set.ml 905 4>>*/ _eE_=
         /*<<op_set.ml 905 4>>*/ caml_call1(_eD_,_eC_);
       /*<<op_set.ml 905 4>>*/ function _eF_(state)
       { /*<<op_set.ml 908 32>>*/ return state[1] /*<<op_set.ml 908 44>>*/ }
       /*<<op_set.ml 905 4>>*/ return  /*<<op_set.ml 905 4>>*/ caml_call2
              (CCList[33],_eF_,_eE_) /*<<op_set.ml 908 45>>*/ }
    function get_missing_deps(t)
     { /*<<op_set.ml 911 4>>*/ var
        /*<<op_set.ml 911 4>>*/ _ed_=t[9],
        /*<<op_set.ml 911 4>>*/ _ee_=ActorMap[1];
       /*<<op_set.ml 911 4>>*/ function _ef_(missing,change)
       { /*<<op_set.ml 913 8>>*/ var
          /*<<op_set.ml 913 8>>*/ _eg_=change[3],
          /*<<op_set.ml 913 8>>*/ _eh_=change[2] - 1 | 0,
          /*<<op_set.ml 913 8>>*/ _ei_=change[1],
          /*<<op_set.ml 913 8>>*/ _ej_=ActorMap[4],
          /*<<op_set.ml 913 19>>*/ deps=
           /*<<op_set.ml 913 19>>*/ caml_call3(_ej_,_ei_,_eh_,_eg_);
         /*<<op_set.ml 913 19>>*/ function _ek_(depActor,depSeq,missing)
         { /*<<op_set.ml 916 12>>*/ var
            /*<<op_set.ml 916 12>>*/ _el_=0,
            /*<<op_set.ml 916 12>>*/ _em_=t[4],
            /*<<op_set.ml 916 12>>*/ _en_=ActorMap[28];
           /*<<op_set.ml 916 15>>*/ if
           ( /*<<op_set.ml 916 15>>*/ caml_call3(_en_,depActor,_em_,_el_)
            <
            depSeq)
           { /*<<op_set.ml 917 14>>*/ var
              /*<<op_set.ml 917 14>>*/ _eo_=0,
              /*<<op_set.ml 917 14>>*/ _ep_=ActorMap[28],
              /*<<op_set.ml 917 25>>*/ curr=
               /*<<op_set.ml 917 25>>*/ caml_call3(_ep_,depActor,missing,_eo_),
              /*<<op_set.ml 917 25>>*/ _eq_=Pervasives[5],
              /*<<op_set.ml 918 36>>*/ _er_=
               /*<<op_set.ml 918 36>>*/ caml_call2(_eq_,depSeq,curr);
             /*<<op_set.ml 918 36>>*/ return  /*<<op_set.ml 918 36>>*/ caml_call3
                    (ActorMap[4],depActor,_er_,missing)}
           /*<<op_set.ml 919 17>>*/ return missing /*<<op_set.ml 919 24>>*/ }
         /*<<op_set.ml 913 19>>*/ return  /*<<op_set.ml 913 19>>*/ caml_call3
                (ActorMap[11],_ek_,missing,deps) /*<<op_set.ml 920 22>>*/ }
       /*<<op_set.ml 911 4>>*/ return  /*<<op_set.ml 911 4>>*/ caml_call3
              (CCFQueue[29],_ef_,_ee_,_ed_) /*<<op_set.ml 921 28>>*/ }
    function valid_field_name(key)
     { /*<<op_set.ml 924 29>>*/  /*<<op_set.ml 924 29>>*/ var
       _d$_=
        cst$2 !== key?1:0;
       /*<<op_set.ml 924 29>>*/ if(_d$_)
       var
        _ea_=1,
        _eb_=Str[29],
        _ec_=cst$3 !==  /*<<op_set.ml 924 42>>*/ caml_call2(_eb_,key,_ea_)?1:0;
      else
       var _ec_=_d$_;
      return _ec_ /*<<op_set.ml 924 70>>*/ }
    function is_field_present(t,obj_id,key)
     { /*<<op_set.ml 927 4>>*/  /*<<op_set.ml 927 4>>*/ var
       _d7_=
         /*<<op_set.ml 927 4>>*/ valid_field_name(key);
       /*<<op_set.ml 927 4>>*/ if(_d7_)
        /*<<op_set.ml 927 49>>*/ var
         /*<<op_set.ml 927 49>>*/ _d8_=
          /*<<op_set.ml 927 49>>*/ get_field_ops(t,obj_id,key),
         /*<<op_set.ml 927 49>>*/ _d9_=CCList[32],
        _d__=1 -  /*<<op_set.ml 927 32>>*/ caml_call1(_d9_,_d8_);
      else
       var _d__=_d7_;
       /*<<op_set.ml 924 29>>*/ return _d__ /*<<op_set.ml 927 78>>*/ }
    function unpack_value(parent_id,patch_diff,children,value)
     { /*<<op_set.ml 930 4>>*/ if(0 === value[0])
       { /*<<op_set.ml 943 22>>*/  /*<<op_set.ml 943 22>>*/ var v=value[1];
         /*<<op_set.ml 943 22>>*/ return [0,
                [0,
                 patch_diff[1],
                 patch_diff[2],
                 patch_diff[3],
                 patch_diff[4],
                 [0,v],
                 patch_diff[6],
                 patch_diff[7],
                 patch_diff[8],
                 patch_diff[9]],
                children]}
       /*<<op_set.ml 932 8>>*/  /*<<op_set.ml 932 8>>*/ var
       patch_diff$0=
        [0,
         patch_diff[1],
         patch_diff[2],
         patch_diff[3],
         patch_diff[4],
         [0,[1,value[1]]],
         _aZ_,
         patch_diff[7],
         patch_diff[8],
         patch_diff[9]];
       /*<<op_set.ml 932 8>>*/ function _d3_(param)
       { /*<<op_set.ml 937 12>>*/ if(param)
         { /*<<op_set.ml 938 31>>*/ var
            /*<<op_set.ml 938 31>>*/ childs=param[1],
            /*<<op_set.ml 938 31>>*/ _d5_=[0,value[1],0],
            /*<<op_set.ml 938 31>>*/ _d6_=CCList[36];
           /*<<op_set.ml 938 36>>*/ return [0,
                   /*<<op_set.ml 938 36>>*/ caml_call2(_d6_,childs,_d5_)]}
         /*<<op_set.ml 939 24>>*/ throw [0,Invalid_argument,cst_child_id] /*<<op_set.ml 939 60>>*/ }
       /*<<op_set.ml 932 8>>*/ var
        /*<<op_set.ml 932 8>>*/ _d4_=ChildMap[29],
        /*<<op_set.ml 936 10>>*/ children$0=
         /*<<op_set.ml 936 10>>*/ caml_call3(_d4_,parent_id,_d3_,children);
       /*<<op_set.ml 936 10>>*/ return [0,patch_diff$0,children$0] /*<<op_set.ml 943 65>>*/ }
    function unpack_conflict_value(parent_id,conflict,children,value)
     { /*<<op_set.ml 946 4>>*/ if(0 === value[0])
       { /*<<op_set.ml 959 22>>*/  /*<<op_set.ml 959 22>>*/ var v=value[1];
         /*<<op_set.ml 959 22>>*/ return [0,
                [0,conflict[1],[0,v],conflict[3]],
                children]}
       /*<<op_set.ml 948 8>>*/  /*<<op_set.ml 948 8>>*/ var
       patch_diff=
        [0,conflict[1],[0,[1,value[1]]],_a0_];
       /*<<op_set.ml 948 8>>*/ function _dZ_(param)
       { /*<<op_set.ml 953 12>>*/ if(param)
         { /*<<op_set.ml 954 31>>*/ var
            /*<<op_set.ml 954 31>>*/ childs=param[1],
            /*<<op_set.ml 954 31>>*/ _d1_=[0,value[1],0],
            /*<<op_set.ml 954 31>>*/ _d2_=CCList[36];
           /*<<op_set.ml 954 36>>*/ return [0,
                   /*<<op_set.ml 954 36>>*/ caml_call2(_d2_,childs,_d1_)]}
         /*<<op_set.ml 955 24>>*/ throw [0,Invalid_argument,cst_child_id$0] /*<<op_set.ml 955 60>>*/ }
       /*<<op_set.ml 948 8>>*/ var
        /*<<op_set.ml 948 8>>*/ _d0_=ChildMap[29],
        /*<<op_set.ml 952 10>>*/ children$0=
         /*<<op_set.ml 952 10>>*/ caml_call3(_d0_,parent_id,_dZ_,children);
       /*<<op_set.ml 952 10>>*/ return [0,patch_diff,children$0] /*<<op_set.ml 959 63>>*/ }
    function unpack_conflicts(parent_id,patch_diff,children,conflicts)
     { /*<<op_set.ml 962 4>>*/  /*<<op_set.ml 962 4>>*/ var
       _dU_=
        [0,0,children];
       /*<<op_set.ml 962 4>>*/ function _dV_(actor,value,param)
       { /*<<op_set.ml 964 8>>*/ var
          /*<<op_set.ml 964 8>>*/ children=param[2],
          /*<<op_set.ml 964 8>>*/ conflicts=param[1],
          /*<<op_set.ml 964 8>>*/ conflict=[0,actor,0,0],
          /*<<op_set.ml 967 12>>*/ match=
           /*<<op_set.ml 967 12>>*/ unpack_conflict_value
           (parent_id,conflict,children,value),
          /*<<op_set.ml 967 12>>*/ children$0=match[2],
          /*<<op_set.ml 967 12>>*/ conflict$0=match[1],
          /*<<op_set.ml 967 12>>*/ _dX_=[0,conflict$0,0],
          /*<<op_set.ml 967 12>>*/ _dY_=CCList[36];
         /*<<op_set.ml 969 11>>*/ return [0,
                 /*<<op_set.ml 969 11>>*/ caml_call2(_dY_,conflicts,_dX_),
                children$0] /*<<op_set.ml 969 58>>*/ }
       /*<<op_set.ml 962 4>>*/ var
        /*<<op_set.ml 962 4>>*/ _dW_=OpMap[11],
        /*<<op_set.ml 963 6>>*/ match=
         /*<<op_set.ml 963 6>>*/ caml_call3(_dW_,_dV_,conflicts,_dU_),
        /*<<op_set.ml 963 6>>*/ children$0=match[2],
        /*<<op_set.ml 963 6>>*/ conflicts$0=match[1];
       /*<<op_set.ml 963 6>>*/ return [0,
              [0,
               patch_diff[1],
               patch_diff[2],
               patch_diff[3],
               patch_diff[4],
               patch_diff[5],
               patch_diff[6],
               patch_diff[7],
               patch_diff[8],
               [0,conflicts$0]],
              children$0] /*<<op_set.ml 972 59>>*/ }
    function get_object_fields(t,obj_id)
     { /*<<op_set.ml 976 4>>*/  /*<<op_set.ml 976 4>>*/ var _dB_=KeySet[38];
       /*<<op_set.ml 976 4>>*/ function _dC_(key)
       { /*<<op_set.ml 978 34>>*/ return  /*<<op_set.ml 978 34>>*/ is_field_present
                (t,obj_id,key) /*<<op_set.ml 978 63>>*/ }
       /*<<op_set.ml 976 4>>*/ var
        /*<<op_set.ml 976 4>>*/ _dD_=CCList[39],
        /*<<op_set.ml 978 8>>*/ _dE_=
         /*<<op_set.ml 978 8>>*/ caml_call1(_dD_,_dC_),
        /*<<op_set.ml 978 8>>*/ _dF_=CCList[146],
        /*<<op_set.ml 978 8>>*/ _dG_=KeyMap[43];
       /*<<op_set.ml 978 8>>*/ function _dH_(_dT_){ /*<<?>>*/ return _dT_[1]}
       /*<<op_set.ml 978 8>>*/ var
        /*<<op_set.ml 978 8>>*/ _dI_=t[3],
        /*<<op_set.ml 978 8>>*/ _dJ_=ObjectIdMap[27],
        /*<<op_set.ml 976 4>>*/ _dK_=
         /*<<op_set.ml 976 4>>*/ caml_call2(_dJ_,obj_id,_dI_),
        /*<<op_set.ml 976 4>>*/ _dL_=CCOpt[34][1],
        /*<<op_set.ml 976 4>>*/ _dM_=
         /*<<op_set.ml 976 4>>*/ caml_call2(_dL_,_dK_,_dH_),
        /*<<op_set.ml 976 4>>*/ _dN_=CCOpt[34][1],
        /*<<op_set.ml 976 4>>*/ _dO_=
         /*<<op_set.ml 976 4>>*/ caml_call2(_dN_,_dM_,_dG_),
        /*<<op_set.ml 976 4>>*/ _dP_=CCOpt[34][1],
        /*<<op_set.ml 976 4>>*/ _dQ_=
         /*<<op_set.ml 976 4>>*/ caml_call2(_dP_,_dO_,_dF_),
        /*<<op_set.ml 976 4>>*/ _dR_=CCOpt[34][1],
        /*<<op_set.ml 976 4>>*/ _dS_=
         /*<<op_set.ml 976 4>>*/ caml_call2(_dR_,_dQ_,_dE_);
       /*<<op_set.ml 976 4>>*/ return  /*<<op_set.ml 976 4>>*/ caml_call2
              (CCOpt[34][1],_dS_,_dB_) /*<<op_set.ml 979 22>>*/ }
    function sexp_of_iterator_mode(param)
     { /*<<op_set.ml 981 2>>*/ switch(param)
       {case 0: /*<<op_set.ml 981 23>>*/ return _a1_;
        case 1: /*<<op_set.ml 981 28>>*/ return _a2_;
        case 2: /*<<op_set.ml 981 37>>*/ return _a3_;
        case 3: /*<<op_set.ml 981 47>>*/ return _a4_;
        default: /*<<op_set.ml 981 55>>*/ return _a5_} /*<<op_set.ml 982 22>>*/ }
    function sexp_of_iterator_val(param)
     { /*<<op_set.ml 984 2>>*/ switch(param[0])
       {case 0:
          /*<<op_set.ml 985 4>>*/ var
           /*<<op_set.ml 985 4>>*/ v0=param[1],
           /*<<op_set.ml 985 4>>*/ _du_=Sexplib_Conv[10],
           /*<<op_set.ml 985 4>>*/ v0$0=
            /*<<op_set.ml 985 4>>*/ caml_call1(_du_,v0);
          /*<<op_set.ml 985 4>>*/ return [1,[0,_a6_,[0,v0$0,0]]];
        case 1:
          /*<<op_set.ml 986 4>>*/ var
           /*<<op_set.ml 986 4>>*/ v0$1=param[1],
           /*<<op_set.ml 986 4>>*/ _dv_=Sexplib_Conv[17],
           /*<<op_set.ml 986 33>>*/ v0$2=
            /*<<op_set.ml 986 33>>*/ caml_call2
            (_dv_,sexp_of_materialized,v0$1);
          /*<<op_set.ml 986 33>>*/ return [1,[0,_a7_,[0,v0$2,0]]];
        case 2:
          /*<<op_set.ml 987 4>>*/ var
          v1=param[2],
          v0$3=param[1],
          _dw_=Sexplib_Conv[10],
           /*<<op_set.ml 987 4>>*/ v0$4=
            /*<<op_set.ml 987 4>>*/ caml_call1(_dw_,v0$3),
           /*<<op_set.ml 987 4>>*/ _dx_=Sexplib_Conv[17],
           /*<<op_set.ml 987 39>>*/ v1$0=
            /*<<op_set.ml 987 39>>*/ caml_call2(_dx_,sexp_of_materialized,v1);
          /*<<op_set.ml 987 39>>*/ return [1,[0,_a8_,[0,v0$4,[0,v1$0,0]]]];
        case 3:
          /*<<op_set.ml 988 4>>*/ var
          v1$1=param[2],
          v0$5=param[1],
          _dy_=Sexplib_Conv[10],
           /*<<op_set.ml 988 4>>*/ v0$6=
            /*<<op_set.ml 988 4>>*/ caml_call1(_dy_,v0$5),
           /*<<op_set.ml 988 4>>*/ _dz_=Sexplib_Conv[7],
           /*<<op_set.ml 988 4>>*/ v1$2=
            /*<<op_set.ml 988 4>>*/ caml_call1(_dz_,v1$1);
          /*<<op_set.ml 988 4>>*/ return [1,[0,_a9_,[0,v0$6,[0,v1$2,0]]]];
        default:
          /*<<op_set.ml 989 4>>*/ var
           /*<<op_set.ml 989 4>>*/ v0$7=param[1],
           /*<<op_set.ml 989 4>>*/ _dA_=OpMap[47],
           /*<<op_set.ml 989 36>>*/ v0$8=
            /*<<op_set.ml 989 36>>*/ caml_call2
            (_dA_,sexp_of_materialized,v0$7);
          /*<<op_set.ml 989 36>>*/ return [1,[0,_a__,[0,v0$8,0]]]} /*<<op_set.ml 990 22>>*/ }
    function sexp_of_iterator_res(param)
     { /*<<op_set.ml 992 2>>*/ var
        /*<<op_set.ml 992 2>>*/ v_value=param[2],
        /*<<op_set.ml 992 2>>*/ v_done=param[1],
        /*<<op_set.ml 992 2>>*/ bnds=0,
        /*<<op_set.ml 992 2>>*/ _ds_=Sexplib_Conv[17],
        /*<<op_set.ml 992 56>>*/ arg=
         /*<<op_set.ml 992 56>>*/ caml_call2
         (_ds_,sexp_of_iterator_val,v_value),
        /*<<op_set.ml 992 56>>*/ bnds$0=[0,[1,[0,_a$_,[0,arg,0]]],bnds],
        /*<<op_set.ml 992 56>>*/ _dt_=Sexplib_Conv[6],
        /*<<op_set.ml 992 23>>*/ arg$0=
         /*<<op_set.ml 992 23>>*/ caml_call1(_dt_,v_done),
        /*<<op_set.ml 992 23>>*/ bnds$1=[0,[1,[0,_ba_,[0,arg$0,0]]],bnds$0];
       /*<<op_set.ml 992 23>>*/ return [1,bnds$1] /*<<op_set.ml 993 22>>*/ }
    function sexp_of_iterator(param)
     { /*<<op_set.ml 995 2>>*/ var
        /*<<op_set.ml 995 2>>*/ v_next=param[1],
        /*<<op_set.ml 995 2>>*/ bnds=0;
       /*<<op_set.ml 995 2>>*/ function _dp_(f)
       { /*<<op_set.ml 997 11>>*/ function _dq_(_dr_){ /*<<?>>*/ return 0}
         /*<<op_set.ml 997 11>>*/ return  /*<<op_set.ml 997 11>>*/ caml_call1
                (Sexplib0_Sexp_conv[24],_dq_) /*<<op_set.ml 998 76>>*/ }
       /*<<op_set.ml 996 6>>*/ var
        /*<<op_set.ml 996 6>>*/ arg= /*<<op_set.ml 996 6>>*/ _dp_(v_next),
        /*<<op_set.ml 996 6>>*/ bnds$0=[0,[1,[0,_bb_,[0,arg,0]]],bnds];
       /*<<op_set.ml 996 6>>*/ return [1,bnds$0] /*<<op_set.ml 999 22>>*/ }
    function instantiate_object(t,obj_id,param)
     { /*<<op_set.ml 1002 10>>*/ var
       children=param[2],
       diffs=param[1],
       _dg_=DiffMap[33],
        /*<<op_set.ml 1002 10>>*/ match=
         /*<<op_set.ml 1002 10>>*/ caml_call2(_dg_,obj_id,diffs);
       /*<<op_set.ml 1002 10>>*/ if(match)
       return [0,diffs,children,[1,obj_id]];
       /*<<op_set.ml 1002 10>>*/ var
        /*<<op_set.ml 1005 8>>*/ _dh_=String[34],
        /*<<op_set.ml 1005 22>>*/ is_root=
         /*<<op_set.ml 1005 22>>*/ caml_call2(_dh_,obj_id,root_id),
        /*<<op_set.ml 1006 22>>*/ obj_typ=
         /*<<op_set.ml 1006 22>>*/ get_obj_action(t,obj_id),
        /*<<op_set.ml 1006 22>>*/ _di_=0,
        /*<<op_set.ml 1006 22>>*/ _dj_=ChildMap[4],
        /*<<op_set.ml 1008 40>>*/ _dk_=
         /*<<op_set.ml 1008 40>>*/ caml_call3(_dj_,obj_id,_di_,children),
        /*<<op_set.ml 1008 40>>*/ _dl_=0,
        /*<<op_set.ml 1008 40>>*/ _dm_=DiffMap[4],
        /*<<op_set.ml 1008 11>>*/ context=
        [0, /*<<op_set.ml 1008 11>>*/ caml_call3(_dm_,obj_id,_dl_,diffs),_dk_];
       /*<<op_set.ml 1008 11>>*/ if(is_root)
       var
        match$0=
          /*<<op_set.ml 1011 26>>*/ instantiate_map(t,obj_id,context);
      else
       switch(obj_typ)
        {case 0:
          var
           match$0=
             /*<<op_set.ml 1014 25>>*/ instantiate_map(t,obj_id,context);
          break;
         case 1:
           /*<<op_set.ml 1015 26>>*/ var
            /*<<op_set.ml 1015 26>>*/ _dn_=1,
           match$0=
             /*<<op_set.ml 1015 26>>*/ instantiate_list(t,obj_id,_dn_,context);
          break;
         case 2:
           /*<<op_set.ml 1016 26>>*/ var
            /*<<op_set.ml 1016 26>>*/ _do_=2,
           match$0=
             /*<<op_set.ml 1016 26>>*/ instantiate_list(t,obj_id,_do_,context);
          break;
         default: /*<<op_set.ml 1017 19>>*/ throw Unknown_object_type}
       /*<<op_set.ml 1002 10>>*/ var children$0=match$0[2],diffs$0=match$0[1];
      return [0,diffs$0,children$0,[1,obj_id]]}
    function instantiate_list(t,obj_id,typ,param)
     { /*<<op_set.ml 1022 22>>*/ var
       children=param[2],
       diffs=param[1],
       _cP_=DiffMap[22],
        /*<<op_set.ml 1022 22>>*/ patch_diffs=
         /*<<op_set.ml 1022 22>>*/ caml_call2(_cP_,obj_id,diffs),
        /*<<op_set.ml 1022 22>>*/ _cQ_=[0,[0,obj_id,typ,0,0,0,0,0,0,0],0],
        /*<<op_set.ml 1022 22>>*/ _cR_=CCList[36],
        /*<<op_set.ml 1024 6>>*/ patch_diffs$0=
         /*<<op_set.ml 1024 6>>*/ caml_call2(_cR_,patch_diffs,_cQ_),
        /*<<op_set.ml 1024 6>>*/ _cS_=[0,diffs,children],
        /*<<op_set.ml 1024 6>>*/ _cT_=4,
        /*<<op_set.ml 1035 20>>*/ conflicts=
         /*<<op_set.ml 1035 20>>*/ list_iterator(t,obj_id,_cT_,_cS_),
        /*<<op_set.ml 1035 20>>*/ _cU_=[0,diffs,children],
        /*<<op_set.ml 1035 20>>*/ _cV_=1,
        /*<<op_set.ml 1036 17>>*/ values=
         /*<<op_set.ml 1036 17>>*/ list_iterator(t,obj_id,_cV_,_cU_),
        /*<<op_set.ml 1036 17>>*/ _cW_=[0,diffs,children],
        /*<<op_set.ml 1036 17>>*/ _cX_=3,
        /*<<op_set.ml 1037 16>>*/ elems=
         /*<<op_set.ml 1037 16>>*/ list_iterator(t,obj_id,_cX_,_cW_);
       /*<<op_set.ml 1037 16>>*/ function loop(patch_diffs,param)
       {var patch_diffs$0=patch_diffs,param$0=param;
        for(;;)
         { /*<<op_set.ml 1039 32>>*/ var
           children=param$0[2],
           diffs=param$0[1],
           _c0_=[0,diffs,children],
           _c1_=elems[1],
            /*<<op_set.ml 1039 32>>*/ match=
             /*<<op_set.ml 1039 32>>*/ caml_call1(_c1_,_c0_),
            /*<<op_set.ml 1039 32>>*/ el=match[3],
            /*<<op_set.ml 1039 32>>*/ children$0=match[2],
            /*<<op_set.ml 1039 32>>*/ diffs$0=match[1];
           /*<<op_set.ml 1039 32>>*/ if(el)
           {var _c2_=el[1];
            if(0 === _c2_[1])
             {var _c3_=_c2_[2];
              if(_c3_)
               {var _c4_=_c3_[1];
                if(3 === _c4_[0])
                 { /*<<op_set.ml 1054 44>>*/ var
                   elem_id=_c4_[2],
                   index=_c4_[1],
                   patch_diff=[0,obj_id,typ,2,0,0,0,[0,index],[0,elem_id],0],
                   _c5_=[0,diffs$0,children$0],
                   _c6_=values[1],
                    /*<<op_set.ml 1054 44>>*/ match$0=
                     /*<<op_set.ml 1054 44>>*/ caml_call1(_c6_,_c5_),
                    /*<<op_set.ml 1054 44>>*/ next_value=match$0[3],
                    /*<<op_set.ml 1054 44>>*/ children$1=match$0[2],
                    /*<<op_set.ml 1054 44>>*/ diffs$1=match$0[1];
                   /*<<op_set.ml 1054 44>>*/ if(next_value)
                   {var _c7_=next_value[1];
                    if(0 === _c7_[1])
                     {var _c8_=_c7_[2];
                      if(_c8_)
                       {var _c9_=_c8_[1];
                        if(1 === _c9_[0])
                         {var _c__=_c9_[1];
                          if(_c__)
                            /*<<op_set.ml 1058 16>>*/ var
                             /*<<op_set.ml 1058 16>>*/ mat_value=_c__[1],
                             /*<<op_set.ml 1059 18>>*/ match$1=
                              /*<<op_set.ml 1059 18>>*/ unpack_value
                              (obj_id,patch_diff,children$1,mat_value),
                             /*<<op_set.ml 1059 18>>*/ children$2=match$1[2],
                             /*<<op_set.ml 1059 18>>*/ patch_diff$0=match$1[1],
                            children$3=children$2,
                            patch_diff$1=patch_diff$0,
                            switch$0=1;
                          else
                           var switch$0=0}
                        else
                         var switch$0=0}
                      else
                       var switch$0=0}
                    else
                     var
                      children$3=children$1,
                      patch_diff$1=patch_diff,
                      switch$0=1;
                     /*<<op_set.ml 54 2>>*/ if(switch$0)
                     { /*<<op_set.ml 1066 10>>*/ var
                        /*<<op_set.ml 1066 10>>*/ _c$_=[0,diffs$1,children$3],
                        /*<<op_set.ml 1066 10>>*/ _da_=conflicts[1],
                        /*<<op_set.ml 1067 12>>*/ match$2=
                         /*<<op_set.ml 1067 12>>*/ caml_call1(_da_,_c$_),
                        /*<<op_set.ml 1067 12>>*/ next_conflict=match$2[3],
                        /*<<op_set.ml 1067 12>>*/ children$4=match$2[2],
                        /*<<op_set.ml 1067 12>>*/ diffs$2=match$2[1];
                       /*<<op_set.ml 1067 12>>*/ if(next_conflict)
                       {var _db_=next_conflict[1];
                        if(0 === _db_[1])
                         {var _dc_=_db_[2];
                          if(_dc_)
                           {var _dd_=_dc_[1];
                            if(4 === _dd_[0])
                              /*<<op_set.ml 1072 16>>*/ var
                               /*<<op_set.ml 1072 16>>*/ conflicts$0=_dd_[1],
                               /*<<op_set.ml 1073 18>>*/ match$3=
                                /*<<op_set.ml 1073 18>>*/ unpack_conflicts
                                (obj_id,patch_diff$1,children$4,conflicts$0),
                               /*<<op_set.ml 1073 18>>*/ children$5=match$3[2],
                               /*<<op_set.ml 1073 18>>*/ patch_diff$2=match$3[1],
                              children$6=children$5,
                              patch_diff$3=patch_diff$2,
                              switch$1=2;
                            else
                             var switch$1=0}
                          else
                           var switch$1=1}
                        else
                         var switch$1=1;
                        switch(switch$1)
                         {case 0:var switch$2=0;break;
                          case 1:
                           var
                            children$6=children$4,
                            patch_diff$3=patch_diff$1,
                            switch$2=1;
                           break;
                          default:var switch$2=1}
                        if(switch$2)
                         { /*<<op_set.ml 1080 10>>*/ var
                            /*<<op_set.ml 1080 10>>*/ param$1=[0,diffs$2,children$6],
                            /*<<op_set.ml 1080 10>>*/ _de_=[0,patch_diff$3,0],
                            /*<<op_set.ml 1080 10>>*/ _df_=CCList[36],
                            /*<<op_set.ml 1080 16>>*/ patch_diffs$1=
                             /*<<op_set.ml 1080 16>>*/ caml_call2
                             (_df_,patch_diffs$0,_de_),
                           patch_diffs$0=patch_diffs$1,
                           param$0=param$1;
                          continue}}
                       /*<<op_set.ml 1078 19>>*/ throw [0,
                             Invalid_argument,
                             cst_next_conflict]}}
                   /*<<op_set.ml 1063 19>>*/ throw [0,
                         Invalid_argument,
                         cst_next_value]}}}}
           /*<<op_set.ml 1081 13>>*/ return [0,
                  diffs$0,
                  children$0,
                  patch_diffs$0]}}
       /*<<op_set.ml 1037 16>>*/ var
        /*<<op_set.ml 1037 16>>*/ _cY_=[0,diffs,children],
        /*<<op_set.ml 1083 39>>*/ match=
         /*<<op_set.ml 1083 39>>*/ loop(patch_diffs$0,_cY_),
        /*<<op_set.ml 1083 39>>*/ patch_diffs$1=match[3],
        /*<<op_set.ml 1083 39>>*/ children$0=match[2],
        /*<<op_set.ml 1083 39>>*/ diffs$0=match[1],
        /*<<op_set.ml 1083 39>>*/ _cZ_=DiffMap[4];
       /*<<op_set.ml 1084 5>>*/ return [0,
               /*<<op_set.ml 1084 5>>*/ caml_call3
               (_cZ_,obj_id,patch_diffs$1,diffs$0),
              children$0]}
    function instantiate_map(t,obj_id,param)
     { /*<<op_set.ml 1087 22>>*/ var
       children=param[2],
       diffs=param[1],
       _cs_=DiffMap[22],
        /*<<op_set.ml 1087 22>>*/ patch_diffs=
         /*<<op_set.ml 1087 22>>*/ caml_call2(_cs_,obj_id,diffs),
        /*<<op_set.ml 1087 22>>*/ _ct_=Datastructures[1][23];
       /*<<op_set.ml 1089 13>>*/ if
       ( /*<<op_set.ml 1089 13>>*/ caml_call2(_ct_,obj_id,root_id))
       var patch_diffs$0=patch_diffs;
      else
        /*<<op_set.ml 1090 8>>*/ var
         /*<<op_set.ml 1090 8>>*/ _cC_=[0,[0,obj_id,0,0,0,0,0,0,0,0],0],
         /*<<op_set.ml 1090 8>>*/ _cD_=CCList[36],
        patch_diffs$0=
          /*<<op_set.ml 1090 8>>*/ caml_call2(_cD_,patch_diffs,_cC_);
       /*<<op_set.ml 1087 22>>*/ var
        /*<<op_set.ml 1102 4>>*/ _cu_=[0,diffs,children],
        /*<<op_set.ml 1103 6>>*/ match=
         /*<<op_set.ml 1103 6>>*/ get_object_conflicts(t,obj_id,_cu_),
        /*<<op_set.ml 1103 6>>*/ conflicts=match[3],
        /*<<op_set.ml 1103 6>>*/ children$0=match[2],
        /*<<op_set.ml 1103 6>>*/ diffs$0=match[1],
        /*<<op_set.ml 1106 12>>*/ match$0=
         /*<<op_set.ml 1106 12>>*/ get_object_fields(t,obj_id);
       /*<<op_set.ml 1106 12>>*/ if(match$0)
       var
        fields=match$0[1],
        _cv_=[0,diffs$0,children$0,patch_diffs$0],
        _cw_=
         function(key,param)
          { /*<<op_set.ml 1109 12>>*/ var
             /*<<op_set.ml 1109 12>>*/ patch_diffs=param[3],
             /*<<op_set.ml 1109 12>>*/ children=param[2],
             /*<<op_set.ml 1109 12>>*/ diffs=param[1],
             /*<<op_set.ml 1109 12>>*/ patch_diff=
             [0,obj_id,0,1,[0,key],0,0,0,0,0],
             /*<<op_set.ml 1109 12>>*/ _cE_=[0,diffs,children],
             /*<<op_set.ml 1123 22>>*/ _cF_=
              /*<<op_set.ml 1123 22>>*/ get_object_field(t,obj_id,key,_cE_),
             /*<<op_set.ml 1123 22>>*/ _cG_=_cF_[3],
             /*<<op_set.ml 1123 22>>*/ _cH_=_cF_[2],
             /*<<op_set.ml 1123 22>>*/ _cI_=_cF_[1];
            /*<<op_set.ml 1123 22>>*/ if(_cG_)
            { /*<<op_set.ml 1125 20>>*/ var
               /*<<op_set.ml 1125 20>>*/ mat_value=_cG_[1],
               /*<<op_set.ml 1126 22>>*/ match=
                /*<<op_set.ml 1126 22>>*/ unpack_value
                (obj_id,patch_diff,_cH_,mat_value),
               /*<<op_set.ml 1126 22>>*/ children$0=match[2],
               /*<<op_set.ml 1126 22>>*/ patch_diff$0=match[1];
              /*<<op_set.ml 1126 22>>*/ if(conflicts)
              { /*<<op_set.ml 1134 24>>*/ var
                all_conf=conflicts[1],
                _cJ_=KeyMap[27],
                 /*<<op_set.ml 1134 24>>*/ match$0=
                  /*<<op_set.ml 1134 24>>*/ caml_call2(_cJ_,key,all_conf);
                /*<<op_set.ml 1134 24>>*/ if(match$0)
                 /*<<op_set.ml 1135 31>>*/ var
                  /*<<op_set.ml 1135 31>>*/ cs=match$0[1],
                  /*<<op_set.ml 1135 31>>*/ _cK_=
                   /*<<op_set.ml 1135 31>>*/ unpack_conflicts
                   (obj_id,patch_diff$0,children$0,cs),
                  /*<<op_set.ml 1135 31>>*/ _cL_=_cK_[2],
                  /*<<op_set.ml 1135 31>>*/ _cM_=_cK_[1],
                 patch_diff$1=_cM_,
                 children$1=_cL_;
               else
                var patch_diff$1=patch_diff$0,children$1=children$0}
             else
              var patch_diff$1=patch_diff$0,children$1=children$0;
              /*<<op_set.ml 1125 20>>*/ var
               /*<<op_set.ml 1139 14>>*/ _cN_=[0,patch_diff$1,0],
               /*<<op_set.ml 1139 14>>*/ _cO_=CCList[36];
              /*<<op_set.ml 1139 32>>*/ return [0,
                     _cI_,
                     children$1,
                      /*<<op_set.ml 1139 32>>*/ caml_call2(_cO_,patch_diffs,_cN_)]}
            /*<<op_set.ml 1129 23>>*/ throw [0,Invalid_argument,cst_obj_key] /*<<op_set.ml 1139 73>>*/ },
        _cx_=caml_call3(KeySet[15],_cw_,fields,_cv_),
        _cy_=_cx_[3],
        _cz_=_cx_[2],
        _cA_=_cx_[1],
        diffs$1=_cA_,
        children$1=_cz_,
        patch_diffs$1=_cy_;
      else
       var diffs$1=diffs$0,children$1=children$0,patch_diffs$1=patch_diffs$0;
       /*<<op_set.ml 1087 22>>*/  /*<<op_set.ml 1144 4>>*/ var
       _cB_=
        DiffMap[4];
       /*<<op_set.ml 1144 5>>*/ return [0,
               /*<<op_set.ml 1144 5>>*/ caml_call3
               (_cB_,obj_id,patch_diffs$1,diffs$1),
              children$1]}
    function get_object_conflicts(t,obj_id,param)
     {var children=param[2],diffs=param[1];
      function _b2_(key,field)
       { /*<<op_set.ml 1152 14>>*/  /*<<op_set.ml 1152 14>>*/ var
         _co_=
           /*<<op_set.ml 1152 14>>*/ valid_field_name(key);
         /*<<op_set.ml 1152 14>>*/ if(_co_)
          /*<<op_set.ml 1153 31>>*/ var
           /*<<op_set.ml 1153 31>>*/ _cp_=
            /*<<op_set.ml 1153 31>>*/ get_field_ops(t,obj_id,key),
           /*<<op_set.ml 1153 31>>*/ _cq_=CCList[1],
          _cr_=1 <  /*<<op_set.ml 1153 17>>*/ caml_call1(_cq_,_cp_)?1:0;
        else
         var _cr_=_co_;
        return _cr_ /*<<op_set.ml 1153 63>>*/ }
       /*<<op_set.ml 1151 10>>*/ var
       _b3_=KeyMap[14],
        /*<<op_set.ml 1151 10>>*/ _b4_=
         /*<<op_set.ml 1151 10>>*/ caml_call1(_b3_,_b2_);
       /*<<op_set.ml 1151 10>>*/ function _b5_(_cn_)
       { /*<<?>>*/ return _cn_[1]}
       /*<<op_set.ml 1151 10>>*/ var
        /*<<op_set.ml 1151 10>>*/ _b6_=t[3],
        /*<<op_set.ml 1151 10>>*/ _b7_=ObjectIdMap[27],
        /*<<op_set.ml 1149 6>>*/ _b8_=
         /*<<op_set.ml 1149 6>>*/ caml_call2(_b7_,obj_id,_b6_),
        /*<<op_set.ml 1149 6>>*/ _b9_=CCOpt[34][1],
        /*<<op_set.ml 1149 6>>*/ _b__=
         /*<<op_set.ml 1149 6>>*/ caml_call2(_b9_,_b8_,_b5_),
        /*<<op_set.ml 1149 6>>*/ _b$_=CCOpt[34][1],
        /*<<op_set.ml 1149 6>>*/ filtered=
         /*<<op_set.ml 1149 6>>*/ caml_call2(_b$_,_b__,_b4_);
       /*<<op_set.ml 1149 6>>*/ if(filtered)
       { /*<<op_set.ml 1158 10>>*/ var
         fil=filtered[1],
         _ca_=[0,diffs,children,KeyMap[1]],
         _cb_=
          function(key,field,param)
           { /*<<op_set.ml 1159 12>>*/ var
              /*<<op_set.ml 1159 12>>*/ res=param[3],
              /*<<op_set.ml 1159 12>>*/ children=param[2],
              /*<<op_set.ml 1159 12>>*/ diffs=param[1],
              /*<<op_set.ml 1159 12>>*/ _cd_=1,
              /*<<op_set.ml 1159 12>>*/ _ce_=CCList[78],
              /*<<op_set.ml 1173 18>>*/ _cf_=
               /*<<op_set.ml 1173 18>>*/ caml_call2(_ce_,_cd_,field),
              /*<<op_set.ml 1173 18>>*/ _cg_=[0,diffs,children,OpMap[1]];
             /*<<op_set.ml 1173 18>>*/ function _ch_(param,op)
             { /*<<op_set.ml 1162 18>>*/ var
                /*<<op_set.ml 1162 18>>*/ conflicts=param[3],
                /*<<op_set.ml 1162 18>>*/ children=param[2],
                /*<<op_set.ml 1162 18>>*/ diffs=param[1],
                /*<<op_set.ml 1162 18>>*/ _ck_=[0,diffs,children],
                /*<<op_set.ml 1164 22>>*/ match=
                 /*<<op_set.ml 1164 22>>*/ get_op_value(t,op,_ck_),
                /*<<op_set.ml 1164 22>>*/ materialized=match[3],
                /*<<op_set.ml 1164 22>>*/ children$0=match[2],
                /*<<op_set.ml 1164 22>>*/ diffs$0=match[1];
               /*<<op_set.ml 1164 22>>*/ if(materialized)
                /*<<op_set.ml 1168 36>>*/ var
                 /*<<op_set.ml 1168 36>>*/ mat=materialized[1],
                 /*<<op_set.ml 1168 36>>*/ _cl_=op[3],
                 /*<<op_set.ml 1168 36>>*/ _cm_=OpMap[4],
                conflicts$0=
                  /*<<op_set.ml 1168 36>>*/ caml_call3
                  (_cm_,_cl_,mat,conflicts);
              else
               var conflicts$0=conflicts;
               /*<<op_set.ml 1171 20>>*/ return [0,
                      diffs$0,
                      children$0,
                      conflicts$0] /*<<op_set.ml 1171 50>>*/ }
             /*<<op_set.ml 1173 18>>*/ var
              /*<<op_set.ml 1173 18>>*/ _ci_=CCList[10],
              /*<<op_set.ml 1161 16>>*/ match=
               /*<<op_set.ml 1161 16>>*/ caml_call3(_ci_,_ch_,_cg_,_cf_),
              /*<<op_set.ml 1161 16>>*/ conflicts=match[3],
              /*<<op_set.ml 1161 16>>*/ children$0=match[2],
              /*<<op_set.ml 1161 16>>*/ diffs$0=match[1],
              /*<<op_set.ml 1161 16>>*/ _cj_=KeyMap[4];
             /*<<op_set.ml 1175 32>>*/ return [0,
                    diffs$0,
                    children$0,
                     /*<<op_set.ml 1175 32>>*/ caml_call3
                     (_cj_,key,conflicts,res)] /*<<op_set.ml 1175 63>>*/ },
         _cc_=KeyMap[11],
          /*<<op_set.ml 1158 10>>*/ match=
           /*<<op_set.ml 1158 10>>*/ caml_call3(_cc_,_cb_,fil,_ca_),
          /*<<op_set.ml 1158 10>>*/ conflicts=match[3],
          /*<<op_set.ml 1158 10>>*/ children$0=match[2],
          /*<<op_set.ml 1158 10>>*/ diffs$0=match[1];
         /*<<op_set.ml 1158 10>>*/ return [0,diffs$0,children$0,[0,conflicts]]}
       /*<<op_set.ml 1180 14>>*/ return [0,diffs,children,0]}
    function get_op_value(t,op,param)
     {var children=param[2],diffs=param[1],_bW_=op[7];
      function _bX_(value)
       { /*<<op_set.ml 1186 10>>*/  /*<<op_set.ml 1186 10>>*/ var _bZ_=op[2];
         /*<<op_set.ml 1186 10>>*/ if(4 <= _bZ_)
         {var switcher=_bZ_ - 4 | 0;
          switch(switcher)
           {case 0:
              /*<<op_set.ml 1187 19>>*/ return [0,
                     [0,diffs,children,[0,value]]];
            case 1:break;
            default:
              /*<<op_set.ml 1189 14>>*/ var
               /*<<op_set.ml 1189 14>>*/ _b0_=[0,diffs,children],
               /*<<op_set.ml 1191 19>>*/ _b1_=
                /*<<op_set.ml 1191 19>>*/ get_op_value_as_string_exn(value);
              /*<<op_set.ml 1190 16>>*/ return [0,
                      /*<<op_set.ml 1190 16>>*/ instantiate_object(t,_b1_,_b0_)]}}
         /*<<op_set.ml 1193 17>>*/ return 0 /*<<op_set.ml 1193 21>>*/ }
       /*<<op_set.ml 1184 6>>*/ var
       _bY_=CCOpt[11],
        /*<<op_set.ml 1184 6>>*/ value=
         /*<<op_set.ml 1184 6>>*/ caml_call2(_bY_,_bX_,_bW_);
       /*<<op_set.ml 1184 6>>*/ if(value)
       {var
         match=value[1],
         value$0=match[3],
         children$0=match[2],
         diffs$0=match[1];
        return [0,diffs$0,children$0,[0,value$0]]}
       /*<<op_set.ml 1198 14>>*/ return [0,diffs,children,0]}
    function get_object_field(t,obj_id,key,param)
     {var children=param[2],diffs=param[1];
       /*<<op_set.ml 1201 11>>*/ if
       ( /*<<op_set.ml 1201 11>>*/ valid_field_name(key))
       { /*<<op_set.ml 1203 12>>*/  /*<<op_set.ml 1203 12>>*/ var
         match=
           /*<<op_set.ml 1203 12>>*/ get_field_ops(t,obj_id,key);
         /*<<op_set.ml 1203 12>>*/ if(match)
         { /*<<op_set.ml 1205 19>>*/  /*<<op_set.ml 1205 19>>*/ var
           hd=
            match[1];
           /*<<op_set.ml 1205 19>>*/ return  /*<<op_set.ml 1205 19>>*/ get_op_value
                  (t,hd,[0,diffs,children])}
         /*<<op_set.ml 1204 14>>*/ return [0,diffs,children,0]}
       /*<<op_set.ml 1201 39>>*/ return [0,diffs,children,0]}
    function list_iterator(t,list_id,mode,context)
     { /*<<op_set.ml 1208 4>>*/ var
        /*<<op_set.ml 1208 4>>*/ elem=[0,_bc_],
        /*<<op_set.ml 1208 4>>*/ index=[0,-1];
       /*<<op_set.ml 1208 4>>*/ function next(param)
       {var children=param[2],diffs=param[1];
        function next(param)
         { /*<<?>>*/ var param$0=param;
          for(;;)
           {var children=param$0[2],diffs=param$0[1];
            if(elem[1])
             { /*<<op_set.ml 1214 20>>*/  /*<<op_set.ml 1214 20>>*/ var
               _bJ_=
                elem[1];
               /*<<op_set.ml 1215 20>>*/ elem[1]
              =
               /*<<op_set.ml 1215 20>>*/ get_next(t,list_id,_bJ_);
               /*<<op_set.ml 1214 20>>*/  /*<<op_set.ml 1215 20>>*/ var
               _bK_=
                elem[1];
               /*<<op_set.ml 1215 20>>*/ if(_bK_)
               { /*<<op_set.ml 1218 28>>*/ var
                  /*<<op_set.ml 1218 28>>*/ elem$0=_bK_[1],
                  /*<<op_set.ml 1219 20>>*/ ops=
                   /*<<op_set.ml 1219 20>>*/ get_field_ops(t,list_id,elem$0);
                 /*<<op_set.ml 1219 20>>*/ if(ops)
                 { /*<<op_set.ml 1223 20>>*/ var
                   tl=ops[2],
                   hd=ops[1],
                   _bL_=[0,diffs,children],
                    /*<<op_set.ml 1223 20>>*/ match=
                     /*<<op_set.ml 1223 20>>*/ get_op_value(t,hd,_bL_),
                    /*<<op_set.ml 1223 20>>*/ value=match[3],
                    /*<<op_set.ml 1223 20>>*/ children$0=match[2],
                    /*<<op_set.ml 1223 20>>*/ diffs$0=match[1];
                   /*<<op_set.ml 1223 20>>*/ index[1] = index[1] + 1 | 0;
                   /*<<op_set.ml 1223 20>>*/ switch(mode)
                   {case 0:
                      /*<<op_set.ml 1228 22>>*/ return [0,
                             diffs$0,
                             children$0,
                             [0,[0,0,[0,[0,index[1]]]]]];
                    case 1:
                      /*<<op_set.ml 1232 22>>*/ return [0,
                             diffs$0,
                             children$0,
                             [0,[0,0,[0,[1,value]]]]];
                    case 2:
                      /*<<op_set.ml 1236 22>>*/ return [0,
                             diffs$0,
                             children$0,
                             [0,[0,0,[0,[2,index[1],value]]]]];
                    case 3:
                      /*<<op_set.ml 1242 22>>*/ return [0,
                             diffs$0,
                             children$0,
                             [0,[0,0,[0,[3,index[1],elem$0]]]]];
                    default:
                      /*<<op_set.ml 1248 22>>*/  /*<<op_set.ml 1248 22>>*/ var
                      _bM_=
                       CCList[1];
                      /*<<op_set.ml 1249 27>>*/ if
                      (1 <  /*<<op_set.ml 1249 27>>*/ caml_call1(_bM_,ops))
                       /*<<op_set.ml 1250 26>>*/ var
                        /*<<op_set.ml 1250 26>>*/ _bN_=
                        [0,diffs$0,children$0,OpMap[1]],
                        /*<<op_set.ml 1250 26>>*/ _bO_=
                        function(param,op)
                         { /*<<op_set.ml 1252 30>>*/ var
                            /*<<op_set.ml 1252 30>>*/ op_map=param[3],
                            /*<<op_set.ml 1252 30>>*/ children=param[2],
                            /*<<op_set.ml 1252 30>>*/ diffs=param[1],
                            /*<<op_set.ml 1252 30>>*/ _bR_=[0,diffs,children],
                            /*<<op_set.ml 1254 34>>*/ match=
                             /*<<op_set.ml 1254 34>>*/ get_op_value(t,op,_bR_),
                            /*<<op_set.ml 1254 34>>*/ op_value=match[3],
                            /*<<op_set.ml 1254 34>>*/ children$0=match[2],
                            /*<<op_set.ml 1254 34>>*/ diffs$0=match[1],
                            /*<<op_set.ml 1254 34>>*/ _bS_=CCOpt[20],
                            /*<<op_set.ml 1258 53>>*/ _bT_=
                             /*<<op_set.ml 1258 53>>*/ caml_call1(_bS_,op_value),
                            /*<<op_set.ml 1258 53>>*/ _bU_=op[3],
                            /*<<op_set.ml 1258 53>>*/ _bV_=OpMap[4];
                           /*<<op_set.ml 1258 34>>*/ return [0,
                                  diffs$0,
                                  children$0,
                                   /*<<op_set.ml 1258 34>>*/ caml_call3(_bV_,_bU_,_bT_,op_map)] /*<<op_set.ml 1259 46>>*/ },
                        /*<<op_set.ml 1250 26>>*/ _bP_=CCList[10],
                        /*<<op_set.ml 1251 28>>*/ match$0=
                         /*<<op_set.ml 1251 28>>*/ caml_call3(_bP_,_bO_,_bN_,tl),
                        /*<<op_set.ml 1251 28>>*/ conflict=match$0[3],
                        /*<<op_set.ml 1251 28>>*/ children$1=match$0[2],
                        /*<<op_set.ml 1251 28>>*/ diffs$1=match$0[1],
                        /*<<op_set.ml 1251 28>>*/ _bQ_=[0,[4,conflict]],
                       diffs$2=diffs$1,
                       children$2=children$1,
                       conflict$0=_bQ_;
                     else
                       /*<<op_set.ml 1264 29>>*/ var
                        /*<<op_set.ml 1264 29>>*/ conflict$1=0,
                       diffs$2=diffs$0,
                       children$2=children$0,
                       conflict$0=conflict$1;
                      /*<<op_set.ml 1269 22>>*/ return [0,
                             diffs$2,
                             children$2,
                             [0,[0,0,conflict$0]]]}}
                 /*<<op_set.ml 1218 28>>*/ var
                  /*<<op_set.ml 1220 22>>*/ param$1=[0,diffs,children],
                 param$0=param$1;
                continue}
               /*<<op_set.ml 1217 22>>*/ return [0,diffs,children,_bd_]}
             /*<<op_set.ml 1213 18>>*/ return [0,diffs,children,0]}}
        return next([0,diffs,children])}
       /*<<op_set.ml 1208 4>>*/ return [0,next] /*<<op_set.ml 1274 10>>*/ }
    function get_next(t,obj_id,key)
     { /*<<op_set.ml 1277 4>>*/ var
        /*<<op_set.ml 1277 4>>*/ _bH_=0,
        /*<<op_set.ml 1277 10>>*/ match=
         /*<<op_set.ml 1277 10>>*/ insertions_after(t,obj_id,key,_bH_);
       /*<<op_set.ml 1277 10>>*/ if(match)
       { /*<<op_set.ml 1278 17>>*/  /*<<op_set.ml 1278 17>>*/ var hd=match[1];
         /*<<op_set.ml 1278 17>>*/ return [0,hd]}
       /*<<op_set.ml 1280 8>>*/ function find_ancestor(key)
       { /*<<?>>*/ var key$0=key;
         /*<<op_set.ml 1281 10>>*/ for(;;)
         { /*<<op_set.ml 1281 16>>*/  /*<<op_set.ml 1281 16>>*/ var
           match=
             /*<<op_set.ml 1281 16>>*/ get_parent(t,obj_id,key$0);
           /*<<op_set.ml 1281 16>>*/ if(match)
           { /*<<op_set.ml 1283 29>>*/ var
              /*<<op_set.ml 1283 29>>*/ ancestor=match[1],
              /*<<op_set.ml 1283 29>>*/ _bI_=[0,ancestor],
              /*<<op_set.ml 1284 18>>*/ match$0=
               /*<<op_set.ml 1284 18>>*/ insertions_after(t,obj_id,_bI_,key$0);
             /*<<op_set.ml 1284 18>>*/ if(match$0)
             { /*<<op_set.ml 1285 25>>*/  /*<<op_set.ml 1285 25>>*/ var
               hd=
                match$0[1];
               /*<<op_set.ml 1285 25>>*/ return [0,hd]}
             /*<<op_set.ml 1283 29>>*/ var
              /*<<op_set.ml 1286 20>>*/ key$1=[0,ancestor],
             key$0=key$1;
            continue}
           /*<<op_set.ml 1282 20>>*/ return 0} /*<<op_set.ml 1286 51>>*/ }
       /*<<op_set.ml 1280 8>>*/ return  /*<<op_set.ml 1280 8>>*/ find_ancestor
              (key) /*<<op_set.ml 1288 25>>*/ }
    function sexp_of_patch(param)
     { /*<<op_set.ml 1290 2>>*/ var
        /*<<op_set.ml 1290 2>>*/ v_diffs=param[5],
        /*<<op_set.ml 1290 2>>*/ v_deps=param[4],
        /*<<op_set.ml 1290 2>>*/ v_clock=param[3],
        /*<<op_set.ml 1290 2>>*/ v_can_redo=param[2],
        /*<<op_set.ml 1290 2>>*/ v_can_undo=param[1],
        /*<<op_set.ml 1290 2>>*/ bnds=0,
        /*<<op_set.ml 1290 2>>*/ _bC_=Sexplib_Conv[20],
        /*<<op_set.ml 1295 18>>*/ arg=
         /*<<op_set.ml 1295 18>>*/ caml_call2(_bC_,sexp_of_diff,v_diffs),
        /*<<op_set.ml 1295 18>>*/ bnds$0=[0,[1,[0,_be_,[0,arg,0]]],bnds],
        /*<<op_set.ml 1295 18>>*/ _bD_=ActorMap[47],
        /*<<op_set.ml 1294 16>>*/ arg$0=
         /*<<op_set.ml 1294 16>>*/ caml_call2(_bD_,sexp_of_seq,v_deps),
        /*<<op_set.ml 1294 16>>*/ bnds$1=[0,[1,[0,_bf_,[0,arg$0,0]]],bnds$0],
        /*<<op_set.ml 1294 16>>*/ _bE_=ActorMap[47],
        /*<<op_set.ml 1293 17>>*/ arg$1=
         /*<<op_set.ml 1293 17>>*/ caml_call2(_bE_,sexp_of_seq,v_clock),
        /*<<op_set.ml 1293 17>>*/ bnds$2=[0,[1,[0,_bg_,[0,arg$1,0]]],bnds$1],
        /*<<op_set.ml 1293 17>>*/ _bF_=Sexplib_Conv[6],
        /*<<op_set.ml 1292 6>>*/ arg$2=
         /*<<op_set.ml 1292 6>>*/ caml_call1(_bF_,v_can_redo),
        /*<<op_set.ml 1292 6>>*/ bnds$3=[0,[1,[0,_bh_,[0,arg$2,0]]],bnds$2],
        /*<<op_set.ml 1292 6>>*/ _bG_=Sexplib_Conv[6],
        /*<<op_set.ml 1291 6>>*/ arg$3=
         /*<<op_set.ml 1291 6>>*/ caml_call1(_bG_,v_can_undo),
        /*<<op_set.ml 1291 6>>*/ bnds$4=[0,[1,[0,_bi_,[0,arg$3,0]]],bnds$3];
       /*<<op_set.ml 1291 6>>*/ return [1,bnds$4] /*<<op_set.ml 1296 22>>*/ }
    function make_patch(t,obj_id,patch_diffs,param)
     { /*<<op_set.ml 1304 8>>*/ var
       children=param[2],
       diffs=param[1],
       _bu_=ChildMap[22],
        /*<<op_set.ml 1304 8>>*/ _bv_=
         /*<<op_set.ml 1304 8>>*/ caml_call2(_bu_,obj_id,children),
        /*<<op_set.ml 1304 8>>*/ _bw_=[0,diffs,patch_diffs];
       /*<<op_set.ml 1304 8>>*/ function _bx_(param,child_id)
       { /*<<op_set.ml 1301 8>>*/ var
          /*<<op_set.ml 1301 8>>*/ patch_diffs=param[2],
          /*<<op_set.ml 1301 8>>*/ diffs=param[1];
         /*<<op_set.ml 1301 8>>*/ return  /*<<op_set.ml 1301 8>>*/ make_patch
                (t,child_id,patch_diffs,[0,diffs,children]) /*<<op_set.ml 1302 63>>*/ }
       /*<<op_set.ml 1304 8>>*/ var
        /*<<op_set.ml 1304 8>>*/ _by_=CCList[10],
        /*<<op_set.ml 1300 6>>*/ match=
         /*<<op_set.ml 1300 6>>*/ caml_call3(_by_,_bx_,_bw_,_bv_),
        /*<<op_set.ml 1300 6>>*/ patch_diffs$0=match[2],
        /*<<op_set.ml 1300 6>>*/ diffs$0=match[1],
        /*<<op_set.ml 1300 6>>*/ _bz_=DiffMap[22],
        /*<<op_set.ml 1306 38>>*/ _bA_=
         /*<<op_set.ml 1306 38>>*/ caml_call2(_bz_,obj_id,diffs$0),
        /*<<op_set.ml 1306 38>>*/ _bB_=CCList[36];
       /*<<op_set.ml 1306 12>>*/ return [0,
              diffs$0,
               /*<<op_set.ml 1306 12>>*/ caml_call2(_bB_,patch_diffs$0,_bA_)]}
    function get_patch(t)
     { /*<<op_set.ml 1309 4>>*/ var
        /*<<op_set.ml 1309 4>>*/ _bm_=[0,DiffMap[1],ChildMap[1]],
        /*<<op_set.ml 1310 6>>*/ match=
         /*<<op_set.ml 1310 6>>*/ instantiate_object(t,root_id,_bm_),
        /*<<op_set.ml 1310 6>>*/ children=match[2],
        /*<<op_set.ml 1310 6>>*/ diffs=match[1],
        /*<<op_set.ml 1310 6>>*/ _bn_=[0,diffs,children],
        /*<<op_set.ml 1310 6>>*/ _bo_=0,
        /*<<op_set.ml 1312 29>>*/ match$0=
         /*<<op_set.ml 1312 29>>*/ make_patch(t,root_id,_bo_,_bn_),
        /*<<op_set.ml 1312 29>>*/ patch_diffs=match$0[2],
        /*<<op_set.ml 1312 29>>*/ _bp_=t[5],
        /*<<op_set.ml 1312 29>>*/ _bq_=t[4],
        /*<<op_set.ml 1312 29>>*/ _br_=t[8],
        /*<<op_set.ml 1312 29>>*/ _bs_=CCList[32],
        /*<<op_set.ml 1314 20>>*/ _bt_=
        1
        -
         /*<<op_set.ml 1314 20>>*/ caml_call1(_bs_,_br_);
       /*<<op_set.ml 1314 20>>*/ return [0,
              0 < t[6]?1:0,
              _bt_,
              _bq_,
              _bp_,
              patch_diffs] /*<<op_set.ml 1317 26>>*/ }
    function list_length(t,obj_id)
     { /*<<op_set.ml 1321 4>>*/ function _bk_(obj_aux)
       { /*<<op_set.ml 1321 44>>*/ return  /*<<op_set.ml 1321 44>>*/ caml_call2
                (CCOpt[34][1],obj_aux[5],CCList[1]) /*<<op_set.ml 1321 79>>*/ }
       /*<<op_set.ml 1321 4>>*/  /*<<op_set.ml 1321 4>>*/ var
       _bl_=
         /*<<op_set.ml 1321 4>>*/ get_obj_aux(t,obj_id);
       /*<<op_set.ml 1321 4>>*/ return  /*<<op_set.ml 1321 4>>*/ caml_call2
              (CCOpt[34][2],_bl_,_bk_) /*<<op_set.ml 1321 79>>*/ }
    function get_clock(param){ /*<<?>>*/ var clock=param[4];return clock}
    function get_deps(param){ /*<<?>>*/ var deps=param[5];return deps}
    function can_undo(param)
     { /*<<?>>*/ var undo_pos=param[6];return 0 < undo_pos?1:0}
    function can_redo(param)
     {var redo_stack=param[8],_bj_=CCList[32];
       /*<<op_set.ml 1329 34>>*/ return 1
             -
              /*<<op_set.ml 1329 34>>*/ caml_call1(_bj_,redo_stack)}
    var
     OpSetBackend=
      [0,
       root_id,
       sexp_of_actor,
       sexp_of_seq,
       sexp_of_obj_id,
       sexp_of_key,
       action_of_sexp,
       sexp_of_action,
       sexp_of_op_val,
       sexp_of_materialized,
       sexp_of_value,
       sexp_of_elem_id,
       SkipList,
       sexp_of_op,
       sexp_of_change_op,
       sexp_of_lamport_op,
       lamport_compare,
       get_op_elem,
       OpSet,
       sexp_of_change,
       sexp_of_state,
       sexp_of_edit_action,
       sexp_of_edit_type,
       sexp_of_conflict,
       sexp_of_edit,
       sexp_of_obj_aux,
       sexp_of_obj,
       sexp_of_diff_type,
       sexp_of_diff_action,
       sexp_of_diff,
       sexp_of_child,
       sexp_of_context,
       sexp_of_t$0,
       LLog,
       get_obj_aux,
       get_obj_aux_exn,
       get_op_value_as_string_exn,
       get_obj_action,
       causaly_ready,
       transitive_deps,
       apply_make,
       apply_insert,
       get_conflicts,
       get_path,
       patch_list,
       is_concurrent,
       get_field_ops,
       get_parent,
       insertions_after,
       get_previous,
       update_list_element,
       update_map_key,
       apply_assign,
       apply_ops,
       apply_change,
       apply_queued_ops,
       push_undo_history,
       add_change,
       init,
       get_missing_changes,
       get_changes_for_actor,
       get_missing_deps,
       valid_field_name,
       is_field_present,
       unpack_value,
       unpack_conflict_value,
       unpack_conflicts,
       get_object_fields,
       sexp_of_iterator_mode,
       sexp_of_iterator_val,
       sexp_of_iterator_res,
       sexp_of_iterator,
       instantiate_object,
       instantiate_list,
       instantiate_map,
       get_object_conflicts,
       get_op_value,
       get_object_field,
       list_iterator,
       get_next,
       sexp_of_patch,
       make_patch,
       get_patch,
       list_length,
       get_clock,
       get_deps,
       can_undo,
       can_redo],
     Op_set=
      [0,
       Inconsistent_reuse_of_sequence,
       Not_supported,
       Modification_of_unknown_object,
       Duplicate_list_element_id,
       Unknown_object_type,
       Unknown_action_type,
       Missing_index_for_list_element,
       Accessing_unefined_element_index,
       log,
       ActorMap,
       SeqMap,
       ObjectIdMap,
       ObjectIdSet,
       ElemIdMap,
       KeyMap,
       KeySet,
       OpMap,
       DiffMap,
       ChildMap,
       OpSetBackend];
    runtime.caml_register_global(190,Op_set,"Op_set");
    return /*<<?>>*/ }
  (function(){return this}()));


//# 1 ".index.eobjs/index.cmo.js"
(function(joo_global_object)
   {"use strict";
     /*<<?>>*/ var
     runtime=joo_global_object.jsoo_runtime,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_js_from_array=runtime.caml_js_from_array,
     caml_js_object=runtime.caml_js_object,
     caml_js_to_array=runtime.caml_js_to_array,
     caml_js_to_string=runtime.caml_js_to_string,
     caml_new_string=runtime.caml_new_string,
     caml_string_notequal=runtime.caml_string_notequal;
     /*<<?>>*/ function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
     /*<<?>>*/ function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
     /*<<?>>*/ function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_boolean=caml_new_string("boolean"),
     cst_number=caml_new_string("number"),
     cst_string=caml_new_string("string"),
     cst_immutable$0=caml_new_string("immutable"),
     cst$1=caml_new_string(""),
     cst_create$0=caml_new_string("create"),
     cst_set$2=caml_new_string("set"),
     cst_insert$0=caml_new_string("insert"),
     cst_map$0=caml_new_string("map"),
     cst_list$0=caml_new_string("list"),
     cst_text$0=caml_new_string("text"),
     cst_action$1=caml_new_string("action"),
     cst_key$1=caml_new_string("key"),
     cst_obj$2=caml_new_string("obj"),
     cst_type$0=caml_new_string("type"),
     cst_link$2=caml_new_string("link"),
     cst_value$2=caml_new_string("value"),
     cst_index$0=caml_new_string("index"),
     cst_elemId$0=caml_new_string("elemId"),
     cst_conflicts$0=caml_new_string("conflicts"),
     cst_change=caml_new_string("change"),
     cst$0=caml_new_string(""),
     cst_immutable=caml_new_string("immutable"),
     cst_actor$0=caml_new_string("actor"),
     cst_seq=caml_new_string("seq"),
     cst_deps=caml_new_string("deps"),
     cst_ops=caml_new_string("ops"),
     cst_action$0=caml_new_string("action"),
     cst_key$0=caml_new_string("key"),
     cst_elem=caml_new_string("elem"),
     cst_value$1=caml_new_string("value"),
     cst_obj$1=caml_new_string("obj"),
     cst_action=caml_new_string("action"),
     cst_obj$0=caml_new_string("obj"),
     cst_key=caml_new_string("key"),
     cst_value$0=caml_new_string("value"),
     cst_type=caml_new_string("type"),
     cst_link$1=caml_new_string("link"),
     cst_conflicts=caml_new_string("conflicts"),
     cst_index=caml_new_string("index"),
     cst_elemId=caml_new_string("elemId"),
     cst_path=caml_new_string("path"),
     cst_path$0=caml_new_string("path"),
     cst_actor=caml_new_string("actor"),
     cst_value=caml_new_string("value"),
     cst=caml_new_string(""),
     cst_obj=caml_new_string("obj"),
     cst_makeMap$0=caml_new_string("makeMap"),
     cst_makeList$0=caml_new_string("makeList"),
     cst_makeText$0=caml_new_string("makeText"),
     cst_ins$0=caml_new_string("ins"),
     cst_set$1=caml_new_string("set"),
     cst_del$0=caml_new_string("del"),
     cst_link$0=caml_new_string("link"),
     cst_set$0=caml_new_string("set"),
     cst_del=caml_new_string("del"),
     cst_makeMap=caml_new_string("makeMap"),
     cst_makeList=caml_new_string("makeList"),
     cst_makeText=caml_new_string("makeText"),
     cst_link=caml_new_string("link"),
     cst_ins=caml_new_string("ins"),
     cst_map=caml_new_string("map"),
     cst_text=caml_new_string("text"),
     cst_list=caml_new_string("list"),
     cst_create=caml_new_string("create"),
     cst_insert=caml_new_string("insert"),
     cst_remove=caml_new_string("remove"),
     cst_set=caml_new_string("set"),
     _a_=
      [0,
       caml_new_string("deps"),
       caml_new_string("clock"),
       caml_new_string("diffs"),
       caml_new_string("canRedo"),
       caml_new_string("canUndo")],
     _b_=
      [0,
       caml_new_string("diffs"),
       caml_new_string("deps"),
       caml_new_string("clock"),
       caml_new_string("canUndo"),
       caml_new_string("canRedo")],
     shared=[0,caml_new_string("obj")],
     cst_Index_Not_supported=caml_new_string("Index.Not_supported"),
     cst_Index_Unknown_request_type=
      caml_new_string("Index.Unknown_request_type"),
     cst_init=caml_new_string("init"),
     cst_applyChanges=caml_new_string("applyChanges"),
     cst_applyLocalChange=caml_new_string("applyLocalChange"),
     cst_getPatch=caml_new_string("getPatch"),
     cst_merge=caml_new_string("merge"),
     cst_getChangesForActor=caml_new_string("getChangesForActor"),
     cst_getChanges=caml_new_string("getChanges"),
     cst_getMissingChanges=caml_new_string("getMissingChanges"),
     cst_getClock=caml_new_string("getClock"),
     Op_set=global_data.Op_set,
     CCList=global_data.CCList,
     CCArray=global_data.CCArray,
     Js=global_data.Js,
     CamlinternalOO=global_data.CamlinternalOO,
     Datastructures=global_data.Datastructures,
     String=global_data.String,
     List=global_data.List;
    function _c_(f,g,x)
     { /*<<index.ml 5 20>>*/ return  /*<<index.ml 5 20>>*/ caml_call1
              (f, /*<<index.ml 5 20>>*/ caml_call1(g,x)) /*<<index.ml 5 25>>*/ }
    var
     Not_supported=[248,cst_Index_Not_supported,caml_fresh_oo_id(0)],
     Unknown_request_type=
      [248,cst_Index_Unknown_request_type,caml_fresh_oo_id(0)];
    function freeze(o)
     { /*<<index.ml 10 21>>*/ return  /*<<index.ml 10 21>>*/ Object.freeze(o) /*<<index.ml 10 79>>*/ }
    var BE=0;
    function clock(t)
     { /*<<index.ml 16 14>>*/ return  /*<<index.ml 16 14>>*/ caml_call1
              (Op_set[20][84],t[1]) /*<<index.ml 16 45>>*/ }
    function list_to_js_array(lis)
     { /*<<index.ml 19 2>>*/ var
        /*<<index.ml 19 2>>*/ _fG_=0,
        /*<<index.ml 19 2>>*/ _fH_=List[1],
        /*<<index.ml 19 35>>*/ _fI_=
         /*<<index.ml 19 35>>*/ caml_call1(_fH_,lis),
        /*<<index.ml 19 35>>*/ _fJ_=Js[15];
       /*<<index.ml 19 35>>*/ function _fK_(t1,t0,param)
       { /*<<?>>*/ return new t1(t0)}
       /*<<index.ml 19 12>>*/  /*<<index.ml 19 12>>*/ var
       arr=
         /*<<index.ml 19 12>>*/ _fK_(_fJ_,_fI_,_fG_);
       /*<<index.ml 19 12>>*/ function _fL_(i,el)
       { /*<<index.ml 20 28>>*/ return  /*<<index.ml 20 28>>*/ caml_call3
                (Js[17],arr,i,el) /*<<index.ml 20 68>>*/ }
       /*<<index.ml 19 12>>*/  /*<<index.ml 19 12>>*/ var _fM_=CCList[108];
       /*<<index.ml 20 2>>*/  /*<<index.ml 20 2>>*/ caml_call2(_fM_,_fL_,lis);
       /*<<index.ml 20 2>>*/ return arr /*<<index.ml 21 5>>*/ }
    function obj_set(conv,name,value,obj_kv)
     { /*<<index.ml 24 2>>*/ if(conv)
       { /*<<index.ml 25 17>>*/ var
          /*<<index.ml 25 17>>*/ conv$0=conv[1],
          /*<<index.ml 25 65>>*/ _fF_=
          [0,[0,name, /*<<index.ml 25 65>>*/ caml_call1(conv$0,value)]];
         /*<<index.ml 25 65>>*/ return  /*<<index.ml 25 65>>*/ caml_call2
                (CCArray[5],obj_kv,_fF_)}
       /*<<index.ml 26 12>>*/ return  /*<<index.ml 26 12>>*/ caml_call2
              (CCArray[5],obj_kv,[0,[0,name,value]]) /*<<index.ml 26 68>>*/ }
    function obj_set_optdef(conv,name,value,obj_kv)
     { /*<<index.ml 29 2>>*/ if(value)
       { /*<<index.ml 30 14>>*/ var
          /*<<index.ml 30 14>>*/ v=value[1],
          /*<<index.ml 30 62>>*/ _fE_=
          [0,[0,name, /*<<index.ml 30 62>>*/ caml_call1(conv,v)]];
         /*<<index.ml 30 62>>*/ return  /*<<index.ml 30 62>>*/ caml_call2
                (CCArray[5],obj_kv,_fE_)}
       /*<<index.ml 31 12>>*/ return obj_kv /*<<index.ml 31 18>>*/ }
    function obj_set_opt(conv,name,value,obj_kv)
     { /*<<index.ml 34 2>>*/ if(value)
       { /*<<index.ml 35 14>>*/ var
          /*<<index.ml 35 14>>*/ v=value[1],
          /*<<index.ml 35 62>>*/ _fD_=
          [0,[0,name, /*<<index.ml 35 62>>*/ caml_call1(conv,v)]];
         /*<<index.ml 35 62>>*/ return  /*<<index.ml 35 62>>*/ caml_call2
                (CCArray[5],obj_kv,_fD_)}
       /*<<index.ml 36 12>>*/ return  /*<<index.ml 36 12>>*/ caml_call2
              (CCArray[5],obj_kv,[0,[0,name,Js[1]]]) /*<<index.ml 36 70>>*/ }
    function edit_action_to_js_edit_action(v)
     { /*<<index.ml 39 2>>*/ switch(v)
       {case 0:var _fC_=cst_create;break;
        case 1:var _fC_=cst_insert;break;
        case 2:var _fC_=cst_remove;break;
        default:var _fC_=cst_set}
      return _fC_.toString() /*<<index.ml 45 27>>*/ }
    function type_to_js_type(v)
     { /*<<index.ml 48 2>>*/ switch(v)
       {case 0:var _fB_=cst_map;break;
        case 1:var _fB_=cst_text;break;
        default:var _fB_=cst_list}
      return _fB_.toString() /*<<index.ml 50 66>>*/ }
    function path_to_js_path(v)
     { /*<<index.ml 53 2>>*/ function _fz_(param)
       { /*<<index.ml 56 9>>*/ if(901025494 <= param[1])
         { /*<<index.ml 57 25>>*/  /*<<index.ml 57 25>>*/ var s=param[2];
           /*<<index.ml 57 25>>*/ return  /*<<index.ml 57 25>>*/ s.toString()}
         /*<<index.ml 58 25>>*/  /*<<index.ml 58 25>>*/ var i=param[2];
         /*<<index.ml 58 25>>*/ return i /*<<index.ml 58 79>>*/ }
       /*<<index.ml 53 2>>*/  /*<<index.ml 53 2>>*/ var _fA_=CCList[33];
       /*<<index.ml 54 4>>*/ return  /*<<index.ml 54 4>>*/ list_to_js_array
              ( /*<<index.ml 54 4>>*/ caml_call2(_fA_,_fz_,v)) /*<<index.ml 59 9>>*/ }
    function actor_to_js_actor(actor)
     { /*<<index.ml 61 30>>*/ return  /*<<index.ml 61 30>>*/ actor.toString() /*<<index.ml 61 64>>*/ }
    function array_to_list(arr)
     { /*<<index.ml 63 40>>*/ return  /*<<index.ml 63 40>>*/ caml_call1
              (CCArray[10], /*<<index.ml 63 40>>*/ caml_js_to_array(arr)) /*<<index.ml 63 57>>*/ }
    function js_action_to_action(js_s)
     { /*<<index.ml 67 2>>*/ var
        /*<<index.ml 67 2>>*/ s= /*<<index.ml 67 2>>*/ caml_js_to_string(js_s),
        /*<<index.ml 67 2>>*/ _fs_=String[34];
       /*<<index.ml 68 5>>*/ if
       ( /*<<index.ml 68 5>>*/ caml_call2(_fs_,s,cst_set$0))
       return 4;
       /*<<index.ml 67 2>>*/  /*<<index.ml 69 7>>*/ var _ft_=String[34];
       /*<<index.ml 69 10>>*/ if
       ( /*<<index.ml 69 10>>*/ caml_call2(_ft_,s,cst_del))
       return 5;
       /*<<index.ml 67 2>>*/  /*<<index.ml 70 7>>*/ var _fu_=String[34];
       /*<<index.ml 70 10>>*/ if
       ( /*<<index.ml 70 10>>*/ caml_call2(_fu_,s,cst_makeMap))
       return 0;
       /*<<index.ml 67 2>>*/  /*<<index.ml 71 7>>*/ var _fv_=String[34];
       /*<<index.ml 71 10>>*/ if
       ( /*<<index.ml 71 10>>*/ caml_call2(_fv_,s,cst_makeList))
       return 1;
       /*<<index.ml 67 2>>*/  /*<<index.ml 72 7>>*/ var _fw_=String[34];
       /*<<index.ml 72 10>>*/ if
       ( /*<<index.ml 72 10>>*/ caml_call2(_fw_,s,cst_makeText))
       return 2;
       /*<<index.ml 67 2>>*/  /*<<index.ml 73 7>>*/ var _fx_=String[34];
       /*<<index.ml 73 10>>*/ if
       ( /*<<index.ml 73 10>>*/ caml_call2(_fx_,s,cst_link))
       return 6;
       /*<<index.ml 67 2>>*/  /*<<index.ml 74 7>>*/ var _fy_=String[34];
       /*<<index.ml 74 10>>*/ if
       ( /*<<index.ml 74 10>>*/ caml_call2(_fy_,s,cst_ins))
       return 3;
       /*<<index.ml 75 7>>*/ throw Not_supported /*<<index.ml 75 26>>*/ }
    function action_to_js_action(a)
     { /*<<index.ml 78 2>>*/ switch(a)
       {case 0:var _fr_=cst_makeMap$0;break;
        case 1:var _fr_=cst_makeList$0;break;
        case 2:var _fr_=cst_makeText$0;break;
        case 3:var _fr_=cst_ins$0;break;
        case 4:var _fr_=cst_set$1;break;
        case 5:var _fr_=cst_del$0;break;
        default:var _fr_=cst_link$0}
      return _fr_.toString() /*<<index.ml 87 21>>*/ }
    function op_val_to_js_value(param)
     { /*<<index.ml 89 25>>*/ switch(param[0])
       {case 0:
          /*<<index.ml 90 32>>*/  /*<<index.ml 90 32>>*/ var b=param[1];
          /*<<index.ml 90 32>>*/ return ! ! b;
        case 1:
          /*<<index.ml 91 31>>*/  /*<<index.ml 91 31>>*/ var s=param[1];
          /*<<index.ml 91 31>>*/ return  /*<<index.ml 91 31>>*/ s.toString();
        default:
          /*<<index.ml 92 34>>*/  /*<<index.ml 92 34>>*/ var n=param[1];
          /*<<index.ml 92 34>>*/ return n} /*<<index.ml 92 73>>*/ }
    var
     value_to_js_value=function _fq_(_fp_){return _fq_.fun(_fp_)},
     _d_=[0,0,0,0];
    runtime.caml_update_dummy
     (value_to_js_value,
      function(value)
       { /*<<index.ml 95 2>>*/ if(0 === value[0])
         { /*<<index.ml 96 15>>*/  /*<<index.ml 96 15>>*/ var s=value[1];
           /*<<index.ml 96 15>>*/ return  /*<<index.ml 96 15>>*/ op_val_to_js_value
                  (s)}
         /*<<index.ml 98 6>>*/ function _ff_(self,obj)
         { /*<<index.ml 99 8>>*/ if(! _d_[1])
           {var
             _fi_=caml_call1(CamlinternalOO[16],shared),
             _fj_=caml_call2(CamlinternalOO[3],_fi_,cst),
             _fk_=caml_call2(CamlinternalOO[7],_fi_,cst_obj),
             _fl_=
              function(self_1)
               { /*<<?>>*/ var env=self_1[_fj_ + 1];return env[1]};
            caml_call3(CamlinternalOO[10],_fi_,_fk_,_fl_);
            var
             _fm_=
              function(_fn_)
               { /*<<?>>*/ var _fo_=caml_call2(CamlinternalOO[24],0,_fi_);
                _fo_[_fj_ + 1] = _fn_;
                return _fo_};
            caml_call1(CamlinternalOO[17],_fi_);
            _d_[1] = _fm_}
          return caml_call1(_d_[1],[0,obj]) /*<<index.ml 101 12>>*/ }
         /*<<index.ml 98 6>>*/ var
          /*<<index.ml 98 6>>*/ _fg_=value[1],
          /*<<index.ml 100 21>>*/ _fh_=
           /*<<index.ml 100 21>>*/ caml_call1(value_to_js_value,_fg_);
         /*<<index.ml 100 21>>*/ return  /*<<index.ml 100 21>>*/ function
                 (t2,param)
                 { /*<<?>>*/ return {"obj":t2}}
                (_fh_,_ff_) /*<<index.ml 101 12>>*/ });
    function js_value_to_op_val(js_value)
     { /*<<index.ml 104 25>>*/  /*<<index.ml 104 25>>*/ var
       typ=
         /*<<index.ml 104 25>>*/ caml_js_to_string(typeof js_value);
       /*<<index.ml 104 25>>*/ if
       ( /*<<index.ml 104 25>>*/ caml_string_notequal(typ,cst_boolean))
       {if(caml_string_notequal(typ,cst_number))
         {if(caml_string_notequal(typ,cst_string))throw Not_supported;
           /*<<index.ml 107 28>>*/ return [1,
                   /*<<index.ml 107 28>>*/ caml_js_to_string(js_value)]}
         /*<<index.ml 111 31>>*/ return [2,js_value]}
       /*<<index.ml 109 29>>*/ return [0,js_value | 0] /*<<index.ml 112 28>>*/ }
    function to_op_list(arr)
     { /*<<index.ml 115 2>>*/  /*<<index.ml 115 2>>*/ var
       _eF_=
         /*<<index.ml 115 2>>*/ array_to_list(arr);
       /*<<index.ml 115 2>>*/ function _eG_(js_op)
       { /*<<index.ml 117 11>>*/ function _eH_(x)
         { /*<<index.ml 123 41>>*/ return  /*<<index.ml 123 41>>*/ caml_call1
                  ( /*<<index.ml 123 41>>*/ caml_get_public_method
                    (x,834174833,1),
                   x) /*<<index.ml 123 54>>*/ }
         /*<<index.ml 117 11>>*/ function _eI_(t6,param)
         { /*<<?>>*/ return t6.value}
         /*<<index.ml 123 41>>*/ var
          /*<<index.ml 123 41>>*/ _eJ_=
           /*<<index.ml 123 41>>*/ _eI_(js_op,_eH_),
          /*<<index.ml 123 41>>*/ _eK_=Js[6][3],
          /*<<index.ml 123 36>>*/ _eL_=
           /*<<index.ml 123 36>>*/ caml_call2(_eK_,_eJ_,js_value_to_op_val),
          /*<<index.ml 123 36>>*/ _eM_=Js[6][10],
          /*<<index.ml 123 26>>*/ _eN_=
           /*<<index.ml 123 26>>*/ caml_call1(_eM_,_eL_);
         /*<<index.ml 123 26>>*/ function _eO_(_fe_){ /*<<?>>*/ return _fe_}
         /*<<index.ml 123 26>>*/ function _eP_(_fd_)
         { /*<<?>>*/ return _fd_ | 0}
         /*<<index.ml 121 45>>*/ function _eQ_(_fc_)
         { /*<<?>>*/ return _c_(_eP_,_eO_,_fc_)}
         /*<<index.ml 121 45>>*/ function _eR_(x)
         { /*<<index.ml 121 32>>*/ return  /*<<index.ml 121 32>>*/ caml_call1
                  ( /*<<index.ml 121 32>>*/ caml_get_public_method
                    (x,-1022044017,2),
                   x) /*<<index.ml 121 44>>*/ }
         /*<<index.ml 121 45>>*/ function _eS_(t5,param)
         { /*<<?>>*/ return t5.elem}
         /*<<index.ml 121 32>>*/ var
          /*<<index.ml 121 32>>*/ _eT_=
           /*<<index.ml 121 32>>*/ _eS_(js_op,_eR_),
          /*<<index.ml 121 32>>*/ _eU_=Js[6][3],
          /*<<index.ml 121 27>>*/ _eV_=
           /*<<index.ml 121 27>>*/ caml_call2(_eU_,_eT_,_eQ_),
          /*<<index.ml 121 27>>*/ _eW_=Js[6][10],
          /*<<index.ml 121 17>>*/ _eX_=
           /*<<index.ml 121 17>>*/ caml_call1(_eW_,_eV_);
         /*<<index.ml 121 17>>*/ function _eY_(x)
         { /*<<index.ml 124 31>>*/ return  /*<<index.ml 124 31>>*/ caml_call1
                  ( /*<<index.ml 124 31>>*/ caml_get_public_method
                    (x,5541879,3),
                   x) /*<<index.ml 124 42>>*/ }
         /*<<index.ml 121 17>>*/ function _eZ_(t7,param)
         { /*<<?>>*/ return t7.obj}
         /*<<index.ml 124 31>>*/ var
          /*<<index.ml 124 31>>*/ _e0_=
           /*<<index.ml 124 31>>*/ _eZ_(js_op,_eY_),
          /*<<index.ml 124 42>>*/ _e1_=
           /*<<index.ml 124 42>>*/ caml_js_to_string(_e0_);
         /*<<index.ml 124 42>>*/ function _e2_(x)
         { /*<<index.ml 117 41>>*/ return  /*<<index.ml 117 41>>*/ caml_call1
                  ( /*<<index.ml 117 41>>*/ caml_get_public_method
                    (x,373701558,4),
                   x) /*<<index.ml 117 55>>*/ }
         /*<<index.ml 124 42>>*/ function _e3_(t3,param)
         { /*<<?>>*/ return t3.action}
         /*<<index.ml 117 41>>*/ var
          /*<<index.ml 117 41>>*/ _e4_=
           /*<<index.ml 117 41>>*/ _e3_(js_op,_e2_),
          /*<<index.ml 117 21>>*/ _e5_=
           /*<<index.ml 117 21>>*/ js_action_to_action(_e4_);
         /*<<index.ml 117 21>>*/ function _e6_(_fb_)
         { /*<<?>>*/ return caml_js_to_string(_fb_)}
         /*<<index.ml 117 21>>*/ function _e7_(x)
         { /*<<index.ml 118 44>>*/ return  /*<<index.ml 118 44>>*/ caml_call1
                  ( /*<<index.ml 118 44>>*/ caml_get_public_method
                    (x,5343647,5),
                   x) /*<<index.ml 118 55>>*/ }
         /*<<index.ml 117 21>>*/ function _e8_(t4,param)
         { /*<<?>>*/ return t4.key}
         /*<<index.ml 118 44>>*/ var
          /*<<index.ml 118 44>>*/ _e9_=
           /*<<index.ml 118 44>>*/ _e8_(js_op,_e7_),
          /*<<index.ml 118 44>>*/ _e__=Js[6][3],
          /*<<index.ml 118 39>>*/ _e$_=
           /*<<index.ml 118 39>>*/ caml_call2(_e__,_e9_,_e6_),
          /*<<index.ml 118 39>>*/ _fa_=Js[6][10];
         /*<<index.ml 118 29>>*/ return [0,
                 /*<<index.ml 118 29>>*/ caml_call1(_fa_,_e$_),
                _e5_,
                _e1_,
                _eX_,
                _eN_] /*<<index.ml 124 44>>*/ }
       /*<<index.ml 115 2>>*/ return  /*<<index.ml 115 2>>*/ caml_call2
              (CCList[33],_eG_,_eF_) /*<<index.ml 125 39>>*/ }
    function conflicts_to_js_conflicts(v)
     { /*<<index.ml 128 2>>*/ function _ew_(confl)
       { /*<<index.ml 131 9>>*/ var
          /*<<index.ml 131 9>>*/ _ey_=CCArray[21],
          /*<<index.ml 131 9>>*/ _ez_=confl[1],
          /*<<index.ml 131 9>>*/ _eA_=[0,actor_to_js_actor],
          /*<<index.ml 131 9>>*/ _eB_=
           /*<<index.ml 131 9>>*/ obj_set(_eA_,cst_actor,_ez_,_ey_),
          /*<<index.ml 131 9>>*/ _eC_=confl[2],
          /*<<index.ml 131 9>>*/ _eD_=
           /*<<index.ml 131 9>>*/ obj_set_optdef
           (op_val_to_js_value,cst_value,_eC_,_eB_);
         /*<<index.ml 131 9>>*/ return  /*<<index.ml 131 9>>*/ function(_eE_)
                 { /*<<?>>*/ return caml_js_object(_eE_)}
                (_eD_) /*<<index.ml 134 25>>*/ }
       /*<<index.ml 128 2>>*/  /*<<index.ml 128 2>>*/ var _ex_=CCList[33];
       /*<<index.ml 129 4>>*/ return  /*<<index.ml 129 4>>*/ list_to_js_array
              ( /*<<index.ml 129 4>>*/ caml_call2(_ex_,_ew_,v)) /*<<index.ml 135 9>>*/ }
    function number_of_int(i)
     { /*<<index.ml 137 22>>*/ return i /*<<index.ml 137 57>>*/ }
    function obj_set_path(edit,obj_kv)
     { /*<<index.ml 140 2>>*/ if(0 === edit[2])return obj_kv;
       /*<<index.ml 141 68>>*/  /*<<index.ml 141 68>>*/ var _eu_=edit[10];
       /*<<index.ml 141 68>>*/ if(_eu_)
       { /*<<index.ml 144 8>>*/ var
          /*<<index.ml 144 8>>*/ v=_eu_[1],
          /*<<index.ml 144 58>>*/ _ev_=
          [0,[0,cst_path, /*<<index.ml 144 58>>*/ path_to_js_path(v)]];
         /*<<index.ml 144 58>>*/ return  /*<<index.ml 144 58>>*/ caml_call2
                (CCArray[5],obj_kv,_ev_)}
       /*<<index.ml 145 14>>*/ return  /*<<index.ml 145 14>>*/ caml_call2
              (CCArray[5],obj_kv,[0,[0,cst_path$0,Js[1]]]) /*<<index.ml 146 15>>*/ }
    function edit_to_js_edit(edit)
     { /*<<index.ml 149 2>>*/ var
        /*<<index.ml 149 2>>*/ _d1_=CCArray[21],
        /*<<index.ml 149 2>>*/ _d2_=edit[2],
        /*<<index.ml 149 2>>*/ _d3_=[0,edit_action_to_js_edit_action],
        /*<<index.ml 149 2>>*/ _d4_=
         /*<<index.ml 149 2>>*/ obj_set(_d3_,cst_action,_d2_,_d1_),
        /*<<index.ml 149 2>>*/ _d5_=edit[6],
        /*<<index.ml 149 2>>*/ _d6_=
        [0,function(_et_){ /*<<?>>*/ return _et_.toString()}],
        /*<<index.ml 149 2>>*/ _d7_=
         /*<<index.ml 149 2>>*/ obj_set(_d6_,cst_obj$0,_d5_,_d4_),
        /*<<index.ml 149 2>>*/ _d8_=edit[4];
       /*<<index.ml 149 2>>*/ function _d9_(_es_)
       { /*<<?>>*/ return _es_.toString()}
       /*<<index.ml 149 2>>*/ var
        /*<<index.ml 149 2>>*/ _d__=
         /*<<index.ml 149 2>>*/ obj_set_optdef(_d9_,cst_key,_d8_,_d7_),
        /*<<index.ml 149 2>>*/ _d$_=edit[5],
        /*<<index.ml 149 2>>*/ _ea_=
         /*<<index.ml 149 2>>*/ obj_set_optdef
         (value_to_js_value,cst_value$0,_d$_,_d__),
        /*<<index.ml 149 2>>*/ _eb_=edit[1],
        /*<<index.ml 149 2>>*/ _ec_=[0,type_to_js_type],
        /*<<index.ml 149 2>>*/ _ed_=
         /*<<index.ml 149 2>>*/ obj_set(_ec_,cst_type,_eb_,_ea_),
        /*<<index.ml 149 2>>*/ _ee_=edit[7]?[0,edit[7]]:0;
      function _ef_(_er_){ /*<<?>>*/ return ! ! _er_}
       /*<<index.ml 149 2>>*/ var
        /*<<index.ml 149 2>>*/ _eg_=
         /*<<index.ml 149 2>>*/ obj_set_optdef(_ef_,cst_link$1,_ee_,_ed_),
        /*<<index.ml 149 2>>*/ _eh_=
         /*<<index.ml 149 2>>*/ obj_set_path(edit,_eg_),
        /*<<index.ml 149 2>>*/ _ei_=edit[9],
        /*<<index.ml 149 2>>*/ _ej_=
         /*<<index.ml 149 2>>*/ obj_set_optdef
         (conflicts_to_js_conflicts,cst_conflicts,_ei_,_eh_),
        /*<<index.ml 149 2>>*/ _ek_=edit[8],
        /*<<index.ml 149 2>>*/ _el_=
         /*<<index.ml 149 2>>*/ obj_set_optdef
         (number_of_int,cst_index,_ek_,_ej_),
        /*<<index.ml 149 2>>*/ _em_=edit[3];
       /*<<index.ml 149 2>>*/ function _en_(_eq_)
       { /*<<?>>*/ return _eq_.toString()}
       /*<<index.ml 149 2>>*/  /*<<index.ml 149 2>>*/ var
       _eo_=
         /*<<index.ml 149 2>>*/ obj_set_optdef(_en_,cst_elemId,_em_,_el_);
       /*<<index.ml 149 2>>*/ return  /*<<index.ml 149 2>>*/ function(_ep_)
               { /*<<?>>*/ return caml_js_object(_ep_)}
              (_eo_) /*<<index.ml 160 18>>*/ }
    function change_op_to_js_change_op(op)
     { /*<<index.ml 163 2>>*/ var
        /*<<index.ml 163 2>>*/ _dD_=CCArray[21],
        /*<<index.ml 163 2>>*/ _dE_=op[2],
        /*<<index.ml 164 22>>*/ _dF_=
         /*<<index.ml 164 22>>*/ action_to_js_action(_dE_),
        /*<<index.ml 164 22>>*/ _dG_=0,
        /*<<index.ml 163 2>>*/ _dH_=
         /*<<index.ml 163 2>>*/ obj_set(_dG_,cst_action$0,_dF_,_dD_),
        /*<<index.ml 163 2>>*/ _dI_=op[1];
       /*<<index.ml 163 2>>*/ function _dJ_(_d0_)
       { /*<<?>>*/ return _d0_.toString()}
       /*<<index.ml 163 2>>*/ var
        /*<<index.ml 163 2>>*/ _dK_=
         /*<<index.ml 163 2>>*/ obj_set_optdef(_dJ_,cst_key$0,_dI_,_dH_),
        /*<<index.ml 163 2>>*/ _dL_=op[4];
       /*<<index.ml 163 2>>*/ function _dM_(_dZ_){ /*<<?>>*/ return _dZ_}
       /*<<index.ml 163 2>>*/ function _dN_(_dY_){ /*<<?>>*/ return _dY_}
       /*<<index.ml 166 20>>*/ function _dO_(_dX_)
       { /*<<?>>*/ return _c_(_dN_,_dM_,_dX_)}
       /*<<index.ml 163 2>>*/ var
        /*<<index.ml 163 2>>*/ _dP_=
         /*<<index.ml 163 2>>*/ obj_set_optdef(_dO_,cst_elem,_dL_,_dK_),
        /*<<index.ml 163 2>>*/ _dQ_=op[5],
        /*<<index.ml 163 2>>*/ _dR_=
         /*<<index.ml 163 2>>*/ obj_set_optdef
         (op_val_to_js_value,cst_value$1,_dQ_,_dP_),
        /*<<index.ml 163 2>>*/ _dS_=op[3],
        /*<<index.ml 168 19>>*/ _dT_= /*<<index.ml 168 19>>*/ _dS_.toString(),
        /*<<index.ml 168 19>>*/ _dU_=0,
        /*<<index.ml 163 2>>*/ _dV_=
         /*<<index.ml 163 2>>*/ obj_set(_dU_,cst_obj$1,_dT_,_dR_);
       /*<<index.ml 163 2>>*/ return  /*<<index.ml 163 2>>*/ function(_dW_)
               { /*<<?>>*/ return caml_js_object(_dW_)}
              (_dV_) /*<<index.ml 169 18>>*/ }
    function actor_map_of_js_obj(js_obj)
     { /*<<index.ml 172 2>>*/ var
        /*<<index.ml 172 2>>*/ _dy_=Js[13],
        /*<<index.ml 172 14>>*/ _dz_=
         /*<<index.ml 172 14>>*/ caml_call1(_dy_,js_obj),
        /*<<index.ml 172 37>>*/ _dA_=
         /*<<index.ml 172 37>>*/ caml_js_to_array(_dz_),
        /*<<index.ml 172 37>>*/ _dB_=Op_set[10][1];
       /*<<index.ml 172 37>>*/ function _dC_(amap,js_actor)
       { /*<<index.ml 175 9>>*/  /*<<index.ml 175 9>>*/ var
         value=
          js_obj[js_actor];
         /*<<index.ml 176 22>>*/ return  /*<<index.ml 176 22>>*/ caml_call3
                (Op_set[10][4],
                  /*<<index.ml 176 22>>*/ caml_js_to_string(js_actor),
                 value,
                 amap) /*<<index.ml 176 56>>*/ }
       /*<<index.ml 172 37>>*/ return  /*<<index.ml 172 37>>*/ caml_call3
              (CCArray[29],_dC_,_dB_,_dA_) /*<<index.ml 177 21>>*/ }
    function js_obj_of_actor_map(conv,m)
     { /*<<index.ml 181 2>>*/ var
        /*<<index.ml 181 2>>*/ _ds_=Op_set[10][45],
        /*<<index.ml 182 20>>*/ _dt_=
         /*<<index.ml 182 20>>*/ caml_call1(_ds_,m),
        /*<<index.ml 182 20>>*/ _du_=CCArray[11],
        /*<<index.ml 182 4>>*/ _dv_=
         /*<<index.ml 182 4>>*/ caml_call1(_du_,_dt_);
       /*<<index.ml 182 4>>*/ function _dw_(param)
       { /*<<index.ml 183 19>>*/ var
          /*<<index.ml 183 19>>*/ v=param[2],
          /*<<index.ml 183 19>>*/ k=param[1];
         /*<<index.ml 183 55>>*/ return [0,
                k,
                 /*<<index.ml 183 55>>*/ caml_call1(conv,v)] /*<<index.ml 183 65>>*/ }
       /*<<index.ml 182 4>>*/ var
        /*<<index.ml 182 4>>*/ _dx_=CCArray[63],
        /*<<index.ml 182 4>>*/ kv=
         /*<<index.ml 182 4>>*/ caml_call2(_dx_,_dw_,_dv_);
       /*<<index.ml 182 4>>*/ return  /*<<index.ml 182 4>>*/ caml_js_object
              (kv) /*<<index.ml 185 18>>*/ }
    function int_of_js_number(n)
     { /*<<index.ml 187 38>>*/ return n | 0 /*<<index.ml 187 60>>*/ }
    function js_change_to_change(js_change)
     { /*<<index.ml 190 2>>*/ function _dd_(x)
       { /*<<index.ml 193 20>>*/ return  /*<<index.ml 193 20>>*/ caml_call1
                ( /*<<index.ml 193 20>>*/ caml_get_public_method(x,5545010,6),
                 x) /*<<index.ml 193 35>>*/ }
       /*<<index.ml 190 2>>*/ function _de_(t11,param)
       { /*<<?>>*/ return t11.ops}
       /*<<index.ml 193 20>>*/ var
        /*<<index.ml 193 20>>*/ _df_=
         /*<<index.ml 193 20>>*/ _de_(js_change,_dd_),
        /*<<index.ml 193 9>>*/ _dg_= /*<<index.ml 193 9>>*/ to_op_list(_df_);
       /*<<index.ml 193 9>>*/ function _dh_(x)
       { /*<<index.ml 192 30>>*/ return  /*<<index.ml 192 30>>*/ caml_call1
                ( /*<<index.ml 192 30>>*/ caml_get_public_method
                  (x,-1033479228,7),
                 x) /*<<index.ml 192 46>>*/ }
       /*<<index.ml 193 9>>*/ function _di_(t10,param)
       { /*<<?>>*/ return t10.deps}
       /*<<index.ml 192 30>>*/ var
        /*<<index.ml 192 30>>*/ _dj_=
         /*<<index.ml 192 30>>*/ _di_(js_change,_dh_),
        /*<<index.ml 192 10>>*/ _dk_=
         /*<<index.ml 192 10>>*/ actor_map_of_js_obj(_dj_);
       /*<<index.ml 192 10>>*/ function _dl_(x)
       { /*<<index.ml 191 26>>*/ return  /*<<index.ml 191 26>>*/ caml_call1
                ( /*<<index.ml 191 26>>*/ caml_get_public_method(x,5741471,8),
                 x) /*<<index.ml 191 41>>*/ }
       /*<<index.ml 192 10>>*/ function _dm_(t9,param)
       { /*<<?>>*/ return t9.seq}
       /*<<index.ml 191 26>>*/ var
        /*<<index.ml 191 26>>*/ _dn_=
         /*<<index.ml 191 26>>*/ _dm_(js_change,_dl_),
        /*<<index.ml 191 9>>*/ _do_=
         /*<<index.ml 191 9>>*/ int_of_js_number(_dn_);
       /*<<index.ml 191 9>>*/ function _dp_(x)
       { /*<<index.ml 190 24>>*/ return  /*<<index.ml 190 24>>*/ caml_call1
                ( /*<<index.ml 190 24>>*/ caml_get_public_method
                  (x,463915765,9),
                 x) /*<<index.ml 190 41>>*/ }
       /*<<index.ml 191 9>>*/ function _dq_(t8,param)
       { /*<<?>>*/ return t8.actor}
       /*<<index.ml 190 24>>*/  /*<<index.ml 190 24>>*/ var
       _dr_=
         /*<<index.ml 190 24>>*/ _dq_(js_change,_dp_);
       /*<<index.ml 190 41>>*/ return [0,
               /*<<index.ml 190 41>>*/ caml_js_to_string(_dr_),
              _do_,
              _dk_,
              _dg_] /*<<index.ml 193 37>>*/ }
    function js_number_of_int(i)
     { /*<<index.ml 195 25>>*/ return i /*<<index.ml 195 60>>*/ }
    function change_to_js_change(change)
     { /*<<index.ml 198 2>>*/ var
        /*<<index.ml 198 2>>*/ _cM_=CCArray[21],
        /*<<index.ml 198 2>>*/ _cN_=change[1],
        /*<<index.ml 198 2>>*/ _cO_=
        [0,function(_dc_){ /*<<?>>*/ return _dc_.toString()}],
        /*<<index.ml 198 2>>*/ _cP_=
         /*<<index.ml 198 2>>*/ obj_set(_cO_,cst_actor$0,_cN_,_cM_),
        /*<<index.ml 198 2>>*/ _cQ_=change[2];
       /*<<index.ml 198 2>>*/ function _cR_(_db_){ /*<<?>>*/ return _db_}
       /*<<index.ml 198 2>>*/ function _cS_(_da_){ /*<<?>>*/ return _da_}
       /*<<index.ml 200 19>>*/ var
        /*<<index.ml 200 19>>*/ _cT_=
        [0,function(_c$_){ /*<<?>>*/ return _c_(_cS_,_cR_,_c$_)}],
        /*<<index.ml 198 2>>*/ _cU_=
         /*<<index.ml 198 2>>*/ obj_set(_cT_,cst_seq,_cQ_,_cP_),
        /*<<index.ml 198 2>>*/ _cV_=change[3],
        /*<<index.ml 201 19>>*/ _cW_=
        [0,
         function(_c__)
          { /*<<?>>*/ return js_obj_of_actor_map(js_number_of_int,_c__)}],
        /*<<index.ml 198 2>>*/ _cX_=
         /*<<index.ml 198 2>>*/ obj_set(_cW_,cst_deps,_cV_,_cU_),
        /*<<index.ml 198 2>>*/ _cY_=change[4],
        /*<<index.ml 198 2>>*/ _cZ_=CCList[33],
        /*<<index.ml 203 43>>*/ _c0_=
         /*<<index.ml 203 43>>*/ caml_call1(_cZ_,change_op_to_js_change_op),
        /*<<index.ml 203 43>>*/ _c1_=CCArray[11];
       /*<<index.ml 203 43>>*/ function _c2_(_c9_)
       { /*<<?>>*/ return caml_js_from_array(_c9_)}
       /*<<index.ml 203 14>>*/ function _c3_(_c8_)
       { /*<<?>>*/ return _c_(_c2_,_c1_,_c8_)}
       /*<<index.ml 203 13>>*/ var
        /*<<index.ml 203 13>>*/ _c4_=
        [0,function(_c7_){ /*<<?>>*/ return _c_(_c3_,_c0_,_c7_)}],
        /*<<index.ml 198 2>>*/ _c5_=
         /*<<index.ml 198 2>>*/ obj_set(_c4_,cst_ops,_cY_,_cX_);
       /*<<index.ml 198 2>>*/ return  /*<<index.ml 198 2>>*/ function(_c6_)
               { /*<<?>>*/ return caml_js_object(_c6_)}
              (_c5_) /*<<index.ml 205 18>>*/ }
    function require_module(s)
     { /*<<index.ml 211 25>>*/  /*<<index.ml 211 25>>*/ var
       _cL_=
         /*<<index.ml 211 25>>*/ s.toString();
       /*<<index.ml 210 6>>*/ return  /*<<index.ml 210 6>>*/ require(_cL_) /*<<index.ml 211 40>>*/ }
    function _e_(_cK_){ /*<<?>>*/ return _cK_}
    function _f_(_cJ_){ /*<<?>>*/ return _cJ_}
     /*<<index.ml 213 15>>*/ function number(_cI_)
     { /*<<?>>*/ return _c_(_f_,_e_,_cI_)}
     /*<<index.ml 213 15>>*/ function clock$0(clock)
     { /*<<index.ml 215 42>>*/ return  /*<<index.ml 215 42>>*/ js_obj_of_actor_map
              (number,clock) /*<<index.ml 215 74>>*/ }
     /*<<index.ml 213 15>>*/ function change_list(lis)
     { /*<<index.ml 217 24>>*/  /*<<index.ml 217 24>>*/ var _cH_=CCList[33];
       /*<<index.ml 217 24>>*/ return  /*<<index.ml 217 24>>*/ list_to_js_array
              ( /*<<index.ml 217 24>>*/ caml_call2
                (_cH_,change_to_js_change,lis)) /*<<index.ml 217 78>>*/ }
     /*<<index.ml 213 15>>*/ function imm_Map(kv)
     { /*<<index.ml 220 20>>*/  /*<<index.ml 220 20>>*/ var
       immutable=
         /*<<index.ml 220 20>>*/ require_module(cst_immutable);
       /*<<index.ml 220 20>>*/ function _cF_(x)
       { /*<<index.ml 221 15>>*/ return  /*<<index.ml 221 15>>*/ caml_call1
                ( /*<<index.ml 221 15>>*/ caml_get_public_method
                  (x,1057359741,10),
                 x) /*<<index.ml 221 51>>*/ }
       /*<<index.ml 220 20>>*/ function _cG_(t12,param)
       { /*<<?>>*/ return t12.Map}
       /*<<index.ml 221 15>>*/  /*<<index.ml 221 15>>*/ var
       Map=
         /*<<index.ml 221 15>>*/ _cG_(immutable,_cF_);
       /*<<index.ml 221 15>>*/ return  /*<<index.ml 221 15>>*/ Map(kv) /*<<index.ml 222 53>>*/ }
     /*<<index.ml 213 15>>*/ function imm(o)
     { /*<<index.ml 225 4>>*/ function _cB_(x)
       { /*<<index.ml 225 17>>*/ return  /*<<index.ml 225 17>>*/ caml_call1
                ( /*<<index.ml 225 17>>*/ caml_get_public_method
                  (x,-855557372,11),
                 x) /*<<index.ml 225 44>>*/ }
       /*<<index.ml 225 4>>*/ function _cC_(t13,param)
       { /*<<?>>*/ return t13.toJS}
       /*<<index.ml 225 17>>*/  /*<<index.ml 225 17>>*/ var
       is_imm=
         /*<<index.ml 225 17>>*/ _cC_(o,_cB_);
       /*<<index.ml 225 17>>*/ function _cD_(param)
       { /*<<index.ml 228 27>>*/ return  /*<<index.ml 228 27>>*/ o.toJS() /*<<index.ml 228 59>>*/ }
       /*<<index.ml 225 17>>*/ function _cE_(param)
       { /*<<index.ml 227 17>>*/ return o /*<<index.ml 227 18>>*/ }
       /*<<index.ml 225 17>>*/ return  /*<<index.ml 225 17>>*/ caml_call3
              (Js[6][7],is_imm,_cE_,_cD_) /*<<index.ml 228 61>>*/ }
     /*<<index.ml 213 15>>*/  /*<<index.ml 213 15>>*/ var
     ToJs=
      [0,require_module,number,clock$0,change_list,imm_Map,imm];
     /*<<index.ml 213 15>>*/ function from_imm(imm_obj)
     { /*<<index.ml 232 36>>*/ return  /*<<index.ml 232 36>>*/ imm_obj.toJS() /*<<index.ml 232 74>>*/ }
     /*<<index.ml 213 15>>*/ function clock$1(clock)
     { /*<<index.ml 235 18>>*/ var
        /*<<index.ml 235 18>>*/ simple=
         /*<<index.ml 235 18>>*/ from_imm(clock),
        /*<<index.ml 235 18>>*/ _cv_=Js[13],
        /*<<index.ml 236 18>>*/ _cw_=
         /*<<index.ml 236 18>>*/ caml_call1(_cv_,simple);
       /*<<index.ml 236 18>>*/ function _cx_(_cA_)
       { /*<<?>>*/ return caml_js_to_array(_cA_)}
       /*<<index.ml 236 18>>*/ var
        /*<<index.ml 236 18>>*/ actors= /*<<index.ml 236 18>>*/ _cx_(_cw_),
        /*<<index.ml 236 18>>*/ _cy_=Op_set[10][1];
       /*<<index.ml 236 18>>*/ function _cz_(clock,actor)
       { /*<<index.ml 239 8>>*/ var
          /*<<index.ml 239 8>>*/ seq=simple[actor],
          /*<<index.ml 240 8>>*/ seq$0=seq | 0;
         /*<<index.ml 241 21>>*/ return  /*<<index.ml 241 21>>*/ caml_call3
                (Op_set[10][4],
                  /*<<index.ml 241 21>>*/ caml_js_to_string(actor),
                 seq$0,
                 clock) /*<<index.ml 241 52>>*/ }
       /*<<index.ml 236 18>>*/ return  /*<<index.ml 236 18>>*/ caml_call3
              (CCArray[29],_cz_,_cy_,actors) /*<<index.ml 242 28>>*/ }
     /*<<index.ml 213 15>>*/ var
      /*<<index.ml 213 15>>*/ FromJs=[0,from_imm,clock$1],
      /*<<index.ml 213 15>>*/ _g_=[0,0,0,0];
     /*<<index.ml 213 15>>*/ function make_patch(t,diffs)
     { /*<<index.ml 248 2>>*/ var
        /*<<index.ml 248 2>>*/ _b1_=t[1],
        /*<<index.ml 248 2>>*/ _b2_=Op_set[20][84],
        /*<<index.ml 248 14>>*/ clock=
         /*<<index.ml 248 14>>*/ caml_call1(_b2_,_b1_);
       /*<<index.ml 248 14>>*/ function _b3_
       (self,clock,deps,canUndo,canRedo,diffs)
       { /*<<?>>*/ if(! _g_[1])
         {var
           _cf_=caml_call1(CamlinternalOO[16],_a_),
           _cg_=caml_call2(CamlinternalOO[3],_cf_,cst$0),
           _ch_=caml_call2(CamlinternalOO[8],_cf_,_b_),
           _ci_=_ch_[1],
           _cj_=_ch_[2],
           _ck_=_ch_[3],
           _cl_=_ch_[4],
           _cm_=_ch_[5],
           _cn_=
            function(self_2)
             { /*<<?>>*/ var env=self_2[_cg_ + 1];return env[1]},
           _co_=
            function(self_2)
             { /*<<?>>*/ var env=self_2[_cg_ + 1];return env[2]},
           _cp_=
            function(self_2)
             { /*<<?>>*/ var env=self_2[_cg_ + 1];return env[3]},
           _cq_=
            function(self_2)
             { /*<<?>>*/ var env=self_2[_cg_ + 1];return env[4]},
           _cr_=
            [0,
             _ck_,
             function(self_2)
              { /*<<?>>*/ var env=self_2[_cg_ + 1];return env[5]},
             _cj_,
             _cq_,
             _cl_,
             _cp_,
             _cm_,
             _co_,
             _ci_,
             _cn_];
          caml_call2(CamlinternalOO[11],_cf_,_cr_);
          var
           _cs_=
            function(_ct_)
             { /*<<?>>*/ var _cu_=caml_call2(CamlinternalOO[24],0,_cf_);
              _cu_[_cg_ + 1] = _ct_;
              return _cu_};
          caml_call1(CamlinternalOO[17],_cf_);
          _g_[1] = _cs_}
        return caml_call1(_g_[1],[0,diffs,canRedo,canUndo,deps,clock])}
       /*<<index.ml 248 14>>*/ var
        /*<<index.ml 248 14>>*/ _b4_=t[1],
        /*<<index.ml 248 14>>*/ _b5_=Op_set[20][87],
        /*<<index.ml 257 26>>*/ _b6_=
         /*<<index.ml 257 26>>*/ caml_call1(_b5_,_b4_),
        /*<<index.ml 257 58>>*/ _b7_=! ! _b6_,
        /*<<index.ml 257 58>>*/ _b8_=t[1],
        /*<<index.ml 257 58>>*/ _b9_=Op_set[20][86],
        /*<<index.ml 255 26>>*/ _b__=
         /*<<index.ml 255 26>>*/ caml_call1(_b9_,_b8_),
        /*<<index.ml 255 58>>*/ _b$_=! ! _b__,
        /*<<index.ml 255 58>>*/ _ca_=t[1],
        /*<<index.ml 255 58>>*/ _cb_=Op_set[20][85],
        /*<<index.ml 253 43>>*/ _cc_=
         /*<<index.ml 253 43>>*/ caml_call1(_cb_,_ca_),
        /*<<index.ml 253 6>>*/ _cd_=
         /*<<index.ml 253 6>>*/ js_obj_of_actor_map(js_number_of_int,_cc_),
        /*<<index.ml 250 16>>*/ _ce_=
         /*<<index.ml 250 16>>*/ js_obj_of_actor_map(js_number_of_int,clock);
       /*<<index.ml 250 16>>*/ return  /*<<index.ml 250 16>>*/ function
               (t14,t15,t16,t17,t18,param)
               { /*<<?>>*/ return {"clock":t14,
                        "deps":t15,
                        "canUndo":t16,
                        "canRedo":t17,
                        "diffs":t18}}
              (_ce_,_cd_,_b$_,_b7_,diffs,_b3_) /*<<index.ml 260 5>>*/ }
     /*<<index.ml 213 15>>*/ function init(param)
     { /*<<index.ml 262 14>>*/ var
        /*<<index.ml 262 14>>*/ _bZ_=0,
        /*<<index.ml 262 14>>*/ _b0_=Op_set[20][58];
       /*<<index.ml 262 23>>*/ return [0,
               /*<<index.ml 262 23>>*/ caml_call1(_b0_,_bZ_)] /*<<index.ml 262 44>>*/ }
     /*<<index.ml 213 15>>*/ function apply(t,changes,undoable)
     { /*<<index.ml 265 2>>*/  /*<<index.ml 265 2>>*/ var _bS_=[0,t,0];
       /*<<index.ml 265 2>>*/ function _bT_(param,change)
       { /*<<index.ml 267 6>>*/ var
          /*<<index.ml 267 6>>*/ diffs=param[2],
          /*<<index.ml 267 6>>*/ t=param[1],
          /*<<index.ml 267 6>>*/ _bV_=t[1],
          /*<<index.ml 267 6>>*/ _bW_=Op_set[20][57],
          /*<<index.ml 269 10>>*/ match=
           /*<<index.ml 269 10>>*/ caml_call3(_bW_,_bV_,change,undoable),
          /*<<index.ml 269 10>>*/ new_diffs=match[2],
          /*<<index.ml 269 10>>*/ op_set=match[1],
          /*<<index.ml 269 10>>*/ _bX_=[0,diffs,[0,new_diffs,0]],
          /*<<index.ml 269 10>>*/ _bY_=CCList[7];
         /*<<index.ml 271 19>>*/ return [0,
                [0,op_set],
                 /*<<index.ml 271 19>>*/ caml_call1(_bY_,_bX_)] /*<<index.ml 271 54>>*/ }
       /*<<index.ml 265 2>>*/ var
        /*<<index.ml 265 2>>*/ _bU_=CCList[10],
        /*<<index.ml 266 4>>*/ match=
         /*<<index.ml 266 4>>*/ caml_call3(_bU_,_bT_,_bS_,changes),
        /*<<index.ml 266 4>>*/ diffs=match[2],
        /*<<index.ml 266 4>>*/ t$0=match[1];
       /*<<index.ml 266 4>>*/ return [0,t$0,diffs] /*<<index.ml 274 12>>*/ }
     /*<<index.ml 213 15>>*/ function apply_changes(t,changes)
     { /*<<index.ml 276 30>>*/ return  /*<<index.ml 276 30>>*/ apply
              (t,changes,0) /*<<index.ml 276 51>>*/ }
     /*<<index.ml 213 15>>*/ function apply_changes$0(t,js_changes)
     { /*<<index.ml 279 2>>*/ var
        /*<<index.ml 279 2>>*/ _bD_=ToJs[6],
        /*<<index.ml 279 19>>*/ js_changes$0=
         /*<<index.ml 279 19>>*/ caml_call1(_bD_,js_changes),
        /*<<index.ml 280 2>>*/ _bE_=
         /*<<index.ml 280 2>>*/ caml_js_to_array(js_changes$0),
        /*<<index.ml 280 2>>*/ _bF_=CCArray[10],
        /*<<index.ml 281 4>>*/ _bG_=
         /*<<index.ml 281 4>>*/ caml_call1(_bF_,_bE_),
        /*<<index.ml 281 4>>*/ _bH_=CCList[33],
        /*<<index.ml 281 4>>*/ changes=
         /*<<index.ml 281 4>>*/ caml_call2(_bH_,js_change_to_change,_bG_),
        /*<<index.ml 283 17>>*/ match=
         /*<<index.ml 283 17>>*/ apply_changes(t,changes),
        /*<<index.ml 283 17>>*/ diffs=match[2],
        /*<<index.ml 283 17>>*/ t$0=match[1],
        /*<<index.ml 283 17>>*/ _bI_=CCList[33],
        /*<<index.ml 284 34>>*/ _bJ_=
         /*<<index.ml 284 34>>*/ caml_call2(_bI_,edit_to_js_edit,diffs),
        /*<<index.ml 284 17>>*/ js_diffs=
         /*<<index.ml 284 17>>*/ list_to_js_array(_bJ_),
        /*<<index.ml 285 17>>*/ js_patch=
         /*<<index.ml 285 17>>*/ make_patch(t$0,js_diffs),
        /*<<index.ml 285 17>>*/ _bK_=0,
        /*<<index.ml 285 17>>*/ _bL_=2,
        /*<<index.ml 285 17>>*/ _bM_=Js[15];
       /*<<index.ml 285 17>>*/ function _bN_(t20,t19,param)
       { /*<<?>>*/ return new t20(t19)}
       /*<<index.ml 286 12>>*/ var
        /*<<index.ml 286 12>>*/ ret=
         /*<<index.ml 286 12>>*/ _bN_(_bM_,_bL_,_bK_),
        /*<<index.ml 286 12>>*/ _bO_=0,
        /*<<index.ml 286 12>>*/ _bP_=Js[17];
       /*<<index.ml 287 2>>*/  /*<<index.ml 287 2>>*/ caml_call3
       (_bP_,ret,_bO_,t$0);
       /*<<index.ml 286 12>>*/ var
        /*<<index.ml 287 2>>*/ _bQ_=1,
        /*<<index.ml 287 2>>*/ _bR_=Js[17];
       /*<<index.ml 288 2>>*/  /*<<index.ml 288 2>>*/ caml_call3
       (_bR_,ret,_bQ_,js_patch);
       /*<<index.ml 288 2>>*/ return ret /*<<index.ml 289 5>>*/ }
     /*<<index.ml 213 15>>*/ function apply_local_change(t,js_change)
     { /*<<index.ml 292 15>>*/  /*<<index.ml 292 15>>*/ var
       change=
         /*<<index.ml 292 15>>*/ js_change_to_change(js_change);
       /*<<index.ml 292 15>>*/ function _be_(x)
       { /*<<index.ml 293 34>>*/ return  /*<<index.ml 293 34>>*/ caml_call1
                ( /*<<index.ml 293 34>>*/ caml_get_public_method
                  (x,-429239895,12),
                 x) /*<<index.ml 293 57>>*/ }
       /*<<index.ml 292 15>>*/ function _bf_(t29,param)
       { /*<<?>>*/ return t29.requestType}
       /*<<index.ml 293 34>>*/ var
        /*<<index.ml 293 34>>*/ request_type=
         /*<<index.ml 293 34>>*/ caml_js_to_string
         ( /*<<index.ml 293 34>>*/ _bf_(js_change,_be_)),
        /*<<index.ml 293 34>>*/ _bg_=Datastructures[1][23];
       /*<<index.ml 295 7>>*/ if
       ( /*<<index.ml 295 7>>*/ caml_call2(_bg_,request_type,cst_change))
       { /*<<index.ml 295 49>>*/ var
          /*<<index.ml 295 49>>*/ _bh_=1,
          /*<<index.ml 295 49>>*/ _bi_=[0,change,0],
          /*<<index.ml 295 49>>*/ match=
           /*<<index.ml 295 49>>*/ apply(t,_bi_,_bh_),
         diffs=match[2],
         t$0=match[1],
         _bj_=CCList[33],
          /*<<index.ml 298 34>>*/ _bk_=
           /*<<index.ml 298 34>>*/ caml_call2(_bj_,edit_to_js_edit,diffs),
          /*<<index.ml 298 17>>*/ js_diffs=
           /*<<index.ml 298 17>>*/ list_to_js_array(_bk_),
          /*<<index.ml 299 17>>*/ js_patch=
           /*<<index.ml 299 17>>*/ make_patch(t$0,js_diffs),
          /*<<index.ml 299 17>>*/ _bl_=
          function(x)
           { /*<<index.ml 300 2>>*/ return  /*<<index.ml 300 2>>*/ caml_call1
                    ( /*<<index.ml 300 2>>*/ caml_get_public_method
                      (x,463915765,13),
                     x) /*<<index.ml 300 37>>*/ },
          /*<<index.ml 299 17>>*/ _bm_=
          function(x)
           { /*<<index.ml 300 41>>*/ return  /*<<index.ml 300 41>>*/ caml_call1
                    ( /*<<index.ml 300 41>>*/ caml_get_public_method
                      (x,463915765,14),
                     x) /*<<index.ml 300 58>>*/ },
          /*<<index.ml 299 17>>*/ _bn_=
          function(t26,param){ /*<<?>>*/ return t26.actor},
          /*<<index.ml 300 41>>*/ _bo_=
           /*<<index.ml 300 41>>*/ _bn_(js_change,_bm_),
          /*<<index.ml 300 41>>*/ _bp_=
          function(t28,t27,param){ /*<<?>>*/ return t28.actor = t27};
         /*<<index.ml 300 2>>*/  /*<<index.ml 300 2>>*/ _bp_
         (js_patch,_bo_,_bl_);
         /*<<index.ml 295 49>>*/ var
          /*<<index.ml 300 2>>*/ _bq_=
          function(x)
           { /*<<index.ml 301 2>>*/ return  /*<<index.ml 301 2>>*/ caml_call1
                    ( /*<<index.ml 301 2>>*/ caml_get_public_method
                      (x,5741471,15),
                     x) /*<<index.ml 301 35>>*/ },
          /*<<index.ml 300 2>>*/ _br_=
          function(x)
           { /*<<index.ml 301 39>>*/ return  /*<<index.ml 301 39>>*/ caml_call1
                    ( /*<<index.ml 301 39>>*/ caml_get_public_method
                      (x,5741471,16),
                     x) /*<<index.ml 301 54>>*/ },
          /*<<index.ml 300 2>>*/ _bs_=
          function(t23,param){ /*<<?>>*/ return t23.seq},
          /*<<index.ml 301 39>>*/ _bt_=
           /*<<index.ml 301 39>>*/ _bs_(js_change,_br_),
          /*<<index.ml 301 39>>*/ _bu_=
          function(t25,t24,param){ /*<<?>>*/ return t25.seq = t24};
         /*<<index.ml 301 2>>*/  /*<<index.ml 301 2>>*/ _bu_
         (js_patch,_bt_,_bq_);
         /*<<index.ml 295 49>>*/ var
          /*<<index.ml 301 2>>*/ _bv_=0,
          /*<<index.ml 301 2>>*/ _bw_=2,
          /*<<index.ml 301 2>>*/ _bx_=Js[15],
          /*<<index.ml 301 2>>*/ _by_=
          function(t22,t21,param){ /*<<?>>*/ return new t22(t21)},
          /*<<index.ml 302 12>>*/ ret=
           /*<<index.ml 302 12>>*/ _by_(_bx_,_bw_,_bv_),
          /*<<index.ml 302 12>>*/ _bz_=0,
          /*<<index.ml 302 12>>*/ _bA_=Js[17];
         /*<<index.ml 303 2>>*/  /*<<index.ml 303 2>>*/ caml_call3
         (_bA_,ret,_bz_,t$0);
         /*<<index.ml 295 49>>*/ var
          /*<<index.ml 303 2>>*/ _bB_=1,
          /*<<index.ml 303 2>>*/ _bC_=Js[17];
         /*<<index.ml 304 2>>*/  /*<<index.ml 304 2>>*/ caml_call3
         (_bC_,ret,_bB_,js_patch);
         /*<<index.ml 304 2>>*/ return ret}
       /*<<index.ml 296 9>>*/ throw Unknown_request_type /*<<index.ml 305 5>>*/ }
     /*<<index.ml 213 15>>*/ function diff_to_js_diff(diff)
     { /*<<index.ml 308 2>>*/ switch(diff[3])
       {case 0:var _aG_=cst_create$0;break;
        case 1:var _aG_=cst_set$2;break;
        default:var _aG_=cst_insert$0}
      var action=_aG_.toString();
      switch(diff[2])
       {case 0:var _aH_=cst_map$0;break;
        case 1:var _aH_=cst_list$0;break;
        default:var _aH_=cst_text$0}
       /*<<index.ml 322 2>>*/ var
       type=_aH_.toString(),
       _aI_=CCArray[21],
       _aJ_=0,
        /*<<index.ml 322 2>>*/ _aK_=
         /*<<index.ml 322 2>>*/ obj_set(_aJ_,cst_action$1,action,_aI_),
        /*<<index.ml 322 2>>*/ _aL_=diff[4];
       /*<<index.ml 322 2>>*/ function _aM_(_bd_)
       { /*<<?>>*/ return _bd_.toString()}
       /*<<index.ml 322 2>>*/ var
        /*<<index.ml 322 2>>*/ _aN_=
         /*<<index.ml 322 2>>*/ obj_set_optdef(_aM_,cst_key$1,_aL_,_aK_),
        /*<<index.ml 322 2>>*/ _aO_=diff[1],
        /*<<index.ml 322 2>>*/ _aP_=
        [0,function(_bc_){ /*<<?>>*/ return _bc_.toString()}],
        /*<<index.ml 322 2>>*/ _aQ_=
         /*<<index.ml 322 2>>*/ obj_set(_aP_,cst_obj$2,_aO_,_aN_),
        /*<<index.ml 322 2>>*/ _aR_=0,
        /*<<index.ml 322 2>>*/ _aS_=
         /*<<index.ml 322 2>>*/ obj_set(_aR_,cst_type$0,type,_aQ_),
        /*<<index.ml 322 2>>*/ _aT_=diff[6];
       /*<<index.ml 322 2>>*/ function _aU_(_bb_){ /*<<?>>*/ return ! ! _bb_}
       /*<<index.ml 322 2>>*/ var
        /*<<index.ml 322 2>>*/ _aV_=
         /*<<index.ml 322 2>>*/ obj_set_optdef(_aU_,cst_link$2,_aT_,_aS_),
        /*<<index.ml 322 2>>*/ _aW_=diff[5],
        /*<<index.ml 322 2>>*/ _aX_=
         /*<<index.ml 322 2>>*/ obj_set_optdef
         (op_val_to_js_value,cst_value$2,_aW_,_aV_),
        /*<<index.ml 322 2>>*/ _aY_=diff[7];
       /*<<index.ml 322 2>>*/ function _aZ_(_ba_){ /*<<?>>*/ return _ba_}
       /*<<index.ml 322 2>>*/ function _a0_(_a$_){ /*<<?>>*/ return _a$_}
       /*<<index.ml 328 20>>*/ function _a1_(_a__)
       { /*<<?>>*/ return _c_(_a0_,_aZ_,_a__)}
       /*<<index.ml 322 2>>*/ var
        /*<<index.ml 322 2>>*/ _a2_=
         /*<<index.ml 322 2>>*/ obj_set_optdef(_a1_,cst_index$0,_aY_,_aX_),
        /*<<index.ml 322 2>>*/ _a3_=diff[8];
       /*<<index.ml 322 2>>*/ function _a4_(_a9_)
       { /*<<?>>*/ return _a9_.toString()}
       /*<<index.ml 322 2>>*/ var
        /*<<index.ml 322 2>>*/ _a5_=
         /*<<index.ml 322 2>>*/ obj_set_optdef(_a4_,cst_elemId$0,_a3_,_a2_),
        /*<<index.ml 322 2>>*/ _a6_=diff[9],
        /*<<index.ml 322 2>>*/ _a7_=
         /*<<index.ml 322 2>>*/ obj_set_optdef
         (conflicts_to_js_conflicts,cst_conflicts$0,_a6_,_a5_);
       /*<<index.ml 322 2>>*/ return  /*<<index.ml 322 2>>*/ function(_a8_)
               { /*<<?>>*/ return caml_js_object(_a8_)}
              (_a7_) /*<<index.ml 331 18>>*/ }
     /*<<index.ml 213 15>>*/  /*<<index.ml 213 15>>*/ var _h_=[0,0,0,0];
     /*<<index.ml 213 15>>*/ function get_patch(t)
     { /*<<index.ml 334 2>>*/ var
        /*<<index.ml 334 2>>*/ _ac_=t[1],
        /*<<index.ml 334 2>>*/ _ad_=Op_set[20][82],
        /*<<index.ml 334 14>>*/ patch=
         /*<<index.ml 334 14>>*/ caml_call1(_ad_,_ac_),
        /*<<index.ml 334 14>>*/ _ae_=patch[5],
        /*<<index.ml 334 14>>*/ _af_=CCList[33],
        /*<<index.ml 335 31>>*/ _ag_=
         /*<<index.ml 335 31>>*/ caml_call2(_af_,diff_to_js_diff,_ae_),
        /*<<index.ml 335 14>>*/ diffs=
         /*<<index.ml 335 14>>*/ list_to_js_array(_ag_);
       /*<<index.ml 335 14>>*/ function _ah_
       (self,canUndo,canRedo,clock,deps,diffs)
       { /*<<?>>*/ if(! _h_[1])
         {var
           _aq_=caml_call1(CamlinternalOO[16],_a_),
           _ar_=caml_call2(CamlinternalOO[3],_aq_,cst$1),
           _as_=caml_call2(CamlinternalOO[8],_aq_,_b_),
           _at_=_as_[1],
           _au_=_as_[2],
           _av_=_as_[3],
           _aw_=_as_[4],
           _ax_=_as_[5],
           _ay_=
            function(self_3)
             { /*<<?>>*/ var env=self_3[_ar_ + 1];return env[1]},
           _az_=
            function(self_3)
             { /*<<?>>*/ var env=self_3[_ar_ + 1];return env[2]},
           _aA_=
            function(self_3)
             { /*<<?>>*/ var env=self_3[_ar_ + 1];return env[3]},
           _aB_=
            function(self_3)
             { /*<<?>>*/ var env=self_3[_ar_ + 1];return env[4]},
           _aC_=
            [0,
             _aw_,
             function(self_3)
              { /*<<?>>*/ var env=self_3[_ar_ + 1];return env[5]},
             _ax_,
             _aB_,
             _av_,
             _aA_,
             _au_,
             _az_,
             _at_,
             _ay_];
          caml_call2(CamlinternalOO[11],_aq_,_aC_);
          var
           _aD_=
            function(_aE_)
             { /*<<?>>*/ var _aF_=caml_call2(CamlinternalOO[24],0,_aq_);
              _aF_[_ar_ + 1] = _aE_;
              return _aF_};
          caml_call1(CamlinternalOO[17],_aq_);
          _h_[1] = _aD_}
        return caml_call1(_h_[1],[0,diffs,deps,clock,canRedo,canUndo])}
       /*<<index.ml 335 14>>*/ var
        /*<<index.ml 335 14>>*/ _ai_=patch[4],
        /*<<index.ml 343 15>>*/ _aj_=
         /*<<index.ml 343 15>>*/ js_obj_of_actor_map(js_number_of_int,_ai_),
        /*<<index.ml 343 15>>*/ _ak_=patch[3],
        /*<<index.ml 341 16>>*/ _al_=
         /*<<index.ml 341 16>>*/ js_obj_of_actor_map(js_number_of_int,_ak_),
        /*<<index.ml 341 16>>*/ _am_=patch[2],
        /*<<index.ml 339 18>>*/ _an_=! ! _am_,
        /*<<index.ml 339 18>>*/ _ao_=patch[1],
        /*<<index.ml 337 18>>*/ _ap_=! ! _ao_;
       /*<<index.ml 337 18>>*/ return  /*<<index.ml 337 18>>*/ function
               (t30,t31,t32,t33,t34,param)
               { /*<<?>>*/ return {"canUndo":t30,
                        "canRedo":t31,
                        "clock":t32,
                        "deps":t33,
                        "diffs":t34}}
              (_ap_,_an_,_al_,_aj_,diffs,_ah_) /*<<index.ml 346 5>>*/ }
     /*<<index.ml 213 15>>*/ function merge(local,remote)
     { /*<<index.ml 349 2>>*/ var
        /*<<index.ml 349 2>>*/ _P_=local[1],
        /*<<index.ml 349 2>>*/ _Q_=Op_set[20][84],
        /*<<index.ml 351 6>>*/ _R_= /*<<index.ml 351 6>>*/ caml_call1(_Q_,_P_),
        /*<<index.ml 351 6>>*/ _S_=remote[1],
        /*<<index.ml 351 6>>*/ _T_=Op_set[20][59],
        /*<<index.ml 350 4>>*/ changes=
         /*<<index.ml 350 4>>*/ caml_call2(_T_,_S_,_R_),
        /*<<index.ml 353 17>>*/ match=
         /*<<index.ml 353 17>>*/ apply_changes(local,changes),
        /*<<index.ml 353 17>>*/ diffs=match[2],
        /*<<index.ml 353 17>>*/ t=match[1],
        /*<<index.ml 353 17>>*/ _U_=CCList[33],
        /*<<index.ml 354 34>>*/ _V_=
         /*<<index.ml 354 34>>*/ caml_call2(_U_,edit_to_js_edit,diffs),
        /*<<index.ml 354 17>>*/ js_diffs=
         /*<<index.ml 354 17>>*/ list_to_js_array(_V_),
        /*<<index.ml 355 17>>*/ js_patch=
         /*<<index.ml 355 17>>*/ make_patch(t,js_diffs),
        /*<<index.ml 355 17>>*/ _W_=0,
        /*<<index.ml 355 17>>*/ _X_=2,
        /*<<index.ml 355 17>>*/ _Y_=Js[15];
       /*<<index.ml 355 17>>*/ function _Z_(t36,t35,param)
       { /*<<?>>*/ return new t36(t35)}
       /*<<index.ml 356 12>>*/ var
        /*<<index.ml 356 12>>*/ ret= /*<<index.ml 356 12>>*/ _Z_(_Y_,_X_,_W_),
        /*<<index.ml 356 12>>*/ ___=0,
        /*<<index.ml 356 12>>*/ _$_=Js[17];
       /*<<index.ml 357 2>>*/  /*<<index.ml 357 2>>*/ caml_call3
       (_$_,ret,___,t);
       /*<<index.ml 356 12>>*/ var
        /*<<index.ml 357 2>>*/ _aa_=1,
        /*<<index.ml 357 2>>*/ _ab_=Js[17];
       /*<<index.ml 358 2>>*/  /*<<index.ml 358 2>>*/ caml_call3
       (_ab_,ret,_aa_,js_patch);
       /*<<index.ml 358 2>>*/ return ret /*<<index.ml 359 5>>*/ }
     /*<<index.ml 213 15>>*/ function get_changes_for_actor(t,js_actor_id)
     { /*<<index.ml 362 46>>*/ var
        /*<<index.ml 362 46>>*/ _F_=
         /*<<index.ml 362 46>>*/ caml_js_to_string(js_actor_id),
        /*<<index.ml 362 46>>*/ _G_=0,
        /*<<index.ml 362 46>>*/ _H_=t[1],
        /*<<index.ml 362 46>>*/ _I_=Op_set[20][60],
        /*<<index.ml 362 2>>*/ _J_=
         /*<<index.ml 362 2>>*/ caml_call3(_I_,_H_,_G_,_F_),
        /*<<index.ml 362 2>>*/ _K_=CCList[33],
        /*<<index.ml 362 2>>*/ _L_=
         /*<<index.ml 362 2>>*/ caml_call2(_K_,change_to_js_change,_J_),
        /*<<index.ml 362 2>>*/ _M_=CCArray[11],
        /*<<index.ml 362 2>>*/ _N_= /*<<index.ml 362 2>>*/ caml_call1(_M_,_L_);
       /*<<index.ml 362 2>>*/ return  /*<<index.ml 362 2>>*/ function(_O_)
               { /*<<?>>*/ return caml_js_from_array(_O_)}
              (_N_) /*<<index.ml 364 32>>*/ }
     /*<<index.ml 213 15>>*/ function get_changes(old_state,new_state)
     { /*<<index.ml 367 18>>*/ var
        /*<<index.ml 367 18>>*/ old_clock=
         /*<<index.ml 367 18>>*/ clock(old_state),
        /*<<index.ml 367 18>>*/ _B_=new_state[1],
        /*<<index.ml 367 18>>*/ _C_=Op_set[20][59],
        /*<<index.ml 373 2>>*/ _D_=
         /*<<index.ml 373 2>>*/ caml_call2(_C_,_B_,old_clock),
        /*<<index.ml 373 2>>*/ _E_=CCList[33];
       /*<<index.ml 373 2>>*/ return  /*<<index.ml 373 2>>*/ list_to_js_array
              ( /*<<index.ml 373 2>>*/ caml_call2(_E_,change_to_js_change,_D_)) /*<<index.ml 375 21>>*/ }
     /*<<index.ml 213 15>>*/ function get_missing_changes(t,clock)
     { /*<<index.ml 378 2>>*/ var
        /*<<index.ml 378 2>>*/ _y_=FromJs[2],
        /*<<index.ml 378 14>>*/ clock$0=
         /*<<index.ml 378 14>>*/ caml_call1(_y_,clock),
        /*<<index.ml 378 14>>*/ _z_=t[1],
        /*<<index.ml 378 14>>*/ _A_=Op_set[20][59],
        /*<<index.ml 379 16>>*/ changes=
         /*<<index.ml 379 16>>*/ caml_call2(_A_,_z_,clock$0);
       /*<<index.ml 379 16>>*/ return  /*<<index.ml 379 16>>*/ caml_call1
              (ToJs[4],changes) /*<<index.ml 380 26>>*/ }
     /*<<index.ml 213 15>>*/ function get_clock(t)
     { /*<<index.ml 383 2>>*/ var
        /*<<index.ml 383 2>>*/ _r_=ToJs[1],
        /*<<index.ml 383 18>>*/ immutable=
         /*<<index.ml 383 18>>*/ caml_call1(_r_,cst_immutable$0);
       /*<<index.ml 383 18>>*/ function _s_(x)
       { /*<<index.ml 384 12>>*/ return  /*<<index.ml 384 12>>*/ caml_call1
                ( /*<<index.ml 384 12>>*/ caml_get_public_method
                  (x,1057359741,17),
                 x) /*<<index.ml 384 48>>*/ }
       /*<<index.ml 383 18>>*/ function _t_(t37,param)
       { /*<<?>>*/ return t37.Map}
       /*<<index.ml 384 12>>*/ var
        /*<<index.ml 384 12>>*/ map=
         /*<<index.ml 384 12>>*/ _t_(immutable,_s_),
        /*<<index.ml 384 12>>*/ _u_=t[1],
        /*<<index.ml 384 12>>*/ _v_=Op_set[20][84],
        /*<<index.ml 385 25>>*/ _w_=
         /*<<index.ml 385 25>>*/ caml_call1(_v_,_u_),
        /*<<index.ml 385 25>>*/ _x_=ToJs[3],
        /*<<index.ml 385 14>>*/ clock=
         /*<<index.ml 385 14>>*/ caml_call1(_x_,_w_);
       /*<<index.ml 385 14>>*/ return  /*<<index.ml 385 14>>*/ map(clock) /*<<index.ml 386 70>>*/ }
     /*<<index.ml 213 15>>*/  /*<<index.ml 213 15>>*/ var _i_=Js[48];
     /*<<index.ml 389 2>>*/  /*<<index.ml 389 2>>*/ caml_call2
     (_i_,cst_init,init);
     /*<<index.ml 213 15>>*/  /*<<index.ml 389 2>>*/ var _j_=Js[48];
     /*<<index.ml 390 2>>*/  /*<<index.ml 390 2>>*/ caml_call2
     (_j_,cst_applyChanges,apply_changes$0);
     /*<<index.ml 213 15>>*/  /*<<index.ml 390 2>>*/ var _k_=Js[48];
     /*<<index.ml 391 2>>*/  /*<<index.ml 391 2>>*/ caml_call2
     (_k_,cst_applyLocalChange,apply_local_change);
     /*<<index.ml 213 15>>*/  /*<<index.ml 391 2>>*/ var _l_=Js[48];
     /*<<index.ml 392 2>>*/  /*<<index.ml 392 2>>*/ caml_call2
     (_l_,cst_getPatch,get_patch);
     /*<<index.ml 213 15>>*/  /*<<index.ml 392 2>>*/ var _m_=Js[48];
     /*<<index.ml 393 2>>*/  /*<<index.ml 393 2>>*/ caml_call2
     (_m_,cst_merge,merge);
     /*<<index.ml 213 15>>*/  /*<<index.ml 393 2>>*/ var _n_=Js[48];
     /*<<index.ml 394 2>>*/  /*<<index.ml 394 2>>*/ caml_call2
     (_n_,cst_getChangesForActor,get_changes_for_actor);
     /*<<index.ml 213 15>>*/  /*<<index.ml 394 2>>*/ var _o_=Js[48];
     /*<<index.ml 395 2>>*/  /*<<index.ml 395 2>>*/ caml_call2
     (_o_,cst_getChanges,get_changes);
     /*<<index.ml 213 15>>*/  /*<<index.ml 395 2>>*/ var _p_=Js[48];
     /*<<index.ml 396 2>>*/  /*<<index.ml 396 2>>*/ caml_call2
     (_p_,cst_getMissingChanges,get_missing_changes);
     /*<<index.ml 213 15>>*/  /*<<index.ml 396 2>>*/ var _q_=Js[48];
     /*<<index.ml 397 2>>*/  /*<<index.ml 397 2>>*/ caml_call2
     (_q_,cst_getClock,get_clock);
     /*<<index.ml 213 15>>*/  /*<<index.ml 397 2>>*/ var
     Index=
      [0,
       _c_,
       Not_supported,
       Unknown_request_type,
       freeze,
       BE,
       clock,
       list_to_js_array,
       obj_set,
       obj_set_optdef,
       obj_set_opt,
       edit_action_to_js_edit_action,
       type_to_js_type,
       path_to_js_path,
       actor_to_js_actor,
       array_to_list,
       js_action_to_action,
       action_to_js_action,
       op_val_to_js_value,
       value_to_js_value,
       js_value_to_op_val,
       to_op_list,
       conflicts_to_js_conflicts,
       number_of_int,
       obj_set_path,
       edit_to_js_edit,
       change_op_to_js_change_op,
       actor_map_of_js_obj,
       js_obj_of_actor_map,
       int_of_js_number,
       js_change_to_change,
       js_number_of_int,
       change_to_js_change,
       ToJs,
       FromJs,
       make_patch,
       init,
       apply,
       apply_changes,
       apply_changes$0,
       apply_local_change,
       diff_to_js_diff,
       get_patch,
       merge,
       get_changes_for_actor,
       get_changes,
       get_missing_changes,
       get_clock];
     /*<<index.ml 397 2>>*/  /*<<index.ml 397 2>>*/ runtime.caml_register_global
     (122,Index,"Index");
     /*<<index.ml 397 2>>*/ return /*<<?>>*/ }
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJpbmRleC5iYy5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJfbm9fcHJlZCIsImVycl9ub19zdWNjIiwib2NhbWxfdmVyc2lvbiIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJtaW5faW50JDEiLCJtYXhfaW50JDEiLCJkdW1teV9wb3MiLCJ6ZXJvX3BvcyIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImxvY2ZtdCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJ6ZXJvJDIiLCJvbmUkMiIsImkiLCJlcmFzZV9yZWwiLCJyZXN0IiwicmVzdCQwIiwicmVzdCQxIiwicmVzdCQyIiwicmVzdCQzIiwicmVzdCQ0IiwicmVzdCQ1IiwicmVzdCQ2IiwicmVzdCQ3IiwidHkiLCJyZXN0JDgiLCJ0eTEiLCJyZXN0JDkiLCJyZXN0JDEwIiwicmVzdCQxMSIsInJlc3QkMTIiLCJyZXN0JDEzIiwiY29uY2F0X2ZtdHR5IiwiZm10dHkxIiwiZm10dHkyIiwidHkyIiwiY29uY2F0X2ZtdCIsImZtdDEiLCJmbXQyIiwicGFkIiwicGFkJDAiLCJwcmVjIiwicGFkJDEiLCJpY29udiIsInByZWMkMCIsInBhZCQyIiwiaWNvbnYkMCIsInByZWMkMSIsInBhZCQzIiwiaWNvbnYkMSIsInByZWMkMiIsInBhZCQ0IiwiaWNvbnYkMiIsInByZWMkMyIsInBhZCQ1IiwiZmNvbnYiLCJwYWQkNiIsInN0ciIsImNociIsImZtdHR5IiwicGFkJDciLCJmbXR0eSQwIiwicGFkJDgiLCJyZXN0JDE0IiwicmVzdCQxNSIsInJlc3QkMTYiLCJmbXRpbmdfbGl0IiwicmVzdCQxNyIsImZtdGluZ19nZW4iLCJyZXN0JDE4IiwicmVzdCQxOSIsImNoYXJfc2V0Iiwid2lkdGhfb3B0IiwicmVzdCQyMCIsImNvdW50ZXIiLCJyZXN0JDIxIiwicmVzdCQyMiIsImlnbiIsInJlc3QkMjMiLCJmIiwiYXJpdHkiLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbl9mbG9hdCIsIm1heF9pbnQiLCJtaW5faW50IiwiX2dfIiwiczEiLCJzMiIsImwxIiwibDIiLCJjaGFyX29mX2ludCIsIm4iLCJzdHJpbmdfb2ZfYm9vbCIsImIiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwibCIsImkkMCIsInN0cmluZ19vZl9mbG9hdCIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJ0bCIsImhkIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJpdGVyIiwiYSIsIm91dHB1dF9ieXRlcyIsIm9jIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dCIsIm9mcyIsImxlbiIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfdmFsdWUiLCJjaGFuIiwidiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJyZXMiLCJiZWciLCJhY2N1JDAiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0IiwiZXhpdF9mdW5jdGlvbiIsIl9uXyIsInN0cjIiLCJzdHIxIiwiYXRfZXhpdCIsImciLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJwYXJhbSQwIiwibCQwIiwibiQwIiwibCQxIiwibiQxIiwibDEkMCIsImwyJDAiLCJsMSQxIiwibDIkMSIsImluaXRfYXV4IiwiYWNjIiwiYWNjJDAiLCJwYXJhbSIsImFjY3UkMSIsImEyIiwiYTEiLCJwIiwicGFpciIsInJ5IiwicngiLCJjbXAiLCJtYXRjaCIsInQyIiwiaDIiLCJ0MSIsImgxIiwiY2hvcCIsImsiLCJrJDAiLCJrJDEiLCJzb3J0IiwieDIiLCJ4MSIsIngzIiwieDIkMCIsIngxJDAiLCJuMSIsIm4yIiwicmV2X3NvcnQiLCJjJDAiLCJjJDEiLCJjJDIiLCJjJDMiLCJjJDQiLCJjJDUiLCJjJDYiLCJhY2N1JDIiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSIsImMxIiwiYzIiLCJlcXVhbCIsIm1pbiQwIiwibWF4JDAiLCJsb19ib3VuZCIsImhpX2JvdW5kIiwiYm9tIiwicmVwIiwic3VjYyIsInUiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDAiLCJjb21wYXJlJDAiLCJoYXNoIiwiX3NfIiwibGVmdCIsInJpZ2h0Iiwic3Jjb2ZmIiwiZHN0b2ZmIiwiY3B5bGVuIiwib2ZzMSIsIm9mczIiLCJzZXAiLCJzZXBsZW4iLCJkc3QiLCJpc19zcGFjZSIsImoiLCJhcHBseTEiLCJpbmRleF9yZWMiLCJsaW0iLCJpJDEiLCJpbmRleF9yZWNfb3B0IiwicmluZGV4X3JlYyIsInJpbmRleF9yZWNfb3B0IiwiaXNfc3BhY2UkMCIsImluZGV4X3JlYyQwIiwiaW5kZXhfcmVjX29wdCQwIiwicmluZGV4X3JlYyQwIiwicmluZGV4X3JlY19vcHQkMCIsIm9zX3R5cGUiLCJiYWNrZW5kX3R5cGUiLCJ1bml4Iiwid2luMzIiLCJjeWd3aW4iLCJtYXhfYXJyYXlfbGVuZ3RoIiwibWF4X3N0cmluZ19sZW5ndGgiLCJiaWdfZW5kaWFuIiwic2l6ZSIsImludF9zaXplIiwiZ2V0ZW52X29wdCIsImludGVyYWN0aXZlIiwic2V0X3NpZ25hbCIsInNpZ19udW0iLCJzaWdfYmVoIiwic2lnYWJydCIsInNpZ2Fscm0iLCJzaWdmcGUiLCJzaWdodXAiLCJzaWdpbGwiLCJzaWdpbnQiLCJzaWdraWxsIiwic2lncGlwZSIsInNpZ3F1aXQiLCJzaWdzZWd2Iiwic2lndGVybSIsInNpZ3VzcjEiLCJzaWd1c3IyIiwic2lnY2hsZCIsInNpZ2NvbnQiLCJzaWdzdG9wIiwic2lndHN0cCIsInNpZ3R0aW4iLCJzaWd0dG91Iiwic2lndnRhbHJtIiwic2lncHJvZiIsInNpZ2J1cyIsInNpZ3BvbGwiLCJzaWdzeXMiLCJzaWd0cmFwIiwic2lndXJnIiwic2lneGNwdSIsInNpZ3hmc3oiLCJjYXRjaF9icmVhayIsIm9uIiwibWVyZ2UkMCIsIm9yZGVyIiwibGlzdCIsImluaXRsaXN0IiwiZTIiLCJtZXJnZTIiLCJzd2FwIiwiYXJyIiwidG1wIiwiYXJyYXkiLCJxc29ydCIsImxvIiwiaGkiLCJsbyQwIiwiaGkkMCIsIm1pZCIsInBpdm90IiwibG8kMSIsImhpJDEiLCJ2YWxfaSIsInRvX2J1ZmZlciIsImJ1ZmYiLCJmbGFncyIsImhlYWRlcl9zaXplIiwiZGF0YV9zaXplIiwidG90YWxfc2l6ZSIsImZyb21fYnl0ZXMiLCJmcm9tX3N0cmluZyIsImlzX2Jsb2NrIiwiZG91YmxlX2ZpZWxkIiwic2V0X2RvdWJsZV9maWVsZCIsIm1hcnNoYWwiLCJvYmoiLCJ1bm1hcnNoYWwiLCJwb3MiLCJmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2xvdCIsImV4dGVuc2lvbl9uYW1lIiwiZXh0ZW5zaW9uX2lkIiwibGVuZ3RoJDAiLCJzeCIsInN5IiwiaW5pdCIsImxhIiwibGIiLCJyZXMkMCIsInRsJDAiLCJoZCQwIiwibWF4c29uIiwiaTMxIiwidHJpY2tsZWRvd24iLCJlIiwidHJpY2tsZSIsImJ1YmJsZWRvd24iLCJidWJibGUiLCJpJDIiLCJlJDAiLCJmYXRoZXIiLCJtZXJnZSIsInNyYzFvZnMiLCJzcmMxbGVuIiwic3JjMiIsInNyYzJvZnMiLCJzcmMybGVuIiwiZHN0b2ZzIiwic3JjMXIiLCJzcmMyciIsInMyJDEiLCJzMSQxIiwiaTEiLCJpMiIsImQiLCJpMiQwIiwiZCQwIiwiczIkMCIsImkxJDAiLCJkJDEiLCJzMSQwIiwiaXNvcnR0byIsInNyY29mcyIsInNvcnR0byIsInQiLCJ6ZXJvIiwib25lIiwibWludXNfb25lIiwic3VjYyQwIiwicHJlZCQwIiwiYWJzJDAiLCJtaW5faW50JDAiLCJtYXhfaW50JDAiLCJsb2dub3QiLCJ0b19zdHJpbmckMCIsIm9mX3N0cmluZ19vcHQiLCJjb21wYXJlJDMiLCJlcXVhbCQzIiwic3VjYyQxIiwicHJlZCQxIiwiYWJzJDEiLCJsb2dub3QkMCIsInRvX3N0cmluZyQxIiwib2Zfc3RyaW5nX29wdCQwIiwiY29tcGFyZSQ0IiwiZXF1YWwkNCIsInplcm8kMSIsIm9uZSQxIiwibWludXNfb25lJDEiLCJzdWNjJDIiLCJwcmVkJDIiLCJhYnMkMiIsIm1pbl9pbnQkMiIsIm1heF9pbnQkMiIsImxvZ25vdCQxIiwidG9fc3RyaW5nJDIiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDUiLCJlcXVhbCQ1IiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJyZXN1bHQiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsImF1eF9idWZmZXIiLCJsZXhidWYiLCJyZWFkIiwibmV3bGVuIiwibmV3YnVmIiwiZnJvbV9jaGFubmVsIiwiZnJvbV9zdHJpbmckMCIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJjbWQkMCIsImFyZyQxIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaCIsImNyZWF0ZSIsImhsIiwiaCQwIiwiaHIiLCJiYWwiLCJsciIsImx2IiwibGwiLCJscnIiLCJscnYiLCJscmwiLCJyciIsInJ2IiwicmwiLCJybHIiLCJybHYiLCJybGwiLCJhZGQiLCJzaW5nbGV0b24iLCJhZGRfbWluX2VsZW1lbnQiLCJhZGRfbWF4X2VsZW1lbnQiLCJqb2luIiwicmgiLCJsaCIsIm1pbl9lbHQiLCJtaW5fZWx0X29wdCIsIm1heF9lbHQiLCJtYXhfZWx0X29wdCIsInJlbW92ZV9taW5fZWx0IiwiciQwIiwiY29uY2F0Iiwic3BsaXQiLCJwcmVzIiwicHJlcyQwIiwiZW1wdHkiLCJpc19lbXB0eSIsIm1lbSIsInBhcmFtJDEiLCJyZW1vdmUiLCJ1bmlvbiIsInIyIiwidjIiLCJyMSIsInYxIiwicjIkMCIsInIxJDAiLCJpbnRlciIsImRpZmYiLCJjb25zX2VudW0iLCJzJDEiLCJlJDEiLCJlMiQyIiwiZTEkMiIsImUxIiwiZTIkMCIsImUxJDAiLCJlMiQxIiwiZTEkMSIsInN1YnNldCIsImZvbGQiLCJmb3JfYWxsIiwiZXhpc3RzIiwiZmlsdGVyIiwicHYiLCJwYXJ0aXRpb24iLCJsZiIsImx0IiwicmYiLCJydCIsImNhcmRpbmFsIiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJmaW5kIiwiZmluZF9maXJzdCIsInYkMCIsImZpbmRfZmlyc3Rfb3B0IiwiZmluZF9sYXN0IiwiZmluZF9sYXN0X29wdCIsImZpbmRfb3B0IiwibWFwIiwib2ZfbGlzdCIsInN1YiIsImwkMyIsIngwIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsImwkMiIsIng0IiwibGQiLCJscmQiLCJyZCIsInJsZCIsImRhdGEiLCJtIiwibWluX2JpbmRpbmciLCJtaW5fYmluZGluZ19vcHQiLCJtYXhfYmluZGluZyIsIm1heF9iaW5kaW5nX29wdCIsInJlbW92ZV9taW5fYmluZGluZyIsInVwZGF0ZSIsImRhdGEkMCIsIm1hcGkiLCJtJDAiLCJhZGRfbWluX2JpbmRpbmciLCJhZGRfbWF4X2JpbmRpbmciLCJjb25jYXRfb3Jfam9pbiIsImQxIiwiZDIiLCJkMiQwIiwiZDEkMCIsImQyJDEiLCJkMSQxIiwicHZkIiwibSQxIiwibTEiLCJtMiIsImJpbmRpbmdzX2F1eCIsImJpbmRpbmdzIiwiY2xlYXIiLCJjb3B5JDIiLCJwdXNoIiwicG9wIiwidG9wIiwibGVuZ3RoJDEiLCJpdGVyJDMiLCJjcmVhdGUkMCIsImNsZWFyJDAiLCJxIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwidGFrZSIsImNvcHkkMyIsInFfcmVzIiwicHJldiIsIm5leHQiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDQiLCJmb2xkJDAiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJyYWlzZV91bmRlZmluZWQiLCJmb3JjZV9sYXp5X2Jsb2NrIiwiYmxrIiwiY2xvc3VyZSIsImZvcmNlX3ZhbF9sYXp5X2Jsb2NrIiwiZm9yY2UiLCJsenYiLCJmb3JjZV92YWwiLCJmcm9tX2Z1biIsImZyb21fdmFsIiwiaXNfdmFsIiwiY291bnQiLCJmaWxsX2J1ZmYiLCJnZXRfZGF0YSIsImQxMSIsImEkMCIsImEkMSIsInBlZWtfZGF0YSIsInBlZWskMCIsImp1bmtfZGF0YSIsImp1bmsiLCJuZ2V0X2RhdGEiLCJhbCIsIm5wZWVrIiwiZW1wdHkkMCIsIml0ZXIkNSIsInN0cm0iLCJmcm9tIiwib2ZfbGlzdCQwIiwib2Zfc3RyaW5nJDAiLCJvZl9ieXRlcyIsIm9mX2NoYW5uZWwiLCJpYXBwIiwiaWNvbnMiLCJpc2luZyIsImxhcHAiLCJsY29ucyIsImxzaW5nIiwic2VtcHR5Iiwic2xhenkiLCJkdW1wIiwiZHVtcF9kYXRhIiwiY3JlYXRlJDEiLCJjb250ZW50cyIsInRvX2J5dGVzIiwic3ViJDIiLCJibGl0JDIiLCJzcmMiLCJudGgkMCIsImxlbmd0aCQzIiwiY2xlYXIkMSIsInJlc2V0IiwicmVzaXplIiwibW9yZSIsIm5ld19sZW4iLCJuZXdfYnVmZmVyIiwiYWRkX2NoYXIiLCJhZGRfdXRmXzhfdWNoYXIiLCJwb3MkMCIsInBvcyQxIiwiYWRkX3V0Zl8xNmJlX3VjaGFyIiwidSQwIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImJwcmludF9wYWR0eSIsInBhZHR5IiwiYnByaW50X2lnbm9yZWRfZmxhZyIsImlnbl9mbGFnIiwiYnByaW50X3BhZF9vcHQiLCJicHJpbnRfcGFkZGluZyIsInBhZHR5JDAiLCJicHJpbnRfcHJlY2lzaW9uIiwiYnByaW50X2ljb252X2ZsYWciLCJicHJpbnRfYWx0aW50X2ZtdCIsImJwcmludF9mY29udl9mbGFnIiwic3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0Iiwic3RyJDAiLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19nZW4iLCJmb3JtYXR0aW5nX2dlbiIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsImlzX2Fsb25lJDAiLCJpc19hbG9uZSIsImokMCIsImokMSIsImZtdCQwIiwic3ltbSIsImZtdHR5X3JlbF9kZXQiLCJkZSIsImVkIiwiYWYiLCJmYSIsImRlJDAiLCJlZCQwIiwiYWYkMCIsImZhJDAiLCJkZSQxIiwiZWQkMSIsImFmJDEiLCJmYSQxIiwiZGUkMiIsImVkJDIiLCJhZiQyIiwiZmEkMiIsImRlJDMiLCJlZCQzIiwiYWYkMyIsImZhJDMiLCJkZSQ0IiwiZWQkNCIsImFmJDQiLCJmYSQ0IiwiZGUkNSIsImVkJDUiLCJhZiQ1IiwiZmEkNSIsImRlJDYiLCJlZCQ2IiwiYWYkNiIsImZhJDYiLCJkZSQ3IiwiZWQkNyIsImFmJDciLCJmYSQ3IiwiZGUkOCIsImVkJDgiLCJhZiQ4IiwiZmEkOCIsInRyYW5zIiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJyZXN0MiIsInJlc3QyJDAiLCJyZXN0MiQxIiwicmVzdDIkMiIsInJlc3QyJDMiLCJyZXN0MiQ0IiwicmVzdDIkNSIsInJlc3QyJDYiLCJyZXN0MiQ3IiwicmVzdDIkOCIsInR5MjIiLCJ0eTIxIiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImZtdHR5X29mX3BhZGRpbmdfZm10dHkiLCJmbXR0eV9vZl9jdXN0b20iLCJhcml0eSQwIiwiZm10dHlfb2ZfZm10IiwidHlfcmVzdCIsInByZWNfdHkiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJ0eV9yZXN0JDAiLCJwcmVjX3R5JDAiLCJ0eV9yZXN0JDEiLCJwcmVjX3R5JDEiLCJ0eV9yZXN0JDIiLCJwcmVjX3R5JDIiLCJ0eV9yZXN0JDMiLCJwcmVjX3R5JDMiLCJmbXR0eSQxIiwiZm10dHkkMiIsImZtdHR5JDMiLCJ0eSQwIiwiZm10dHkkNCIsImZtdHR5JDUiLCJ0eXBlX3BhZGRpbmciLCJ3IiwidHlwZV9wYWRwcmVjIiwidHlwZV9mb3JtYXQiLCJ0eXBlX2Zvcm1hdF9nZW4iLCJ0eXBlX2lnbm9yZWRfcGFyYW1fb25lIiwiZm10dHlfcmVzdCIsImZtdF9yZXN0IiwiZm10dHlfcmVzdCQwIiwiZm10X3Jlc3QkMCIsImZtdF9yZXN0JDEiLCJmbXR0eV9yZXN0JDEiLCJmbXQkMiIsImZtdF9yZXN0JDIiLCJmbXR0eV9yZXN0JDIiLCJmbXQkMyIsImZtdF9yZXN0JDMiLCJmbXR0eV9yZXN0JDMiLCJmbXQkNCIsImZtdF9yZXN0JDQiLCJmbXR0eV9yZXN0JDQiLCJmbXQkNSIsImZtdF9yZXN0JDUiLCJmbXR0eV9yZXN0JDUiLCJmbXR0eSQ2IiwiZm10JDYiLCJmbXRfcmVzdCQ2IiwiZm10dHlfcmVzdCQ2IiwiZm10dHkkNyIsImZtdCQ3IiwiZm10X3Jlc3QkNyIsImZtdHR5X3Jlc3QkNyIsImZtdHR5JDgiLCJmbXQkOCIsImZtdF9yZXN0JDgiLCJmbXR0eV9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10JDkiLCJmbXRfcmVzdCQ5IiwiZm10dHkkMTAiLCJmbXQkMTAiLCJmbXRfcmVzdCQxMCIsImZtdHR5JDExIiwiZm10JDExIiwiZm10X3Jlc3QkMTEiLCJmbXR0eSQxMiIsImZtdCQxMiIsImZtdHR5X3Jlc3QkOSIsImZtdF9yZXN0JDEyIiwiZm10dHkkMTMiLCJmbXQkMTMiLCJmbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdHR5X3Jlc3QkMTEiLCJmbXRfcmVzdCQxNCIsImZtdHR5JDE1IiwiZm10JDE1IiwiZm10dHlfcmVzdCQxMiIsImZtdF9yZXN0JDE1IiwiZm10dHkkMTYiLCJmbXQkMTYiLCJmbXRfcmVzdCQxNiIsImZtdHR5JDE3IiwiZm10JDE3IiwiZm10X3Jlc3QkMTciLCJmbXR0eTMiLCJmbXQzIiwic3RyJDEiLCJmbXQxJDAiLCJmbXR0eTIkMCIsImZtdDIkMCIsImZtdHR5MyQwIiwiZm10MyQwIiwiZm10dHlfcmVzdCQxMyIsImZtdF9yZXN0JDE4IiwiZm10dHkkMTgiLCJmbXQkMTgiLCJmbXR0eV9yZXN0JDE0IiwiZm10X3Jlc3QkMTkiLCJmbXR0eSQxOSIsImZtdCQxOSIsImZtdHR5X3Jlc3QkMTUiLCJmbXRfcmVzdCQyMCIsImZtdHR5JDIwIiwiZm10JDIwIiwiZm10dHlfcmVzdCQxNiIsImZtdHR5JDIxIiwiZm10JDIxIiwic3ViX2ZtdHR5JDIiLCJzdWJfZm10dHkkMyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInN1Yl9mbXR0eV9yZXN0Iiwic3ViX2ZtdHR5X3Jlc3QkMCIsInN1Yl9mbXR0eV9yZXN0JDEiLCJzdWJfZm10dHlfcmVzdCQyIiwic3ViX2ZtdHR5X3Jlc3QkMyIsInN1Yl9mbXR0eV9yZXN0JDQiLCJzdWJfZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkNiIsInN1Yl9mbXR0eV9yZXN0JDciLCJzdWJfZm10dHlfcmVzdCQ4Iiwic3ViX2ZtdHR5X3Jlc3QkOSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJzdWJfZm10dHlfcmVzdCQxMiIsInN1Yl9mbXR0eV9yZXN0JDEzIiwic3ViX2ZtdHR5X3Jlc3QkMTQiLCJzdWIyX2ZtdHR5Iiwic3ViX2ZtdHR5X3Jlc3QkMTUiLCJzdWIyX2ZtdHR5JDAiLCJzdWJfZm10dHlfcmVzdCQxNiIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsInN1Yl9mbXR0eV9yZXN0JDE4Iiwic3ViX2ZtdHR5X3Jlc3QkMTkiLCJzdWJfZm10dHlfcmVzdCQyMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJzdWJfZm10dHlfcmVzdCQyMyIsInN1Yl9mbXR0eV9yZXN0JDI0Iiwic3ViX2ZtdHR5X3Jlc3QkMjUiLCJzdWJfZm10dHlfcmVzdCQyNiIsInJlY2FzdCIsImZpeF9wYWRkaW5nIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJzaWduIiwic3ltYiIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIiwibyIsIm1ha2VfcHJpbnRmIiwicCQwIiwicCQxIiwibWFrZV9wYWRkaW5nIiwibmV3X2FjYyIsIm1ha2VfcHJpbnRmJDAiLCJhY2MkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImtvYyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsImZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIiwibWFrZV9pcHJpbnRmIiwibWFrZV9pcHJpbnRmJDAiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsIm1zZyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInBhcnNlIiwic3RyX2luZCQyIiwicGFyc2VfZmxhZ3MiLCJzdHJfaW5kJDAiLCJwYXJzZV90YWciLCJwYXJzZV9nb29kX2JyZWFrIiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmQkMSIsInBhcnNlX2NvbnZlcnNpb24iLCJwY3RfaW5kIiwicGx1cyIsInNwYWNlIiwicGFkcHJlYyIsInBsdXNfdXNlZCIsImhhc2hfdXNlZCIsInNwYWNlX3VzZWQiLCJpZ25fdXNlZCIsInBhZF91c2VkIiwicHJlY191c2VkIiwiZ2V0X3BsdXMiLCJnZXRfaGFzaCIsImdldF9zcGFjZSIsImdldF9pZ24iLCJnZXRfcGFkIiwiZ2V0X3ByZWMiLCJnZXRfcGFkcHJlYyIsImdldF9pbnRfcGFkIiwiaW5jb21wYXRpYmxlX2ZsYWciLCJjaGVja19ub18wIiwib3B0X29mX3BhZCIsIndpZHRoJDAiLCJ3aWR0aCQxIiwiZ2V0X3BhZF9vcHQiLCJnZXRfcGFkcHJlY19vcHQiLCJmbXRfcmVzdWx0Iiwic3ViX2VuZCIsInNlYXJjaF9zdWJmb3JtYXRfZW5kIiwic3ViX2ZtdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJuZXh0X2luZCIsImNoYXJfc2V0JDEiLCJpZ25vcmVkJDkiLCJjaGFyX2Zvcm1hdCIsImZtdF9yZXN0JDIxIiwiZm10X3Jlc3QkMjIiLCJwYWQkOSIsImZtdF9yZXN0JDIzIiwiaWdub3JlZCQxMCIsImZtdF9yZXN0JDI0IiwicGFkJDEwIiwiZm10X3Jlc3QkMjUiLCJzdWJfZW5kJDAiLCJzdWJfZm10JDAiLCJmbXRfcmVzdCQyNiIsImlnbm9yZWQkMTEiLCJpZ25vcmVkJDMiLCJzeW1iJDAiLCJpZ25vcmVkJDUiLCJjb21wdXRlX2ludF9jb252IiwiaWdub3JlZCQ4IiwicHJlYyQ0Iiwic3BhY2UkMSIsInBsdXMkMiIsInBsdXMkMyIsInNwYWNlJDIiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQwIiwiaGFzaCQwIiwic3BhY2UkMCIsInBsdXMkMSIsImlnbiQwIiwicGFyc2VfYWZ0ZXJfcHJlY2lzaW9uIiwibWludXMiLCJwYXJzZV9jb252IiwicGFyc2VfYWZ0ZXJfcGFkZGluZyIsInBhcnNlX2xpdGVyYWwiLCJwYXJzZV9wb3NpdGl2ZSIsIm5ld19pbmQiLCJtaW51cyQwIiwic2V0X2ZsYWciLCJzdHJfaW5kJDMiLCJzdHJfaW5kJDQiLCJzdHJfaW5kJDUiLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm9ybWF0JDAiLCJmb3JtYXR0aW5nJDAiLCJmb3JtYXR0aW5nIiwic3RyX2luZF8xIiwicGFyc2VfaW50ZWdlciIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJzdWJfZW5kJDEiLCJzdWJfZW5kJDIiLCJzdHJfaW5kJDYiLCJzdHJfaW5kJDciLCJvcHRpb24iLCJzdWJmbXQiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsInByaW50ZiIsImVwcmludGYiLCJrc3ByaW50ZiIsInNwcmludGYiLCJhc3NvYzMiLCJ5MiIsInkxIiwic3BsaXQkMCIsIm1ha2Vfc3ltbGlzdCIsInByZWZpeCIsInN1ZmZpeCIsImhlbHBfYWN0aW9uIiwiYWRkX2hlbHAiLCJzcGVjbGlzdCIsImFkZDIiLCJ1c2FnZV9iIiwiZXJybXNnIiwiZG9jIiwic3BlYyIsImtleSIsInVzYWdlX3N0cmluZyIsInVzYWdlIiwiYm9vbF9vZl9zdHJpbmdfb3B0JDAiLCJpbnRfb2Zfc3RyaW5nX29wdCQwIiwiZmxvYXRfb2Zfc3RyaW5nX29wdCQwIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsImVycm9yIiwicHJvZ25hbWUiLCJvcHQiLCJhY3Rpb24iLCJmb2xsb3ckMCIsImtleXdvcmQiLCJub19hcmckMCIsImZvbGxvdyIsIm5vX2FyZyIsImdldF9hcmckMCIsImdldF9hcmciLCJjb25zdW1lX2FyZyQwIiwiY29uc3VtZV9hcmciLCJ0cmVhdF9hY3Rpb24kMCIsInRyZWF0X2FjdGlvbiIsImYkMCIsImYkMSIsInIkMSIsImYkMiIsInIkMiIsImFyZyQyIiwieCQwIiwiZiQzIiwiYXJnJDMiLCJ4JDEiLCJyJDMiLCJhcmckNCIsIngkMiIsInNwZWNzIiwiZiQ0IiwiYXJnJDUiLCJmJDUiLCJmJDYiLCJhcmckNiIsIm5ld2FyZyIsImJlZm9yZSIsImFmdGVyIiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMiLCJwYXJzZV9hcmd2X2R5bmFtaWMiLCJzdGgiLCJjdXJyZW50JDAiLCJwYXJzZV9hcmd2IiwibXNnJDAiLCJtc2ckMSIsInBhcnNlX2R5bmFtaWMiLCJwYXJzZV9leHBhbmQiLCJzZWNvbmRfd29yZCIsImxvb3AiLCJtYXhfYXJnX2xlbiIsImN1ciIsImt3ZCIsInJlcGxhY2VfbGVhZGluZ190YWIiLCJzZWVuIiwiYWxpZ24iLCJsaW1pdCIsImNvbXBsZXRlZCIsImtzZCIsImN1dGNvbCQwIiwic3BhY2VzJDAiLCJjdXRjb2wiLCJrd2RfbGVuIiwic3BhY2VzIiwicmVhZF9hdXgiLCJ0cmltIiwiZmlsZSIsIndvcmRzIiwic3Rhc2giLCJ3b3JkIiwicmVhZF9hcmciLCJyZWFkX2FyZzAiLCJ3cml0ZV9hdXgiLCJhcmdzIiwid3JpdGVfYXJnIiwid3JpdGVfYXJnMCIsInByaW50ZXJzIiwiZmllbGQiLCJvdGhlcl9maWVsZHMiLCJmaWVsZHMiLCJ0b19zdHJpbmckMyIsImNvbnYiLCJjaGFyJDAiLCJsaW5lIiwiY2hhciQxIiwibGluZSQwIiwiZmlsZSQwIiwiY2hhciQyIiwibGluZSQxIiwiZmlsZSQxIiwiY29uc3RydWN0b3IiLCJwcmludCIsImZjdCIsImNhdGNoJDAiLCJjb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJidCIsImZvcm1hdF9iYWNrdHJhY2Vfc2xvdCIsImluZm8iLCJpc19yYWlzZSIsInByaW50X3Jhd19iYWNrdHJhY2UiLCJvdXRjaGFuIiwicmF3X2JhY2t0cmFjZSIsImJhY2t0cmFjZSIsInByaW50X2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIiwiYmFja3RyYWNlX3Nsb3RfaXNfcmFpc2UiLCJiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmUiLCJiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiIsImJhY2t0cmFjZV9zbG90cyIsImdldF9iYWNrdHJhY2UiLCJyZWdpc3Rlcl9wcmludGVyIiwiZm4iLCJleG5fc2xvdCIsImV4bl9zbG90X2lkIiwiZXhuX3Nsb3RfbmFtZSIsInVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwic2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIiwicHJpbnRfc3RhdCIsImFsbG9jYXRlZF9ieXRlcyIsIm1hIiwicHJvIiwibWkiLCJjcmVhdGVfYWxhcm0iLCJkZWxldGVfYWxhcm0iLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQxIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDQiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiZGVmYXVsdCQwIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDMiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJoYXNoX3BhcmFtIiwic2VlZGVkX2hhc2giLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJjcmVhdGUkMiIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNsZWFyJDIiLCJyZXNldCQwIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJjb3B5JDUiLCJsZW5ndGgkNCIsInJlc2l6ZSQwIiwiaW5kZXhmdW4iLCJvZGF0YSIsIm9zaXplIiwibnNpemUiLCJuZGF0YSIsIm5kYXRhX3RhaWwiLCJpbnBsYWNlIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJrZXlfaW5kZXgiLCJhZGQkMCIsImJ1Y2tldCIsImZpbmQkMCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9vcHQkMCIsImZpbmRfYWxsJDAiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJtZW0kMSIsIml0ZXIkNiIsImRvX2J1Y2tldCIsIm9sZF90cmF2IiwiZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCIsImZpbHRlcl9tYXBfaW5wbGFjZSIsImZvbGQkMSIsImIkMCIsImJ1Y2tldF9sZW5ndGgiLCJzdGF0cyIsIm1ibCIsImhpc3RvIiwiZmluZF9hbGwiLCJjb3B5IiwibGVuZ3RoIiwic3oiLCJsZW5ndGgkNSIsImZpbGwkMSIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJzeiQwIiwic3okMSIsImNvdW50X2J1Y2tldCIsImFkZF9hdXgiLCJzZXR0ZXIiLCJpbmRleCIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQiLCJuZXdoYXNoZXMiLCJoYnVja2V0IiwicHJldl9sZW4iLCJsaXZlIiwiaiQyIiwibmV3dCIsIm9iIiwib2giLCJzZXR0ZXIkMCIsIm5iIiwibmkiLCJmaW5kX29yIiwiaWZub3Rmb3VuZCIsImZpbmRfc2hhZG93IiwiaWZmb3VuZCIsImxlbnMiLCJ0b3RsZW4iLCJhZGRfcXVldWUiLCJ0YWtlX3F1ZXVlIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfaW5maW5pdHkiLCJwcF9vdXRwdXRfc3RyaW5nIiwicHBfb3V0cHV0X25ld2xpbmUiLCJicmVha19uZXdfbGluZSIsInJlYWxfaW5kZW50IiwiYnJlYWtfbGluZSIsImJyZWFrX3NhbWVfbGluZSIsInBwX2ZvcmNlX2JyZWFrX2xpbmUiLCJibF90eSIsInBwX3NraXBfdG9rZW4iLCJmb3JtYXRfcHBfdG9rZW4iLCJ0YWJzIiwiYWRkX3RhYiIsImxzIiwibHMkMCIsInRhZ3MiLCJ0YWdfbmFtZSIsIm1hcmtlciIsIm9mZiIsIm9mZiQwIiwiaW5zZXJ0aW9uX3BvaW50IiwidGFicyQwIiwidGFiIiwib2ZmJDEiLCJpbnNlcnRpb25fcG9pbnQkMCIsIm9mZnNldCQwIiwiYmxfdHlwZSIsInRib3giLCJ0YWdfbmFtZSQwIiwibWFya2VyJDAiLCJhZHZhbmNlX2xvb3AiLCJzaXplJDAiLCJhZHZhbmNlX2xlZnQiLCJlbnF1ZXVlX2FkdmFuY2UiLCJlbnF1ZXVlX3N0cmluZ19hcyIsInFfZWxlbSIsInNjYW5fc3RhY2tfYm90dG9tIiwiY2xlYXJfc2Nhbl9zdGFjayIsInNldF9zaXplIiwicXVldWVfZWxlbSIsImxlZnRfdG90Iiwic2Nhbl9wdXNoIiwicHBfb3Blbl9ib3hfZ2VuIiwiYnJfdHkiLCJlbGVtIiwicHBfY2xvc2VfYm94IiwicHBfb3Blbl90YWciLCJwcF9jbG9zZV90YWciLCJwcF9zZXRfcHJpbnRfdGFncyIsInBwX3NldF9tYXJrX3RhZ3MiLCJwcF9nZXRfcHJpbnRfdGFncyIsInBwX2dldF9tYXJrX3RhZ3MiLCJwcF9zZXRfdGFncyIsInBwX2dldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInBjdCIsInBvdCIsIm1jdCIsIm1vdCIsInBwX3Jpbml0IiwicHBfZmx1c2hfcXVldWUiLCJwcF9wcmludF9hc19zaXplIiwicHBfcHJpbnRfYXMiLCJpc2l6ZSIsInBwX3ByaW50X3N0cmluZyIsInBwX3ByaW50X2ludCIsInBwX3ByaW50X2Zsb2F0IiwicHBfcHJpbnRfYm9vbCIsInBwX3ByaW50X2NoYXIiLCJwcF9vcGVuX2hib3giLCJwcF9vcGVuX3Zib3giLCJwcF9vcGVuX2h2Ym94IiwicHBfb3Blbl9ob3Zib3giLCJwcF9vcGVuX2JveCIsInBwX3ByaW50X25ld2xpbmUiLCJwcF9wcmludF9mbHVzaCIsInBwX2ZvcmNlX25ld2xpbmUiLCJwcF9wcmludF9pZl9uZXdsaW5lIiwicHBfcHJpbnRfYnJlYWsiLCJwcF9wcmludF9zcGFjZSIsInBwX3ByaW50X2N1dCIsInBwX29wZW5fdGJveCIsInBwX2Nsb3NlX3Rib3giLCJwcF9wcmludF90YnJlYWsiLCJwcF9wcmludF90YWIiLCJwcF9zZXRfdGFiIiwicHBfc2V0X21heF9ib3hlcyIsInBwX2dldF9tYXhfYm94ZXMiLCJwcF9vdmVyX21heF9ib3hlcyIsInBwX3NldF9lbGxpcHNpc190ZXh0IiwicHBfZ2V0X2VsbGlwc2lzX3RleHQiLCJwcF9saW1pdCIsInBwX3NldF9tYXhfaW5kZW50IiwicHBfZ2V0X21heF9pbmRlbnQiLCJwcF9zZXRfbWFyZ2luIiwibmV3X21heF9pbmRlbnQiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwicHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZGlzcGxheV9uZXdsaW5lIiwiYmxhbmtfbGluZSIsImRpc3BsYXlfaW5kZW50IiwicHBfc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsImRlZmF1bHRfcHBfbWFya19vcGVuX3RhZyIsImRlZmF1bHRfcHBfbWFya19jbG9zZV90YWciLCJkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnIiwiZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWciLCJwcF9tYWtlX2Zvcm1hdHRlciIsInBwX3F1ZXVlIiwic3lzX3RvayIsInN5c19zY2FuX3N0YWNrIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwiZmx1c2giLCJwcGYiLCJmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwiLCJmb3JtYXR0ZXJfb2ZfYnVmZmVyIiwicHBfYnVmZmVyX3NpemUiLCJwcF9tYWtlX2J1ZmZlciIsInN0ZGJ1ZiIsInN0ZF9mb3JtYXR0ZXIiLCJlcnJfZm9ybWF0dGVyIiwic3RyX2Zvcm1hdHRlciIsImZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIiLCJmbHVzaF9zdHJfZm9ybWF0dGVyIiwibWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsInNvYiIsImdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwiZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsIml0ZW1zIiwiYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIiwiaXRlbSIsImZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIiwib3Blbl9oYm94Iiwib3Blbl92Ym94Iiwib3Blbl9odmJveCIsIm9wZW5faG92Ym94Iiwib3Blbl9ib3giLCJjbG9zZV9ib3giLCJvcGVuX3RhZyIsImNsb3NlX3RhZyIsInByaW50X2FzIiwicHJpbnRfc3RyaW5nJDAiLCJwcmludF9pbnQkMCIsInByaW50X2Zsb2F0JDAiLCJwcmludF9jaGFyJDAiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X25ld2xpbmUkMCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9tYXhfYm94ZXMiLCJnZXRfbWF4X2JveGVzIiwib3Zlcl9tYXhfYm94ZXMiLCJzZXRfZWxsaXBzaXNfdGV4dCIsImdldF9lbGxpcHNpc190ZXh0Iiwic2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCIsInNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsInNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyIsInNldF9wcmludF90YWdzIiwiZ2V0X3ByaW50X3RhZ3MiLCJzZXRfbWFya190YWdzIiwiZ2V0X21hcmtfdGFncyIsInNldF90YWdzIiwicHBfcHJpbnRfbGlzdCIsInBwX3YiLCJvcHQkMCIsInBwX3NlcCIsIm9wdCQxIiwicHBfcHJpbnRfdGV4dCIsImNvbXB1dGVfdGFnIiwidGFnX2FjYyIsIm91dHB1dF9mb3JtYXR0aW5nX2xpdCIsIm91dHB1dF9hY2MkMCIsImJ0eSIsInAkNSIsInAkNiIsInN0cnB1dF9hY2MkMCIsInNpemUkMSIsImtmcHJpbnRmJDAiLCJpa2ZwcmludGYkMCIsImZwcmludGYkMCIsImlmcHJpbnRmJDAiLCJwcmludGYkMCIsImVwcmludGYkMCIsImtzcHJpbnRmJDAiLCJzcHJpbnRmJDAiLCJrYXNwcmludGYiLCJhc3ByaW50ZiIsInBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyIsImdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMiLCJicHJpbnRmJDAiLCJudWxsX2NoYXIiLCJuZXh0X2NoYXIiLCJpYiIsInBlZWtfY2hhciIsImNoZWNrZWRfcGVla19jaGFyIiwiZW5kX29mX2lucHV0IiwiYmVnaW5uaW5nX29mX2lucHV0IiwibmFtZV9vZl9pbnB1dCIsImZuYW1lIiwiY2hhcl9jb3VudCIsInJlc2V0X3Rva2VuIiwiaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIiLCJ0b2tlbl9zdHJpbmciLCJ0b2tlbl9idWZmZXIiLCJza2lwX2NoYXIiLCJpZ25vcmVfY2hhciIsInN0b3JlX2NoYXIiLCJkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplIiwiY3JlYXRlJDMiLCJpbmFtZSIsImZyb21fc3RyaW5nJDEiLCJmcm9tX2Z1bmN0aW9uJDAiLCJzY2FuX2Nsb3NlX2F0X2VuZCIsInNjYW5fcmFpc2VfYXRfZW5kIiwiZnJvbV9pYyIsInNjYW5fY2xvc2VfaWMiLCJlb2YiLCJzdGRpYiIsIm9wZW5faW5fZmlsZSIsImZyb21fZmlsZSIsImZyb21fZmlsZV9iaW4iLCJmcm9tX2NoYW5uZWwkMCIsImNsb3NlX2luIiwiaWMkMCIsIm1lbW8iLCJtZW1vX2Zyb21faWMiLCJtZW1vX2Zyb21fY2hhbm5lbCIsImJhZF9pbnB1dCIsImJhZF9pbnB1dF9lc2NhcGUiLCJiYWRfdG9rZW5fbGVuZ3RoIiwibWVzc2FnZSIsImJhZF9mbG9hdCIsImJhZF9oZXhfZmxvYXQiLCJjaGFyYWN0ZXJfbWlzbWF0Y2giLCJjaSIsImNoZWNrX3RoaXNfY2hhciIsImNoZWNrX2NoYXIiLCJ0b2tlbl9jaGFyIiwidG9rZW5fYm9vbCIsImludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIiwidG9rZW5faW50X2xpdGVyYWwiLCJ0b2tlbl9mbG9hdCIsInNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIiwid2lkdGgkMiIsInNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQiLCJzY2FuX2RpZ2l0X3BsdXMiLCJiYXNpcyIsImRpZ2l0cCIsIndpZHRoJDMiLCJpc19iaW5hcnlfZGlnaXQiLCJzY2FuX2JpbmFyeV9pbnQiLCJpc19vY3RhbF9kaWdpdCIsInNjYW5fb2N0YWxfaW50IiwiaXNfaGV4YV9kaWdpdCIsInNjYW5faGV4YWRlY2ltYWxfaW50Iiwic2Nhbl9zaWduIiwic2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCIsInNjYW5faW50X2NvbnZlcnNpb24iLCJzY2FuX2ZyYWN0aW9uYWxfcGFydCIsInNjYW5fZXhwb25lbnRfcGFydCIsInNjYW5fZmxvYXQiLCJwcmVjaXNpb24iLCJwcmVjaXNpb24kMCIsImNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIiwic2Nhbl9oZXhfZmxvYXQiLCJ3aWR0aCQ0Iiwid2lkdGgkNSIsIndpZHRoJDYiLCJ3aWR0aCQxMCIsIndpZHRoJDciLCJ3aWR0aCQ4Iiwid2lkdGgkOSIsInNjYW5fY2FtbF9mbG9hdF9yZXN0Iiwid2lkdGhfcHJlY2lzaW9uIiwiZnJhY193aWR0aCIsInNjYW5fY2FtbF9mbG9hdCIsInNjYW5fc3RyaW5nIiwic3RwIiwic2Nhbl9jaGFyIiwiaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciIsImNoZWNrX25leHRfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3JfY2hhciIsImNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIiwic2Nhbl9iYWNrc2xhc2hfY2hhciIsImMwIiwiZ2V0X2RpZ2l0IiwiZ2V0X2RpZ2l0JDAiLCJjMSQwIiwiYzIkMCIsInNjYW5fY2FtbF9jaGFyIiwiZmluZF9zdG9wIiwic2Nhbl9jYW1sX3N0cmluZyIsImZpbmRfc3RvcCQwIiwic2tpcF9zcGFjZXMiLCJzY2FuX2NoYXJzX2luX2NoYXJfc2V0Iiwic2Nhbl9pbmRpYyIsInNjYW5fY2hhcnMiLCJzY2FuZl9iYWRfaW5wdXQiLCJnZXRfY291bnRlciIsIndpZHRoX29mX3BhZF9vcHQiLCJzdG9wcGVyX29mX2Zvcm1hdHRpbmdfbGl0IiwiZm10aW5nIiwidGFrZV9mb3JtYXRfcmVhZGVycyQwIiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyQwIiwicmVhZGVyIiwibmV3X2siLCJyZWFkZXJzX3Jlc3QiLCJ0YWtlX2Zvcm1hdF9yZWFkZXJzIiwiZm10JDIzIiwiZm10JDI0IiwiZm10JDI1IiwidGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyIsInBhZF9wcmVjX3NjYW5mIiwicmVhZGVycyIsInNjYW4iLCJtYWtlX3NjYW5mIiwic2NhbiQwIiwic3RyX3Jlc3QiLCJzY2FuJDEiLCJzY2FuJDIiLCJzY2FuJDMiLCJzY2FuJDQiLCJjb252JDAiLCJzY2FuJDUiLCJjb252JDEiLCJzY2FuJDYiLCJjb252JDIiLCJzY2FuJDciLCJwcmVjJDUiLCJzY2FuJDgiLCJmbXRpbmdfbGl0JDAiLCJzdHAkMCIsInMkMiIsInN0cl9yZXN0JDAiLCJhcmdfcmVzdCIsImtzY2FuZiIsImVmIiwiYXBwbHkiLCJhcmdzJDAiLCJleGMiLCJic2NhbmYiLCJrc3NjYW5mIiwic3NjYW5mIiwic2NhbmYiLCJic2NhbmZfZm9ybWF0IiwiZm9ybWF0Iiwic3NjYW5mX2Zvcm1hdCIsImZvcm1hdF9mcm9tX3N0cmluZyIsInVuZXNjYXBlZCIsImtmc2NhbmYiLCJmc2NhbmYiLCJyZWdpc3RlciIsInJlZ2lzdGVyX2V4Y2VwdGlvbiIsIm8kMCIsInBhcmFtcyQwIiwiaW5pdGlhbF9vYmplY3Rfc2l6ZSIsImR1bW15X2l0ZW0iLCJ0YWciLCJjb21wYXJlJDYiLCJjb21wYXJlJDciLCJjb21wYXJlJDgiLCJkdW1teV90YWJsZSIsInRhYmxlX2NvdW50IiwiZHVtbXlfbWV0IiwiZml0X3NpemUiLCJuZXdfdGFibGUiLCJwdWJfbGFiZWxzIiwibWV0aG9kcyIsInJlc2l6ZSQxIiwibmV3X3NpemUiLCJvbGRfc2l6ZSIsIm5ld19idWNrIiwibWV0aG9kX2NvdW50IiwiaW5zdF92YXJfY291bnQiLCJuZXdfbWV0aG9kIiwidGFibGUiLCJnZXRfbWV0aG9kX2xhYmVsIiwibGFiZWwiLCJnZXRfbWV0aG9kX2xhYmVscyIsIm5hbWVzIiwic2V0X21ldGhvZCIsImVsZW1lbnQiLCJnZXRfbWV0aG9kIiwidG9fbGlzdCQwIiwibmFycm93IiwidmFycyIsInZpcnRfbWV0aHMiLCJjb25jcl9tZXRocyIsInZhcnMkMCIsInZpcnRfbWV0aHMkMCIsImNvbmNyX21ldGhzJDAiLCJ2aXJ0X21ldGhfbGFicyIsImNvbmNyX21ldGhfbGFicyIsImxhYiIsInR2YXJzIiwiYnlfbmFtZSIsImJ5X2xhYmVsIiwibWV0IiwiaG0iLCJ3aWRlbiIsInNhdmVkX3ZhcnMiLCJzYXZlZF9oaWRkZW5fbWV0aHMiLCJuZXdfc2xvdCIsIm5ld192YXJpYWJsZSIsInRvX2FycmF5IiwibmV3X21ldGhvZHNfdmFyaWFibGVzIiwibWV0aHMiLCJ2YWxzIiwibWV0aHMkMCIsIm5tZXRocyIsIm52YWxzIiwiZ2V0X3ZhcmlhYmxlIiwiZ2V0X3ZhcmlhYmxlcyIsImFkZF9pbml0aWFsaXplciIsImNyZWF0ZV90YWJsZSIsInB1YmxpY19tZXRob2RzIiwiaW5pdF9jbGFzcyIsImluaGVyaXRzIiwiY2xhIiwic3VwZXIkMCIsIm5tIiwibWFrZV9jbGFzcyIsInB1Yl9tZXRocyIsImNsYXNzX2luaXQiLCJlbnZfaW5pdCIsIm1ha2VfY2xhc3Nfc3RvcmUiLCJpbml0X3RhYmxlIiwiZHVtbXlfY2xhc3MiLCJsb2MiLCJ1bmRlZiIsImNyZWF0ZV9vYmplY3QiLCJjcmVhdGVfb2JqZWN0X29wdCIsIm9ial8wIiwiaXRlcl9mIiwicnVuX2luaXRpYWxpemVycyIsImluaXRzIiwicnVuX2luaXRpYWxpemVyc19vcHQiLCJjcmVhdGVfb2JqZWN0X2FuZF9ydW5faW5pdGlhbGl6ZXJzIiwiZ2V0X2RhdGEkMCIsImJ1aWxkX3BhdGgiLCJrZXlzIiwibG9va3VwX3RhYmxlcyIsInJvb3QiLCJ0YWJsZXMkMiIsInRhYmxlcyQwIiwidGFibGVzJDEiLCJuZXdfY2FjaGUiLCJzZXRfbWV0aG9kcyIsImNsbyIsImNsbyQwIiwibiQyIiwibiQzIiwibiQ0IiwibiQ1IiwibiQ2IiwieCQzIiwibiQ3IiwieCQ0IiwibiQ4IiwiZiQ3IiwibiQ5IiwieCQ1IiwiZiQ4IiwiZSQyIiwibiQxMCIsIngkNiIsImYkOSIsIm4kMTEiLCJ4JDciLCJuJDEyIiwieCQ4IiwibiQxMyIsIm4kMTQiLCJlJDMiLCJuJDE1IiwibSQyIiwieCQ5IiwibSQzIiwibiQxNiIsIm0kNCIsImUkNCIsIm4kMTciLCJtJDUiLCJuJDE4Iiwic3RhdHMkMCIsImluaXRpYWxfYnVmZmVyIiwiYnVmZmVyIiwiYnVmcG9zIiwicmVzZXRfYnVmZmVyIiwic3RvcmUiLCJuZXdidWZmZXIiLCJnZXRfc3RyaW5nIiwibWFrZV9sZXhlciIsImtleXdvcmRzIiwia3dkX3RhYmxlIiwiaWRlbnRfb3Jfa2V5d29yZCIsImlkIiwia2V5d29yZF9vcl9lcnJvciIsImVuZF9leHBvbmVudF9wYXJ0IiwiZXhwb25lbnRfcGFydCIsIm51bWJlciIsImlkZW50MiIsIm5lZ19udW1iZXIiLCJuZXh0X3Rva2VuJDAiLCJlc2NhcGUiLCJtYXliZV9jb21tZW50IiwiY29tbWVudCIsIm5leHRfdG9rZW4iLCJoa2V5IiwiY2xlYW4iLCJpbnNlcnRfYnVja2V0IiwiY29udGFpbmVyIiwicmVtb3ZlX2J1Y2tldCIsImhrIiwicmVwbGFjZV9idWNrZXQiLCJuZXdfZCIsImJ1Y2tldF9sZW5ndGhfYWxpdmUiLCJzdGF0c19hbGl2ZSIsImNyZWF0ZSQ0IiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsImdldF9kYXRhJDEiLCJnZXRfZGF0YV9jb3B5Iiwic2V0X2RhdGEiLCJ1bnNldF9kYXRhIiwiY2hlY2tfZGF0YSIsImJsaXRfZGF0YSIsInNldF9rZXlfZGF0YSIsImNyZWF0ZSQ1IiwiZ2V0X2tleTEiLCJnZXRfa2V5MV9jb3B5Iiwic2V0X2tleTEiLCJ1bnNldF9rZXkxIiwiY2hlY2tfa2V5MSIsImdldF9rZXkyIiwiZ2V0X2tleTJfY29weSIsInNldF9rZXkyIiwidW5zZXRfa2V5MiIsImNoZWNrX2tleTIiLCJibGl0X2tleTEiLCJibGl0X2tleTIiLCJibGl0X2tleTEyIiwiZ2V0X2RhdGEkMiIsImdldF9kYXRhX2NvcHkkMCIsInNldF9kYXRhJDAiLCJ1bnNldF9kYXRhJDAiLCJjaGVja19kYXRhJDAiLCJibGl0X2RhdGEkMCIsImsyJDAiLCJrMSQwIiwiY3JlYXRlJDYiLCJsZW5ndGgkNiIsImdldF9rZXkkMCIsImdldF9rZXlfY29weSQwIiwic2V0X2tleSQwIiwidW5zZXRfa2V5JDAiLCJjaGVja19rZXkkMCIsImJsaXRfa2V5JDAiLCJvMSIsIm8yIiwiZ2V0X2RhdGEkMyIsImdldF9kYXRhX2NvcHkkMSIsInNldF9kYXRhJDEiLCJ1bnNldF9kYXRhJDEiLCJjaGVja19kYXRhJDEiLCJibGl0X2RhdGEkMSIsImtpIiwiazAiLCJnZW5lcmljX2Jhc2VuYW1lIiwiaXNfZGlyX3NlcCIsImdlbmVyaWNfZGlybmFtZSIsImlzX3JlbGF0aXZlIiwiaXNfaW1wbGljaXQiLCJjaGVja19zdWZmaXgiLCJzdWZmIiwicXVvdGUiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwidGVtcF9kaXJfbmFtZSIsInF1b3RlJDAiLCJhZGRfYnMiLCJsb29wJDAiLCJsb29wX2JzIiwiZHJpdmVfYW5kX3BhdGgiLCJkaXJuYW1lJDAiLCJwYXRoIiwiZHJpdmUiLCJkaXIiLCJiYXNlbmFtZSQwIiwiYmFzZW5hbWUkMSIsImRpcm5hbWUkMSIsImN1cnJlbnRfZGlyX25hbWUkMiIsInBhcmVudF9kaXJfbmFtZSQyIiwiZGlyX3NlcCQyIiwiaXNfZGlyX3NlcCQxIiwiaXNfcmVsYXRpdmUkMSIsImlzX2ltcGxpY2l0JDEiLCJjaGVja19zdWZmaXgkMSIsInRlbXBfZGlyX25hbWUkMCIsInF1b3RlJDEiLCJiYXNlbmFtZSQyIiwiZGlybmFtZSQyIiwiY29uY2F0JDIiLCJjaG9wX3N1ZmZpeCIsImV4dGVuc2lvbl9sZW4iLCJleHRlbnNpb24iLCJjaG9wX2V4dGVuc2lvbiIsInJlbW92ZV9leHRlbnNpb24iLCJwcm5nJDAiLCJ0ZW1wX2ZpbGVfbmFtZSIsInRlbXBfZGlyIiwicm5kIiwiY3VycmVudF90ZW1wX2Rpcl9uYW1lIiwic2V0X3RlbXBfZGlyX25hbWUiLCJnZXRfdGVtcF9kaXJfbmFtZSIsInRlbXBfZmlsZSIsInRyeV9uYW1lIiwiY291bnRlciQxIiwib3Blbl90ZW1wX2ZpbGUiLCJzdGgkMCIsInBlcm1zIiwic3RoJDEiLCJhZGQkMSIsInN1YiQzIiwibmVnIiwiY29uaiIsIm11bCIsImRpdiIsImludiIsIm5vcm0yIiwibm9ybSIsInEkMCIsInBvbGFyIiwic3FydCIsInckMCIsImV4cCIsImxvZyIsInBvdyIsImVuYWJsZWQiLCJpZl9zcGFjZXRpbWVfZW5hYmxlZCIsImNyZWF0ZSQ3IiwiY2hhbm5lbCIsInNhdmVfZXZlbnQiLCJ0aW1lIiwiZXZlbnRfbmFtZSIsInNhdmVfYW5kX2Nsb3NlIiwidGFrZSQwIiwiY2xvc2VkIiwic2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyIsInNleHBfb2ZfdCIsInQiLCJzZXhwX29mX3QkMCIsInNleHBfb2ZfdmFsdWUiLCJrZXkiLCJ2YWx1ZSIsImF0bV9saXMiLCJzZXhwX29mX3QkMSIsInJvb3Rfb3AiLCJyb290X2lkIiwidHBfbG9jIiwibG9nIiwibXNnIiwiY29udiIsInNleHAiLCJzZXhwX29mX2FjdG9yIiwic2V4cF9vZl9zZXEiLCJzZXhwX29mX29ial9pZCIsInNleHBfb2Zfa2V5IiwiYWN0aW9uX29mX3NleHAiLCJzZXhwX29mX2FjdGlvbiIsInNleHBfb2Zfb3BfdmFsIiwidjAiLCJ2MCQwIiwidjAkMSIsInYwJDIiLCJ2MCQzIiwidjAkNCIsInNleHBfb2ZfbWF0ZXJpYWxpemVkIiwidl9vYmpfaWQiLCJibmRzIiwiYXJnIiwiYm5kcyQwIiwic2V4cF9vZl92YWx1ZSIsInZfb2JqIiwic2V4cF9vZl9lbGVtX2lkIiwidjEiLCJ2MSQwIiwiZW1wdHkiLCJpbnNlcnRfaW5kZXgiLCJpbmRleCIsImsiLCJ2IiwidCIsImluZGV4X29mIiwiaXRtayIsImlkeCIsImtleV9vZiIsImtleSIsInNldF92YWx1ZSIsInJlbW92ZV9pbmRleCIsInNleHBfb2Zfb3AiLCJ2X3ZhbHVlIiwidl9lbGVtIiwidl9zZXEiLCJ2X2FjdG9yIiwidl9hY3Rpb24iLCJ2X2tleSIsImFyZyQwIiwiYm5kcyQxIiwiYXJnJDEiLCJibmRzJDIiLCJhcmckMiIsImJuZHMkMyIsImFyZyQzIiwiYm5kcyQ0IiwiYXJnJDQiLCJibmRzJDUiLCJhcmckNSIsImJuZHMkNiIsInNleHBfb2ZfY2hhbmdlX29wIiwic2V4cF9vZl9sYW1wb3J0X29wIiwibGFtcG9ydF9jb21wYXJlIiwib3AxIiwib3AyIiwiZ2V0X29wX2VsZW0iLCJvcCIsImNvbXBhcmUiLCJsb3AxIiwibG9wMiIsInNleHBfb2ZfY2hhbmdlIiwidl9vcHMiLCJ2X2RlcHMiLCJzZXhwX29mX3N0YXRlIiwidl9hbGxEZXBzIiwidl9jaGFuZ2UiLCJzZXhwX29mX2VkaXRfYWN0aW9uIiwic2V4cF9vZl9lZGl0X3R5cGUiLCJzZXhwX29mX2NvbmZsaWN0Iiwidl9saW5rIiwic2V4cF9vZl9lZGl0Iiwidl9wYXRoIiwidl9jb25mbGljdHMiLCJ2X2luZGV4Iiwidl9lbGVtX2lkX2tleSIsInZfdHlwZSIsImFyZyQ2IiwiYm5kcyQ3IiwiYXJnJDciLCJibmRzJDgiLCJhcmckOCIsImJuZHMkOSIsInNleHBfb2Zfb2JqX2F1eCIsInZfaW5zZXJ0aW9uIiwidl9lbGVtX2lkcyIsInZfaW5ib3VuZCIsInZfaW5pdCIsInZfZm9sbG93aW5nIiwidl9tYXhfZWxlbSIsInNleHBfb2Zfb2JqIiwic2V4cF9vZl9kaWZmX3R5cGUiLCJzZXhwX29mX2RpZmZfYWN0aW9uIiwic2V4cF9vZl9kaWZmIiwidl9lbGVtX2lkIiwic2V4cF9vZl9jaGlsZCIsInNleHBfb2ZfY29udGV4dCIsInNleHBfb2ZfdCQwIiwidl91bmRvX2xvY2FsIiwidl9xdWV1ZSIsInZfcmVkb19zdGFjayIsInZfdW5kb19zdGFjayIsInZfdW5kb19wb3MiLCJ2X2Nsb2NrIiwidl9ieV9vYmplY3QiLCJ2X2hpc3RvcnkiLCJ2X3N0YXRlcyIsInN0YXRlcyIsInNlcV9hY3Rvcl9tYXAiLCJtIiwiZ2V0X29ial9hdXgiLCJvYmpfaWQiLCJnZXRfb2JqX2F1eF9leG4iLCJnZXRfb3BfdmFsdWVfYXNfc3RyaW5nX2V4biIsInMiLCJnZXRfb2JqX2FjdGlvbiIsImNhdXNhbHlfcmVhZHkiLCJjaGFuZ2UiLCJzZXEiLCJkZXBBY3RvciIsImRlcFNlcSIsImRlcENsb2NrIiwidHJhbnNpdGl2ZV9kZXBzIiwiYmFzZURlcHMiLCJkZXBzIiwic3RhdGUiLCJsIiwibWF0Y2giLCJyIiwiciQwIiwiYXBwbHlfbWFrZSIsImUiLCJvIiwiZSQwIiwibyQwIiwiZSQxIiwibyQxIiwib2JqX2F1eCIsImVkaXQiLCJieV9vYmplY3QiLCJhcHBseV9pbnNlcnQiLCJlbGVtX2lkIiwib2JqIiwiZm9sbG93aW5nIiwibWF4X2VsZW0iLCJpbnNlcnRpb24iLCJ0JDAiLCJnZXRfY29uZmxpY3RzIiwib3BzIiwib3BzX3Jlc3QiLCJjb25mbGljdHMiLCJsaW5rIiwiY29uZiIsImNzIiwiZ2V0X3BhdGgiLCJwYXRoIiwib2JqX2lkJDAiLCJwYXRoJDAiLCJyZWYiLCJvYmpfYXV4JDAiLCJwIiwicGF0aCQxIiwib2JqX2lkJDEiLCJlbGVtX2lkcyIsInBhdGgkMiIsIm9ial9pZCQyIiwicGF0Y2hfbGlzdCIsImVsZW1faWRfa2V5IiwiYWN0aW9uIiwidHlwZSIsImZpcnN0X29wIiwiZm9wIiwidmFsdWUiLCJ2YWx1ZSQwIiwiZWRpdCQwIiwidmFsdWUkMSIsImVsZW1faWRzJDAiLCJlbGVtX2lkcyQyIiwiZWRpdCQxIiwiZWxlbV9pZHMkMSIsIm9wcyQwIiwiZWRpdCQyIiwib2JqX21hcCIsImlzX2NvbmN1cnJlbnQiLCJjbG9jazEiLCJjbG9jazIiLCJnZXRfZmllbGRfb3BzIiwiZ2V0X3BhcmVudCIsImtleSQwIiwiaW5zZXJ0aW9uc19hZnRlciIsInBhcmVudF9pZCIsImNoaWxkX2lkIiwiY2hpbGRfaWQkMCIsInBhcnRzIiwiYWN0b3IiLCJlbGVtIiwiY2hpbGRfa2V5IiwicGFyZW50X2lkJDAiLCJjaGlsZF9rZXkkMCIsImdldF9wcmV2aW91cyIsImNoaWxkcmVuIiwiY2hpbGQiLCJwcmV2X2lkIiwibG9vcCIsInByZXZfaWQkMCIsImNoaWxkcmVuJDAiLCJwcmV2X2lkJDEiLCJ1cGRhdGVfbGlzdF9lbGVtZW50IiwiaW5kZXgkMCIsImluZGV4JDEiLCJ1cGRhdGVfbWFwX2tleSIsImZzdCIsImFwcGx5X2Fzc2lnbiIsImlzX3RvcF9sZXZlbCIsInVsb2MiLCJ1bmRvX29wcyIsInVuZG9fb3BzJDAiLCJ1bG9jJDAiLCJvYmpfbWFwJDAiLCJyZWZzIiwicmVtIiwib3ZlciIsInJlbWFpbmluZyIsIm92ZXJ3cml0dGVuIiwib3ZlcndyaXR0ZW5fbGlua3MiLCJ0JDEiLCJ0JDIiLCJyZW1haW5pbmckMCIsInJlbWFpbmluZyQxIiwiYnlfb2JqZWN0JDAiLCJ0JDMiLCJvYmpfdHlwZSIsImFwcGx5X29wcyIsIm5ld19vYmpzIiwiYWxsX2RpZmZzIiwiZGlmZnMiLCJkaWZmcyQwIiwibmV3X29ianMkMCIsImRpZmZzJDEiLCJhcHBseV9jaGFuZ2UiLCJwcmlvciIsImFsbERlcHMiLCJuZXdfcHJpb3IiLCJjaF9vcCIsImskMCIsInJlbWFpbmluZ19kZXBzIiwiY2xvY2siLCJoaXN0b3J5IiwiYXBwbHlfcXVldWVkX29wcyIsInF1ZXVlIiwiZGlmZiIsInB1c2hfdW5kb19oaXN0b3J5IiwidW5kb19zdGFjayIsImFkZF9jaGFuZ2UiLCJpbml0IiwiaXNVbmRvYWJsZSIsInJvb3Rfb2JqIiwiZ2V0X21pc3NpbmdfY2hhbmdlcyIsImhhdmVfZGVwcyIsImFsbF9kZXBzIiwiZ2V0X2NoYW5nZXNfZm9yX2FjdG9yIiwib3B0IiwiZm9yX2FjdG9yIiwic3RoIiwiYWZ0ZXJfc2VxIiwiZ2V0X21pc3NpbmdfZGVwcyIsIm1pc3NpbmciLCJjdXJyIiwidmFsaWRfZmllbGRfbmFtZSIsImlzX2ZpZWxkX3ByZXNlbnQiLCJ1bnBhY2tfdmFsdWUiLCJwYXRjaF9kaWZmIiwicGF0Y2hfZGlmZiQwIiwiY2hpbGRzIiwidW5wYWNrX2NvbmZsaWN0X3ZhbHVlIiwiY29uZmxpY3QiLCJ1bnBhY2tfY29uZmxpY3RzIiwiY29uZmxpY3QkMCIsImNvbmZsaWN0cyQwIiwiZ2V0X29iamVjdF9maWVsZHMiLCJzZXhwX29mX2l0ZXJhdG9yX21vZGUiLCJzZXhwX29mX2l0ZXJhdG9yX3ZhbCIsInYxJDEiLCJ2MCQ1IiwidjAkNiIsInYxJDIiLCJ2MCQ3IiwidjAkOCIsInNleHBfb2ZfaXRlcmF0b3JfcmVzIiwidl9kb25lIiwic2V4cF9vZl9pdGVyYXRvciIsInZfbmV4dCIsImYiLCJpbnN0YW50aWF0ZV9vYmplY3QiLCJpc19yb290Iiwib2JqX3R5cCIsImNvbnRleHQiLCJpbnN0YW50aWF0ZV9tYXAiLCJpbnN0YW50aWF0ZV9saXN0IiwidHlwIiwicGF0Y2hfZGlmZnMiLCJwYXRjaF9kaWZmcyQwIiwibGlzdF9pdGVyYXRvciIsInZhbHVlcyIsImVsZW1zIiwiZWwiLCJuZXh0X3ZhbHVlIiwiY2hpbGRyZW4kMSIsIm1hdF92YWx1ZSIsImNoaWxkcmVuJDIiLCJjaGlsZHJlbiQzIiwicGF0Y2hfZGlmZiQxIiwibmV4dF9jb25mbGljdCIsImNoaWxkcmVuJDQiLCJkaWZmcyQyIiwiY2hpbGRyZW4kNSIsInBhdGNoX2RpZmYkMiIsImNoaWxkcmVuJDYiLCJwYXRjaF9kaWZmJDMiLCJwYXRjaF9kaWZmcyQxIiwiZ2V0X29iamVjdF9jb25mbGljdHMiLCJmaWVsZHMiLCJnZXRfb2JqZWN0X2ZpZWxkIiwiYWxsX2NvbmYiLCJmaWVsZCIsImZpbHRlcmVkIiwiZmlsIiwicmVzIiwiZ2V0X29wX3ZhbHVlIiwibWF0ZXJpYWxpemVkIiwibWF0IiwiaGQiLCJsaXN0X2lkIiwibW9kZSIsIm5leHQiLCJnZXRfbmV4dCIsImVsZW0kMCIsInRsIiwib3BfbWFwIiwib3BfdmFsdWUiLCJjb25mbGljdCQxIiwiZmluZF9hbmNlc3RvciIsImFuY2VzdG9yIiwia2V5JDEiLCJzZXhwX29mX3BhdGNoIiwidl9kaWZmcyIsInZfY2FuX3JlZG8iLCJ2X2Nhbl91bmRvIiwibWFrZV9wYXRjaCIsImdldF9wYXRjaCIsImxpc3RfbGVuZ3RoIiwiZ2V0X2Nsb2NrIiwiZ2V0X2RlcHMiLCJjYW5fdW5kbyIsInVuZG9fcG9zIiwiY2FuX3JlZG8iLCJyZWRvX3N0YWNrIiwiX2NfIiwiZiIsImciLCJ4IiwiZnJlZXplIiwibyIsImNsb2NrIiwidCIsImxpc3RfdG9fanNfYXJyYXkiLCJsaXMiLCJ0MSIsInQwIiwiYXJyIiwiaSIsImVsIiwib2JqX3NldCIsImNvbnYiLCJuYW1lIiwidmFsdWUiLCJvYmpfa3YiLCJjb252JDAiLCJvYmpfc2V0X29wdGRlZiIsInYiLCJvYmpfc2V0X29wdCIsImVkaXRfYWN0aW9uX3RvX2pzX2VkaXRfYWN0aW9uIiwidHlwZV90b19qc190eXBlIiwicGF0aF90b19qc19wYXRoIiwicyIsImFjdG9yX3RvX2pzX2FjdG9yIiwiYWN0b3IiLCJhcnJheV90b19saXN0IiwianNfYWN0aW9uX3RvX2FjdGlvbiIsImpzX3MiLCJhY3Rpb25fdG9fanNfYWN0aW9uIiwiYSIsIm9wX3ZhbF90b19qc192YWx1ZSIsImIiLCJuIiwidmFsdWVfdG9fanNfdmFsdWUiLCJzZWxmIiwib2JqIiwic2VsZl8xIiwidDIiLCJqc192YWx1ZV90b19vcF92YWwiLCJqc192YWx1ZSIsInR5cCIsInRvX29wX2xpc3QiLCJqc19vcCIsInQ2IiwidDUiLCJ0NyIsInQzIiwidDQiLCJjb25mbGljdHNfdG9fanNfY29uZmxpY3RzIiwiY29uZmwiLCJudW1iZXJfb2ZfaW50Iiwib2JqX3NldF9wYXRoIiwiZWRpdCIsImVkaXRfdG9fanNfZWRpdCIsImNoYW5nZV9vcF90b19qc19jaGFuZ2Vfb3AiLCJvcCIsImFjdG9yX21hcF9vZl9qc19vYmoiLCJqc19vYmoiLCJhbWFwIiwianNfYWN0b3IiLCJqc19vYmpfb2ZfYWN0b3JfbWFwIiwibSIsImsiLCJrdiIsImludF9vZl9qc19udW1iZXIiLCJqc19jaGFuZ2VfdG9fY2hhbmdlIiwianNfY2hhbmdlIiwidDExIiwidDEwIiwidDkiLCJ0OCIsImpzX251bWJlcl9vZl9pbnQiLCJjaGFuZ2VfdG9fanNfY2hhbmdlIiwiY2hhbmdlIiwicmVxdWlyZV9tb2R1bGUiLCJudW1iZXIiLCJjbG9jayQwIiwiY2hhbmdlX2xpc3QiLCJpbW1fTWFwIiwiaW1tdXRhYmxlIiwidDEyIiwiTWFwIiwiaW1tIiwidDEzIiwiaXNfaW1tIiwiZnJvbV9pbW0iLCJpbW1fb2JqIiwiY2xvY2skMSIsInNpbXBsZSIsImFjdG9ycyIsInNlcSIsInNlcSQwIiwibWFrZV9wYXRjaCIsImRpZmZzIiwiZGVwcyIsImNhblVuZG8iLCJjYW5SZWRvIiwic2VsZl8yIiwidDE0IiwidDE1IiwidDE2IiwidDE3IiwidDE4IiwiaW5pdCIsImFwcGx5IiwiY2hhbmdlcyIsInVuZG9hYmxlIiwibmV3X2RpZmZzIiwib3Bfc2V0IiwidCQwIiwiYXBwbHlfY2hhbmdlcyIsImFwcGx5X2NoYW5nZXMkMCIsImpzX2NoYW5nZXMiLCJqc19jaGFuZ2VzJDAiLCJqc19kaWZmcyIsImpzX3BhdGNoIiwidDIwIiwidDE5IiwicmV0IiwiYXBwbHlfbG9jYWxfY2hhbmdlIiwidDI5IiwicmVxdWVzdF90eXBlIiwidDI2IiwidDI4IiwidDI3IiwidDIzIiwidDI1IiwidDI0IiwidDIyIiwidDIxIiwiZGlmZl90b19qc19kaWZmIiwiZGlmZiIsImFjdGlvbiIsInR5cGUiLCJnZXRfcGF0Y2giLCJwYXRjaCIsInNlbGZfMyIsInQzMCIsInQzMSIsInQzMiIsInQzMyIsInQzNCIsIm1lcmdlIiwibG9jYWwiLCJyZW1vdGUiLCJ0MzYiLCJ0MzUiLCJnZXRfY2hhbmdlc19mb3JfYWN0b3IiLCJqc19hY3Rvcl9pZCIsImdldF9jaGFuZ2VzIiwib2xkX3N0YXRlIiwibmV3X3N0YXRlIiwib2xkX2Nsb2NrIiwiZ2V0X21pc3NpbmdfY2hhbmdlcyIsImdldF9jbG9jayIsInQzNyIsIm1hcCJdLCJtYXBwaW5ncyI6Ijs7Ozs4QkEwbENBLDJCQUFvQjs7OytCQ2xlcEI7a0NBQW9DLHNDQUFXOytCQXpiL0M7aUNBQ0U7O29DQUVFO3NDQUFxQjtvQ0FFckIsbUNBQU87OzBDQUVQO29DQUVKOzJCQzdJQTs2QkFDRTs4QkFBTzs4QkFDQTs4QkFDQTs2QkFDUDs7O2dEQUNGOzJCQTVDQSx3QkFBc0I7OzhCQUFFOzJCQXdEeEI7NkJBQ0U7OEJBQU87OEJBQ0E7Ozs7Ozs7Ozs7OEJBQ0E7Ozs7Ozs7Ozs7Ozs7OzZCQUNQOzs7Z0RBQ0Y7MkJBOUJBOzZCQUNFOzhCQUFPOzhCQUNBOzhCQUNBOzZCQUNQOzs7Z0RBQ0Y7NEJBd0xBOzhCQUNFOzs7c0RBQ0Y7NkJGUkE7K0JBQ0U7Z0NBQU07Z0NBQ0E7K0JBQ047a0NBQVU7OytCQUNWLGlDQUNGOzJCRTVLQTs2QkFDRTs4QkFBTzs4QkFDQTs4QkFDQTs2QkFDUDs7O2dEQUNGOzJCQWpEQTs2QkFDRSx1Q0FBaUI7NkJBQ2pCOytCQUFpQjs2QkFDakIsdUNBQWlCOzZCQUNqQjsrQkFBaUI7NkJBQ2pCLHVDQUFpQjs2QkFDakI7K0JBQWlCOzZCQUNqQiwrQkFDRjs0QkE4SUE7Ozt5REFJQTs0QkFHQTs7OytDQUlBOzRCQU1BOzhCQUNFO2dDQUFXO2dDQUNDO2lDQUFFO2dDQUNGO2lDQUFFO2dDQUNEOzhCQUNiO2dDQUFPO2dD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OztJYXhlRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrQktBO0tBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0M0R0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDcEZBQztLQUNBQztLQUNBQztLQUlBQztLQUNBQzs7OztLQ3pCQUM7S0FvSEFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3k3RU1DO0tBUVFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0MxakZkQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NxREVDO0tBQ0FDO0tBQ0FDOzs7S0EzRFlDO0tBOEVaQztLQUNBQztLQUNBQzs7O0tBK0RBQztLQUNBQztLQUNBQzs7O0tDN0lGQztLQUNBQztLQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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Q0VROzZCQXZJVyx3QkFvTGI7NEJBQ0E7aUNBakNFSzs2QkFwSlcsd0JBcUxiOzRCQUNBO3lCQTdCRUU7NkJBekpXLHdCQXNMYjs0QkFDQTtnQ0FuQkVJOzZCQXBLVyx3QkF1TGI7NEJBQ0E7dUJBZkVDOzZCQXpLVyx3QkF3TGI7OztPQXhZRS9KOzs7T0FJQUk7O09BT0FFO09BRUFFO09BS0FPO09BS0FNO09BS0FFO09BS0FDO09BU0FDO09BS0FDO09BU0FFO09BRUFFO09BRUFDO09BWUFFO09BWUFFO09BS0lHO09BU0FLO09BV0pHO09BYUFPO09BVUFFO09BRUFDO09BU0FFO09BY0FDO09BU0FFO09BUUFJO09BUUFJO09BRUFDO09BTUFNO09BRUFDOzs7T0FrREFvQjtPQWVBVztPQUVBQztPQVlBTTtPQUVBQztPQWFBUTtPQWdCQVc7T0EwQkFJO09BZUFRO09BYUFLO09BS0FFO09BV0FJO09BS0FDOzRCQWVGOzs2Q0Q3WUgiLCJzb3VyY2VzIjpbInN0ZGxpYi5qcyIsIm1sU3RyaW5nLmpzIiwiaW50NjQuanMiLCJpZWVlXzc1NC5qcyIsImZzLmpzIiwiZnNfZmFrZS5qcyIsImZzX25vZGUuanMiLCJiaWdhcnJheS5qcyIsImJpZ3N0cmluZy5qcyIsImpzbGliLmpzIiwibWFyc2hhbC5qcyIsImpzbGliX2pzX29mX29jYW1sLmpzIiwiaW8uanMiLCJnYy5qcyIsIndlYWsuanMiLCJwYXJzaW5nLmpzIiwidW5peC5qcyIsImludGVybmFsTW9kLmpzIiwibGV4aW5nLmpzIiwianNvbjIuanMiLCJtZDUuanMiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvdWNoYXIubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvc3lzLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2ludDY0Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2xleGluZy5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvcHJpbnRleGMubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvZmlsZW5hbWUubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvcGVydmFzaXZlcy5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9saXN0Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2NoYXIubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvYnl0ZXMubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9zb3J0Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL21hcnNoYWwubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvb2JqLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2FycmF5Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2ludDMyLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL3BhcnNpbmcubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvc2V0Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL21hcC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9zdGFjay5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9xdWV1ZS5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2xhenkubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvc3RyZWFtLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9wcmludGYubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvYXJnLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2djLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2RpZ2VzdC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9yYW5kb20ubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC93ZWFrLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL2Zvcm1hdC5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9jYWxsYmFjay5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxPTy5tbCIsIi9Vc2Vycy9uaWNrLy5vcGFtL21lc2hsYW5nL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvVXNlcnMvbmljay8ub3BhbS9tZXNobGFuZy9saWIvb2NhbWwvZXBoZW1lcm9uLm1sIiwiL1VzZXJzL25pY2svLm9wYW0vbWVzaGxhbmcvbGliL29jYW1sL3NwYWNldGltZS5tbCIsImRhdGFzdHJ1Y3R1cmVzLm1sIiwib3Bfc2V0Lm1sIiwiaW5kZXgubWwiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gQ29yZVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiByYXdfYXJyYXlfc3ViIChhLGksbCkge1xuICB2YXIgYiA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IGw7IGorKykgYltqXSA9IGFbaStqXTtcbiAgcmV0dXJuIGJcbn1cblxuLy9Qcm92aWRlczogcmF3X2FycmF5X2NvcHlcbmZ1bmN0aW9uIHJhd19hcnJheV9jb3B5IChhKSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrICkgYltpXSA9IGFbaV07XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiByYXdfYXJyYXlfY29ucyAoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIGJbMF09eDtcbiAgZm9yKHZhciBpID0gMTsgaSA8PSBsOyBpKysgKSBiW2ldID0gYVtpLTFdO1xuICByZXR1cm4gYlxufVxuXG4vL1Byb3ZpZGVzOiByYXdfYXJyYXlfYXBwZW5kX29uZVxuZnVuY3Rpb24gcmF3X2FycmF5X2FwcGVuZF9vbmUoYSx4KSB7XG4gIHZhciBsID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGwrMSk7XG4gIHZhciBpID0gMDtcbiAgZm9yKDsgaSA8IGw7IGkrKyApIGJbaV0gPSBhW2ldO1xuICBiW2ldPXg7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2FsbF9nZW4gKGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogcmF3X2FycmF5X3N1YlxuLy9SZXF1aXJlczogcmF3X2FycmF5X2FwcGVuZF9vbmVcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIHZhciBuID0gZi5sZW5ndGg7XG4gIHZhciBhcmdzTGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBkID0gbiAtIGFyZ3NMZW47XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKVxuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYuYXBwbHkobnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd19hcnJheV9zdWIoYXJncywwLG4pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICByYXdfYXJyYXlfc3ViKGFyZ3MsbixhcmdzTGVuIC0gbikpO1xuICBlbHNlXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KXsgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgcmF3X2FycmF5X2FwcGVuZF9vbmUoYXJncyx4KSk7IH07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmFtZWRfdmFsdWVzXG52YXIgY2FtbF9uYW1lZF92YWx1ZXMgPSB7fTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSAoY29uc3QsY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZShubSx2KSB7XG4gIGNhbWxfbmFtZWRfdmFsdWVzW2NhbWxfanNieXRlc19vZl9zdHJpbmcobm0pXSA9IHY7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlc1xuZnVuY3Rpb24gY2FtbF9uYW1lZF92YWx1ZShubSkge1xuICByZXR1cm4gY2FtbF9uYW1lZF92YWx1ZXNbbm1dXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbnZhciBjYW1sX2dsb2JhbF9kYXRhID0gWzBdO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3JlZ2lzdGVyX2dsb2JhbCAoY29uc3QsIHNoYWxsb3csIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKG4sIHYsIG5hbWVfb3B0KSB7XG4gIGNhbWxfZ2xvYmFsX2RhdGFbbiArIDFdID0gdjtcbiAgaWYobmFtZV9vcHQpIGNhbWxfZ2xvYmFsX2RhdGFbbmFtZV9vcHRdID0gdjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9nZXRfZ2xvYmFsX2RhdGEgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9nZXRfZ2xvYmFsX2RhdGEgKCkgeyByZXR1cm4gY2FtbF9nbG9iYWxfZGF0YTsgfVxuXG4vL1JhaXNlIGV4Y2VwdGlvblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQgKGNvbnN0KVxuLy9WZXJzaW9uOiA8IDQuMDJcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfY29uc3RhbnQgKHRhZykgeyB0aHJvdyBbMCwgdGFnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2NvbnN0YW50IChjb25zdClcbi8vVmVyc2lvbjogPj0gNC4wMlxuZnVuY3Rpb24gY2FtbF9yYWlzZV9jb25zdGFudCAodGFnKSB7IHRocm93IHRhZzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuLy9WZXJzaW9uOiA8IDQuMDJcbmZ1bmN0aW9uIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAodGFnKSB7IHJldHVybiBbMCwgdGFnXTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKGNvbnN0KVxuLy9WZXJzaW9uOiA+PSA0LjAyXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZyxjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcgKHRhZywgbXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgY2FtbF9uZXdfc3RyaW5nIChtc2cpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93cmFwX2V4Y2VwdGlvbiBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfanNfdG9fc3RyaW5nLGNhbWxfbmFtZWRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudFxuZnVuY3Rpb24gY2FtbF93cmFwX2V4Y2VwdGlvbihlKSB7XG4gIGlmKGUgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGU7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGNocm9tZSwgc2FmYXJpXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlJhbmdlRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvbWF4aW11bSBjYWxsIHN0YWNrL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vU3RhY2tfb3ZlcmZsb3c6IGZpcmVmb3hcbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuSW50ZXJuYWxFcnJvclxuICAgICAmJiBlLm1lc3NhZ2VcbiAgICAgJiYgZS5tZXNzYWdlLm1hdGNoKC90b28gbXVjaCByZWN1cnNpb24vaSkpXG4gICAgcmV0dXJuIGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLlN0YWNrX292ZXJmbG93KTtcbiAgLy9XcmFwIEVycm9yIGluIEpzLkVycm9yIGV4Y2VwdGlvblxuICBpZihlIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuRXJyb3IgJiYgY2FtbF9uYW1lZF92YWx1ZShcImpzRXJyb3JcIikpXG4gICAgcmV0dXJuIFswLGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpLGVdO1xuICAvL2ZhbGxiYWNrOiB3cmFwcGVkIGluIEZhaWx1cmVcbiAgcmV0dXJuIFswLGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSxjYW1sX2pzX3RvX3N0cmluZyAoU3RyaW5nKGUpKV07XG59XG5cbi8vIEV4cGVyaW1lbnRhbFxuLy9Qcm92aWRlczogY2FtbF9leG5fd2l0aF9qc19iYWNrdHJhY2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlKGV4biwgZm9yY2UpIHtcbiAgICAvL25ldmVyIHJlcmFpc2UgZm9yIGNvbnN0YW50IGV4blxuICAgIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb25cbmZ1bmN0aW9uIGNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uKGV4bikge1xuICBpZihleG4uanNfZXJyb3IpIHsgcmV0dXJuIGV4bi5qc19lcnJvcjsgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfaW52YWxpZF9hcmd1bWVudCAobXNnKSB7XG4gIGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcoY2FtbF9nbG9iYWxfZGF0YS5JbnZhbGlkX2FyZ3VtZW50LCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkVuZF9vZl9maWxlKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKSB7XG4gIGNhbWxfcmFpc2VfY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5EaXZpc2lvbl9ieV96ZXJvKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub3RfZm91bmRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLk5vdF9mb3VuZCk7IH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial90YWcgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7IHJldHVybiAoeCBpbnN0YW5jZW9mIEFycmF5KT94WzBdOih4IGluc3RhbmNlb2YgTWxCeXRlcyk/MjUyOjEwMDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3NldF90YWcgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3RhZyAoeCwgdGFnKSB7IHhbMF0gPSB0YWc7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX29ial9ibG9jayBjb25zdCAoY29uc3QsY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9ibG9jayAodGFnLCBzaXplKSB7XG4gIHZhciBvID0gbmV3IEFycmF5KHNpemUrMSk7XG4gIG9bMF09dGFnO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzaXplOyBpKyspIG9baV0gPSAwO1xuICByZXR1cm4gbztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3RydW5jYXRlIChtdXRhYmxlLCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9vYmpfdHJ1bmNhdGUgKHgsIHMpIHtcbiAgaWYgKHM8PTAgfHwgcyArIDEgPiB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiT2JqLnRydW5jYXRlXCIpO1xuICBpZiAoeC5sZW5ndGggIT0gcyArIDEpIHgubGVuZ3RoID0gcyArIDE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGF6eV9tYWtlX2ZvcndhcmQgKHYpIHsgcmV0dXJuIFsyNTAsIHZdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5pZiAoIU1hdGguaW11bClcbiAgTWF0aC5pbXVsID1cbiAgICBmdW5jdGlvbiAoeCx5KVxuICAgIHsgeSB8PSAwOyByZXR1cm4gKCgoKHggPj4gMTYpICogeSkgPDwgMTYpICsgKHggJiAweGZmZmYpICogeSl8MDsgfTtcbnZhciBjYW1sX211bCA9IE1hdGguaW11bDtcblxuLy9zbGlnaHRseSBzbG93ZXJcbi8vIGZ1bmN0aW9uIG11bDMyKHgseSkge1xuLy8gICB2YXIgeGxvID0geCAmIDB4ZmZmZjtcbi8vICAgdmFyIHhoaSA9IHggLSB4bG87XG4vLyAgIHJldHVybiAoKCh4aGkgKiB5KSB8MCkgKyB4bG8gKiB5KXwwO1xuLy8gfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2RpdlxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9kaXYoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiAoeC95KXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gY2FtbF9tb2QoeCx5KSB7XG4gIGlmICh5ID09IDApIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHJldHVybiB4JXk7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jaGVja19ib3VuZCAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9jaGVja19ib3VuZCAoYXJyYXksIGluZGV4KSB7XG4gIGlmIChpbmRleCA+Pj4gMCA+PSBhcnJheS5sZW5ndGggLSAxKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3ZlY3QgY29uc3QgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfbWFrZV92ZWN0IChsZW4sIGluaXQpIHtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSBpbml0O1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX2Zsb2F0X3ZlY3QgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9tYWtlX2Zsb2F0X3ZlY3QobGVuKXtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9jcmVhdGUobGVuKXtcbiAgdmFyIGxlbiA9IGxlbiArIDEgfCAwO1xuICB2YXIgYiA9IG5ldyBBcnJheShsZW4pO1xuICBiWzBdPTI1NDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykgYltpXSA9IDA7XG4gIHJldHVybiBiXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZV92YWwgKGNvbnN0LCBjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbCAoYSwgYiwgdG90YWwpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIGZvcig7Oykge1xuICAgIGlmICghKHRvdGFsICYmIGEgPT09IGIpKSB7XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgICAgICBpZiAoYSAhPT0gYikge1xuXHRcdHZhciB4ID0gY2FtbF9zdHJpbmdfY29tcGFyZShhLCBiKTtcblx0XHRpZiAoeCAhPSAwKSByZXR1cm4geDtcblx0ICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgLy8gU2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdfDApKSB7XG4gICAgICAgIHZhciB0YSA9IGFbMF07XG4gICAgICAgIC8vIGlnbm9yZSBkb3VibGVfYXJyYXlfdGFnXG4gICAgICAgIGlmICh0YSA9PT0gMjU0KSB0YT0wO1xuICAgICAgICAvLyBGb3J3YXJkIG9iamVjdFxuICAgICAgICBpZiAodGEgPT09IDI1MCkge1xuICAgICAgICAgIGEgPSBhWzFdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBcnJheSAmJiBiWzBdID09PSAoYlswXXwwKSkge1xuICAgICAgICAgIHZhciB0YiA9IGJbMF07XG4gICAgICAgICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWdcbiAgICAgICAgICBpZiAodGIgPT09IDI1NCkgdGI9MDtcbiAgICAgICAgICAvLyBGb3J3YXJkIG9iamVjdFxuICAgICAgICAgIGlmICh0YiA9PT0gMjUwKSB7XG4gICAgICAgICAgICBiID0gYlsxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGEgIT0gdGIpIHtcbiAgICAgICAgICAgIHJldHVybiAodGEgPCB0Yik/LTE6MTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0YSkge1xuICAgICAgICAgICAgY2FzZSAyNDg6IHtcblx0XHQvLyBPYmplY3Rcblx0XHR2YXIgeCA9IGNhbWxfaW50X2NvbXBhcmUoYVsyXSwgYlsyXSk7XG5cdFx0aWYgKHggIT0gMCkgcmV0dXJuIHg7XG5cdFx0YnJlYWs7XG5cdCAgICB9XG4gICAgICAgICAgICBjYXNlIDI1MToge1xuICAgICAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMjU1OiB7XG5cdFx0Ly8gSW50NjRcblx0XHR2YXIgeCA9IGNhbWxfaW50NjRfY29tcGFyZShhLCBiKTtcblx0XHRpZiAoeCAhPSAwKSByZXR1cm4geDtcblx0XHRicmVhaztcblx0ICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIChhLmxlbmd0aCA8IGIubGVuZ3RoKT8tMToxO1xuICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPiAxKSBzdGFjay5wdXNoKGEsIGIsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBNbEJ5dGVzIHx8XG4gICAgICAgICAgICAgICAgIChiIGluc3RhbmNlb2YgQXJyYXkgJiYgYlswXSA9PT0gKGJbMF18MCkpKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgIT0gXCJudW1iZXJcIiAmJiBhICYmIGEuY29tcGFyZSkge1xuICAgICAgICB2YXIgY21wID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZiAoY21wICE9IDApIHJldHVybiBjbXA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBmdW5jdGlvbmFsIHZhbHVlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2Vcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKSB7XG4gIHZhciBpID0gMCwgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpLCBiYXNlID0gMTAsIHNpZ24gPSAxO1xuICBpZiAobGVuID4gMCkge1xuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpKSB7XG4gICAgY2FzZSA0NTogaSsrOyBzaWduID0gLTE7IGJyZWFrO1xuICAgIGNhc2UgNDM6IGkrKzsgc2lnbiA9IDE7IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoaSArIDEgPCBsZW4gJiYgY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKSA9PSA0OClcbiAgICBzd2l0Y2ggKGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSArIDEpKSB7XG4gICAgY2FzZSAxMjA6IGNhc2UgODg6IGJhc2UgPSAxNjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExMTogY2FzZSA3OTogYmFzZSA9ICA4OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgIDk4OiBjYXNlIDY2OiBiYXNlID0gIDI7IGkgKz0gMjsgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gW2ksIHNpZ24sIGJhc2VdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2RpZ2l0XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2RpZ2l0KGMpIHtcbiAgaWYgKGMgPj0gNDggJiYgYyA8PSA1NykgIHJldHVybiBjIC0gNDg7XG4gIGlmIChjID49IDY1ICYmIGMgPD0gOTApICByZXR1cm4gYyAtIDU1O1xuICBpZiAoYyA+PSA5NyAmJiBjIDw9IDEyMikgcmV0dXJuIGMgLSA4NztcbiAgcmV0dXJuIC0xO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UsIGNhbWxfcGFyc2VfZGlnaXQsIGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfaW50X29mX3N0cmluZyAocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpO1xuICB2YXIgdGhyZXNob2xkID0gLTEgPj4+IDA7XG4gIHZhciBjID0gKGkgPCBsZW4pP2NhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk6MDtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGQ7XG4gIGZvciAoaSsrO2k8bGVuO2krKykge1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICByZXMgPSBiYXNlICogcmVzICsgZDtcbiAgICBpZiAocmVzID4gdGhyZXNob2xkKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBsZW4pIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAvLyBGb3IgYmFzZSBkaWZmZXJlbnQgZnJvbSAxMCwgd2UgZXhwZWN0IGFuIHVuc2lnbmVkIHJlcHJlc2VudGF0aW9uLFxuICAvLyBoZW5jZSBhbnkgdmFsdWUgb2YgJ3JlcycgKGxlc3MgdGhhbiAndGhyZXNob2xkJykgaXMgYWNjZXB0YWJsZS5cbiAgLy8gQnV0IHdlIGhhdmUgdG8gY29udmVydCB0aGUgcmVzdWx0IGJhY2sgdG8gYSBzaWduZWQgaW50ZWdlci5cbiAgcmVzID0gc2lnbiAqIHJlcztcbiAgaWYgKChiYXNlID09IDEwKSAmJiAoKHJlcyB8IDApICE9IHJlcykpXG4gICAgLyogU2lnbmVkIHJlcHJlc2VudGF0aW9uIGV4cGVjdGVkLCBhbGxvdyAtMl4obmJpdHMtMSkgdG8gMl4obmJpdHMtMSkgLSAxICovXG4gICAgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHJldHVybiByZXMgfCAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2Zsb2F0X29mX3N0cmluZyhzKSB7XG4gIHZhciByZXM7XG4gIHMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIChzKTtcbiAgcmVzID0gK3M7XG4gIGlmICgocy5sZW5ndGggPiAwKSAmJiAocmVzID09PSByZXMpKSByZXR1cm4gcmVzO1xuICBzID0gcy5yZXBsYWNlKC9fL2csXCJcIik7XG4gIHJlcyA9ICtzO1xuICBpZiAoKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHx8IC9eWystXT9uYW4kL2kudGVzdChzKSkgcmV0dXJuIHJlcztcbiAgdmFyIG0gPSAvXiAqKFsrLV0/KTB4KFswLTlhLWZdKylcXC4/KFswLTlhLWZdKilwKFsrLV0/WzAtOV0rKS9pLmV4ZWMocyk7XG4vLyAgICAgICAgICAgIDEgICAgICAgIDIgICAgICAgICAgICAgMyAgICAgICAgICAgNFxuICBpZihtKXtcbiAgICB2YXIgbTMgPSBtWzNdLnJlcGxhY2UoLzArJC8sJycpO1xuICAgIHZhciBtYW50aXNzYSA9IHBhcnNlSW50KG1bMV0gKyBtWzJdICsgbTMsIDE2KTtcbiAgICB2YXIgZXhwb25lbnQgPSAobVs0XXwwKSAtIDQqbTMubGVuZ3RoO1xuICAgIHJlcyA9IG1hbnRpc3NhICogTWF0aC5wb3coMiwgZXhwb25lbnQpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYoL15cXCs/aW5mKGluaXR5KT8kL2kudGVzdChzKSkgcmV0dXJuIEluZmluaXR5O1xuICBpZigvXi1pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gLUluZmluaXR5O1xuICBjYW1sX2ZhaWx3aXRoKFwiZmxvYXRfb2Zfc3RyaW5nXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX3ByaW50YWJsZSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2lzX3ByaW50YWJsZShjKSB7IHJldHVybiArKGMgPiAzMSAmJiBjIDwgMTI3KTsgfVxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9mb3JtYXRcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9wYXJzZV9mb3JtYXQgKGZtdCkge1xuICBmbXQgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGZtdCk7XG4gIHZhciBsZW4gPSBmbXQubGVuZ3RoO1xuICBpZiAobGVuID4gMzEpIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImZvcm1hdF9pbnQ6IGZvcm1hdCB0b28gbG9uZ1wiKTtcbiAgdmFyIGYgPVxuICAgIHsganVzdGlmeTonKycsIHNpZ25zdHlsZTonLScsIGZpbGxlcjonICcsIGFsdGVybmF0ZTpmYWxzZSxcbiAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgc2lnbjoxLCBwcmVjOi0xLCBjb252OidmJyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGMgPSBmbXQuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgIGNhc2UgJy0nOlxuICAgICAgZi5qdXN0aWZ5ID0gJy0nOyBicmVhaztcbiAgICBjYXNlICcrJzogY2FzZSAnICc6XG4gICAgICBmLnNpZ25zdHlsZSA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJzAnOlxuICAgICAgZi5maWxsZXIgPSAnMCc7IGJyZWFrO1xuICAgIGNhc2UgJyMnOlxuICAgICAgZi5hbHRlcm5hdGUgPSB0cnVlOyBicmVhaztcbiAgICBjYXNlICcxJzogY2FzZSAnMic6IGNhc2UgJzMnOiBjYXNlICc0JzogY2FzZSAnNSc6XG4gICAgY2FzZSAnNic6IGNhc2UgJzcnOiBjYXNlICc4JzogY2FzZSAnOSc6XG4gICAgICBmLndpZHRoID0gMDtcbiAgICAgIHdoaWxlIChjPWZtdC5jaGFyQ29kZUF0KGkpIC0gNDgsIGMgPj0gMCAmJiBjIDw9IDkpIHtcbiAgICAgICAgZi53aWR0aCA9IGYud2lkdGggKiAxMCArIGM7IGkrK1xuICAgICAgfVxuICAgICAgaS0tO1xuICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfbmV3X3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCByYXdidWZmZXIpIHtcbiAgaWYgKGYudXBwZXJjYXNlKSByYXdidWZmZXIgPSByYXdidWZmZXIudG9VcHBlckNhc2UoKTtcbiAgdmFyIGxlbiA9IHJhd2J1ZmZlci5sZW5ndGg7XG4gIC8qIEFkanVzdCBsZW4gdG8gcmVmbGVjdCBhZGRpdGlvbmFsIGNoYXJzIChzaWduLCBldGMpICovXG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgKGYuc2lnbiA8IDAgfHwgZi5zaWduc3R5bGUgIT0gJy0nKSkgbGVuKys7XG4gIGlmIChmLmFsdGVybmF0ZSkge1xuICAgIGlmIChmLmJhc2UgPT0gOCkgbGVuICs9IDE7XG4gICAgaWYgKGYuYmFzZSA9PSAxNikgbGVuICs9IDI7XG4gIH1cbiAgLyogRG8gdGhlIGZvcm1hdHRpbmcgKi9cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJysnICYmIGYuZmlsbGVyID09ICcgJylcbiAgICBmb3IgKHZhciBpID0gbGVuOyBpIDwgZi53aWR0aDsgaSsrKSBidWZmZXIgKz0gJyAnO1xuICBpZiAoZi5zaWduZWRjb252KSB7XG4gICAgaWYgKGYuc2lnbiA8IDApIGJ1ZmZlciArPSAnLSc7XG4gICAgZWxzZSBpZiAoZi5zaWduc3R5bGUgIT0gJy0nKSBidWZmZXIgKz0gZi5zaWduc3R5bGU7XG4gIH1cbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSA4KSBidWZmZXIgKz0gJzAnO1xuICBpZiAoZi5hbHRlcm5hdGUgJiYgZi5iYXNlID09IDE2KSBidWZmZXIgKz0gXCIweFwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnMCcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcwJztcbiAgYnVmZmVyICs9IHJhd2J1ZmZlcjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnLScpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgcmV0dXJuIGNhbWxfbmV3X3N0cmluZyAoYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfaW50IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZywgY2FtbF9zdHJfcmVwZWF0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX25ld19zdHJpbmcoXCJcIitpKTtcbiAgdmFyIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICBpZiAoaSA8IDApIHsgaWYgKGYuc2lnbmVkY29udikgeyBmLnNpZ24gPSAtMTsgaSA9IC1pOyB9IGVsc2UgaSA+Pj49IDA7IH1cbiAgdmFyIHMgPSBpLnRvU3RyaW5nKGYuYmFzZSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gcy5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBzID0gY2FtbF9zdHJfcmVwZWF0IChuLCAnMCcpICsgcztcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIHZhciBzLCBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgdmFyIHByZWMgPSAoZi5wcmVjIDwgMCk/NjpmLnByZWM7XG4gIGlmICh4IDwgMCB8fCAoeCA9PSAwICYmIDEveCA9PSAtSW5maW5pdHkpKSB7IGYuc2lnbiA9IC0xOyB4ID0gLXg7IH1cbiAgaWYgKGlzTmFOKHgpKSB7IHMgPSBcIm5hblwiOyBmLmZpbGxlciA9ICcgJzsgfVxuICBlbHNlIGlmICghaXNGaW5pdGUoeCkpIHsgcyA9IFwiaW5mXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2VcbiAgICBzd2l0Y2ggKGYuY29udikge1xuICAgIGNhc2UgJ2UnOlxuICAgICAgdmFyIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyk7XG4gICAgICAvLyBleHBvbmVudCBzaG91bGQgYmUgYXQgbGVhc3QgdHdvIGRpZ2l0c1xuICAgICAgdmFyIGkgPSBzLmxlbmd0aDtcbiAgICAgIGlmIChzLmNoYXJBdChpIC0gMykgPT0gJ2UnKVxuICAgICAgICBzID0gcy5zbGljZSAoMCwgaSAtIDEpICsgJzAnICsgcy5zbGljZSAoaSAtIDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZic6XG4gICAgICBzID0geC50b0ZpeGVkKHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy8vLy8vLy8vLy8vLyBIYXNodGJsXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfdW5pdl9wYXJhbSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF91bml2X3BhcmFtIChjb3VudCwgbGltaXQsIG9iaikge1xuICB2YXIgaGFzaF9hY2N1ID0gMDtcbiAgZnVuY3Rpb24gaGFzaF9hdXggKG9iaikge1xuICAgIGxpbWl0IC0tO1xuICAgIGlmIChjb3VudCA8IDAgfHwgbGltaXQgPCAwKSByZXR1cm47XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5ICYmIG9ialswXSA9PT0gKG9ialswXXwwKSkge1xuICAgICAgc3dpdGNoIChvYmpbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgY291bnQgLS07XG4gICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9ialsyXSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUwOlxuICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgIGxpbWl0Kys7IGhhc2hfYXV4KG9iaik7IGJyZWFrO1xuICAgICAgY2FzZSAyNTU6XG4gICAgICAgIC8vIEludDY0XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBvYmpbMV0gKyAob2JqWzJdIDw8IDI0KSkgfCAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50IC0tO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBvYmpbMF0pIHwgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IG9iai5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSBoYXNoX2F1eCAob2JqW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgc3dpdGNoIChvYmoudCAmIDYpIHtcbiAgICAgIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhvYmopO1xuICAgICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLmMsIGwgPSBvYmoubCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgICAgICBmb3IgKHZhciBhID0gb2JqLmMsIGwgPSBvYmoubCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYVtpXSkgfCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqID09PSAob2JqfDApKSB7XG4gICAgICAvLyBJbnRlZ2VyXG4gICAgICBjb3VudCAtLTtcbiAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iaikgfCAwO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSArb2JqKSB7XG4gICAgICAvLyBGbG9hdFxuICAgICAgY291bnQtLTtcbiAgICAgIHZhciBwID0gY2FtbF9pbnQ2NF90b19ieXRlcyAoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IChvYmopKTtcbiAgICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IGktLSkgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgcFtpXSkgfCAwO1xuICAgIH0gZWxzZSBpZihvYmogJiYgb2JqLmhhc2ggJiYgdHlwZW9mIG9iai5oYXNoID09PSBcImZ1bmN0aW9uXCIpIHtcblx0Ly8gQ3VzdG9tXG5cdGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiA2NTU5OSArIG9iai5oYXNoKCkpIHwgMDtcbiAgICB9XG4gIH1cbiAgaGFzaF9hdXggKG9iaik7XG4gIHJldHVybiBoYXNoX2FjY3UgJiAweDNGRkZGRkZGO1xufVxuXG4vL2Z1bmN0aW9uIFJPVEwzMih4LG4pIHsgcmV0dXJuICgoeCA8PCBuKSB8ICh4ID4+PiAoMzItbikpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ludChoLGQpIHtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4Y2M5ZTJkNTF8MCk7XG4gIGQgPSAoKGQgPDwgMTUpIHwgKGQgPj4+ICgzMi0xNSkpKTsgLy8gUk9UTDMyKGQsIDE1KTtcbiAgZCA9IGNhbWxfbXVsKGQsIDB4MWI4NzM1OTMpO1xuICBoIF49IGQ7XG4gIGggPSAoKGggPDwgMTMpIHwgKGggPj4+ICgzMi0xMykpKTsgICAvL1JPVEwzMihoLCAxMyk7XG4gIHJldHVybiAoKChoICsgKGggPDwgMikpfDApICsgKDB4ZTY1NDZiNjR8MCkpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfbXVsXG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpIHtcbiAgaCBePSBoID4+PiAxNjtcbiAgaCA9IGNhbWxfbXVsIChoLCAweDg1ZWJjYTZifDApO1xuICBoIF49IGggPj4+IDEzO1xuICBoID0gY2FtbF9tdWwgKGgsIDB4YzJiMmFlMzV8MCk7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2Zsb2F0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICB2YXIgdiA9IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAodjApO1xuICB2YXIgbG8gPSB2WzFdIHwgKHZbMl0gPDwgMjQpO1xuICB2YXIgaGkgPSAodlsyXSA+Pj4gOCkgfCAodlszXSA8PCAxNik7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBsbyk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBoaSk7XG4gIHJldHVybiBoO1xufVxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9pbnQ2NFxuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgdmFyIGxvID0gdlsxXSB8ICh2WzJdIDw8IDI0KTtcbiAgdmFyIGhpID0gKHZbMl0gPj4+IDgpIHwgKHZbM10gPDwgMTYpO1xuICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgaGkgXiBsbyk7XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHIoaCwgcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGgsIGksIHc7XG4gIGZvciAoaSA9IDA7IGkgKyA0IDw9IGxlbjsgaSArPSA0KSB7XG4gICAgdyA9IHMuY2hhckNvZGVBdChpKVxuICAgICAgICB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCA4KVxuICAgICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgICAgfCAocy5jaGFyQ29kZUF0KGkrMykgPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHMuY2hhckNvZGVBdChpKzEpIDw8IDg7XG4gIGNhc2UgMTogdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzW2ldXG4gICAgICB8IChzW2krMV0gPDwgOClcbiAgICAgIHwgKHNbaSsyXSA8PCAxNilcbiAgICAgIHwgKHNbaSszXSA8PCAyNCk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICB9XG4gIHcgPSAwO1xuICBzd2l0Y2ggKGxlbiAmIDMpIHtcbiAgY2FzZSAzOiB3ICA9IHNbaSsyXSA8PCAxNjtcbiAgY2FzZSAyOiB3IHw9IHNbaSsxXSA8PCA4O1xuICBjYXNlIDE6IHcgfD0gc1tpXTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIGRlZmF1bHQ6XG4gIH1cbiAgaCBePSBsZW47XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9zdHJpbmdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsIHYpIHtcbiAgICBzd2l0Y2ggKHYudCAmIDYpIHtcbiAgICBkZWZhdWx0OlxuICAgICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzICh2KTtcbiAgICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X3N0cmluZ19zdHIoaCwgdi5jKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOiAvKiBBUlJBWSAqL1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmdfYXJyKGgsIHYuYyk7XG4gICAgfVxuICAgIHJldHVybiBoXG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoIG11dGFibGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50NjQsIGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nXG52YXIgSEFTSF9RVUVVRV9TSVpFID0gMjU2O1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICAgIHZhciBxdWV1ZSwgcmQsIHdyLCBzeiwgbnVtLCBoLCB2LCBpLCBsZW47XG4gICAgc3ogPSBsaW1pdDtcbiAgICBpZiAoc3ogPCAwIHx8IHN6ID4gSEFTSF9RVUVVRV9TSVpFKSBzeiA9IEhBU0hfUVVFVUVfU0laRTtcbiAgICBudW0gPSBjb3VudDtcbiAgICBoID0gc2VlZDtcbiAgICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgICB3aGlsZSAocmQgPCB3ciAmJiBudW0gPiAwKSB7XG4gICAgICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICAgICAgc3dpdGNoICh2WzBdKSB7XG4gICAgICAgICAgICBjYXNlIDI0ODpcbiAgICAgICAgICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdlsyXSk7XG4gICAgICAgICAgICAgICAgbnVtLS07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI1MDpcbiAgICAgICAgICAgICAgICAvLyBGb3J3YXJkXG4gICAgICAgICAgICAgICAgcXVldWVbLS1yZF0gPSB2WzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTU6XG4gICAgICAgICAgICAgICAgLy8gSW50NjRcbiAgICAgICAgICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQ2NCAoaCwgdik7XG4gICAgICAgICAgICAgICAgbnVtIC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gKCh2Lmxlbmd0aCAtIDEpIDw8IDEwKSB8IHZbMF07XG4gICAgICAgICAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHRhZyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod3IgPj0gc3opIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVt3cisrXSA9IHZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBNbEJ5dGVzKSB7XG4gICAgICAgICAgICBoID0gY2FtbF9oYXNoX21peF9zdHJpbmcoaCx2KVxuICAgICAgICAgICAgbnVtLS07XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PT0gKHZ8MCkpIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB2K3YrMSk7XG4gICAgICAgICAgICBudW0tLTtcbiAgICAgICAgfSBlbHNlIGlmICh2ID09PSArdikge1xuICAgICAgICAgICAgLy8gRmxvYXRcbiAgICAgICAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsdik7XG4gICAgICAgICAgICBudW0tLTtcbiAgICAgICAgfSBlbHNlIGlmKHYgJiYgdi5oYXNoICYmIHR5cGVvZiB2Lmhhc2ggPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgLy8gQ3VzdG9tXG5cdCAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdi5oYXNoKCkpO1xuXHR9XG4gICAgfVxuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICAgIHJldHVybiBoICYgMHgzRkZGRkZGRjtcbn1cblxuLy8vLy8vLy8vLy8vLyBTeXNcbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3RpbWUgbXV0YWJsZVxudmFyIGNhbWxfaW5pdGlhbF90aW1lID0gbmV3IERhdGUoKSAqIDAuMDAxO1xuZnVuY3Rpb24gY2FtbF9zeXNfdGltZSAoKSB7IHJldHVybiBuZXcgRGF0ZSgpICogMC4wMDEgLSBjYW1sX2luaXRpYWxfdGltZTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0X2NvbmZpZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX25ld19zdHJpbmcoXCJVbml4XCIpLCAzMiwgMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iYWNrZW5kX3R5cGUgKCkge1xuICByZXR1cm4gWzAsIGNhbWxfbmV3X3N0cmluZyhcImpzX29mX29jYW1sXCIpXTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yYW5kb21fc2VlZCBtdXRhYmxlXG4vL1ZlcnNpb246IDwgNC4wMFxuLy9UaGUgZnVuY3Rpb24gbmVlZHMgdG8gcmV0dXJuIGFuIGFycmF5IHNpbmNlIE9DYW1sIDQuMC4uLlxuZnVuY3Rpb24gY2FtbF9zeXNfcmFuZG9tX3NlZWQgKCkge1xuICB2YXIgeCA9IG5ldyBEYXRlKCleMHhmZmZmZmZmZipNYXRoLnJhbmRvbSgpO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmFuZG9tX3NlZWQgbXV0YWJsZVxuLy9WZXJzaW9uOiA+PSA0LjAwXG4vL1RoZSBmdW5jdGlvbiBuZWVkcyB0byByZXR1cm4gYW4gYXJyYXkgc2luY2UgT0NhbWwgNC4wLi4uXG5mdW5jdGlvbiBjYW1sX3N5c19yYW5kb21fc2VlZCAoKSB7XG4gIHZhciB4ID0gbmV3IERhdGUoKV4weGZmZmZmZmZmKk1hdGgucmFuZG9tKCk7XG4gIHJldHVybiBbMCx4XTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4gKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2ludF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9pbnRfc2l6ZSAoKSB7IHJldHVybiAzMjsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9tYXhfd29zaXplIGNvbnN0XG4vLyBtYXhfaW50IC8gNCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgZG9lcyBub3Qgb3ZlcmZsb3dcbi8vbGV0IG1heF9zdHJpbmdfbGVuZ3RoID0gd29yZF9zaXplIC8gOCAqIG1heF9hcnJheV9sZW5ndGggLSAxOztcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgKCkgeyByZXR1cm4gKDB4N0ZGRkZGRkYvNCkgfCAwO31cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gMTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19zeXN0ZW1fY29tbWFuZFxuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNtZC50b1N0cmluZygpO1xuICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmxvZyhjbWQpO1xuICBpZiAodHlwZW9mIHJlcXVpcmUgIT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZXhlY1N5bmMpIHtcbiAgICB0cnkge3JlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYyhjbWQpOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9zdWIgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9zdWIgKGEsIGksIGxlbikge1xuICB2YXIgYTIgPSBuZXcgQXJyYXkobGVuKzEpO1xuICBhMlswXT0wO1xuICBmb3IodmFyIGkyID0gMSwgaTE9IGkrMTsgaTIgPD0gbGVuOyBpMisrLGkxKysgKXtcbiAgICBhMltpMl09YVtpMV07XG4gIH1cbiAgcmV0dXJuIGEyO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2FwcGVuZCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2FwcGVuZChhMSwgYTIpIHtcbiAgdmFyIGwxID0gYTEubGVuZ3RoLCBsMiA9IGEyLmxlbmd0aDtcbiAgdmFyIGwgPSBsMStsMi0xXG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBhWzBdID0gMDtcbiAgdmFyIGkgPSAxLGogPSAxO1xuICBmb3IoO2k8bDE7aSsrKSBhW2ldPWExW2ldO1xuICBmb3IoO2k8bDtpKyssaisrKSBhW2ldPWEyW2pdO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9jb25jYXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9hcnJheV9jb25jYXQobCkge1xuICB2YXIgYSA9IFswXTtcbiAgd2hpbGUgKGwgIT09IDApIHtcbiAgICB2YXIgYiA9IGxbMV07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiLmxlbmd0aDsgaSsrKSBhLnB1c2goYltpXSk7XG4gICAgbCA9IGxbMl07XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYmxpdFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gQ2FtbGludGVybmFsT09cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgY29uc3RcbnZhciBjYW1sX21ldGhvZF9jYWNoZSA9IFtdO1xuZnVuY3Rpb24gY2FtbF9nZXRfcHVibGljX21ldGhvZCAob2JqLCB0YWcsIGNhY2hlaWQpIHtcbiAgdmFyIG1ldGhzID0gb2JqWzFdO1xuICB2YXIgb2ZzID0gY2FtbF9tZXRob2RfY2FjaGVbY2FjaGVpZF07XG4gIGlmIChvZnMgPT09IG51bGwpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9iYWNrdHJhY2Vfc3RhdHVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfZXhjZXB0aW9uX3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3JlY29yZF9iYWNrdHJhY2VcbmZ1bmN0aW9uIGNhbWxfcmVjb3JkX2JhY2t0cmFjZSAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UgKCkgeyByZXR1cm4gWzBdOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCgpIHsgcmV0dXJuIDAgfVxuLy9Qcm92aWRlczogY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3QgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJQcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZV9zbG90OiBpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZ2V0X2N1cnJlbnRfY2FsbHN0YWNrICgpIHsgcmV0dXJuIFswXTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzX3RvX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfZ2V0ZW52IChuYW1lKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBuID0gbmFtZS50b1N0cmluZygpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfanNfdG9fc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBjYW1sX3JhaXNlX25vdF9mb3VuZCAoKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4aXRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zeXNfZXhpdCAoY29kZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZihnLnF1aXQpIGcucXVpdChjb2RlKTtcbiAgLy9ub2RlanNcbiAgaWYoZy5wcm9jZXNzICYmIGcucHJvY2Vzcy5leGl0KVxuICAgIGcucHJvY2Vzcy5leGl0KGNvZGUpO1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJGdW5jdGlvbiAnZXhpdCcgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndiBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmdcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9zdWJcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldF9hcmd2ICgpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIG1haW4gPSBcImEub3V0XCI7XG4gIHZhciBhcmdzID0gW11cblxuICBpZihnLnByb2Nlc3NcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3ZcbiAgICAgJiYgZy5wcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICAgIHZhciBhcmd2ID0gZy5wcm9jZXNzLmFyZ3ZcbiAgICAvL25vZGVqc1xuICAgIG1haW4gPSBhcmd2WzFdO1xuICAgIGFyZ3MgPSByYXdfYXJyYXlfc3ViKGFyZ3YsMixhcmd2Lmxlbmd0aCAtIDIpO1xuICB9XG5cbiAgdmFyIHAgPSBjYW1sX2pzX3RvX3N0cmluZyhtYWluKTtcbiAgdmFyIGFyZ3MyID0gWzAsIHBdO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKylcbiAgICBhcmdzMi5wdXNoKGNhbWxfanNfdG9fc3RyaW5nKGFyZ3NbaV0pKTtcbiAgcmV0dXJuIFswLCBwLCBhcmdzMl07XG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZ1xuZnVuY3Rpb24gdW5peF9pbmV0X2FkZHJfb2Zfc3RyaW5nICgpIHtyZXR1cm4gMDt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfb29fbGFzdF9pZFxudmFyIGNhbWxfb29fbGFzdF9pZCA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfc2V0X29vX2lkIChiKSB7XG4gIGJbMl09Y2FtbF9vb19sYXN0X2lkKys7XG4gIHJldHVybiBiO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZyZXNoX29vX2lkXG4vL1JlcXVpcmVzOiBjYW1sX29vX2xhc3RfaWRcbmZ1bmN0aW9uIGNhbWxfZnJlc2hfb29faWQoKSB7XG4gIHJldHVybiBjYW1sX29vX2xhc3RfaWQrKztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIoKXtyZXR1cm4gMH1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90KCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Jzd2FwMTZcbmZ1bmN0aW9uIGNhbWxfYnN3YXAxNih4KSB7XG4gIHJldHVybiAoKCgoeCAmIDB4MDBGRikgPDwgOCkgfFxuICAgICAgICAgICAoKHggJiAweEZGMDApID4+IDgpKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Jzd2FwXG5mdW5jdGlvbiBjYW1sX2ludDMyX2Jzd2FwKHgpIHtcbiAgcmV0dXJuICgoKHggJiAweDAwMDAwMEZGKSA8PCAyNCkgfFxuICAgICAgICAgICgoeCAmIDB4MDAwMEZGMDApIDw8IDgpIHxcbiAgICAgICAgICAoKHggJiAweDAwRkYwMDAwKSA+Pj4gOCkgfFxuICAgICAgICAgICgoeCAmIDB4RkYwMDAwMDApID4+PiAyNCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9ic3dhcCh4KSB7XG4gIHJldHVybiBbXG4gICAgMjU1LFxuICAgICgoKHhbM10gJiAweDAwMDBmZjAwKSA+PiA4KSB8XG4gICAgICgoeFszXSAmIDB4MDAwMDAwZmYpIDw8IDgpIHxcbiAgICAgKCh4WzJdICYgMHgwMGZmMDAwMCkpKSxcbiAgICAoKCh4WzJdICYgMHgwMDAwZmYwMCkgPj4gOCkgfFxuICAgICAoKHhbMl0gJiAweDAwMDAwMGZmKSA8PCA4KSB8XG4gICAgICgoeFsxXSAmIDB4MDBmZjAwMDApKSksXG4gICAgKCgoeFsxXSAmIDB4MDAwMGZmMDApID4+IDgpIHxcbiAgICAgKCh4WzFdICYgMHgwMDAwMDBmZikgPDwgOCkpXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9saXN0X29mX2pzX2FycmF5KGEpe1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgaT1hLmxlbmd0aCAtIDE7IGk+PTA7IGktLSl7XG4gICAgdmFyIGUgPSBhW2ldO1xuICAgIGwgPSBbMCxlLGxdO1xuICB9XG4gIHJldHVybiBsXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xudmFyIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IDA7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3Ncbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5ncyAoYm9vbCkge1xuICBjYW1sX3J1bnRpbWVfd2FybmluZ3MgPSBib29sO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcbi8vUmVxdWlyZXM6IGNhbWxfcnVudGltZV93YXJuaW5nc1xuZnVuY3Rpb24gY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3J1bnRpbWVfd2FybmluZ3M7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcnVudGltZV92YXJpYW50XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcoXCJcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVyc1xuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3J1bnRpbWVfcGFyYW1ldGVycyhfdW5pdCkge1xuICByZXR1cm4gY2FtbF9uZXdfc3RyaW5nKFwiXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzYXR0eVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNhdHR5KF9jaGFuKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lKF9jaGFubmVsKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJTcGFjZXRpbWUgcHJvZmlsaW5nIG9ubHkgd29ya3MgZm9yIG5hdGl2ZSBjb2RlXCIpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfanNcbmZ1bmN0aW9uIGNhbWxfaXNfanMoKSB7XG4gIHJldHVybiAxO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMTQgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQW4gT0NhbWwgc3RyaW5nIGlzIGFuIG9iamVjdCB3aXRoIHRocmVlIGZpZWxkczpcbi8vIC0gdGFnICd0J1xuLy8gLSBsZW5ndGggJ2wnXG4vLyAtIGNvbnRlbnRzICdjJ1xuLy9cbi8vIFRoZSBjb250ZW50cyBvZiB0aGUgc3RyaW5nIGNhbiBiZSBlaXRoZXIgYSBKYXZhU2NyaXB0IGFycmF5IG9yXG4vLyBhIEphdmFTY3JpcHQgc3RyaW5nLiBUaGUgbGVuZ3RoIG9mIHRoaXMgc3RyaW5nIGNhbiBiZSBsZXNzIHRoYW4gdGhlXG4vLyBsZW5ndGggb2YgdGhlIE9DYW1sIHN0cmluZy4gSW4gdGhpcyBjYXNlLCByZW1haW5pbmcgYnl0ZXMgYXJlXG4vLyBhc3N1bWVkIHRvIGJlIHplcm9lcy4gQXJyYXlzIGFyZSBtdXRhYmxlIGJ1dCBjb25zdW1lcyBtb3JlIG1lbW9yeVxuLy8gdGhhbiBzdHJpbmdzLiBBIGNvbW1vbiBwYXR0ZXJuIGlzIHRvIHN0YXJ0IGZyb20gYW4gZW1wdHkgc3RyaW5nIGFuZFxuLy8gcHJvZ3Jlc3NpdmVseSBmaWxsIGl0IGZyb20gdGhlIHN0YXJ0LiBQYXJ0aWFsIHN0cmluZ3MgbWFrZXMgaXRcbi8vIHBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGVmZmljaWVudGx5LlxuLy9cbi8vIFdoZW4gY29udmVydGluZyB0byBhbmQgZnJvbSBVVEYtMTYsIHdlIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGVcbi8vIHN0cmluZyBpcyBjb21wb3NlZCBvbmx5IG9mIEFTQ0lJIGNoYXJhY3RlcnMgKGluIHdoaWNoIGNhc2UsIG5vXG4vLyBjb252ZXJzaW9uIG5lZWRzIHRvIGJlIHBlcmZvcm1lZCkgb3Igbm90LlxuLy9cbi8vIFRoZSBzdHJpbmcgdGFnIGNhbiB0aHVzIHRha2UgdGhlIGZvbGxvd2luZyB2YWx1ZXM6XG4vLyAgIGZ1bGwgc3RyaW5nICAgICBCWVRFIHwgVU5LTk9XTjogICAgICAwXG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgQVNDSUk6ICAgICAgICA5XG4vLyAgICAgICAgICAgICAgICAgICBCWVRFIHwgTk9UX0FTQ0lJOiAgICA4XG4vLyAgIHN0cmluZyBwcmVmaXggICBQQVJUSUFMOiAgICAgICAgICAgICAyXG4vLyAgIGFycmF5ICAgICAgICAgICBBUlJBWTogICAgICAgICAgICAgICA0XG4vL1xuLy8gT25lIGNhbiB1c2UgYml0IG1hc2tpbmcgdG8gZGlzY3JpbWluYXRlIHRoZXNlIGRpZmZlcmVudCBjYXNlczpcbi8vICAga25vd25fZW5jb2RpbmcoeCkgPSB4Jjhcbi8vICAgaXNfYXNjaWkoeCkgPSAgICAgICB4JjFcbi8vICAga2luZCh4KSA9ICAgICAgICAgICB4JjZcblxuLy9Qcm92aWRlczogY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX3N0cl9yZXBlYXQobiwgcykge1xuICBpZiAocy5yZXBlYXQpIHJldHVybiBzLnJlcGVhdChuKTsgLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgZm9yKDs7KSB7XG4gICAgaWYgKG4gJiAxKSByICs9IHM7XG4gICAgbiA+Pj0gMTtcbiAgICBpZiAobiA9PSAwKSByZXR1cm4gcjtcbiAgICBzICs9IHM7XG4gICAgbCsrO1xuICAgIGlmIChsID09IDkpIHtcbiAgICAgIHMuc2xpY2UoMCwxKTsgLy8gZmxhdHRlbiB0aGUgc3RyaW5nXG4gICAgICAvLyB0aGVuLCB0aGUgZmxhdHRlbmluZyBvZiB0aGUgd2hvbGUgc3RyaW5nIHdpbGwgYmUgZmFzdGVyLFxuICAgICAgLy8gYXMgaXQgd2lsbCBiZSBjb21wb3NlZCBvZiBsYXJnZXIgcGllY2VzXG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiBjYW1sX3N1YmFycmF5X3RvX3N0cmluZyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIHJhd19hcnJheV9zdWIoYSxpLCBNYXRoLm1pbihsZW4sIDEwMjQpKSk7XG4gIHJldHVybiBzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0Zjhfb2ZfdXRmMTZcbmZ1bmN0aW9uIGNhbWxfdXRmOF9vZl91dGYxNihzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gYiwgYywgZCwgaSA9IDAsIGwgPSBzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMgPSBzLmNoYXJDb2RlQXQoaikpIDwgMHg4MDsgaisrKTtcbiAgICAgIGlmIChqIC0gaSA+IDUxMikgeyB0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjsgYiArPSBzLnNsaWNlKGksIGopIH1cbiAgICAgIGVsc2UgdCArPSBzLnNsaWNlKGksIGopO1xuICAgICAgaWYgKGogPT0gbCkgYnJlYWs7XG4gICAgICBpID0gajtcbiAgICB9XG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4YzAgfCAoYyA+PiA2KSk7XG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZGZmZikge1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCAoYyA+PiAxMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPj0gMHhkYmZmIHx8IGkgKyAxID09IGwgfHxcbiAgICAgICAgICAgICAgIChkID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgZCA+IDB4ZGZmZikge1xuICAgICAgLy8gVW5tYXRjaGVkIHN1cnJvZ2F0ZSBwYWlyLCByZXBsYWNlZCBieSBcXHVmZmZkIChyZXBsYWNlbWVudCBjaGFyYWN0ZXIpXG4gICAgICB0ICs9IFwiXFx4ZWZcXHhiZlxceGJkXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkrKztcbiAgICAgIGMgPSAoYyA8PCAxMCkgKyBkIC0gMHgzNWZkYzAwO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAgfCAoYyA+PiAxOCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiAxMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKChjID4+IDYpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8IChjICYgMHgzZikpO1xuICAgIH1cbiAgICBpZiAodC5sZW5ndGggPiAxMDI0KSB7dC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7fVxuICB9XG4gIHJldHVybiBiK3Q7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24gY2FtbF91dGYxNl9vZl91dGY4KHMpIHtcbiAgZm9yICh2YXIgYiA9IFwiXCIsIHQgPSBcIlwiLCBjLCBjMSwgYzIsIHYsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjMSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoYzEgPCAweDgwKSB7XG4gICAgICBmb3IgKHZhciBqID0gaSArIDE7IChqIDwgbCkgJiYgKGMxID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIHYgPSAxO1xuICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICBjID0gYzIgKyAoYzEgPDwgNik7XG4gICAgICBpZiAoYzEgPCAweGUwKSB7XG4gICAgICAgIHYgPSBjIC0gMHgzMDgwO1xuICAgICAgICBpZiAodiA8IDB4ODApIHYgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IDI7XG4gICAgICAgIGlmICgoKytpIDwgbCkgJiYgKCgoYzIgPSBzLmNoYXJDb2RlQXQoaSkpICYgLTY0KSA9PSAxMjgpKSB7XG4gICAgICAgICAgYyA9IGMyICsgKGMgPDwgNik7XG4gICAgICAgICAgaWYgKGMxIDwgMHhmMCkge1xuICAgICAgICAgICAgdiA9IGMgLSAweGUyMDgwO1xuICAgICAgICAgICAgaWYgKCh2IDwgMHg4MDApIHx8ICgodiA+PSAweGQ3ZmYpICYmICh2IDwgMHhlMDAwKSkpIHYgPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYgPSAzO1xuICAgICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgICAgKGMxIDwgMHhmNSkpIHtcbiAgICAgICAgICAgICAgICB2ID0gYzIgLSAweDNjODIwODAgKyAoYyA8PCA2KTtcbiAgICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodiA8IDQpIHsgLy8gSW52YWxpZCBzZXF1ZW5jZVxuICAgICAgaSAtPSB2O1xuICAgICAgdCArPSBcIlxcdWZmZmRcIjtcbiAgICB9IGVsc2UgaWYgKHYgPiAweGZmZmYpXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkN2MwICsgKHYgPj4gMTApLCAweGRjMDAgKyAodiAmIDB4M0ZGKSlcbiAgICBlbHNlXG4gICAgICB0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2FzY2lpXG5mdW5jdGlvbiBjYW1sX2lzX2FzY2lpIChzKSB7XG4gIC8vIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2V0cyBiZXR0ZXIgYXQgYXJvdW5kIHRoaXMgcG9pbnQgZm9yIGFsbCBicm93c2Vyc1xuICBpZiAocy5sZW5ndGggPCAyNCkge1xuICAgIC8vIFNwaWRlcm1vbmtleSBnZXRzIG11Y2ggc2xvd2VyIHdoZW4gcy5sZW5ndGggPj0gMjQgKG9uIDY0IGJpdCBhcmNocylcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIGlmIChzLmNoYXJDb2RlQXQoaSkgPiAxMjcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICEvW15cXHgwMC1cXHg3Zl0vLnRlc3Qocyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX2lzX2FzY2lpLCBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgc3dpdGNoIChzLnQpIHtcbiAgY2FzZSA5OiAvKkJZVEVTIHwgQVNDSUkqL1xuICAgIHJldHVybiBzLmM7XG4gIGRlZmF1bHQ6XG4gICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgY2FzZSAwOiAvKkJZVEVTIHwgVU5LT1dOKi9cbiAgICBpZiAoY2FtbF9pc19hc2NpaShzLmMpKSB7XG4gICAgICBzLnQgPSA5OyAvKkJZVEVTIHwgQVNDSUkqL1xuICAgICAgcmV0dXJuIHMuYztcbiAgICB9XG4gICAgcy50ID0gODsgLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gIGNhc2UgODogLypCWVRFUyB8IE5PVF9BU0NJSSovXG4gICAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzLmMpO1xuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSkge1xuICBzd2l0Y2ggKHMudCAmIDYpIHtcbiAgZGVmYXVsdDogLyogUEFSVElBTCAqL1xuICAgIGlmIChpID49IHMuYy5sZW5ndGgpIHJldHVybiAwO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgcmV0dXJuIHMuYy5jaGFyQ29kZUF0KGkpO1xuICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgcmV0dXJuIHMuY1tpXVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgc3dpdGNoIChzLnQgJiA2KSB7XG4gIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICBpZiAoaSA+PSBzLmMubGVuZ3RoKSByZXR1cm4gMDtcbiAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgIHJldHVybiBzLmMuY2hhckNvZGVBdChpKTtcbiAgY2FzZSA0OiAvKiBBUlJBWSAqL1xuICAgIHJldHVybiBzLmNbaV1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkgKHMpO1xuICB9XG4gIHMuY1tpXSA9IGM7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0KHMsaSxjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IgKCkge1xuICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQzMihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sICsgMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSksXG4gICAgICBiMiA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKSxcbiAgICAgIGIzID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMyk7XG4gIHJldHVybiAoYjQgPDwgMjQgfCBiMyA8PCAxNiB8IGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dldDY0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBjYW1sX3N0cmluZ19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0NjQocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCArIDcpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBhID0gbmV3IEFycmF5KDgpO1xuICBmb3IodmFyIGogPSAwOyBqIDwgODsgaisrKXtcbiAgICBhWzcgLSBqXSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0IChzLCBpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0MTYocyxpLGkxNil7XG4gIGlmIChpID4+PiAwID49IHMubCArIDEpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDAsIGIxKTtcbiAgY2FtbF9zdHJpbmdfdW5zYWZlX3NldCAocywgaSArIDEsIGIyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICAgIHJldHVybiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19ib3VuZF9lcnJvciwgY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQzMihzLGksaTMyKXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sICsgMykgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGI0ID0gMHhGRiAmIGkzMiA+PiAyNCxcbiAgICAgIGIzID0gMHhGRiAmIGkzMiA+PiAxNixcbiAgICAgIGIyID0gMHhGRiAmIGkzMiA+PiA4LFxuICAgICAgYjEgPSAweEZGICYgaTMyO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMSwgYjIpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMiwgYjMpO1xuICBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19zZXQzMlxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0MzIocyxpLGkzMil7XG4gICAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgKyA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGkgKyA3IC0gaiwgYVtqXSk7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDY0KHMsaSxpNjQpe1xuICAgIHJldHVybiBjYW1sX2J5dGVzX3NldDY0KHMsaSxpNjQpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQgKHMsIGksIGMpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF90b19qc19zdHJpbmdcbmZ1bmN0aW9uIE1sQnl0ZXMgKHRhZywgY29udGVudHMsIGxlbmd0aCkge1xuICB0aGlzLnQ9dGFnOyB0aGlzLmM9Y29udGVudHM7IHRoaXMubD1sZW5ndGg7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7cmV0dXJuIGNhbWxfdG9fanNfc3RyaW5nKHRoaXMpfTtcblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJfcmVwZWF0LCBjYW1sX3N1YmFycmF5X3RvX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19zdHJpbmcgKHMuYywgMCwgcy5jLmxlbmd0aCk7XG4gIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5IChzKSB7XG4gIC8qIEFzc3VtZXMgbm90IEFSUkFZICovXG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KHMubCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEgPSBuZXcgQXJyYXkocy5sKTtcbiAgfVxuICB2YXIgYiA9IHMuYywgbCA9IGIubGVuZ3RoLCBpID0gMDtcbiAgZm9yICg7IGkgPCBsOyBpKyspIGFbaV0gPSBiLmNoYXJDb2RlQXQoaSk7XG4gIGZvciAobCA9IHMubDsgaSA8IGw7IGkrKykgYVtpXSA9IDA7XG4gIHMuYyA9IGE7XG4gIHMudCA9IDQ7IC8qIEFSUkFZICovXG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX3N0cmluZyAocykge1xuICBpZiAocy50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9qc2J5dGVzX29mX3N0cmluZyAocykge1xuICBpZiAoKHMudCAmIDYpICE9IDAgLyogQllURVMgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gIHJldHVybiBzLmM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2lzX2FzY2lpLCBjYW1sX3V0Zjhfb2ZfdXRmMTYsIE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghY2FtbF9pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogTWxCeXRlcyxjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYgKGxlbiA8IDApIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfc3RyaW5nIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbmV3X3N0cmluZyAocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9hcnJheVxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHsgcmV0dXJuIG5ldyBNbEJ5dGVzKDQsYSxhLmxlbmd0aCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19lcXVhbChzMSwgczIpIHtcbiAgaWYoczEgPT09IHMyKSByZXR1cm4gMTtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jID09IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbm90ZXF1YWwoczEsIHMyKSB7IHJldHVybiAxLWNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMik7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDw9IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19sZXNzZXF1YWwgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzZXF1YWwoczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3N0aGFuKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc3RoYW4gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19sZXNzdGhhbihzMSwgczIpIHtcbiAgKHMxLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMxKTtcbiAgKHMyLnQgJiA2KSAmJiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMyKTtcbiAgcmV0dXJuIChzMS5jIDwgczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVyZXF1YWxcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc2VxdWFsKHMyLHMxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3NlcXVhbFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVyZXF1YWwoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3NlcXVhbChzMixzMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuXG5mdW5jdGlvbiBjYW1sX2J5dGVzX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzdGhhbihzMiwgczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyX3JlcGVhdCwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X3N0cmluZ190b19hcnJheShzKTtcbiAgICAgIGZvciAobCArPSBpOyBpIDwgbDsgaSsrKSBzLmNbaV0gPSBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9maWxsX2J5dGVzXG52YXIgY2FtbF9maWxsX3N0cmluZyA9IGNhbWxfZmlsbF9ieXRlc1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nLCBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JsaXRfYnl0ZXMoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICBpZiAobGVuID09IDApIHJldHVybiAwO1xuICBpZiAoKGkyID09IDApICYmXG4gICAgICAobGVuID49IHMyLmwgfHwgKHMyLnQgPT0gMiAvKiBQQVJUSUFMICovICYmIGxlbiA+PSBzMi5jLmxlbmd0aCkpKSB7XG4gICAgczIuYyA9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgICAgICAgIGNhbWxfc3ViYXJyYXlfdG9fc3RyaW5nKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgICAgICAgIChpMSA9PSAwICYmIHMxLmMubGVuZ3RoID09IGxlbik/czEuYzpzMS5jLnN1YnN0cihpMSwgbGVuKTtcbiAgICBzMi50ID0gKHMyLmMubGVuZ3RoID09IHMyLmwpPzAgLyogQllURVMgfCBVTktPV04gKi8gOjI7IC8qIFBBUlRJQUwgKi9cbiAgfSBlbHNlIGlmIChzMi50ID09IDIgLyogUEFSVElBTCAqLyAmJiBpMiA9PSBzMi5jLmxlbmd0aCkge1xuICAgIHMyLmMgKz0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICAgICAgICAgY2FtbF9zdWJhcnJheV90b19zdHJpbmcoczEuYywgaTEsIGxlbik6XG4gICAgICAgICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYXJyYXkoczIpO1xuICAgIHZhciBjMSA9IHMxLmMsIGMyID0gczIuYztcbiAgICBpZiAoczEudCA9PSA0IC8qIEFSUkFZICovKSB7XG4gICAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gYzEgW2kxICsgaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgdmFyIGwgPSBNYXRoLm1pbiAobGVuLCBjMS5sZW5ndGggLSBpMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykgYzIgW2kyICsgaV0gPSBjMS5jaGFyQ29kZUF0KGkxICsgaSk7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoczEsIGkxLCBzMiwgaTIsIGxlbikge1xuICAvLyBUT0RPOiBzMSAtPiBzdHJpbmcgdG8gYnl0ZXNcbiAgcmV0dXJuIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgeyByZXR1cm4gcy5sIH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9ieXRlc19sZW5ndGggY29uc3RcbmZ1bmN0aW9uIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHMpIHsgcmV0dXJuIHMubCB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSB7IHJldHVybiBzfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX3N0cmluZyBjb25zdFxuZnVuY3Rpb24gY2FtbF9ieXRlc19vZl9zdHJpbmcocykgeyByZXR1cm4gc31cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mZnNldFxudmFyIGNhbWxfaW50NjRfb2Zmc2V0ID0gTWF0aC5wb3coMiwgLTI0KTtcblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF91Y29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF91Y29tcGFyZSh4LHkpIHtcbiAgaWYgKHhbM10gPiB5WzNdKSByZXR1cm4gMTtcbiAgaWYgKHhbM10gPCB5WzNdKSByZXR1cm4gLTE7XG4gIGlmICh4WzJdID4geVsyXSkgcmV0dXJuIDE7XG4gIGlmICh4WzJdIDwgeVsyXSkgcmV0dXJuIC0xO1xuICBpZiAoeFsxXSA+IHlbMV0pIHJldHVybiAxO1xuICBpZiAoeFsxXSA8IHlbMV0pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3Vjb21wYXJlXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIGNhbWxfaW50NjRfdWNvbXBhcmUoeCx5KSA8IDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jb21wYXJlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2NvbXBhcmUoeCx5KSB7XG4gIHZhciB4MyA9IHhbM10gPDwgMTY7XG4gIHZhciB5MyA9IHlbM10gPDwgMTY7XG4gIGlmICh4MyA+IHkzKSByZXR1cm4gMTtcbiAgaWYgKHgzIDwgeTMpIHJldHVybiAtMTtcbiAgaWYgKHhbMl0gPiB5WzJdKSByZXR1cm4gMTtcbiAgaWYgKHhbMl0gPCB5WzJdKSByZXR1cm4gLTE7XG4gIGlmICh4WzFdID4geVsxXSkgcmV0dXJuIDE7XG4gIGlmICh4WzFdIDwgeVsxXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9uZWcgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbmVnICh4KSB7XG4gIHZhciB5MSA9IC0geFsxXTtcbiAgdmFyIHkyID0gLSB4WzJdICsgKHkxID4+IDI0KTtcbiAgdmFyIHkzID0gLSB4WzNdICsgKHkyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHkxICYgMHhmZmZmZmYsIHkyICYgMHhmZmZmZmYsIHkzICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hZGQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYWRkICh4LCB5KSB7XG4gIHZhciB6MSA9IHhbMV0gKyB5WzFdO1xuICB2YXIgejIgPSB4WzJdICsgeVsyXSArICh6MSA+PiAyNCk7XG4gIHZhciB6MyA9IHhbM10gKyB5WzNdICsgKHoyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zdWIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc3ViICh4LCB5KSB7XG4gIHZhciB6MSA9IHhbMV0gLSB5WzFdO1xuICB2YXIgejIgPSB4WzJdIC0geVsyXSArICh6MSA+PiAyNCk7XG4gIHZhciB6MyA9IHhbM10gLSB5WzNdICsgKHoyID4+IDI0KTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHtcbiAgdmFyIHoxID0geFsxXSAqIHlbMV07XG4gIHZhciB6MiA9ICgoejEgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHhbMl0gKiB5WzFdICsgeFsxXSAqIHlbMl07XG4gIHZhciB6MyA9ICgoejIgKiBjYW1sX2ludDY0X29mZnNldCkgfCAwKSArIHhbM10gKiB5WzFdICsgeFsyXSAqIHlbMl0gKyB4WzFdICogeVszXTtcbiAgcmV0dXJuIFsyNTUsIHoxICYgMHhmZmZmZmYsIHoyICYgMHhmZmZmZmYsIHozICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkge1xuICByZXR1cm4gKHhbM118eFsyXXx4WzFdKSA9PSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpIHtcbiAgcmV0dXJuICh4WzNdIDw8IDE2KSA8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbWluX2ludCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19taW5faW50KHgpIHtcbiAgcmV0dXJuIHhbM10gPT0gMHg4MDAwICYmICh4WzFdfHhbMl0pID09IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaXNfbWludXNfb25lIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX21pbnVzX29uZSh4KSB7XG4gIHJldHVybiB4WzNdID09IDB4ZmZmZiAmJiAoeFsxXSZ4WzJdKSA9PSAweGZmZmZmZjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9hbmQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYW5kICh4LCB5KSB7XG4gIHJldHVybiBbMjU1LCB4WzFdJnlbMV0sIHhbMl0meVsyXSwgeFszXSZ5WzNdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXXx5WzFdLCB4WzJdfHlbMl0sIHhbM118eVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfeG9yIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3hvciAoeCwgeSkge1xuICByZXR1cm4gWzI1NSwgeFsxXV55WzFdLCB4WzJdXnlbMl0sIHhbM11eeVszXV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfbGVmdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0ICh4LCBzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB4O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKHhbMV0gPDwgcykgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFsyXSA8PCBzKSB8ICh4WzFdID4+ICgyNCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFszXSA8PCBzKSB8ICh4WzJdID4+ICgyNCAtIHMpKSkgJiAweGZmZmZdO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LCAwLFxuICAgICAgICAgICAgKHhbMV0gPDwgKHMgLSAyNCkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPDwgKHMgLSAyNCkpIHwgKHhbMV0gPj4gKDQ4IC0gcykpKSAmIDB4ZmZmZl07XG4gIHJldHVybiBbMjU1LCAwLCAwLCAoeFsxXSA8PCAocyAtIDQ4KSkgJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0X3Vuc2lnbmVkICh4LCBzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB4O1xuICBpZiAocyA8IDI0KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzFdID4+IHMpIHwgKHhbMl0gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKCh4WzJdID4+IHMpIHwgKHhbM10gPDwgKDI0IC0gcykpKSAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKHhbM10gPj4gcyldO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzJdID4+IChzIC0gMjQpKSB8ICh4WzNdIDw8ICg0OCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICh4WzNdID4+IChzIC0gMjQpKSxcbiAgICAgICAgICAgIDBdO1xuICByZXR1cm4gWzI1NSwgKHhbM10gPj4gKHMgLSA0OCkpLCAwLCAwXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCAoeCwgcykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4geDtcbiAgdmFyIGggPSAoeFszXSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgICAoKHhbMV0gPj4gcykgfCAoeFsyXSA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbMl0gPj4gcykgfCAoaCA8PCAoMjQgLSBzKSkpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICAoKHhbM10gPDwgMTYpID4+IHMpID4+PiAxNl07XG4gIHZhciBzaWduID0gKHhbM10gPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBbMjU1LFxuICAgICAgICAgICAgKCh4WzJdID4+IChzIC0gMjQpKSB8ICh4WzNdIDw8ICg0OCAtIHMpKSkgJiAweGZmZmZmZixcbiAgICAgICAgICAgICgoeFszXSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYpICYgMHhmZmZmZmYsXG4gICAgICAgICAgICBzaWduICYgMHhmZmZmXTtcbiAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgKCh4WzNdIDw8IDE2KSA+PiAocyAtIDMyKSkgJiAweGZmZmZmZixcbiAgICAgICAgICBzaWduICYgMHhmZmZmZmYsIHNpZ24gJiAweGZmZmZdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xzbDEgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbHNsMSAoeCkge1xuICB4WzNdID0gKHhbM10gPDwgMSkgfCAoeFsyXSA+PiAyMyk7XG4gIHhbMl0gPSAoKHhbMl0gPDwgMSkgfCAoeFsxXSA+PiAyMykpICYgMHhmZmZmZmY7XG4gIHhbMV0gPSAoeFsxXSA8PCAxKSAmIDB4ZmZmZmZmO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2xzcjEgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfbHNyMSAoeCkge1xuICB4WzFdID0gKCh4WzFdID4+PiAxKSB8ICh4WzJdIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgeFsyXSA9ICgoeFsyXSA+Pj4gMSkgfCAoeFszXSA8PCAyMykpICYgMHhmZmZmZmY7XG4gIHhbM10gPSB4WzNdID4+PiAxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3VkaXZtb2QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdWNvbXBhcmUsIGNhbWxfaW50NjRfbHNsMSwgY2FtbF9pbnQ2NF9sc3IxXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3N1YlxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VkaXZtb2QgKHgsIHkpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gY2FtbF9vYmpfZHVwKHgpO1xuICB2YXIgZGl2aXNvciA9IGNhbWxfb2JqX2R1cCh5KTtcbiAgdmFyIHF1b3RpZW50ID0gWzI1NSwgMCwgMCwgMF07XG4gIHdoaWxlIChjYW1sX2ludDY0X3Vjb21wYXJlIChtb2R1bHVzLCBkaXZpc29yKSA+IDApIHtcbiAgICBvZmZzZXQrKztcbiAgICBjYW1sX2ludDY0X2xzbDEgKGRpdmlzb3IpO1xuICB9XG4gIHdoaWxlIChvZmZzZXQgPj0gMCkge1xuICAgIG9mZnNldCAtLTtcbiAgICBjYW1sX2ludDY0X2xzbDEgKHF1b3RpZW50KTtcbiAgICBpZiAoY2FtbF9pbnQ2NF91Y29tcGFyZSAobW9kdWx1cywgZGl2aXNvcikgPj0gMCkge1xuICAgICAgcXVvdGllbnRbMV0gKys7XG4gICAgICBtb2R1bHVzID0gY2FtbF9pbnQ2NF9zdWIgKG1vZHVsdXMsIGRpdmlzb3IpO1xuICAgIH1cbiAgICBjYW1sX2ludDY0X2xzcjEgKGRpdmlzb3IpO1xuICB9XG4gIHJldHVybiBbMCxxdW90aWVudCwgbW9kdWx1c107XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZGl2IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfcmFpc2VfemVyb19kaXZpZGVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfbmVnLCBjYW1sX2ludDY0X3VkaXZtb2RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KVxue1xuICBpZiAoY2FtbF9pbnQ2NF9pc196ZXJvICh5KSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4WzNdIF4geVszXTtcbiAgaWYgKHhbM10gJiAweDgwMDApIHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgaWYgKHlbM10gJiAweDgwMDApIHkgPSBjYW1sX2ludDY0X25lZyh5KTtcbiAgdmFyIHEgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgeSlbMV07XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gY2FtbF9pbnQ2NF9uZWcocSk7XG4gIHJldHVybiBxO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X21vZCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc196ZXJvLCBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X25lZywgY2FtbF9pbnQ2NF91ZGl2bW9kXG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSlcbntcbiAgaWYgKGNhbWxfaW50NjRfaXNfemVybyAoeSkpIGNhbWxfcmFpc2VfemVyb19kaXZpZGUgKCk7XG4gIHZhciBzaWduID0geFszXTtcbiAgaWYgKHhbM10gJiAweDgwMDApIHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgaWYgKHlbM10gJiAweDgwMDApIHkgPSBjYW1sX2ludDY0X25lZyh5KTtcbiAgdmFyIHIgPSBjYW1sX2ludDY0X3VkaXZtb2QoeCwgeSlbMl07XG4gIGlmIChzaWduICYgMHg4MDAwKSByID0gY2FtbF9pbnQ2NF9uZWcocik7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBbMjU1LCB4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmZdXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHtcbiAgcmV0dXJuIHhbMV0gfCAoeFsyXSA8PCAyNCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHtcbiAgcmV0dXJuICgoeFszXSA8PCAxNikgKiBNYXRoLnBvdygyLCAzMikgKyB4WzJdICogTWF0aC5wb3coMiwgMjQpKSArIHhbMV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIFsyNTUsXG4gICAgICAgICAgeCAmIDB4ZmZmZmZmLFxuICAgICAgICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZmZmLFxuICAgICAgICAgIE1hdGguZmxvb3IoeCAqIGNhbWxfaW50NjRfb2Zmc2V0ICogY2FtbF9pbnQ2NF9vZmZzZXQpICYgMHhmZmZmXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mb3JtYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlLCBjYW1sX2ludDY0X25lZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91ZGl2bW9kLCBjYW1sX2ludDY0X3RvX2ludDMyXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2lzX3plcm8sIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9mb3JtYXQgKGZtdCwgeCkge1xuICB2YXIgZiA9IGNhbWxfcGFyc2VfZm9ybWF0KGZtdCk7XG4gIGlmIChmLnNpZ25lZGNvbnYgJiYgY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSkge1xuICAgIGYuc2lnbiA9IC0xOyB4ID0gY2FtbF9pbnQ2NF9uZWcoeCk7XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IFwiXCI7XG4gIHZhciB3YmFzZSA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZi5iYXNlKTtcbiAgdmFyIGN2dGJsID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG4gIGRvIHtcbiAgICB2YXIgcCA9IGNhbWxfaW50NjRfdWRpdm1vZCh4LCB3YmFzZSk7XG4gICAgeCA9IHBbMV07XG4gICAgYnVmZmVyID0gY3Z0YmwuY2hhckF0KGNhbWxfaW50NjRfdG9faW50MzIocFsyXSkpICsgYnVmZmVyO1xuICB9IHdoaWxlICghIGNhbWxfaW50NjRfaXNfemVybyh4KSk7XG4gIGlmIChmLnByZWMgPj0gMCkge1xuICAgIGYuZmlsbGVyID0gJyAnO1xuICAgIHZhciBuID0gZi5wcmVjIC0gYnVmZmVyLmxlbmd0aDtcbiAgICBpZiAobiA+IDApIGJ1ZmZlciA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIGJ1ZmZlcjtcbiAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBidWZmZXIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX3BhcnNlX2RpZ2l0LCBNbEJ5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2ludDMyLCBjYW1sX2ludDY0X3VkaXZtb2QsIGNhbWxfaW50NjRfdWx0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9tdWwsIGNhbWxfaW50NjRfbmVnXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9zdHJpbmcocykge1xuICB2YXIgciA9IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSAocyk7XG4gIHZhciBpID0gclswXSwgc2lnbiA9IHJbMV0sIGJhc2UgPSByWzJdO1xuICB2YXIgYmFzZTY0ID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihiYXNlKTtcbiAgdmFyIHRocmVzaG9sZCA9XG4gICAgY2FtbF9pbnQ2NF91ZGl2bW9kKFsyNTUsIDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZl0sIGJhc2U2NClbMV07XG4gIHZhciBjID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTtcbiAgdmFyIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgdmFyIHJlcyA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gIGZvciAoOzspIHtcbiAgICBpKys7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIC8qIERldGVjdCBvdmVyZmxvdyBpbiBtdWx0aXBsaWNhdGlvbiBiYXNlICogcmVzICovXG4gICAgaWYgKGNhbWxfaW50NjRfdWx0KHRocmVzaG9sZCwgcmVzKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gICAgZCA9IGNhbWxfaW50NjRfb2ZfaW50MzIoZCk7XG4gICAgcmVzID0gY2FtbF9pbnQ2NF9hZGQoY2FtbF9pbnQ2NF9tdWwoYmFzZTY0LCByZXMpLCBkKTtcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gYWRkaXRpb24gKGJhc2UgKiByZXMpICsgZCAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdChyZXMsIGQpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgfVxuICBpZiAoaSAhPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoclsyXSA9PSAxMCAmJiBjYW1sX2ludDY0X3VsdChbMjU1LCAwLCAwLCAweDgwMDBdLCByZXMpKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICBpZiAoc2lnbiA8IDApIHJlcyA9IGNhbWxfaW50NjRfbmVnKHJlcyk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSkge1xuICByZXR1cm4gWzI1NSwgYVs3XSB8IChhWzZdIDw8IDgpIHwgKGFbNV0gPDwgMTYpLFxuICAgICAgICAgIGFbNF0gfCAoYVszXSA8PCA4KSB8IChhWzJdIDw8IDE2KSwgYVsxXSB8IChhWzBdIDw8IDgpXTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fYnl0ZXMoeCkge1xuICByZXR1cm4gW3hbM10gPj4gOCwgeFszXSAmIDB4ZmYsIHhbMl0gPj4gMTYsICh4WzJdID4+IDgpICYgMHhmZiwgeFsyXSAmIDB4ZmYsXG4gICAgICAgICAgeFsxXSA+PiAxNiwgKHhbMV0gPj4gOCkgJiAweGZmLCB4WzFdICYgMHhmZl07XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gICAgaWYobG9nMl9vaykgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cyKHgpKVxuICAgIHZhciBpID0gMDtcbiAgICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICAgIGlmKHg+PTEpIHt3aGlsZSAoeD49Mikge3gvPTI7IGkrK30gfVxuICAgIGVsc2Uge3doaWxlICh4IDwgMSkge3gqPTI7IGktLX0gfTtcbiAgICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCAoeCkge1xuICBpZiAoIWlzRmluaXRlKHgpKSB7XG4gICAgaWYgKGlzTmFOKHgpKSByZXR1cm4gWzI1NSwgMSwgMCwgMHg3ZmYwXTtcbiAgICByZXR1cm4gKHggPiAwKT9bMjU1LDAsMCwweDdmZjBdOlsyNTUsMCwwLDB4ZmZmMF07XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8weDgwMDA6KHg+PTApPzA6MHg4MDAwO1xuICBpZiAoc2lnbikgeCA9IC14O1xuICAvLyBJbnQ2NC5iaXRzX29mX2Zsb2F0IDEuMTIzNTU4MjA5Mjg4OTQ3NEUrMzA3ID0gMHg3ZmIwMDAwMDAwMDAwMDAwTFxuICAvLyB1c2luZyBNYXRoLkxPRzJFKk1hdGgubG9nKHgpIGluIHBsYWNlIG9mIE1hdGgubG9nMiByZXN1bHQgaW4gcHJlY2lzaW9uIGxvc3RcbiAgdmFyIGV4cCA9IGpzb29fZmxvb3JfbG9nMih4KSArIDEwMjM7XG4gIGlmIChleHAgPD0gMCkge1xuICAgIGV4cCA9IDA7XG4gICAgeCAvPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgfSBlbHNlIHtcbiAgICB4IC89IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICAgIGlmICh4IDwgMTYpIHtcbiAgICAgIHggKj0gMjsgZXhwIC09MTsgfVxuICAgIGlmIChleHAgPT0gMCkge1xuICAgICAgeCAvPSAyOyB9XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLDI0KTtcbiAgdmFyIHIzID0geHwwO1xuICB4ID0gKHggLSByMykgKiBrO1xuICB2YXIgcjIgPSB4fDA7XG4gIHggPSAoeCAtIHIyKSAqIGs7XG4gIHZhciByMSA9IHh8MDtcbiAgcjMgPSAocjMgJjB4ZikgfCBzaWduIHwgZXhwIDw8IDQ7XG4gIHJldHVybiBbMjU1LCByMSwgcjIsIHIzXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzJcbmZ1bmN0aW9uIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdCAoeCkge1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KDEpO1xuICBmbG9hdDMyYVswXSA9IHg7XG4gIHZhciBpbnQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheShmbG9hdDMyYS5idWZmZXIpO1xuICByZXR1cm4gaW50MzJhWzBdIHwgMDtcbn1cblxuLy9GUCBsaXRlcmFscyBjYW4gYmUgd3JpdHRlbiB1c2luZyB0aGUgaGV4YWRlY2ltYWxcbi8vbm90YXRpb24gMHg8bWFudGlzc2EgaW4gaGV4PnA8ZXhwb25lbnQ+IGZyb20gSVNPIEM5OS5cbi8vaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpL2pzLWhleGZsb2F0L2Jsb2IvbWFzdGVyL2hleGZsb2F0LmpzXG4vL1Byb3ZpZGVzOiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9qc190b19zdHJpbmcsIGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9oZXhzdHJpbmdfb2ZfZmxvYXQgKHgsIHByZWMsIHN0eWxlKSB7XG4gIGlmICghaXNGaW5pdGUoeCkpIHtcbiAgICBpZiAoaXNOYU4oeCkpIHJldHVybiBjYW1sX2pzX3RvX3N0cmluZyhcIm5hblwiKTtcbiAgICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcgKCh4ID4gMCk/XCJpbmZpbml0eVwiOlwiLWluZmluaXR5XCIpO1xuICB9XG4gIHZhciBzaWduID0gKHg9PTAgJiYgMS94ID09IC1JbmZpbml0eSk/MTooeD49MCk/MDoxO1xuICBpZihzaWduKSB4ID0gLXg7XG4gIHZhciBleHAgPSAwO1xuICBpZiAoeCA9PSAwKSB7IH1cbiAgZWxzZSBpZiAoeCA8IDEpIHtcbiAgICB3aGlsZSAoeCA8IDEgJiYgZXhwID4gLTEwMjIpICB7IHggKj0gMjsgZXhwLS0gfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlICh4ID49IDIpIHsgeCAvPSAyOyBleHArKyB9XG4gIH1cbiAgdmFyIGV4cF9zaWduID0gZXhwIDwgMCA/ICcnIDogJysnO1xuICB2YXIgc2lnbl9zdHIgPSAnJztcbiAgaWYgKHNpZ24pIHNpZ25fc3RyID0gJy0nXG4gIGVsc2Uge1xuICAgIHN3aXRjaChzdHlsZSl7XG4gICAgY2FzZSA0MyAvKiAnKycgKi86IHNpZ25fc3RyID0gJysnOyBicmVhaztcbiAgICBjYXNlIDMyIC8qICcgJyAqLzogc2lnbl9zdHIgPSAnICc7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAocHJlYyA+PSAwICYmIHByZWMgPCAxMykge1xuICAgIC8qIElmIGEgcHJlY2lzaW9uIGlzIGdpdmVuLCBhbmQgaXMgc21hbGwsIHJvdW5kIG1hbnRpc3NhIGFjY29yZGluZ2x5ICovXG4gICAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgICB4ID0gTWF0aC5yb3VuZCh4ICogY3N0KSAvIGNzdDtcbiAgfVxuICB2YXIgeF9zdHIgPSB4LnRvU3RyaW5nKDE2KTtcbiAgaWYocHJlYyA+PSAwKXtcbiAgICAgIHZhciBpZHggPSB4X3N0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYoaWR4PDApIHtcbiAgICAgIHhfc3RyICs9ICcuJyArIGNhbWxfc3RyX3JlcGVhdChwcmVjLCAnMCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaXplID0gaWR4KzErcHJlYztcbiAgICAgIGlmKHhfc3RyLmxlbmd0aCA8IHNpemUpXG4gICAgICAgIHhfc3RyICs9IGNhbWxfc3RyX3JlcGVhdChzaXplIC0geF9zdHIubGVuZ3RoLCAnMCcpO1xuICAgICAgZWxzZVxuICAgICAgICB4X3N0ciA9IHhfc3RyLnN1YnN0cigwLHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9qc190b19zdHJpbmcgKHNpZ25fc3RyICsgJzB4JyArIHhfc3RyICsgJ3AnICsgZXhwX3NpZ24gKyBleHAudG9TdHJpbmcoMTApKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGV4cCA9ICh4WzNdICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICAgIGlmICgoeFsxXXx4WzJdfCh4WzNdJjB4ZikpID09IDApXG4gICAgICAgIHJldHVybiAoeFszXSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBOYU47XG4gIH1cbiAgdmFyIGsgPSBNYXRoLnBvdygyLC0yNCk7XG4gIHZhciByZXMgPSAoeFsxXSprK3hbMl0pKmsrKHhbM10mMHhmKTtcbiAgaWYgKGV4cCA+IDApIHtcbiAgICByZXMgKz0gMTY7XG4gICAgcmVzICo9IE1hdGgucG93KDIsZXhwLTEwMjcpO1xuICB9IGVsc2VcbiAgICByZXMgKj0gTWF0aC5wb3coMiwtMTAyNik7XG4gIGlmICh4WzNdICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgKHgpIHtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KDEpO1xuICBpbnQzMmFbMF0gPSB4O1xuICB2YXIgZmxvYXQzMmEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuRmxvYXQzMkFycmF5KGludDMyYS5idWZmZXIpO1xuICByZXR1cm4gZmxvYXQzMmFbMF07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2xhc3NpZnlfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfY2xhc3NpZnlfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIGlmIChNYXRoLmFicyh4KSA+PSAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgcmV0dXJuIDA7XG4gICAgaWYgKHggIT0gMCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDI7XG4gIH1cbiAgcmV0dXJuIGlzTmFOKHgpPzQ6Mztcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbW9kZl9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9tb2RmX2Zsb2F0ICh4KSB7XG4gIGlmIChpc0Zpbml0ZSAoeCkpIHtcbiAgICB2YXIgbmVnID0gKDEveCkgPCAwO1xuICAgIHggPSBNYXRoLmFicyh4KTtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IgKHgpO1xuICAgIHZhciBmID0geCAtIGk7XG4gICAgaWYgKG5lZykgeyBpID0gLWk7IGYgPSAtZjsgfVxuICAgIHJldHVybiBbMCwgZiwgaV07XG4gIH1cbiAgaWYgKGlzTmFOICh4KSkgcmV0dXJuIFswLCBOYU4sIE5hTl07XG4gIHJldHVybiBbMCwgMS94LCB4XTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfbGRleHBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbGRleHBfZmxvYXQgKHgsZXhwKSB7XG4gIGV4cCB8PSAwO1xuICBpZiAoZXhwID4gMTAyMykge1xuICAgIGV4cCAtPSAxMDIzO1xuICAgIHggKj0gTWF0aC5wb3coMiwgMTAyMyk7XG4gICAgaWYgKGV4cCA+IDEwMjMpIHsgIC8vIGluIGNhc2UgeCBpcyBzdWJub3JtYWxcbiAgICAgIGV4cCAtPSAxMDIzO1xuICAgICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cCA8IC0xMDIzKSB7XG4gICAgZXhwICs9IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAtMTAyMyk7XG4gIH1cbiAgeCAqPSBNYXRoLnBvdygyLCBleHApO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZnJleHBfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9mcmV4cF9mbG9hdCAoeCkge1xuICBpZiAoKHggPT0gMCkgfHwgIWlzRmluaXRlKHgpKSByZXR1cm4gWzAsIHgsIDBdO1xuICB2YXIgbmVnID0geCA8IDA7XG4gIGlmIChuZWcpIHggPSAtIHg7XG4gIHZhciBleHAgPSBqc29vX2Zsb29yX2xvZzIoeCkgKyAxO1xuICB4ICo9IE1hdGgucG93KDIsLWV4cCk7XG4gIGlmICh4IDwgMC41KSB7IHggKj0gMjsgZXhwIC09IDE7IH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuaWYoam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmlmKGNhbWxfY3VycmVudF9kaXIuc2xpY2UoLTEpICE9PSBcIi9cIikgY2FtbF9jdXJyZW50X2RpciArPSBcIi9cIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2N1cnJlbnRfZGlyLm1hdGNoKC9bXlxcL10qXFwvLylbMF07XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9tYWtlX3BhdGggKG5hbWUpIHtcbiAgbmFtZT0obmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBpZihuYW1lLmNoYXJDb2RlQXQoMCkgIT0gNDcpXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGlmKG5jb21wLmxlbmd0aCA9PSAwKSBuY29tcC5wdXNoKFwiXCIpOyBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gICAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sTm9kZURldmljZShjYW1sX3Jvb3QpfSk7XG59IGVsc2Uge1xuICAgIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290KX0pO1xufVxuanNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCtcInN0YXRpYy9cIiwgZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UoY2FtbF9yb290K1wic3RhdGljL1wiKX0pO1xuXG4vL1Byb3ZpZGVzOmNhbWxfbGlzdF9tb3VudF9wb2ludFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgICB2YXIgcHJldiA9IDBcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBvbGQgPSBwcmV2O1xuICAgICAgICBwcmV2ID0gWzAsIGNhbWxfbmV3X3N0cmluZyhqc29vX21vdW50X3BvaW50W2ldLnBhdGgpLCBvbGRdXG4gICAgfVxuICAgIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgICAgcmVzID0ge3BhdGg6bS5wYXRoLGRldmljZTptLmRldmljZSxyZXN0Om5hbWUuc3Vic3RyaW5nKG0ucGF0aC5sZW5ndGgsbmFtZS5sZW5ndGgpfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21vdW50X2F1dG9sb2FkXG4vL1JlcXVpcmVzOiBNbEZha2VEZXZpY2UsIGNhbWxfbWFrZV9wYXRoLCBqc29vX21vdW50X3BvaW50XG5mdW5jdGlvbiBjYW1sX21vdW50X2F1dG9sb2FkKG5hbWUsZil7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICBqc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6bmFtZSxkZXZpY2U6bmV3IE1sRmFrZURldmljZShuYW1lLGYpfSlcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdW5tb3VudFxuLy9SZXF1aXJlczoganNvb19tb3VudF9wb2ludCwgY2FtbF9tYWtlX3BhdGhcbmZ1bmN0aW9uIGNhbWxfdW5tb3VudChuYW1lKXtcbiAgdmFyIHBhdGggPSBjYW1sX21ha2VfcGF0aChuYW1lKTtcbiAgdmFyIG5hbWUgPSBwYXRoLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gIHZhciBpZHggPSAtMTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGpzb29fbW91bnRfcG9pbnQubGVuZ3RoOyBpKyspXG4gICAgaWYoanNvb19tb3VudF9wb2ludFtpXS5wYXRoID09IG5hbWUpIGlkeCA9IGk7XG4gIGlmKGlkeCA+IC0xKSBqc29vX21vdW50X3BvaW50LnNwbGljZShpZHgsMSk7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2dldGN3ZFxuLy9SZXF1aXJlczogY2FtbF9jdXJyZW50X2RpciwgY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRjd2QoKSB7XG4gIHJldHVybiBjYW1sX25ld19zdHJpbmcoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoICsgcm9vdC5yZXN0ICsgXCIvXCI7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGRpcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgbmFtZSA9IChuYW1lIGluc3RhbmNlb2YgTWxCeXRlcyk/bmFtZS50b1N0cmluZygpOm5hbWU7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX3JhaXNlX3N5c19lcnJvclxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIG5hbWUgPSAobmFtZSBpbnN0YW5jZW9mIE1sQnl0ZXMpP25hbWUudG9TdHJpbmcoKTpuYW1lO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vdF9hX2RpciwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLnJlYWRkaXIocm9vdC5yZXN0KTtcbiAgdmFyIGwgPSBuZXcgQXJyYXkoYS5sZW5ndGggKyAxKTtcbiAgbFswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8YS5sZW5ndGg7aSsrKVxuICAgIGxbaSsxXSA9IGNhbWxfbmV3X3N0cmluZyhhW2ldKTtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbW92ZVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW1vdmUobmFtZSl7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBvayA9IHJvb3QuZGV2aWNlLnVubGluayhyb290LnJlc3QpO1xuICBpZihvayA9PSAwKSBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2lzX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5pc19kaXIocm9vdC5yZXN0KTtcbiAgcmV0dXJuIGE/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZW5hbWVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZW5hbWUobyxuKXtcbiAgdmFyIG9fcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG8pO1xuICB2YXIgbl9yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobik7XG4gIGlmKG9fcm9vdC5kZXZpY2UgIT0gbl9yb290LmRldmljZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBjYW5ub3QgbW92ZSBmaWxlIGJldHdlZW4gdHdvIGZpbGVzeXN0ZW1cIik7XG4gIGlmKCFvX3Jvb3QuZGV2aWNlLnJlbmFtZSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zeXNfcmVuYW1lOiBubyBpbXBsZW1lbnRlZFwiKTtcbiAgb19yb290LmRldmljZS5yZW5hbWUob19yb290LnJlc3QsIG5fcm9vdC5yZXN0KTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlKHZmZCwga2luZCwgbGF5b3V0LCBzaGFyZWQsIGRpbXMsIHBvcykge1xuICAvLyB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW3ZmZF07XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2JhX21hcF9maWxlIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZVxuLy9SZXF1aXJlczogY2FtbF9iYV9tYXBfZmlsZVxuZnVuY3Rpb24gY2FtbF9iYV9tYXBfZmlsZV9ieXRlY29kZShhcmd2LGFyZ24pe1xuICByZXR1cm4gY2FtbF9iYV9tYXBfZmlsZShhcmd2WzBdLGFyZ3ZbMV0sYXJndlsyXSxhcmd2WzNdLGFyZ3ZbNF0sYXJndls1XSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlX2V4dGVybihuYW1lLGNvbnRlbnQpe1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlKVxuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KTtcbiAgZWxzZSB7XG4gICAgaWYoIWpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wKSBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICAgIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wLnB1c2goe25hbWU6bmFtZSxjb250ZW50OmNvbnRlbnR9KTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mc19pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9maWxlXG5mdW5jdGlvbiBjYW1sX2ZzX2luaXQgKCl7XG4gIHZhciB0bXA9am9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXBcbiAgaWYodG1wKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG1wLmxlbmd0aDsgaSsrKXtcbiAgICAgIGNhbWxfY3JlYXRlX2ZpbGUodG1wW2ldLm5hbWUsdG1wW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2NyZWF0ZV9maWxlID0gY2FtbF9jcmVhdGVfZmlsZTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9maWxlKG5hbWUsY29udGVudCkge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcmVhZF9maWxlX2NvbnRlbnQgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gYnVmXG4gIH1cbiAgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUobmFtZSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGUsIGNhbWxfbmV3X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIE1sRmFrZURldmljZSAocm9vdCwgZikge1xuICB0aGlzLmNvbnRlbnQ9e307XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMubG9va3VwRnVuID0gZjtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubm0gPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiAodGhpcy5yb290ICsgbmFtZSk7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIXRoaXMuY29udGVudFtuYW1lXSAmJiB0aGlzLmxvb2t1cEZ1bikge1xuICAgIHZhciByZXMgPSB0aGlzLmxvb2t1cEZ1bihjYW1sX25ld19zdHJpbmcodGhpcy5yb290KSwgY2FtbF9uZXdfc3RyaW5nKG5hbWUpKTtcbiAgICBpZihyZXMgIT0gMCkgdGhpcy5jb250ZW50W25hbWVdPW5ldyBNbEZha2VGaWxlKHJlc1sxXSk7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCk7XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZiAobi5tYXRjaChyKSkgcmV0dXJuIDFcbiAgfVxuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0pIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjb250ZW50IGluc3RhbmNlb2YgTWxCeXRlcylcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjb250ZW50KTtcbiAgZWxzZSBpZihjb250ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgdGhpcy5jb250ZW50W25hbWVdID0gbmV3IE1sRmFrZUZpbGUoY2FtbF9zdHJpbmdfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKGNvbnRlbnQudG9TdHJpbmcpIHtcbiAgICB2YXIgbWxzdHJpbmcgPSBjYW1sX25ld19zdHJpbmcoY29udGVudC50b1N0cmluZygpKTtcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShtbHN0cmluZyk7XG4gIH1cbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCxjYW1sX2JsaXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0XG5mdW5jdGlvbiBNbEZha2VGaWxlKGNvbnRlbnQpe1xuICB0aGlzLmRhdGEgPSBjb250ZW50O1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuTWxGYWtlRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbihsZW4pe1xuICB2YXIgb2xkID0gdGhpcy5kYXRhO1xuICB0aGlzLmRhdGEgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW58MCk7XG4gIGNhbWxfYmxpdF9ieXRlcyhvbGQsIDAsIHRoaXMuZGF0YSwgMCwgbGVuKTtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHRoaXMuZGF0YSk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKG9mZnNldCxidWYscG9zLGxlbil7XG4gIHZhciBjbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgaWYob2Zmc2V0ICsgbGVuID49IGNsZW4pIHtcbiAgICB2YXIgbmV3X3N0ciA9IGNhbWxfY3JlYXRlX2J5dGVzKG9mZnNldCArIGxlbik7XG4gICAgdmFyIG9sZF9kYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IG5ld19zdHI7XG4gICAgY2FtbF9ibGl0X2J5dGVzKG9sZF9kYXRhLCAwLCB0aGlzLmRhdGEsIDAsIGNsZW4pO1xuICB9XG4gIGNhbWxfYmxpdF9ieXRlcyhidWYsIHBvcywgdGhpcy5kYXRhLCBvZmZzZXQsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1Zixwb3MsbGVuKXtcbiAgdmFyIGNsZW4gPSB0aGlzLmxlbmd0aCgpO1xuICBjYW1sX2JsaXRfYnl0ZXModGhpcy5kYXRhLCBvZmZzZXQsIGJ1ZiwgcG9zLCBsZW4pO1xuICByZXR1cm4gMFxufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICByZXR1cm4gY2FtbF9ieXRlc19nZXQodGhpcy5kYXRhLCBvZmZzZXQpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZUZpbGVcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGZzX25vZGVfc3VwcG9ydGVkXG5mdW5jdGlvbiBmc19ub2RlX3N1cHBvcnRlZCAoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAmJiB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2Vzcy52ZXJzaW9ucyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnKVxufVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sTm9kZUZpbGVcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5mcy5leGlzdHNTeW5jKHRoaXMubm0obmFtZSkpPzE6MDtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMucmVhZGRpclN5bmModGhpcy5ubShuYW1lKSk7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZnMuc3RhdFN5bmModGhpcy5ubShuYW1lKSkuaXNEaXJlY3RvcnkoKT8xOjA7XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGIgPSB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB0aGlzLmZzLnVubGlua1N5bmModGhpcy5ubShuYW1lKSk7XG4gIHJldHVybiBiXG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihuYW1lLCBmKSB7XG4gIHZhciBjb25zdHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvcih2YXIga2V5IGluIGYpe1xuICAgIHN3aXRjaChrZXkpe1xuICAgIGNhc2UgXCJyZG9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fUkRPTkxZOyBicmVhaztcbiAgICBjYXNlIFwid3Jvbmx5XCIgIDogcmVzIHw9IGNvbnN0cy5PX1dST05MWTsgYnJlYWs7XG4gICAgY2FzZSBcImFwcGVuZFwiICA6XG4gICAgICByZXMgfD0gY29uc3RzLk9fV1JPTkxZIHwgY29uc3RzLk9fQVBQRU5EO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNyZWF0ZVwiICAgOiByZXMgfD0gY29uc3RzLk9fQ1JFQVQ7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cnVuY2F0ZVwiIDogcmVzIHw9IGNvbnN0cy5PX1RSVU5DOyAgICBicmVhaztcbiAgICBjYXNlIFwiZXhjbFwiICAgICA6IHJlcyB8PSBjb25zdHMuT19FWENMOyAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJpbmFyeVwiICAgOiByZXMgfD0gY29uc3RzLk9fQklOQVJZOyAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0XCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX1RFWFQ7ICAgICBicmVhaztcbiAgICBjYXNlIFwibm9uYmxvY2tcIiA6IHJlcyB8PSBjb25zdHMuT19OT05CTE9DSzsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBmZCA9IHRoaXMuZnMub3BlblN5bmModGhpcy5ubShuYW1lKSwgcmVzKTtcbiAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvLG4pIHtcbiAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xufVxuXG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRGV2aWNlXG5cbi8vUHJvdmlkZXM6IE1sTm9kZUZpbGVcbi8vUmVxdWlyZXM6IE1sRmlsZSwgY2FtbF9hcnJheV9vZl9zdHJpbmcsIGNhbWxfYnl0ZXNfc2V0XG5cbnZhciBCdWZmZXIgPSBqb29fZ2xvYmFsX29iamVjdC5CdWZmZXJcblxuZnVuY3Rpb24gTWxOb2RlRmlsZShmZCl7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLmZkID0gZmQ7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZSA9IG5ldyBNbEZpbGUgKCk7XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlciAoYSk7XG4gIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICByZXR1cm4gMDtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLGJ1Zl9vZmZzZXQsbGVuKXtcbiAgdmFyIGEgPSBjYW1sX2FycmF5X29mX3N0cmluZyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhKTtcbiAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBjYW1sX2J5dGVzX3NldChidWYsYnVmX29mZnNldCArIGksYnVmZmVyW2J1Zl9vZmZzZXQraV0pO1xuICB9XG4gIHJldHVybiAwXG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoMSk7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGEpO1xuICB0aGlzLmZzLnJlYWRTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgMCwgMSwgb2Zmc2V0KTtcbiAgcmV0dXJuIGJ1ZmZlclswXTtcbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5mcy5jbG9zZVN5bmModGhpcy5mZCk7XG59XG5cbk1sTm9kZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxOb2RlRmlsZTtcbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3Ncbi8vXG4vLyBOb3RlOyBpbnQ2NCtjb21wbGV4IHN1cHBvcnQgaWYgcHJvdmlkZWQgYnkgYWxsb2NhdGluZyBhIHNlY29uZCBUeXBlZEFycmF5XG4vLyBOb3RlOyBhY2Nlc3NvciBmdW5jdGlvbnMgYXJlIHNlbGVjdGVkIHdoZW4gdGhlIGJpZ2FycmF5IGlzIGNyZWF0ZWQuICBJdCBpcyBhc3N1bWVkXG4vLyAgICAgICB0aGF0IHRoaXMgcmVzdWx0cyBpbiBqdXN0IGEgZnVuY3Rpb24gcG9pbnRlciBhbmQgd2lsbCB0aHVzIGJlIGZhc3QuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfaW5pdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9iYV9pbml0KCkge1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2luaXRfdmlld3Ncbi8vUmVxdWlyZXM6IGNhbWxfYmFfdmlld3NcbmZ1bmN0aW9uIGNhbWxfYmFfaW5pdF92aWV3cygpIHtcbiAgICBpZiAoIWNhbWxfYmFfdmlld3MpIHtcbiAgICAgICAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgICAgICAgY2FtbF9iYV92aWV3cyA9IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBnLkZsb2F0MzJBcnJheSwgZy5GbG9hdDY0QXJyYXksIGcuSW50OEFycmF5LCBnLlVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgZy5JbnQxNkFycmF5LCBnLlVpbnQxNkFycmF5LCBnLkludDMyQXJyYXksIGcuSW50MzJBcnJheSxcbiAgICAgICAgICAgICAgICBnLkludDMyQXJyYXksIGcuSW50MzJBcnJheSwgZy5GbG9hdDMyQXJyYXksIGcuRmxvYXQ2NEFycmF5LCBnLlVpbnQ4QXJyYXldLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLCAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLyxcbiAgICAgICAgICAgICAgICAwIC8qIEdlbmVyYWwgKi8sIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLCAxIC8qIEludDY0ICovLFxuICAgICAgICAgICAgICAgIDAgLyogR2VuZXJhbCAqLywgMCAvKiBHZW5lcmFsICovLCAyIC8qIENvbXBsZXggKi8sIDIgLyogQ29tcGxleCAqLywgMCAvKiBHZW5lcmFsICovXVxuICAgICAgICBdO1xuICAgIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2dldF9zaXplKGRpbXMpIHtcbiAgICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gICAgdmFyIHNpemUgPSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbl9kaW1zOyBpKyspIHtcbiAgICAgICAgaWYgKGRpbXNbaV0gPCAwKVxuICAgICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdmlld3NcbnZhciBjYW1sX2JhX3ZpZXdzO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YSwgZGF0YTIsIGRhdGFfdHlwZSwga2luZCwgbGF5b3V0LCBkaW1zKSB7XG4gICAgdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICAgIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcblxuICAgIC8vXG4gICAgLy8gRnVuY3Rpb25zIHRvIGNvbXB1dGUgdGhlIG9mZnNldHMgZm9yIEMgb3IgRm9ydHJhbiBsYXlvdXQgYXJyYXlzXG4gICAgLy8gZnJvbSB0aGUgZ2l2ZW4gYXJyYXkgb2YgaW5kaWNlcy5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIG9mZnNldF9jKGluZGV4KSB7XG4gICAgICAgIHZhciBvZnMgPSAwO1xuICAgICAgICBpZiAobl9kaW1zICE9IGluZGV4Lmxlbmd0aClcbiAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluZGV4W2ldIDwgMCB8fCBpbmRleFtpXSA+PSBkaW1zW2ldKVxuICAgICAgICAgICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgICAgICAgIG9mcyA9IChvZnMgKiBkaW1zW2ldKSArIGluZGV4W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0X2ZvcnRyYW4oaW5kZXgpIHtcbiAgICAgICAgdmFyIG9mcyA9IDA7XG4gICAgICAgIGlmIChuX2RpbXMgIT0gaW5kZXgubGVuZ3RoKVxuICAgICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuZ2V0L3NldDogd3JvbmcgbnVtYmVyIG9mIGluZGljZXNcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSBuX2RpbXMgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGluZGV4W2ldIDwgMSB8fCBpbmRleFtpXSA+IGRpbXNbaV0pXG4gICAgICAgICAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgICAgICAgb2ZzID0gKG9mcyAqIGRpbXNbaV0pICsgKGluZGV4W2ldIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mcztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gbGF5b3V0ID09IDAgPyBvZmZzZXRfYyA6IG9mZnNldF9mb3J0cmFuO1xuXG4gICAgdmFyIGRpbTAgPSBkaW1zWzBdO1xuXG4gICAgLy9cbiAgICAvLyBFbGVtZW50IGdldCBmdW5jdGlvbnMuXG4gICAgLy9cbiAgICBmdW5jdGlvbiBnZXRfc3RkKGluZGV4KSB7XG4gICAgICAgIHZhciBvZnMgPSBvZmZzZXQoaW5kZXgpO1xuICAgICAgICB2YXIgdiA9IGRhdGFbb2ZzXTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X2ludDY0KGluZGV4KSB7XG4gICAgICAgIHZhciBvZmYgPSBvZmZzZXQoaW5kZXgpO1xuICAgICAgICB2YXIgbCA9IGRhdGFbb2ZmXTtcbiAgICAgICAgdmFyIGggPSBkYXRhMltvZmZdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMjU1LFxuICAgICAgICAgICAgbCAmIDB4ZmZmZmZmLFxuICAgICAgICAgICAgKChsID4+PiAyNCkgJiAweGZmKSB8ICgoaCAmIDB4ZmZmZikgPDwgOCksXG4gICAgICAgICAgICAoaCA+Pj4gMTYpICYgMHhmZmZmXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfY29tcGxleChpbmRleCkge1xuICAgICAgICB2YXIgb2ZmID0gb2Zmc2V0KGluZGV4KTtcbiAgICAgICAgdmFyIHIgPSBkYXRhW29mZl07XG4gICAgICAgIHZhciBpID0gZGF0YTJbb2ZmXTtcbiAgICAgICAgcmV0dXJuIFsyNTQsIHIsIGldO1xuICAgIH1cblxuICAgIHZhciBnZXQgPSBkYXRhX3R5cGUgPT0gMSAvKiBJbnQ2NCAqLyA/IGdldF9pbnQ2NCA6IChkYXRhX3R5cGUgPT0gMiAvKiBDb21wbGV4ICovID8gZ2V0X2NvbXBsZXggOiBnZXRfc3RkKTtcblxuICAgIGZ1bmN0aW9uIGdldDFfYyhpKSB7XG4gICAgICAgIGlmIChpIDwgMCB8fCBpID49IGRpbTApXG4gICAgICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICAgIHJldHVybiBkYXRhW2ldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXQxX2ZvcnRyYW4oaSkge1xuICAgICAgICBpZiAoaSA8IDEgfHwgaSA+IGRpbTApXG4gICAgICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICAgIHJldHVybiBkYXRhW2kgLSAxXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0MV9hbnkoaSkge1xuICAgICAgICByZXR1cm4gZ2V0KFtpXSk7XG4gICAgfVxuXG4gICAgdmFyIGdldDEgPSBkYXRhX3R5cGUgPT0gMCAvKiBHZW5lcmFsICovID8gKGxheW91dCA9PSAwID8gZ2V0MV9jIDogZ2V0MV9mb3J0cmFuKSA6IGdldDFfYW55O1xuXG4gICAgLy9cbiAgICAvLyBFbGVtZW50IHNldCBmdW5jdGlvbnNcbiAgICAvL1xuICAgIGZ1bmN0aW9uIHNldF9zdGRfcmF3KG9mZiwgdikge1xuICAgICAgICBkYXRhW29mZl0gPSB2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldF9pbnQ2NF9yYXcob2ZmLCB2KSB7XG4gICAgICAgIGRhdGFbb2ZmXSA9IHZbMV0gfCAoKHZbMl0gJiAweGZmKSA8PCAyNCk7XG4gICAgICAgIGRhdGEyW29mZl0gPSAoKHZbMl0gPj4+IDgpICYgMHhmZmZmKSB8ICh2WzNdIDw8IDE2KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRfY29tcGxleF9yYXcob2ZmLCB2KSB7XG4gICAgICAgIGRhdGFbb2ZmXSA9IHZbMV07XG4gICAgICAgIGRhdGEyW29mZl0gPSB2WzJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldF9zdGQoaW5kZXgsIHYpIHtcbiAgICAgICAgdmFyIG9mcyA9IG9mZnNldChpbmRleCk7XG4gICAgICAgIHJldHVybiBzZXRfc3RkX3JhdyhvZnMsIHYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRfaW50NjQoaW5kZXgsIHYpIHtcbiAgICAgICAgcmV0dXJuIHNldF9pbnQ2NF9yYXcob2Zmc2V0KGluZGV4KSwgdik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldF9jb21wbGV4KGluZGV4LCB2KSB7XG4gICAgICAgIHJldHVybiBzZXRfY29tcGxleF9yYXcob2Zmc2V0KGluZGV4KSwgdik7XG4gICAgfVxuXG4gICAgdmFyIHNldCA9IGRhdGFfdHlwZSA9PSAxIC8qIEludDY0ICovID8gc2V0X2ludDY0IDogKGRhdGFfdHlwZSA9PSAyIC8qIENvbXBsZXggKi8gPyBzZXRfY29tcGxleCA6IHNldF9zdGQpO1xuXG4gICAgZnVuY3Rpb24gc2V0MV9jKGksIHYpIHtcbiAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gZGltMClcbiAgICAgICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgICAgZGF0YVtpXSA9IHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldDFfZm9ydHJhbihpLCB2KSB7XG4gICAgICAgIGlmIChpIDwgMSB8fCBpID4gZGltMClcbiAgICAgICAgICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgICAgICAgZGF0YVtpIC0gMV0gPSB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQxX2FueShpLCB2KSB7XG4gICAgICAgIHNldChbaV0sIHYpO1xuICAgIH1cblxuICAgIHZhciBzZXQxID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IChsYXlvdXQgPT0gMCA/IHNldDFfYyA6IHNldDFfZm9ydHJhbikgOiBzZXQxX2FueTtcblxuICAgIC8vXG4gICAgLy8gb3RoZXJcbiAgICAvL1xuICAgIGZ1bmN0aW9uIG50aF9kaW0oaSkge1xuICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBuX2RpbXMpXG4gICAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gICAgICAgIHJldHVybiBkaW1zW2ldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGwodikge1xuICAgICAgICBpZiAoZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBzZXRfc3RkX3JhdyhpLCB2KTtcbiAgICAgICAgaWYgKGRhdGFfdHlwZSA9PSAxIC8qIEludDY0ICovKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNldF9pbnQ2NF9yYXcoaSwgdik7XG4gICAgICAgIGlmIChkYXRhX3R5cGUgPT0gMiAvKiBDb21wbGV4ICovKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNldF9jb21wbGV4X3JhdyhpLCB2KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmxpdChmcm9tKSB7XG4gICAgICAgIGlmIChuX2RpbXMgIT0gZnJvbS5udW1fZGltcylcbiAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmJsaXQ6IGRpbWVuc2lvbiBtaXNtYXRjaFwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgICAgICAgIGlmIChkaW1zW2ldICE9IGZyb20ubnRoX2RpbShpKSlcbiAgICAgICAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gICAgICAgIGRhdGEuc2V0KGZyb20uZGF0YSk7XG4gICAgICAgIGlmIChkYXRhX3R5cGUgIT0gMCAvKiBHZW5lcmFsICovKVxuICAgICAgICAgICAgZGF0YTIuc2V0KGZyb20uZGF0YTIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YihvZnMsIGxlbikge1xuICAgICAgICB2YXIgY2hhbmdlZF9kaW07XG4gICAgICAgIHZhciBtdWwgPSAxO1xuXG4gICAgICAgIGlmIChsYXlvdXQgPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgICAgICAgICAgICBtdWwgPSBtdWwgKiBkaW1zW2ldO1xuICAgICAgICAgICAgY2hhbmdlZF9kaW0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAobl9kaW1zIC0gMSk7IGkrKylcbiAgICAgICAgICAgICAgICBtdWwgPSBtdWwgKiBkaW1zW2ldO1xuICAgICAgICAgICAgY2hhbmdlZF9kaW0gPSBuX2RpbXMgLSAxO1xuICAgICAgICAgICAgb2ZzID0gb2ZzIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBkaW1zW2NoYW5nZWRfZGltXSlcbiAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnN1YjogYmFkIHN1Yi1hcnJheVwiKTtcblxuICAgICAgICB2YXIgbmV3X2RhdGEgPSBkYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICAgICAgICB2YXIgbmV3X2RhdGEyID0gZGF0YV90eXBlID09IDAgLyogR2VuZXJhbCAqLyA/IG51bGwgOiBkYXRhMi5zdWJhcnJheShvZnMgKiBtdWwsIChvZnMgKyBsZW4pICogbXVsKTtcblxuICAgICAgICB2YXIgbmV3X2RpbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgICAgICAgIG5ld19kaW1zW2ldID0gZGltc1tpXTtcbiAgICAgICAgbmV3X2RpbXNbY2hhbmdlZF9kaW1dID0gbGVuO1xuXG4gICAgICAgIHJldHVybiBjYW1sX2JhX2NyZWF0ZV9mcm9tKG5ld19kYXRhLCBuZXdfZGF0YTIsIGRhdGFfdHlwZSwga2luZCwgbGF5b3V0LCBuZXdfZGltcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2xpY2UodmluZCkge1xuICAgICAgICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4ID0gW107XG4gICAgICAgIHZhciBzdWJfZGltcyA9IFtdO1xuICAgICAgICB2YXIgb2ZzO1xuXG4gICAgICAgIGlmIChudW1faW5kcyA+PSBuX2RpbXMpXG4gICAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5zbGljZTogdG9vIG1hbnkgaW5kaWNlc1wiKTtcblxuICAgICAgICAvLyBDb21wdXRlIG9mZnNldCBhbmQgY2hlY2sgYm91bmRzXG4gICAgICAgIGlmIChsYXlvdXQgPT0gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgICAgICAgICAgIGluZGV4W2ldID0gdmluZFtpXTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbl9kaW1zOyBpKyspXG4gICAgICAgICAgICAgICAgaW5kZXhbaV0gPSAwO1xuICAgICAgICAgICAgb2ZzID0gb2Zmc2V0KGluZGV4KTtcbiAgICAgICAgICAgIHN1Yl9kaW1zID0gZGltcy5zbGljZShudW1faW5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9pbmRzOyBpKyspXG4gICAgICAgICAgICAgICAgaW5kZXhbbl9kaW1zIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5fZGltcyAtIG51bV9pbmRzOyBpKyspXG4gICAgICAgICAgICAgICAgaW5kZXhbaV0gPSAxO1xuICAgICAgICAgICAgb2ZzID0gb2Zmc2V0KGluZGV4KTtcbiAgICAgICAgICAgIHN1Yl9kaW1zID0gZGltcy5zbGljZSgwLCBudW1faW5kcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IGNhbWxfYmFfZ2V0X3NpemUoc3ViX2RpbXMpO1xuICAgICAgICB2YXIgbmV3X2RhdGEgPSBkYXRhLnN1YmFycmF5KG9mcywgb2ZzICsgc2l6ZSk7XG4gICAgICAgIHZhciBuZXdfZGF0YTIgPSBkYXRhX3R5cGUgPT0gMCAvKiBHZW5lcmFsICovID8gbnVsbCA6IGRhdGEyLnN1YmFycmF5KG9mcywgb2ZzICsgc2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20obmV3X2RhdGEsIG5ld19kYXRhMiwgZGF0YV90eXBlLCBraW5kLCBsYXlvdXQsIHN1Yl9kaW1zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNoYXBlKHZkaW0pIHtcbiAgICAgICAgdmFyIG5ld19kaW0gPSBbXTtcbiAgICAgICAgdmFyIG51bV9kaW1zID0gdmRpbS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG51bV9kaW1zIDwgMSlcbiAgICAgICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgICAgICAgdmFyIG51bV9lbHRzID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICAgICAgICBuZXdfZGltW2ldID0gdmRpbVtpXTtcbiAgICAgICAgICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgICAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBuZWdhdGl2ZSBkaW1lbnNpb25cIik7XG4gICAgICAgICAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoYXQgc2l6ZXMgYWdyZWVcbiAgICAgICAgaWYgKG51bV9lbHRzICE9IHNpemUpXG4gICAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuXG4gICAgICAgIHJldHVybiBjYW1sX2JhX2NyZWF0ZV9mcm9tKGRhdGEsIGRhdGEyLCBkYXRhX3R5cGUsIGtpbmQsIGxheW91dCwgbmV3X2RpbSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZShiLCB0b3RhbCkge1xuICAgICAgICBpZiAobGF5b3V0ICE9IGIubGF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuIGIubGF5b3V0IC0gbGF5b3V0O1xuICAgICAgICBpZiAobl9kaW1zICE9IGIubnVtX2RpbXMpXG4gICAgICAgICAgICByZXR1cm4gYi5udW1fZGltcyAtIG5fZGltcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKylcbiAgICAgICAgICAgIGlmIChudGhfZGltKGkpICE9IGIubnRoX2RpbShpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKG50aF9kaW0oaSkgPCBiLm50aF9kaW0oaSkpID8gLTEgOiAxO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIHZhciB4LCB5O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGIuZGF0YVtpXTtcblxuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPiB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICE9IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRvdGFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ID09IHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID09IHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2Vjb25kIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gZGF0YTJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYi5kYXRhMltpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4IDwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA+IHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCAhPSB5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRvdGFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0geClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSA9PSB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA+IGIuZGF0YVtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEyW2ldIDwgYi5kYXRhMltpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEyW2ldID4gYi5kYXRhMltpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXSA8IGIuZGF0YVtpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPiBiLmRhdGFbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRhdGEyOiBkYXRhMixcbiAgICAgICAgZGF0YV90eXBlOiBkYXRhX3R5cGUsXG4gICAgICAgIG51bV9kaW1zOiBuX2RpbXMsXG4gICAgICAgIG50aF9kaW06IG50aF9kaW0sXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBzdWI6IHN1YixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBibGl0OiBibGl0LFxuICAgICAgICBmaWxsOiBmaWxsLFxuICAgICAgICByZXNoYXBlOiByZXNoYXBlLFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgZ2V0MTogZ2V0MSxcbiAgICAgICAgc2V0OiBzZXQsXG4gICAgICAgIHNldDE6IHNldDEsXG4gICAgICAgIGNvbXBhcmU6IGNvbXBhcmVcbiAgICB9O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX3ZpZXdzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2luaXRfdmlld3Ncbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBUeXBlZEFycmF5IHZpZXdzXG4gICAgY2FtbF9iYV9pbml0X3ZpZXdzKCk7XG5cbiAgICAvLyBzZXQgdXAgZGltZW5zaW9ucyBhbmQgY2FsY3VsYXRlIHNpemVcbiAgICB2YXIgZGltcyA9IGNhbWxfanNfZnJvbV9hcnJheShkaW1zX21sKTtcblxuICAgIC8vdmFyIG5fZGltcyA9IGRpbXMubGVuZ3RoO1xuICAgIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcblxuICAgIC8vIEFsbG9jYXRlIFR5cGVkQXJyYXlcbiAgICB2YXIgdmlldyA9IGNhbWxfYmFfdmlld3NbMF1ba2luZF07XG4gICAgaWYgKCF2aWV3KVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5jcmVhdGU6IHVuc3VwcG9ydGVkIGtpbmRcIik7XG4gICAgdmFyIGRhdGEgPSBuZXcgdmlldyhzaXplKTtcblxuICAgIC8vIDJuZCBUeXBlZEFycmF5IGZvciBpbnQ2NCwgY29tcGxleDMyIGFuZCBjb21wbGV4NjRcbiAgICB2YXIgZGF0YV90eXBlID0gY2FtbF9iYV92aWV3c1sxXVtraW5kXTtcbiAgICB2YXIgZGF0YTIgPSBudWxsO1xuICAgIGlmIChkYXRhX3R5cGUgIT0gMCAvKiBHZW5lcmFsICovKSB7XG4gICAgICAgIGRhdGEyID0gbmV3IHZpZXcoc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YSwgZGF0YTIsIGRhdGFfdHlwZSwga2luZCwgbGF5b3V0LCBkaW1zKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9mcm9tXG5mdW5jdGlvbiBjYW1sX2JhX2NoYW5nZV9sYXlvdXQoYmEsIGxheW91dCkge1xuICBpZihiYS5sYXlvdXQgPT0gbGF5b3V0KSByZXR1cm4gYmE7XG4gIHZhciBkaW1zID0gW107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5udW1fZGltczsgaSsrKVxuICAgIGRpbXNbaV0gPSBiYS5udGhfZGltKGkpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbShiYS5kYXRhLCBiYS5kYXRhMiwgYmEuZGF0YV90eXBlLCBiYS5raW5kLCBsYXlvdXQsIGRpbXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICAgIHJldHVybiBiYS5raW5kO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2xheW91dFxuZnVuY3Rpb24gY2FtbF9iYV9sYXlvdXQoYmEpIHtcbiAgICByZXR1cm4gYmEubGF5b3V0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX251bV9kaW1zXG5mdW5jdGlvbiBjYW1sX2JhX251bV9kaW1zKGJhLCBfZGltKSB7XG4gICAgcmV0dXJuIGJhLm51bV9kaW1zO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW0oYmEsIGRpbSkge1xuICAgIHJldHVybiBiYS5udGhfZGltKGRpbSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZGltXzFcbmZ1bmN0aW9uIGNhbWxfYmFfZGltXzEoYmEpIHtcbiAgICByZXR1cm4gYmEubnRoX2RpbSgwKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9kaW1fMlxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICAgIHJldHVybiBiYS5udGhfZGltKDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG5mdW5jdGlvbiBjYW1sX2JhX2RpbV8zKGJhKSB7XG4gICAgcmV0dXJuIGJhLm50aF9kaW0oMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0X2dlbmVyaWNcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfZ2VuZXJpYyhiYSwgaW5kZXgpIHtcbiAgICByZXR1cm4gYmEuZ2V0KGNhbWxfanNfZnJvbV9hcnJheShpbmRleCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDE2XG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDE2KGJhLCBpMCkge1xuICAgIHZhciBiMSA9IGJhLmdldDEoaTApO1xuICAgIHZhciBiMiA9IGJhLmdldDEoaTArMSkgPDwgODtcbiAgICByZXR1cm4gKGIxIHwgYjIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICAgIHZhciBiMSA9IGJhLmdldDEoaTApO1xuICAgIHZhciBiMiA9IGJhLmdldDEoaTArMSkgPDwgODtcbiAgICB2YXIgYjMgPSBiYS5nZXQxKGkwKzIpIDw8IDE2O1xuICAgIHZhciBiNCA9IGJhLmdldDEoaTArMykgPDwgMjQ7XG4gICAgcmV0dXJuIChiMSB8IGIyIHwgYjMgfCBiNCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gICAgdmFyIGIxID0gYmEuZ2V0MShpMCk7XG4gICAgdmFyIGIyID0gYmEuZ2V0MShpMCsxKSA8PCA4O1xuICAgIHZhciBiMyA9IGJhLmdldDEoaTArMikgPDwgMTY7XG4gICAgdmFyIGI0ID0gYmEuZ2V0MShpMCszKTtcbiAgICB2YXIgYjUgPSBiYS5nZXQxKGkwKzQpIDw8IDg7XG4gICAgdmFyIGI2ID0gYmEuZ2V0MShpMCs1KSA8PCAxNjtcbiAgICB2YXIgYjcgPSBiYS5nZXQxKGkwKzYpO1xuICAgIHZhciBiOCA9IGJhLmdldDEoaTArNykgPDwgODtcbiAgICByZXR1cm4gWzI1NSwgYjEgfCBiMiB8IGIzLCBiNCB8IGI1IHwgYjYsIGI3IHwgYjggXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfMShiYSwgaTApIHtcbiAgICByZXR1cm4gYmEuZ2V0MShpMCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZ2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0XzIoYmEsIGkwLCBpMSkge1xuICAgIHJldHVybiBiYS5nZXQoW2kwLCBpMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gICAgcmV0dXJuIGJhLmdldChbaTAsIGkxLCBpMl0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0X2dlbmVyaWMoYmEsIGluZGV4LCB2KSB7XG4gICAgcmV0dXJuIGJhLnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaW5kZXgpLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQxNlxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQxNihiYSwgaTAsIHYpIHtcbiAgICBiYS5zZXQxKGkwLCB2ICYgMHhmZik7XG4gICAgYmEuc2V0MShpMCsxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQzMlxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQzMihiYSwgaTAsIHYpIHtcbiAgICBiYS5zZXQxKGkwLCB2ICYgMHhmZik7XG4gICAgYmEuc2V0MShpMCsxLCAodiA+Pj4gOCkgJiAweGZmKTtcbiAgICBiYS5zZXQxKGkwKzIsICh2ID4+PiAxNikgJiAweGZmKTtcbiAgICBiYS5zZXQxKGkwKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV91aW50OF9zZXQ2NFxuZnVuY3Rpb24gY2FtbF9iYV91aW50OF9zZXQ2NChiYSwgaTAsIHYpIHtcbiAgICBiYS5zZXQxKGkwLCB2WzFdICYgMHhmZik7XG4gICAgYmEuc2V0MShpMCsxLCAodlsxXSA+PiA4KSAmIDB4ZmYpO1xuICAgIGJhLnNldDEoaTArMiwgdlsxXSA+PiAxNik7XG4gICAgYmEuc2V0MShpMCszLCB2WzJdICYgMHhmZik7XG4gICAgYmEuc2V0MShpMCs0LCAodlsyXSA+PiA4KSAmIDB4ZmYpO1xuICAgIGJhLnNldDEoaTArNSwgdlsyXSA+PiAxNik7XG4gICAgYmEuc2V0MShpMCs2LCB2WzNdICYgMHhmZik7XG4gICAgYmEuc2V0MShpMCs3LCB2WzNdID4+IDgpO1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICAgIHJldHVybiBiYS5zZXQxKGkwLCB2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfMlxuZnVuY3Rpb24gY2FtbF9iYV9zZXRfMihiYSwgaTAsIGkxLCB2KSB7XG4gICAgcmV0dXJuIGJhLnNldChbaTAsIGkxXSwgdik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgICByZXR1cm4gYmEuc2V0KFtpMCwgaTEsIGkyXSwgdik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfYmxpdFxuZnVuY3Rpb24gY2FtbF9iYV9ibGl0KHNyYywgZHN0KSB7XG4gICAgZHN0LmJsaXQoc3JjKTtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9maWxsXG5mdW5jdGlvbiBjYW1sX2JhX2ZpbGwoYmEsIGluaXQpIHtcbiAgICBiYS5maWxsKGluaXQpO1xuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3N1YlxuZnVuY3Rpb24gY2FtbF9iYV9zdWIoYmEsIG9mcywgbGVuKSB7XG4gICAgcmV0dXJuIGJhLnN1YihvZnMsIGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2xpY2Vcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICAgIHJldHVybiBiYS5zbGljZShjYW1sX2pzX2Zyb21fYXJyYXkodmluZCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3Jlc2hhcGVcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gICAgcmV0dXJuIGJhLnJlc2hhcGUoY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpKTtcbn1cbiIsIi8vLy8vLy8vLyBCSUdTVFJJTkdcbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19hbGxvY1xuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19hbGxvYyhfLHNpemUpe1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGUoMTIsIDAsIFswLHNpemVdKTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2Rlc3Ryb3lfc3R1YlxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2JhX2NyZWF0ZV9mcm9tXG5mdW5jdGlvbiBiaWdzdHJpbmdfZGVzdHJveV9zdHViKHZfYnN0cikge1xuICBpZiAodl9ic3RyLmRhdGEyICE9IG51bGwpIHtcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImJpZ3N0cmluZ19kZXN0cm95OiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB9XG5cbiAgaWYgKHZfYnN0ci5oYXNPd25Qcm9wZXJ0eSgnX19pc19kZWFsbG9jYXRlZCcpKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnc3RyaW5nX2Rlc3Ryb3k6IGJpZ3N0cmluZyBpcyBhbHJlYWR5IGRlYWxsb2NhdGVkXCIpO1xuICB9XG5cbiAgdmFyIGRlc3Ryb3llZF9kYXRhID0gbmV3IHZfYnN0ci5kYXRhLl9fcHJvdG9fXy5jb25zdHJ1Y3RvcigwKTtcbiAgdmFyIGRlc3Ryb3llZF9iaWdzdHJpbmcgPVxuICAgICAgY2FtbF9iYV9jcmVhdGVfZnJvbShkZXN0cm95ZWRfZGF0YSwgbnVsbCwgdl9ic3RyLmRhdGFfdHlwZSwgdl9ic3RyLmtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZfYnN0ci5sYXlvdXQsIFswXSk7XG4gIGRlc3Ryb3llZF9iaWdzdHJpbmcuX19pc19kZWFsbG9jYXRlZCA9IHRydWU7XG5cbiAgLy8gTXV0YXRlIHRoZSBvcmlnaW5hbCBiaWdzdHJpbmcgaW4tcGxhY2UsIHRvIHNpbXVsYXRlIHdoYXQgdGhlIEMgdmVyc2lvbiBkb2VzXG4gIE9iamVjdC5hc3NpZ24odl9ic3RyLCBkZXN0cm95ZWRfYmlnc3RyaW5nKTtcblxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1Yih2X2JzdHIsIHZfc3JjX3Bvcywgdl9zdHIsIHZfZHN0X3Bvcywgdl9sZW4pe1xuICBmb3IodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKyl7XG4gICAgdmFyIGMgPSBjYW1sX2JhX2dldF8xKHZfYnN0cix2X3NyY19wb3MgKyBpKTtcbiAgICBjYW1sX2J5dGVzX3NldCh2X3N0cix2X2RzdF9wb3MgKyBpLGMpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG52YXIgYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX3N0cmluZ19zdHViID0gYmlnc3RyaW5nX2JsaXRfYmlnc3RyaW5nX2J5dGVzX3N0dWJcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGJpZ3N0cmluZ19ibGl0X2JpZ3N0cmluZ19ieXRlc19zdHViXG52YXIgY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmcgPSBiaWdzdHJpbmdfYmxpdF9iaWdzdHJpbmdfYnl0ZXNfc3R1YlxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2dldCwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2JsaXRfc3RyaW5nX2JpZ3N0cmluZ19zdHViKHZfc3RyLCB2X3NyY19wb3MsIHZfYnN0ciwgdl9kc3RfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykgY2FtbF9iYV9zZXRfMSh2X2JzdHIsdl9kc3RfcG9zICsgaSxjYW1sX3N0cmluZ19nZXQodl9zdHIsdl9zcmNfcG9zICsgaSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX2JsaXRfYnl0ZXNfYmlnc3RyaW5nX3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfZ2V0LCBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9ieXRlc19iaWdzdHJpbmdfc3R1Yih2X3N0ciwgdl9zcmNfcG9zLCB2X2JzdHIsIHZfZHN0X3Bvcywgdl9sZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZfbGVuOyBpKyspIGNhbWxfYmFfc2V0XzEodl9ic3RyLHZfZHN0X3BvcyArIGksY2FtbF9ieXRlc19nZXQodl9zdHIsdl9zcmNfcG9zICsgaSkpO1xuICByZXR1cm4gMDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdfdG9fYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBiaWdzdHJpbmdfYmxpdF9zdHJpbmdfYmlnc3RyaW5nX3N0dWJcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGJpZ3N0cmluZ19ibGl0X3N0cmluZ19iaWdzdHJpbmdfc3R1YlxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfYmxpdF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xLCBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfYmxpdF9zdHViKHMxLCBpMSwgczIsIGkyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjYW1sX2JhX3NldF8xKHMyLGkyICsgaSxjYW1sX2JhX2dldF8xKHMxLGkxICsgaSkpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX21lbWNtcF9zdHViXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWVtY21wX3N0dWIodl9zMSwgdl9zMV9wb3MsIHZfczIsIHZfczJfcG9zLCB2X2xlbil7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdl9sZW47IGkrKykge1xuICAgIHZhciBhID0gY2FtbF9iYV9nZXRfMSh2X3MxLHZfczFfcG9zICsgaSk7XG4gICAgdmFyIGIgPSBjYW1sX2JhX2dldF8xKHZfczIsdl9zMl9wb3MgKyBpKTtcbiAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfZmluZFxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX2ZpbmQoYnMsIGNociwgcG9zLCBsZW4pe1xuICB3aGlsZShsZW4gPiAwKXtcbiAgICBpZihjYW1sX2JhX2dldF8xKGJzLHBvcykgPT0gY2hyKSByZXR1cm4gcG9zO1xuICAgIHBvcysrO1xuICAgIGxlbi0tO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlciBtdXRhYmxlXG5mdW5jdGlvbiBiaWdzdHJpbmdfdG9fYXJyYXlfYnVmZmVyKGJzKSB7XG4gIHJldHVybiBicy5kYXRhLmJ1ZmZlclxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2Zyb21cbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl9hcnJheV9idWZmZXIoYWIpIHtcbiAgdmFyIHRhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkoYWIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfZnJvbSh0YSwgbnVsbCwgMCwgMTIsIDAsIFt0YS5sZW5ndGhdKVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWFyc2hhbF9kYXRhX3NpemVfc3R1YiBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JhX3VpbnQ4X2dldDMyXG5mdW5jdGlvbiBiaWdzdHJpbmdfbWFyc2hhbF9kYXRhX3NpemVfc3R1YiAocywgb2ZzKSB7XG4gIGlmIChjYW1sX2JhX3VpbnQ4X2dldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGNhbWxfYmFfdWludDhfZ2V0MzIocywgb2ZzICsgNCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfdW5tYXJzaGFsX3N0dWIgbXV0YWJsZVxuLy9SZXF1aXJlczogQmlnU3RyaW5nUmVhZGVyLCBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyXG5mdW5jdGlvbiBiaWdzdHJpbmdfdW5tYXJzaGFsX3N0dWIocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBCaWdTdHJpbmdSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19tYXJzaGFsX3N0dWIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBiaWdzdHJpbmdfYWxsb2MsIGNhbWxfYmFfc2V0XzFcbmZ1bmN0aW9uIGJpZ3N0cmluZ19tYXJzaGFsX3N0dWIgKHYsIF9mbCkge1xuICAvKiBpZ25vcmVzIGZsYWdzLi4uICovXG4gIHZhciBhcnIgPSBjYW1sX291dHB1dF92YWwgKHYpO1xuICB2YXIgYnMgID0gYmlnc3RyaW5nX2FsbG9jKDAsYXJyLmxlbmd0aCk7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgIGNhbWxfYmFfc2V0XzEoYnMsIGksIGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIGJzO1xufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfbWFyc2hhbF9ibGl0X3N0dWJcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9mYWlsd2l0aCwgY2FtbF9iYV9zZXRfMVxuZnVuY3Rpb24gYmlnc3RyaW5nX21hcnNoYWxfYmxpdF9zdHViIChzLCBvZnMsIGxlbiwgdiwgX2ZsKSB7XG4gIC8qIGlnbm9yZXMgZmxhZ3MuLi4gKi9cbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspe1xuICAgIGNhbWxfYmFfc2V0XzEocywgKGkgKyBvZnMpLCB0W2ldKTtcbiAgfVxuICByZXR1cm4gdC5sZW5ndGg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X3N0cmluZ19hcnJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nKGgsIGJzKSB7XG4gICAgcmV0dXJuIGNhbWxfaGFzaF9taXhfc3RyaW5nX2FycihoLGJzLmRhdGEpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgbGlicmFyeVxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEpzbGliXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfcHVyZV9leHByIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX3B1cmVfZXhwciAoZikgeyByZXR1cm4gZigpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfc2V0IChtdXRhYmxlLCBjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3NldChvLGYsdikgeyBvW2ZdPXY7cmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2dldCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2dldChvLGYpIHsgcmV0dXJuIG9bZl07IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZGVsZXRlIChtdXRhYmxlLCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZGVsZXRlKG8sZikgeyBkZWxldGUgb1tmXTsgcmV0dXJuIDB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaW5zdGFuY2VvZiAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19pbnN0YW5jZW9mKG8sYykgeyByZXR1cm4gbyBpbnN0YW5jZW9mIGM7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc190eXBlb2YgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc190eXBlb2YobykgeyByZXR1cm4gdHlwZW9mIG87IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19vbl9pZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19vbl9pZSAoKSB7XG4gIHZhciB1YSA9XG4gICAgam9vX2dsb2JhbF9vYmplY3QubmF2aWdhdG9yP2pvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvci51c2VyQWdlbnQ6XCJcIjtcbiAgcmV0dXJuIHVhLmluZGV4T2YoXCJNU0lFXCIpICE9IC0xICYmIHVhLmluZGV4T2YoXCJPcGVyYVwiKSAhPSAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZXNjYXBlIGNvbnN0IChjb25zdClcbnZhciBjYW1sX2pzX3JlZ2V4cHMgPSB7IGFtcDovJi9nLCBsdDovPC9nLCBxdW90Oi9cXFwiL2csIGFsbDovWyY8XFxcIl0vIH07XG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZXNjYXBlIChzKSB7XG4gIGlmICghY2FtbF9qc19yZWdleHBzLmFsbC50ZXN0KHMpKSByZXR1cm4gcztcbiAgcmV0dXJuIHMucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMuYW1wLCBcIiZhbXA7XCIpXG4gICAgICAgICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmx0LCBcIiZsdDtcIilcbiAgICAgICAgICAucmVwbGFjZShjYW1sX2pzX3JlZ2V4cHMucXVvdCwgXCImcXVvdDtcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfaHRtbF9lbnRpdGllcyBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2h0bWxfZW50aXRpZXMocykge1xuICAgIHZhciBzdHIsIHRlbXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgdGVtcC5pbm5lckhUTUw9IHM7XG4gICAgc3RyPSB0ZW1wLnRleHRDb250ZW50IHx8IHRlbXAuaW5uZXJUZXh0O1xuICAgIHRlbXA9bnVsbDtcbiAgICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuZnVuY3Rpb24ganNfcHJpbnRfc3Rkb3V0KHMpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgLy8gYXMgY29uc29sZSBsb2dnaW5nIGRpc3BsYXkgYSBuZXdsaW5lIGF0IHRoZSBlbmRcbiAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gIHZhciB2ID0gZy5jb25zb2xlO1xuICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbmZ1bmN0aW9uIGpzX3ByaW50X3N0ZGVycihzKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAvLyBEbyBub3Qgb3V0cHV0IHRoZSBsYXN0IFxcbiBpZiBwcmVzZW50XG4gIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgIHMgPSBzLnN1YnN0cigwLHMubGVuZ3RoIC0gMSApO1xuICB2YXIgdiA9IGcuY29uc29sZTtcbiAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfY29uc3RhbnRzXG52YXIgY2FtbF9tYXJzaGFsX2NvbnN0YW50cyA9IHtcbiAgUFJFRklYX1NNQUxMX0JMT0NLOiAgICAgICAgIDB4ODAsXG4gIFBSRUZJWF9TTUFMTF9JTlQ6ICAgICAgICAgICAweDQwLFxuICBQUkVGSVhfU01BTExfU1RSSU5HOiAgICAgICAgMHgyMCxcbiAgQ09ERV9JTlQ4OiAgICAgICAgICAgICAgICAgIDB4MDAsXG4gIENPREVfSU5UMTY6ICAgICAgICAgICAgICAgICAweDAxLFxuICBDT0RFX0lOVDMyOiAgICAgICAgICAgICAgICAgMHgwMixcbiAgQ09ERV9JTlQ2NDogICAgICAgICAgICAgICAgIDB4MDMsXG4gIENPREVfU0hBUkVEODogICAgICAgICAgICAgICAweDA0LFxuICBDT0RFX1NIQVJFRDE2OiAgICAgICAgICAgICAgMHgwNSxcbiAgQ09ERV9TSEFSRUQzMjogICAgICAgICAgICAgIDB4MDYsXG4gIENPREVfQkxPQ0szMjogICAgICAgICAgICAgICAweDA4LFxuICBDT0RFX0JMT0NLNjQ6ICAgICAgICAgICAgICAgMHgxMyxcbiAgQ09ERV9TVFJJTkc4OiAgICAgICAgICAgICAgIDB4MDksXG4gIENPREVfU1RSSU5HMzI6ICAgICAgICAgICAgICAweDBBLFxuICBDT0RFX0RPVUJMRV9CSUc6ICAgICAgICAgICAgMHgwQixcbiAgQ09ERV9ET1VCTEVfTElUVExFOiAgICAgICAgIDB4MEMsXG4gIENPREVfRE9VQkxFX0FSUkFZOF9CSUc6ICAgICAweDBELFxuICBDT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOiAgMHgwRSxcbiAgQ09ERV9ET1VCTEVfQVJSQVkzMl9CSUc6ICAgIDB4MEYsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfTElUVExFOiAweDA3LFxuICBDT0RFX0NPREVQT0lOVEVSOiAgICAgICAgICAgMHgxMCxcbiAgQ09ERV9JTkZJWFBPSU5URVI6ICAgICAgICAgIDB4MTEsXG4gIENPREVfQ1VTVE9NOiAgICAgICAgICAgICAgICAweDEyXG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1JlYWRlclxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBNbEJ5dGVzUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sQnl0ZXNSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5zLmNoYXJDb2RlQXQodGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQgPj4gMTYpIHwgcy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgocy5jaGFyQ29kZUF0KGkpIDw8IDI0KSB8IChzLmNoYXJDb2RlQXQoaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKHMuY2hhckNvZGVBdChpKzIpIDw8IDgpIHwgcy5jaGFyQ29kZUF0KGkrMykpID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgbGVuO1xuICAgIHJldHVybiBjYW1sX25ld19zdHJpbmcodGhpcy5zLnN1YnN0cmluZyhpLCBpICsgbGVuKSk7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogQmlnU3RyaW5nUmVhZGVyXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9iYV9nZXRfMVxuZnVuY3Rpb24gQmlnU3RyaW5nUmVhZGVyIChicywgaSkgeyB0aGlzLnMgPSBiczsgdGhpcy5pID0gaTsgfVxuQmlnU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbWxfYmFfZ2V0XzEodGhpcy5zLHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgOCkgfCBjYW1sX2JhX2dldF8xKHMsaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAoY2FtbF9iYV9nZXRfMShzLGkpIDw8IDI0ID4+IDE2KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpICAgICAgICAgKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgICA8PCAyNCkgfCAoY2FtbF9iYV9nZXRfMShzLGkrMSkgPDwgMTYpIHxcblx0ICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sQnl0ZXNSZWFkZXIgKHMsIHR5cGVvZiBvZnM9PVwibnVtYmVyXCI/b2ZzOm9mc1swXSk7XG4gIHJldHVybiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxCeXRlc1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlclxuZnVuY3Rpb24gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX2J5dGVzKHMsb2ZzKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgTWxCeXRlc1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9SZXF1aXJlczogY2FtbF9mbG9hdF9vZl9ieXRlcywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICAgIHZhciBjLCBzID0gXCJcIjtcbiAgICAgICAgICB3aGlsZSAoKGMgPSByZWFkZXIucmVhZDh1ICgpKSAhPSAwKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGMpO1xuICAgICAgICAgIHN3aXRjaChzKSB7XG4gICAgICAgICAgY2FzZSBcIl9qXCI6XG4gICAgICAgICAgICAvLyBJbnQ2NFxuICAgICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdmFyIHYgPSBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGNhc2UgXCJfaVwiOlxuICAgICAgICAgICAgLy8gSW50MzJcbiAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBjYXNlIFwiX25cIjpcbiAgICAgICAgICAgIC8vIE5hdGl2ZWludFxuICAgICAgICAgICAgc3dpdGNoIChyZWFkZXIucmVhZDh1ICgpKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWQzMnMgKCk7XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbGwtZm9ybWVkIG5hdGl2ZSBpbnRlZ2VyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGggKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgcmVzID0gaW50ZXJuX3JlYyAoKTtcbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc2l6ZSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGQgPSB2Lmxlbmd0aDtcbiAgICBpZiAoZCA8IHNpemUpIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgdltkXSA9IGludGVybl9yZWMgKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZnMhPVwibnVtYmVyXCIpIG9mc1swXSA9IHJlYWRlci5pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAocywgb2ZzKSB7XG4gIGZ1bmN0aW9uIGdldDMyKHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkpIDw8IDI0KSB8XG4gICAgICAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDIpIDw8IDgpIHxcbiAgICAgICAgICAgIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLCBpICsgMyk7XG4gIH1cbiAgaWYgKGdldDMyKHMsIG9mcykgIT0gKDB4ODQ5NUE2QkV8MCkpXG4gICAgY2FtbF9mYWlsd2l0aChcIk1hcnNoYWwuZGF0YV9zaXplOiBiYWQgb2JqZWN0XCIpO1xuICByZXR1cm4gKGdldDMyKHMsIG9mcyArIDQpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IE1sQnl0ZXMsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxudmFyIGNhbWxfb3V0cHV0X3ZhbCA9IGZ1bmN0aW9uICgpe1xuICBmdW5jdGlvbiBXcml0ZXIgKCkgeyB0aGlzLmNodW5rID0gW107IH1cbiAgV3JpdGVyLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua19pZHg6MjAsIGJsb2NrX2xlbjowLCBvYmpfY291bnRlcjowLCBzaXplXzMyOjAsIHNpemVfNjQ6MCxcbiAgICB3cml0ZTpmdW5jdGlvbiAoc2l6ZSwgdmFsdWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIHdyaXRlX2NvZGU6ZnVuY3Rpb24gKHNpemUsIGNvZGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gY29kZTtcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3RoaXMuY2h1bmtfaWR4KytdID0gKHZhbHVlID4+IGkpICYgMHhGRjtcbiAgICB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZ1bmN0aW9uIGV4dGVybl9yZWMgKHYpIHtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgQXJyYXkgJiYgdlswXSA9PT0gKHZbMF18MCkpIHtcbiAgICAgICAgaWYgKHZbMF0gPT0gMjU1KSB7XG4gICAgICAgICAgLy8gSW50NjRcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHdyaXRlci53cml0ZSAoOCwgXCJfalxcMFwiLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHZhciBiID0gY2FtbF9pbnQ2NF90b19ieXRlcyAodik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHdyaXRlci53cml0ZSAoOCwgYltpXSk7XG4gICAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gNDtcbiAgICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAzO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2WzBdIDwgMTYgJiYgdi5sZW5ndGggLSAxIDwgOClcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8gKyB2WzBdICsgKCh2Lmxlbmd0aCAtIDEpPDw0KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgzMiwgMHgwOCAvKmNzdC5DT0RFX0JMT0NLMzIqLywgKCh2Lmxlbmd0aC0xKSA8PCAxMCkgfCB2WzBdKTtcbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gdi5sZW5ndGg7XG4gICAgICAgIHdyaXRlci5zaXplXzY0ICs9IHYubGVuZ3RoO1xuICAgICAgICBpZiAodi5sZW5ndGggPiAxKSBzdGFjay5wdXNoICh2LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIE1sQnl0ZXMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4vL1xuLy8gSWYgYSBmbG9hdCBoYXBwZW5zIHRvIGJlIGFuIGludGVnZXIgaXQgaXMgc2VyaWFsaXplZCBhcyBhbiBpbnRlZ2VyXG4vLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuLy8gZmxvYXQgb3IgaW50ZWdlci4pIFRoaXMgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGNyYXNoZXMgd2hlblxuLy8gdW5tYXJzaGFsbGluZyB1c2luZyB0aGUgc3RhbmRhcmQgcnVudGltZS4gSXQgc2VlbXMgYmV0dGVyIHRvXG4vLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuLy9cbi8vICAgICAgICAgIGlmKHR5cGVfb2ZfdiAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IGFic3RyYWN0IHZhbHVlIChcIit0eXBlX29mX3YrXCIpXCIpO1xuLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4vLyAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MEIgLypjc3QuQ09ERV9ET1VCTEVfQklHKi8pO1xuLy8gICAgICAgICAgZm9yKHZhciBpID0gMDsgaTw4OyBpKyspe3dyaXRlci53cml0ZSg4LHRbaV0pfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gMCAmJiB2IDwgMHg0MCkge1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMFg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8gKyB2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiA+PSAtKDEgPDwgNykgJiYgdiA8ICgxIDw8IDcpKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoOCwgMHgwMCAvKmNzdC5DT0RFX0lOVDgqLywgdik7XG4gICAgICAgICAgZWxzZSBpZiAodiA+PSAtKDEgPDwgMTUpICYmIHYgPCAoMSA8PCAxNSkpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSgxNiwgMHgwMSAvKmNzdC5DT0RFX0lOVDE2Ki8sIHYpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDMyLCAweDAyIC8qY3N0LkNPREVfSU5UMzIqLywgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXh0ZXJuX3JlYyAodik7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBpID0gc3RhY2sucG9wICgpO1xuICAgICAgdmFyIHYgPSBzdGFjay5wb3AgKCk7XG4gICAgICBpZiAoaSArIDEgPCB2Lmxlbmd0aCkgc3RhY2sucHVzaCAodiwgaSArIDEpO1xuICAgICAgZXh0ZXJuX3JlYyAodltpXSk7XG4gICAgfVxuICAgIHdyaXRlci5maW5hbGl6ZSAoKTtcbiAgICByZXR1cm4gd3JpdGVyLmNodW5rO1xuICB9XG59ICgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX3N0cmluZ19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nICh2LCBfZmwpIHtcbiAgLyogaWdub3JlcyBmbGFncy4uLiAqL1xuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGNhbWxfb3V0cHV0X3ZhbCAodikpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZV90b19ieXRlcyAodiwgX2ZsKSB7XG4gIC8qIGlnbm9yZXMgZmxhZ3MuLi4gKi9cbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWwsIGNhbWxfZmFpbHdpdGgsIGNhbWxfYmxpdF9ieXRlc1xuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnVmZmVyIChzLCBvZnMsIGxlbiwgdiwgX2ZsKSB7XG4gIC8qIGlnbm9yZXMgZmxhZ3MuLi4gKi9cbiAgdmFyIHQgPSBjYW1sX291dHB1dF92YWwgKHYpO1xuICBpZiAodC5sZW5ndGggPiBsZW4pIGNhbWxfZmFpbHdpdGggKFwiTWFyc2hhbC50b19idWZmZXI6IGJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgY2FtbF9ibGl0X2J5dGVzKHQsIDAsIHMsIG9mcywgdC5sZW5ndGgpO1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHsgcmV0dXJuIHMudG9TdHJpbmcoKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG4vL1JlcXVpcmVzOiByYXdfYXJyYXlfc3ViXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkgeyByZXR1cm4gcmF3X2FycmF5X3N1YihhLDEsYS5sZW5ndGgtMSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbi8vUmVxdWlyZXM6IHJhd19hcnJheV9jb25zXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2FycmF5KGEpIHsgcmV0dXJuIHJhd19hcnJheV9jb25zKGEsMCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc192YXIgbXV0YWJsZSAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdmFyKHgpIHtcbiAgdmFyIHggPSB4LnRvU3RyaW5nKCk7XG4gIC8vQ2hlY2tzIHRoYXQgeCBoYXMgdGhlIGZvcm0gaWRlbnRbLmlkZW50XSpcbiAgaWYoIXgubWF0Y2goL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSooXFwuW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKSokLykpe1xuICAgIGpzX3ByaW50X3N0ZGVycihcImNhbWxfanNfdmFyOiBcXFwiXCIgKyB4ICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIEphdmFTY3JpcHQgdmFyaWFibGUuIGNvbnRpbnVpbmcgLi5cIik7XG4gICAgLy9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLmVycm9yKFwiSnMuVW5zYWZlLmV2YWxfc3RyaW5nXCIpXG4gIH1cbiAgcmV0dXJuIGV2YWwoeCk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2NhbGwgKGNvbnN0LCBtdXRhYmxlLCBzaGFsbG93KVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX2NhbGwoZiwgbywgYXJncykgeyByZXR1cm4gZi5hcHBseShvLCBjYW1sX2pzX2Zyb21fYXJyYXkoYXJncykpOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Z1bl9jYWxsIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19mdW5fY2FsbChmLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAxOiByZXR1cm4gZigpO1xuICBjYXNlIDI6IHJldHVybiBmIChhWzFdKTtcbiAgY2FzZSAzOiByZXR1cm4gZiAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdKTtcbiAgY2FzZSA2OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBmIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSxhWzddKTtcbiAgfVxuICByZXR1cm4gZi5hcHBseShudWxsLCBjYW1sX2pzX2Zyb21fYXJyYXkoYSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19tZXRoX2NhbGwgKG11dGFibGUsIGNvbnN0LCBzaGFsbG93KVxuLy9SZXF1aXJlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2pzX21ldGhfY2FsbChvLCBmLCBhcmdzKSB7XG4gIHJldHVybiBvW2YudG9TdHJpbmcoKV0uYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbmV3IChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19uZXcoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDI6IHJldHVybiBuZXcgYyAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10pO1xuICBjYXNlIDU6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0pO1xuICBjYXNlIDg6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgY2FtbF9qc19mcm9tX2FycmF5KGEpKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX29qc19uZXdfYXJyIChjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9vanNfbmV3X2FycihjLCBhKSB7XG4gIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgY2FzZSAwOiByZXR1cm4gbmV3IGM7XG4gIGNhc2UgMTogcmV0dXJuIG5ldyBjIChhWzBdKTtcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMF0sYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgfVxuICBmdW5jdGlvbiBGKCkgeyByZXR1cm4gYy5hcHBseSh0aGlzLCBhKTsgfVxuICBGLnByb3RvdHlwZSA9IGMucHJvdG90eXBlO1xuICByZXR1cm4gbmV3IEY7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMCl7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY2FtbF9qc193cmFwX2NhbGxiYWNrKGYpKGFyZ3VtZW50cyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSkgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICYmIGkgPCBhcml0eTsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2sgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlbixyYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2soZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYscmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfYXJndW1lbnRzIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4scmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZixbdGhpcyxhcmd1bWVudHNdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuLCByYXdfYXJyYXlfY29uc1xuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0KGFyaXR5LCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmKG4gPT0gYXJpdHkpIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIHJhd19hcnJheV9jb25zKGFyZ3VtZW50cyx0aGlzKSk7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJpdHkgKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG4gJiYgaSA8PSBhcml0eTsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICB9O1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW4scmF3X2FycmF5X2NvbnNcbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX3Vuc2FmZShmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7IGYuYXBwbHkobnVsbCwgcmF3X2FycmF5X2NvbnMoYXJndW1lbnRzLHRoaXMpKTsgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc19lcXVhbHMgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19lcXVhbHMgKHgsIHkpIHsgcmV0dXJuICsoeCA9PSB5KTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19ieXRlX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9uZXdfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2J5dGVfc3RyaW5nIChzKSB7cmV0dXJuIGNhbWxfbmV3X3N0cmluZyAocyk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V2YWxfc3RyaW5nIChjb25zdClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfZXZhbF9zdHJpbmcgKHMpIHtyZXR1cm4gZXZhbChzLnRvU3RyaW5nKCkpO31cblxuLy9Qcm92aWRlczogY2FtbF9qc19leHByIChjb25zdClcbi8vUmVxdWlyZXM6IGpzX3ByaW50X3N0ZGVyclxuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9qc19leHByKHMpIHtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9qc19leHByOiBmYWxsYmFjayB0byBydW50aW1lIGV2YWx1YXRpb25cIik7XG4gIHJldHVybiBldmFsKHMudG9TdHJpbmcoKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3B1cmVfanNfZXhwciBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcHVyZV9qc19leHByIChzKXtcbiAganNfcHJpbnRfc3RkZXJyKFwiY2FtbF9wdXJlX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblwiKTtcbiAgcmV0dXJuIGV2YWwocy50b1N0cmluZygpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfb2JqZWN0IChvYmplY3RfbGl0ZXJhbClcbi8vUmVxdWlyZXM6IE1sQnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfb2JqZWN0IChhKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gYVtpXTtcbiAgICBvW3BbMV0udG9TdHJpbmcoKV0gPSBwWzJdO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwb3J0X3ZhclxuZnVuY3Rpb24gY2FtbF9qc19leHBvcnRfdmFyICgpe1xuICBpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzXG4gIGVsc2VcbiAgICByZXR1cm4gam9vX2dsb2JhbF9vYmplY3Q7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIElvXG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2Nsb3NlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3N5c19jbG9zZShmZCkge1xuICBkZWxldGUgY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmcsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9zdGRfb3V0cHV0KGNoYW5pZCxzKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBzdHIgPSBjYW1sX25ld19zdHJpbmcocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lLnRvU3RyaW5nKCkgKyBcIiA6IGZsYWdzIE9wZW5fcmRvbmx5IGFuZCBPcGVuX3dyb25seSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIGlmKGYudGV4dCAmJiBmLmJpbmFyeSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihuYW1lLnRvU3RyaW5nKCkgKyBcIiA6IGZsYWdzIE9wZW5fdGV4dCBhbmQgT3Blbl9iaW5hcnkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LGYpO1xuICB2YXIgaWR4ID0gY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeD9jYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4OjA7XG4gIHJldHVybiBjYW1sX3N5c19vcGVuX2ludGVybmFsIChpZHgrMSxjYW1sX3N0ZF9vdXRwdXQsZmlsZSxmKTtcbn1cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMCxjYW1sX3N0ZF9vdXRwdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkaW5cbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMSxqc19wcmludF9zdGRvdXQsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3Rkb3V0XG5jYW1sX3N5c19vcGVuX2ludGVybmFsKDIsanNfcHJpbnRfc3RkZXJyLCBuZXcgTWxGYWtlRmlsZShjYW1sX2NyZWF0ZV9ieXRlcygwKSkpOyAvL3N0ZGVyclxuXG5cbi8vIG9jYW1sIENoYW5uZWxzXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfbmFtZVxuZnVuY3Rpb24gY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lKCkge1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2NoYW5uZWxzXG52YXIgY2FtbF9tbF9jaGFubmVscyA9IG5ldyBBcnJheSgpO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dF9jaGFubmVsc19saXN0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX291dF9jaGFubmVsc19saXN0ICgpIHtcbiAgdmFyIGwgPSAwO1xuICBmb3IodmFyIGMgPSAwOyBjIDwgY2FtbF9tbF9jaGFubmVscy5sZW5ndGg7IGMrKyl7XG4gICAgaWYoY2FtbF9tbF9jaGFubmVsc1tjXSAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm9wZW5lZCAmJiBjYW1sX21sX2NoYW5uZWxzW2NdLm91dClcbiAgICAgIGw9WzAsY2FtbF9tbF9jaGFubmVsc1tjXS5mZCxsXTtcbiAgfVxuICByZXR1cm4gbDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXQgKGZkKSB7XG4gIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbZmRdO1xuICBpZihkYXRhLmZsYWdzLnJkb25seSkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJmZCBcIisgZmQgKyBcIiBpcyByZWFkb25seVwiKTtcbiAgdmFyIGNoYW5uZWwgPSB7XG4gICAgZmlsZTpkYXRhLmZpbGUsXG4gICAgb2Zmc2V0OmRhdGEub2Zmc2V0LFxuICAgIGZkOmZkLFxuICAgIG9wZW5lZDp0cnVlLFxuICAgIG91dDp0cnVlLFxuICAgIGJ1ZmZlcjpcIlwiXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLGNhbWxfc3lzX29wZW4sY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIChmZCkgIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3Mud3Jvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHdyaXRlb25seVwiKTtcblxuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OiBmYWxzZSxcbiAgICByZWZpbGw6bnVsbFxuICB9O1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5uZWwuZmRdPWNoYW5uZWw7XG4gIHJldHVybiBjaGFubmVsLmZkO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZShjaGFuaWQsbW9kZSl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdO1xuICBkYXRhLmZsYWdzLnRleHQgPSAhbW9kZVxuICBkYXRhLmZsYWdzLmJpbmFyeSA9IG1vZGVcbiAgcmV0dXJuIDA7XG59XG5cbi8vSW5wdXQgZnJvbSBpbl9jaGFubmVsXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2xvc2VfY2hhbm5lbFxuLy9SZXF1aXJlczogY2FtbF9tbF9mbHVzaCwgY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9zeXNfY2xvc2VcbmZ1bmN0aW9uIGNhbWxfbWxfY2xvc2VfY2hhbm5lbCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNoYW4ub3BlbmVkID0gZmFsc2U7XG4gIGNoYW4uZmlsZS5jbG9zZSgpO1xuICBjYW1sX3N5c19jbG9zZShjaGFuLmZkKVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNoYW4uZmlsZS5sZW5ndGgoKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9jaGFubmVsX3NpemVfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9jaGFubmVsX3NpemVfNjQoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjaGFuLmZpbGUubGVuZ3RoICgpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0KGNoYW5pZCxmKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsKGNoYW5pZCxmKSB7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5yZWZpbGwgPSBmO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbikge1xuICB2YXIgc3RyID0gY2hhbi5yZWZpbGwoKTtcbiAgdmFyIHN0cl9sZW4gPSBjYW1sX21sX2J5dGVzX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG5cbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKDgpO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCw4KTtcblxuICAvLyBIZWFkZXIgaXMgMjAgYnl0ZXNcbiAgdmFyIGxlbiA9IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgKGJ1ZiwgMCkgKyAyMDtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKTtcbiAgY2hhbi5maWxlLnJlYWQoY2hhbi5vZmZzZXQsYnVmLDAsbGVuKTtcblxuICB2YXIgb2Zmc2V0ID0gWzBdO1xuICB2YXIgcmVzID0gY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3N0cmluZyhidWYsIG9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0ID0gY2hhbi5vZmZzZXQgKyBvZmZzZXRbMF07XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2NoYXIgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIGlmIChjaGFuLm9mZnNldCA+PSBjaGFuLmZpbGUubGVuZ3RoKCkpXG4gICAgY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSgpO1xuICB2YXIgcmVzID0gY2hhbi5maWxlLnJlYWRfb25lKGNoYW4ub2Zmc2V0KTtcbiAgY2hhbi5vZmZzZXQrKztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9pbnRcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X2ludCAoY2hhbmlkKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICB2YXIgZmlsZSA9IGNoYW4uZmlsZTtcbiAgd2hpbGUgKChjaGFuLm9mZnNldCArIDMpID49IGZpbGUubGVuZ3RoKCkpIHtcbiAgICB2YXIgbCA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICAgIGlmIChsID09IDApIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgfVxuICB2YXIgbyA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgciA9KGZpbGUucmVhZF9vbmUobyAgKSA8PCAyNClcbiAgICAgIHwgIChmaWxlLnJlYWRfb25lKG8rMSkgPDwgMTYpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzIpIDw8IDgpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzMpKTtcbiAgY2hhbi5vZmZzZXQrPTQ7XG4gIHJldHVybiByO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfaW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfaW4oY2hhbmlkLHBvcyl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZiAoY2hhbi5yZWZpbGwgIT0gbnVsbCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJJbGxlZ2FsIHNlZWtcIik7XG4gIGNoYW4ub2Zmc2V0ID0gcG9zO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luXzY0KGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IGNhbWxfaW50NjRfdG9fZmxvYXQocG9zKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbihjaGFuaWQpIHtyZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldH1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3NfaW5fNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX2luXzY0KGNoYW5pZCkge3JldHVybiBjYW1sX2ludDY0X29mX2Zsb2F0KGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQpfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X3NjYW5fbGluZVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0X3NjYW5fbGluZShjaGFuaWQpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9tYXlfcmVmaWxsX2lucHV0KGNoYW5pZCk7XG4gIHZhciBwID0gY2hhbi5vZmZzZXQ7XG4gIHZhciBsZW4gPSBjaGFuLmZpbGUubGVuZ3RoKCk7XG4gIGlmKHAgPj0gbGVuKSB7IHJldHVybiAwO31cbiAgd2hpbGUodHJ1ZSkge1xuICAgIGlmKHAgPj0gbGVuKSByZXR1cm4gLSAocCAtIGNoYW4ub2Zmc2V0KTtcbiAgICBpZihjaGFuLmZpbGUucmVhZF9vbmUocCkgPT0gMTApIHJldHVybiBwIC0gY2hhbi5vZmZzZXQgKyAxO1xuICAgIHArKztcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2ZsdXNoXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9mbHVzaCAoY2hhbmlkKSB7XG4gICAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gICAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgICBpZighY2hhbi5idWZmZXIgfHwgY2hhbi5idWZmZXIgPT0gXCJcIikgcmV0dXJuIDA7XG4gICAgaWYoY2hhbi5mZFxuICAgICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICAgJiYgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0O1xuICAgICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgICAgY2FzZSAyOiBvdXRwdXQoY2hhbmlkLGNoYW4uYnVmZmVyKTticmVhaztcbiAgICAgIGRlZmF1bHQ6IG91dHB1dChjaGFuLmJ1ZmZlcilcbiAgICAgIH07XG4gICAgfVxuICAgIGNoYW4uYnVmZmVyID0gXCJcIjtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsYnVmZmVyLG9mZnNldCxsZW4pIHtcbiAgICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgICB2YXIgc3RyaW5nO1xuICAgIGlmKG9mZnNldCA9PSAwICYmIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ1ZmZlcikgPT0gbGVuKVxuICAgICAgICBzdHJpbmcgPSBidWZmZXI7XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmluZyA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LHN0cmluZywwLGxlbik7XG4gICAgfVxuICAgIHZhciBqc3N0cmluZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoc3RyaW5nKTtcbiAgICB2YXIgaWQgPSBqc3N0cmluZy5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICBpZihpZCA8IDApXG4gICAgICAgIGNoYW4uYnVmZmVyKz1qc3N0cmluZztcbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nLnN1YnN0cigwLGlkKzEpO1xuICAgICAgICBjYW1sX21sX2ZsdXNoIChjaGFuaWQpO1xuICAgICAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gICAgcmV0dXJuIGNhbWxfbWxfb3V0cHV0X2J5dGVzKGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX25ld19zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gICAgdmFyIHMgPSBjYW1sX25ld19zdHJpbmcoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZywgY2FtbF9tbF9vdXRwdXQsY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX291dHB1dF92YWx1ZSAoY2hhbmlkLHYsX2ZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYpO1xuICBjYW1sX21sX291dHB1dChjaGFuaWQscywwLGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSk7XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19vdXQoY2hhbmlkLHBvcyl7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0ID0gY2FtbF9pbnQ2NF90b19mbG9hdChwb3MpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9wb3Nfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19vdXQoY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX291dF82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9mbG9hdCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3Nfb3V0XzY0KGNoYW5pZCkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19zZXQoeCwgaSwgdikge1xuICAgIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLnNldFwiKTtcbiAgICB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gPSB2O1xuICAgIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gICAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcIldlYWsuZ2V0X2tleVwiKTtcbiAgICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2NoZWNrIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX3dlYWtfY2hlY2soeCwgaSkge1xuICBpZih4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0hPT11bmRlZmluZWQgJiYgeFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldICE9PTApXG4gICAgcmV0dXJuIDE7XG4gIGVsc2VcbiAgICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2JsaXRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgLy8gbWludXMgb25lIGJlY2F1c2UgY2FtbF9hcnJheV9ibGl0IHdvcmtzIG9uIG9jYW1sIGFycmF5XG4gIGNhbWxfYXJyYXlfYmxpdChhMSwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMSAtIDEsXG4gICAgICAgICAgICAgICAgICBhMiwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpMiAtIDEsXG4gICAgICAgICAgICAgICAgICBsZW4pO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NyZWF0ZVxudmFyIGNhbWxfZXBoZV9jcmVhdGUgPSBjYW1sX3dlYWtfY3JlYXRlXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9ibGl0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2JsaXRcbnZhciBjYW1sX2VwaGVfYmxpdF9rZXkgPSBjYW1sX3dlYWtfYmxpdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2dldFxudmFyIGNhbWxfZXBoZV9nZXRfa2V5ID0gY2FtbF93ZWFrX2dldFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0X2NvcHlcbnZhciBjYW1sX2VwaGVfZ2V0X2tleV9jb3B5ID0gY2FtbF93ZWFrX2dldF9jb3B5XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19jaGVja1xudmFyIGNhbWxfZXBoZV9jaGVja19rZXkgPSBjYW1sX3dlYWtfY2hlY2tcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX3NldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfa2V5KHgsIGksIHYpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgWzAsIHZdKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfc2V0XG5mdW5jdGlvbiBjYW1sX2VwaGVfdW5zZXRfa2V5KHgsIGkpIHtcbiAgcmV0dXJuIGNhbWxfd2Vha19zZXQoeCwgaSwgMClcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9ibGl0X2RhdGEoc3JjLCBkc3Qpe1xuICBkc3RbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHNyY1tjYW1sX2VwaGVfZGF0YV9vZmZzZXRdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9SZXF1aXJlczogY2FtbF9vYmpfZHVwXG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5KHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiBbMCwgY2FtbF9vYmpfZHVwKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IGRhdGE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfdW5zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9kYXRhKHgsIGRhdGEpe1xuICB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPSB1bmRlZmluZWQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY2hlY2tfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9jaGVja19kYXRhKHgpe1xuICBpZih4W2NhbWxfZXBoZV9kYXRhX29mZnNldF0gPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiAxO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgbGV4ZXIgYW5kIHVwZGF0ZXMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzeW1iX3N0YXJ0IGFuZCBzeW1iX2VuZCAqL1xuICAgIGNhc2UgMTovL1RPS0VOX1JFQUQ6XG4gICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfYmxvY2tdW2FyZ1swXSArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gYXJnWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gdGFibGVzW3RibF90cmFuc2xfY29uc3RdW2FyZyArIDFdO1xuICAgICAgICBlbnZbZW52X2x2YWxdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSA3Oi8vdGVzdHNoaWZ0OlxuICAgICAgbjEgPSB0YWJsZXMuc2luZGV4W3N0YXRlXTtcbiAgICAgIG4yID0gbjEgKyBlbnZbZW52X2N1cnJfY2hhcl07XG4gICAgICBpZiAobjEgIT0gMCAmJiBuMiA+PSAwICYmIG4yIDw9IHRhYmxlc1t0YmxfdGFibGVzaXplXSAmJlxuICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gZW52W2Vudl9jdXJyX2NoYXJdKSB7XG4gICAgICAgIGNtZCA9IHNoaWZ0OyBicmVhaztcbiAgICAgIH1cbiAgICAgIG4xID0gdGFibGVzLnJpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBuID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgICAgY21kID0gcmVkdWNlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChlcnJmbGFnIDw9IDApIHtcbiAgICAgICAgcmVzID0gQ0FMTF9FUlJPUl9GVU5DVElPTjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIE1MIGNvZGUgcmFpc2VzIFBhcnNlX2Vycm9yICovXG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IC0xO1xuICAgICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgODovL3NoaWZ0OlxuICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICBpZiAoZXJyZmxhZyA+IDApIGVycmZsYWctLTtcbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgIGNhc2UgOTovL3NoaWZ0X3JlY292ZXI6XG4gICAgICBzdGF0ZSA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICBzcCsrO1xuICAgICAgaWYgKHNwID49IGVudltlbnZfc3RhY2tzaXplXSkge1xuICAgICAgICByZXMgPSBHUk9XX1NUQUNLU18xO1xuICAgICAgICBicmVhayBleGl0O1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMzovL1NUQUNLU19HUk9XTl8yOlxuICAgICAgcmVzID0gQ09NUFVURV9TRU1BTlRJQ19BQ1RJT047XG4gICAgICBicmVhayBleGl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBzZW1hbnRpYyBhY3Rpb24gKi9cbiAgICBjYXNlIDQ6Ly9TRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQ6XG4gICAgICBlbnZbZW52X3Nfc3RhY2tdW3NwICsgMV0gPSBzdGF0ZTtcbiAgICAgIGVudltlbnZfdl9zdGFja11bc3AgKyAxXSA9IGFyZztcbiAgICAgIHZhciBhc3AgPSBlbnZbZW52X2FzcF07XG4gICAgICBlbnZbZW52X3N5bWJfZW5kX3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICBpZiAoc3AgPiBhc3ApIHtcbiAgICAgICAgLyogVGhpcyBpcyBhbiBlcHNpbG9uIHByb2R1Y3Rpb24uIFRha2Ugc3ltYl9zdGFydCBlcXVhbCB0byBzeW1iX2VuZC4gKi9cbiAgICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX2VuZF9zdGFja11bYXNwICsgMV07XG4gICAgICB9XG4gICAgICBjbWQgPSBsb29wOyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgamFudWFyeWZpcnN0ID0gbmV3IERhdGUoRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKSk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkIC0gamFudWFyeWZpcnN0KSAvIDg2NDAwMDAwKTtcbiAgcmV0dXJuIFswLCBkLmdldFVUQ1NlY29uZHMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgICBkLmdldFVUQ0RhdGUoKSwgZC5nZXRVVENNb250aCgpLCBkLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTAwLFxuICAgICAgICAgIGQuZ2V0VVRDRGF5KCksIGRveSxcbiAgICAgICAgICBmYWxzZSB8IDAgLyogZm9yIFVUQyBkYXlsaWdodCBzYXZpbmdzIHRpbWUgaXMgZmFsc2UgKi9dXG59XG5cbi8vUHJvdmlkZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X2xvY2FsdGltZSAodCkge1xuICB2YXIgZCA9IG5ldyBEYXRlICh0ICogMTAwMCk7XG4gIHZhciBqYW51YXJ5Zmlyc3QgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZCAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIFswLCBkLmdldFNlY29uZHMoKSwgZC5nZXRNaW51dGVzKCksIGQuZ2V0SG91cnMoKSxcbiAgZC5nZXREYXRlKCksIGQuZ2V0TW9udGgoKSwgZC5nZXRGdWxsWWVhcigpIC0gMTkwMCxcbiAgZC5nZXREYXkoKSwgZG95LFxuICAoZC5nZXRUaW1lem9uZU9mZnNldCgpIDwgc3RkVGltZXpvbmVPZmZzZXQpIHwgMCAvKiBkYXlsaWdodCBzYXZpbmdzIHRpbWUgIGZpZWxkLiAqL11cbn1cblxuLy9Qcm92aWRlczogdW5peF9ta3RpbWVcbi8vUmVxdWlyZXM6IHVuaXhfbG9jYWx0aW1lXG5mdW5jdGlvbiB1bml4X21rdGltZSh0bSl7XG4gICAgdmFyIGQgPSBuZXcgRGF0ZSh0bVs2XSsxOTAwLHRtWzVdLHRtWzRdLHRtWzNdLHRtWzJdLHRtWzFdKTtcbiAgICB2YXIgdCA9IE1hdGguZmxvb3IoZC5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICB2YXIgdG0yID0gdW5peF9sb2NhbHRpbWUodCk7XG4gICAgcmV0dXJuIFswLHQsdG0yXTtcbn1cblxuLy9Qcm92aWRlczogd2luX3N0YXJ0dXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9zdGFydHVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2NsZWFudXAgY29uc3RcbmZ1bmN0aW9uIHdpbl9jbGVhbnVwKCkge31cblxuLy9Qcm92aWRlczogd2luX2hhbmRsZV9mZCBjb25zdFxuZnVuY3Rpb24gd2luX2hhbmRsZV9mZCh4KSB7cmV0dXJuIHg7fVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT17ZnVuOnVuZGVmX21vZHVsZX07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgIHN3aXRjaChzaGFwZSl7XG4gICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICAgIHJlYWwuZnVuID0geDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTovL2xhenlcbiAgICBkZWZhdWx0Oi8vY2FzZSAyOi8vY2xhc3NcbiAgICAgIGNhbWxfdXBkYXRlX2R1bW15KHJlYWwseCk7XG4gICAgfVxuICBlbHNlXG4gICAgc3dpdGNoKHNoYXBlWzBdKXtcbiAgICBjYXNlIDA6Ly9tb2R1bGVcbiAgICAgIGZvcih2YXIgaT0xO2k8c2hhcGVbMV0ubGVuZ3RoO2krKylcbiAgICAgICAgY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZVsxXVtpXSxyZWFsW2ldLHhbaV0pO1xuICAgICAgYnJlYWs7XG4gICAgLy9jYXNlIDE6Ly9WYWx1ZVxuICAgIGRlZmF1bHQ6XG4gICAgfTtcbiAgcmV0dXJuIDBcbn1cbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKi9cbi8qICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKi9cbi8qICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSwgd2l0aCAgICAgKi9cbi8qICB0aGUgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gZmlsZSAuLi9MSUNFTlNFLiAgICAgKi9cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyogJElkOiBsZXhpbmcuYyA2MDQ1IDIwMDQtMDEtMDEgMTY6NDI6NDNaIGRvbGlnZXogJCAqL1xuXG4vKiBUaGUgdGFibGUtZHJpdmVuIGF1dG9tYXRvbiBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4LiAqL1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2xleF9hcnJheVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9sZXhfYXJyYXkocykge1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKTtcbiAgdmFyIGwgPSBzLmxlbmd0aCAvIDI7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICBhW2ldID0gKHMuY2hhckNvZGVBdCgyICogaSkgfCAocy5jaGFyQ29kZUF0KDIgKiBpICsgMSkgPDwgOCkpIDw8IDE2ID4+IDE2O1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfZW5naW5lXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoLCBjYW1sX2xleF9hcnJheSwgY2FtbF9hcnJheV9vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9zdHJpbmcobGV4YnVmW2xleF9idWZmZXJdKTtcblxuICBpZiAoc3RhdGUgPj0gMCkge1xuICAgIC8qIEZpcnN0IGVudHJ5ICovXG4gICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X3N0YXJ0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIC8qIFJlZW50cnkgYWZ0ZXIgcmVmaWxsICovXG4gICAgc3RhdGUgPSAtc3RhdGUgLSAxO1xuICB9XG4gIGZvcig7Oykge1xuICAgIC8qIExvb2t1cCBiYXNlIGFkZHJlc3Mgb3IgYWN0aW9uIG51bWJlciBmb3IgY3VycmVudCBzdGF0ZSAqL1xuICAgIHZhciBiYXNlID0gdGJsLmxleF9iYXNlW3N0YXRlXTtcbiAgICBpZiAoYmFzZSA8IDApIHJldHVybiAtYmFzZS0xO1xuICAgIC8qIFNlZSBpZiBpdCdzIGEgYmFja3RyYWNrIHBvaW50ICovXG4gICAgdmFyIGJhY2t0cmsgPSB0YmwubGV4X2JhY2t0cmtbc3RhdGVdO1xuICAgIGlmIChiYWNrdHJrID49IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBFcmFzZSB0aGUgRU9GIGNvbmRpdGlvbiBvbmx5IGlmIHRoZSBFT0YgcHNldWRvLWNoYXJhY3RlciB3YXNcbiAgICAgICAgIGNvbnN1bWVkIGJ5IHRoZSBhdXRvbWF0b24gKGkuZS4gdGhlcmUgd2FzIG5vIGJhY2t0cmFjayBhYm92ZSlcbiAgICAgICAqL1xuICAgICAgaWYgKGMgPT0gMjU2KSBsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9IDA7XG4gICAgfVxuICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIE5ldyBsZXhlciBlbmdpbmUsIHdpdGggbWVtb3J5IG9mIHBvc2l0aW9ucyAgKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy9Qcm92aWRlczogY2FtbF9uZXdfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmcsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX3N0cmluZyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFzZV9jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICByZXR1cm4gLWJhc2UtMTtcbiAgICB9XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgdmFyIHBjX29mZiA9IHRibC5sZXhfYmFja3Rya19jb2RlW3N0YXRlXTtcbiAgICAgIGNhbWxfbGV4X3J1bl90YWcodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSk7XG4gICAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSBiYWNrdHJrO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgd2UgbmVlZCBhIHJlZmlsbCAqL1xuICAgIGlmIChsZXhidWZbbGV4X2N1cnJfcG9zXSA+PSBsZXhidWZbbGV4X2J1ZmZlcl9sZW5dKXtcbiAgICAgIGlmIChsZXhidWZbbGV4X2VvZl9yZWFjaGVkXSA9PSAwKVxuICAgICAgICByZXR1cm4gLXN0YXRlIC0gMTtcbiAgICAgIGVsc2VcbiAgICAgICAgYyA9IDI1NjtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIFJlYWQgbmV4dCBpbnB1dCBjaGFyICovXG4gICAgICBjID0gYnVmZmVyW2xleGJ1ZltsZXhfY3Vycl9wb3NdXTtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdICsrO1xuICAgIH1cbiAgICAvKiBEZXRlcm1pbmUgbmV4dCBzdGF0ZSAqL1xuICAgIHZhciBwc3RhdGUgPSBzdGF0ZSA7XG4gICAgaWYgKHRibC5sZXhfY2hlY2tbYmFzZSArIGNdID09IHN0YXRlKVxuICAgICAgc3RhdGUgPSB0YmwubGV4X3RyYW5zW2Jhc2UgKyBjXTtcbiAgICBlbHNlXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfZGVmYXVsdFtzdGF0ZV07XG4gICAgLyogSWYgbm8gdHJhbnNpdGlvbiBvbiB0aGlzIGNoYXIsIHJldHVybiB0byBsYXN0IGJhY2t0cmFjayBwb2ludCAqL1xuICAgIGlmIChzdGF0ZSA8IDApIHtcbiAgICAgIGxleGJ1ZltsZXhfY3Vycl9wb3NdID0gbGV4YnVmW2xleF9sYXN0X3Bvc107XG4gICAgICBpZiAobGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPT0gLTEpXG4gICAgICAgIGNhbWxfZmFpbHdpdGgoXCJsZXhpbmc6IGVtcHR5IHRva2VuXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gbGV4YnVmW2xleF9sYXN0X2FjdGlvbl07XG4gICAgfWVsc2V7XG4gICAgICAvKiBJZiBzb21lIHRyYW5zaXRpb24sIGdldCBhbmQgcGVyZm9ybSBtZW1vcnkgbW92ZXMgKi9cbiAgICAgIHZhciBiYXNlX2NvZGUgPSB0YmwubGV4X2Jhc2VfY29kZVtwc3RhdGVdLCBwY19vZmY7XG4gICAgICBpZiAodGJsLmxleF9jaGVja19jb2RlW2Jhc2VfY29kZSArIGNdID09IHBzdGF0ZSlcbiAgICAgICAgcGNfb2ZmID0gdGJsLmxleF90cmFuc19jb2RlW2Jhc2VfY29kZSArIGNdO1xuICAgICAgZWxzZVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X2RlZmF1bHRfY29kZVtwc3RhdGVdO1xuICAgICAgaWYgKHBjX29mZiA+IDApXG4gICAgICAgIGNhbWxfbGV4X3J1bl9tZW1cbiAgICAgICAgICAodGJsLmxleF9jb2RlLCBwY19vZmYsIGxleGJ1ZltsZXhfbWVtXSwgbGV4YnVmW2xleF9jdXJyX3Bvc10pO1xuICAgICAgLyogRXJhc2UgdGhlIEVPRiBjb25kaXRpb24gb25seSBpZiB0aGUgRU9GIHBzZXVkby1jaGFyYWN0ZXIgd2FzXG4gICAgICAgICBjb25zdW1lZCBieSB0aGUgYXV0b21hdG9uIChpLmUuIHRoZXJlIHdhcyBubyBiYWNrdHJhY2sgYWJvdmUpXG4gICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4iLG51bGwsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMCBKw6lyw7RtZSBWb3VpbGxvblxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X2NoYW5cbi8vUmVxdWlyZXM6IGNhbWxfbWQ1X3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfYXJyYXksY2FtbF9tbF9jaGFubmVsc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9lbmRfb2ZfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMgIFxuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoYnVmLDAsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tZDVfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9hcnJheSwgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xudmFyIGNhbWxfbWQ1X3N0cmluZyA9XG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZCAoeCwgeSkgeyByZXR1cm4gKHggKyB5KSB8IDA7IH1cbiAgZnVuY3Rpb24geHgocSxhLGIseCxzLHQpIHtcbiAgICBhID0gYWRkKGFkZChhLCBxKSwgYWRkKHgsIHQpKTtcbiAgICByZXR1cm4gYWRkKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gIH1cbiAgZnVuY3Rpb24gZmYoYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2coYSxiLGMsZCx4LHMsdCkge1xuICAgIHJldHVybiB4eCgoYiAmIGQpIHwgKGMgJiAofmQpKSwgYSwgYiwgeCwgcywgdCk7XG4gIH1cbiAgZnVuY3Rpb24gaGgoYSxiLGMsZCx4LHMsdCkgeyByZXR1cm4geHgoYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTsgfVxuICBmdW5jdGlvbiBpaShhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChjIF4gKGIgfCAofmQpKSwgYSwgYiwgeCwgcywgdCk7IH1cblxuICBmdW5jdGlvbiBtZDUoYnVmZmVyLCBsZW5ndGgpIHtcbiAgICB2YXIgaSA9IGxlbmd0aDtcbiAgICBidWZmZXJbaSA+PiAyXSB8PSAweDgwIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgZm9yIChpID0gKGkgJiB+MHgzKSArIDg7KGkgJiAweDNGKSA8IDYwIDtpICs9IDQpXG4gICAgICBidWZmZXJbKGkgPj4gMikgLSAxXSA9IDA7XG4gICAgYnVmZmVyWyhpID4+IDIpIC0xXSA9IGxlbmd0aCA8PCAzO1xuICAgIGJ1ZmZlcltpID4+IDJdID0gKGxlbmd0aCA+PiAyOSkgJiAweDFGRkZGRkZGO1xuXG4gICAgdmFyIHcgPSBbMHg2NzQ1MjMwMSwgMHhFRkNEQUI4OSwgMHg5OEJBRENGRSwgMHgxMDMyNTQ3Nl07XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICB2YXIgYSA9IHdbMF0sIGIgPSB3WzFdLCBjID0gd1syXSwgZCA9IHdbM107XG5cbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgMF0sIDcsIDB4RDc2QUE0NzgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAxXSwgMTIsIDB4RThDN0I3NTYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyAyXSwgMTcsIDB4MjQyMDcwREIpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAzXSwgMjIsIDB4QzFCRENFRUUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNywgMHhGNTdDMEZBRik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDVdLCAxMiwgMHg0Nzg3QzYyQSk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNywgMHhBODMwNDYxMyk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDddLCAyMiwgMHhGRDQ2OTUwMSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDhdLCA3LCAweDY5ODA5OEQ4KTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgOV0sIDEyLCAweDhCNDRGN0FGKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE3LCAweEZGRkY1QkIxKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsxMV0sIDIyLCAweDg5NUNEN0JFKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDcsIDB4NkI5MDExMjIpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEzXSwgMTIsIDB4RkQ5ODcxOTMpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE0XSwgMTcsIDB4QTY3OTQzOEUpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE1XSwgMjIsIDB4NDlCNDA4MjEpO1xuXG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDFdLCA1LCAweEY2MUUyNTYyKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgNl0sIDksIDB4QzA0MEIzNDApO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTQsIDB4MjY1RTVBNTEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAwXSwgMjAsIDB4RTlCNkM3QUEpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA1XSwgNSwgMHhENjJGMTA1RCk7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTBdLCA5LCAweDAyNDQxNDUzKTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE0LCAweEQ4QTFFNjgxKTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgNF0sIDIwLCAweEU3RDNGQkM4KTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDUsIDB4MjFFMUNERTYpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE0XSwgOSwgMHhDMzM3MDdENik7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNCwgMHhGNEQ1MEQ4Nyk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDhdLCAyMCwgMHg0NTVBMTRFRCk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA1LCAweEE5RTNFOTA1KTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsgMl0sIDksIDB4RkNFRkEzRjgpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTQsIDB4Njc2RjAyRDkpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEyXSwgMjAsIDB4OEQyQTRDOEEpO1xuXG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA0LCAweEZGRkEzOTQyKTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgOF0sIDExLCAweDg3NzFGNjgxKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxMV0sIDE2LCAweDZEOUQ2MTIyKTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsxNF0sIDIzLCAweEZERTUzODBDKTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDQsIDB4QTRCRUVBNDQpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA0XSwgMTEsIDB4NEJERUNGQTkpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA3XSwgMTYsIDB4RjZCQjRCNjApO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEwXSwgMjMsIDB4QkVCRkJDNzApO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEzXSwgNCwgMHgyODlCN0VDNik7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDBdLCAxMSwgMHhFQUExMjdGQSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDNdLCAxNiwgMHhENEVGMzA4NSk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krIDZdLCAyMywgMHgwNDg4MUQwNSk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krIDldLCA0LCAweEQ5RDREMDM5KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsxMl0sIDExLCAweEU2REI5OUU1KTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsxNV0sIDE2LCAweDFGQTI3Q0Y4KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgMl0sIDIzLCAweEM0QUM1NjY1KTtcblxuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNiwgMHhGNDI5MjI0NCk7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krIDddLCAxMCwgMHg0MzJBRkY5Nyk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNSwgMHhBQjk0MjNBNyk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDVdLCAyMSwgMHhGQzkzQTAzOSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krMTJdLCA2LCAweDY1NUI1OUMzKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgM10sIDEwLCAweDhGMENDQzkyKTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxMF0sIDE1LCAweEZGRUZGNDdEKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgMV0sIDIxLCAweDg1ODQ1REQxKTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDYsIDB4NkZBODdFNEYpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzE1XSwgMTAsIDB4RkUyQ0U2RTApO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKyA2XSwgMTUsIDB4QTMwMTQzMTQpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzEzXSwgMjEsIDB4NEUwODExQTEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA0XSwgNiwgMHhGNzUzN0U4Mik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTFdLCAxMCwgMHhCRDNBRjIzNSk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNSwgMHgyQUQ3RDJCQik7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krIDldLCAyMSwgMHhFQjg2RDM5MSk7XG5cbiAgICAgIHdbMF0gPSBhZGQoYSwgd1swXSk7XG4gICAgICB3WzFdID0gYWRkKGIsIHdbMV0pO1xuICAgICAgd1syXSA9IGFkZChjLCB3WzJdKTtcbiAgICAgIHdbM10gPSBhZGQoZCwgd1szXSk7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoMTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgIHRbaSAqIDQgKyBqXSA9ICh3W2ldID4+ICg4ICogaikpICYgMHhGRjtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAocywgb2ZzLCBsZW4pIHtcbiAgICAvLyBGSVg6IG1heWJlIHdlIHNob3VsZCBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBieSBjaHVuayBvZiA2NCBieXRlc1xuICAgIC8vIGFzIGluIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LmpzXG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIHN3aXRjaCAocy50ICYgNikge1xuICAgIGRlZmF1bHQ6XG4gICAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICAgIGNhc2UgMDogLyogQllURVMgKi9cbiAgICAgIHZhciBiID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPVxuICAgICAgICAgIGIuY2hhckNvZGVBdChqKSB8IChiLmNoYXJDb2RlQXQoaisxKSA8PCA4KSB8XG4gICAgICAgICAgKGIuY2hhckNvZGVBdChqKzIpIDw8IDE2KSB8IChiLmNoYXJDb2RlQXQoaiszKSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYi5jaGFyQ29kZUF0KGkgKyBvZnMpIDw8ICg4ICogKGkgJiAzKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6IC8qIEFSUkFZICovXG4gICAgICB2YXIgYSA9IHMuYztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICAgIHZhciBqID0gaSArIG9mcztcbiAgICAgICAgYnVmW2k+PjJdID0gYVtqXSB8IChhW2orMV0gPDwgOCkgfCAoYVtqKzJdIDw8IDE2KSB8IChhW2orM10gPDwgMjQpO1xuICAgICAgfVxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykgYnVmW2k+PjJdIHw9IGFbaSArIG9mc10gPDwgKDggKiAoaSAmIDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KG1kNShidWYsIGxlbikpO1xuICB9XG59ICgpO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICBEYW5pZWwgQy4gQnVlbnpsaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5cbmxldCBlcnJfbm9fcHJlZCA9IFwiVSswMDAwIGhhcyBubyBwcmVkZWNlc3NvclwiXG5sZXQgZXJyX25vX3N1Y2MgPSBcIlUrMTBGRkZGIGhhcyBubyBzdWNjZXNzb3JcIlxubGV0IGVycl9ub3Rfc3YgaSA9IGZvcm1hdF9pbnQgXCIlWFwiIGkgXiBcIiBpcyBub3QgYW4gVW5pY29kZSBzY2FsYXIgdmFsdWVcIlxubGV0IGVycl9ub3RfbGF0aW4xIHUgPSBcIlUrXCIgXiBmb3JtYXRfaW50IFwiJTA0WFwiIHUgXiBcIiBpcyBub3QgYSBsYXRpbjEgY2hhcmFjdGVyXCJcblxudHlwZSB0ID0gaW50XG5cbmxldCBtaW4gPSAweDAwMDBcbmxldCBtYXggPSAweDEwRkZGRlxubGV0IGxvX2JvdW5kID0gMHhEN0ZGXG5sZXQgaGlfYm91bmQgPSAweEUwMDBcblxubGV0IGJvbSA9IDB4RkVGRlxubGV0IHJlcCA9IDB4RkZGRFxuXG5sZXQgc3VjYyB1ID1cbiAgaWYgdSA9IGxvX2JvdW5kIHRoZW4gaGlfYm91bmQgZWxzZVxuICBpZiB1ID0gbWF4IHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3N1Y2MgZWxzZVxuICB1ICsgMVxuXG5sZXQgcHJlZCB1ID1cbiAgaWYgdSA9IGhpX2JvdW5kIHRoZW4gbG9fYm91bmQgZWxzZVxuICBpZiB1ID0gbWluIHRoZW4gaW52YWxpZF9hcmcgZXJyX25vX3ByZWQgZWxzZVxuICB1IC0gMVxuXG5sZXQgaXNfdmFsaWQgaSA9IChtaW4gPD0gaSAmJiBpIDw9IGxvX2JvdW5kKSB8fCAoaGlfYm91bmQgPD0gaSAmJiBpIDw9IG1heClcbmxldCBvZl9pbnQgaSA9IGlmIGlzX3ZhbGlkIGkgdGhlbiBpIGVsc2UgaW52YWxpZF9hcmcgKGVycl9ub3Rfc3YgaSlcbmV4dGVybmFsIHVuc2FmZV9vZl9pbnQgOiBpbnQgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHRvX2ludCA6IHQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfY2hhciB1ID0gdSA8IDI1NlxubGV0IG9mX2NoYXIgYyA9IENoYXIuY29kZSBjXG5sZXQgdG9fY2hhciB1ID1cbiAgaWYgdSA+IDI1NSB0aGVuIGludmFsaWRfYXJnIChlcnJfbm90X2xhdGluMSB1KSBlbHNlXG4gIENoYXIudW5zYWZlX2NociB1XG5cbmxldCB1bnNhZmVfdG9fY2hhciA9IENoYXIudW5zYWZlX2NoclxuXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFBlcnZhc2l2ZXMuY29tcGFyZVxubGV0IGhhc2ggPSB0b19pbnRcbiIsIiMyIFwic3RkbGliL3N5cy5tbHBcIlxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBXQVJOSU5HOiBzeXMubWwgaXMgZ2VuZXJhdGVkIGZyb20gc3lzLm1scC4gIERPIE5PVCBFRElUIHN5cy5tbCBvclxuICAgeW91ciBjaGFuZ2VzIHdpbGwgYmUgbG9zdC5cbiopXG5cbnR5cGUgYmFja2VuZF90eXBlID1cbiAgfCBOYXRpdmVcbiAgfCBCeXRlY29kZVxuICB8IE90aGVyIG9mIHN0cmluZ1xuKCogU3lzdGVtIGludGVyZmFjZSAqKVxuXG5leHRlcm5hbCBnZXRfY29uZmlnOiB1bml0IC0+IHN0cmluZyAqIGludCAqIGJvb2wgPSBcImNhbWxfc3lzX2dldF9jb25maWdcIlxuZXh0ZXJuYWwgZ2V0X2FyZ3Y6IHVuaXQgLT4gc3RyaW5nICogc3RyaW5nIGFycmF5ID0gXCJjYW1sX3N5c19nZXRfYXJndlwiXG5leHRlcm5hbCBiaWdfZW5kaWFuIDogdW5pdCAtPiBib29sID0gXCIlYmlnX2VuZGlhblwiXG5leHRlcm5hbCB3b3JkX3NpemUgOiB1bml0IC0+IGludCA9IFwiJXdvcmRfc2l6ZVwiXG5leHRlcm5hbCBpbnRfc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlaW50X3NpemVcIlxuZXh0ZXJuYWwgbWF4X3dvc2l6ZSA6IHVuaXQgLT4gaW50ID0gXCIlbWF4X3dvc2l6ZVwiXG5leHRlcm5hbCB1bml4IDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX3VuaXhcIlxuZXh0ZXJuYWwgd2luMzIgOiB1bml0IC0+IGJvb2wgPSBcIiVvc3R5cGVfd2luMzJcIlxuZXh0ZXJuYWwgY3lnd2luIDogdW5pdCAtPiBib29sID0gXCIlb3N0eXBlX2N5Z3dpblwiXG5leHRlcm5hbCBnZXRfYmFja2VuZF90eXBlIDogdW5pdCAtPiBiYWNrZW5kX3R5cGUgPSBcIiViYWNrZW5kX3R5cGVcIlxuXG5sZXQgKGV4ZWN1dGFibGVfbmFtZSwgYXJndikgPSBnZXRfYXJndigpXG5sZXQgKG9zX3R5cGUsIF8sIF8pID0gZ2V0X2NvbmZpZygpXG5sZXQgYmFja2VuZF90eXBlID0gZ2V0X2JhY2tlbmRfdHlwZSAoKVxubGV0IGJpZ19lbmRpYW4gPSBiaWdfZW5kaWFuICgpXG5sZXQgd29yZF9zaXplID0gd29yZF9zaXplICgpXG5sZXQgaW50X3NpemUgPSBpbnRfc2l6ZSAoKVxubGV0IHVuaXggPSB1bml4ICgpXG5sZXQgd2luMzIgPSB3aW4zMiAoKVxubGV0IGN5Z3dpbiA9IGN5Z3dpbiAoKVxubGV0IG1heF9hcnJheV9sZW5ndGggPSBtYXhfd29zaXplICgpXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDFcbmV4dGVybmFsIHJ1bnRpbWVfdmFyaWFudCA6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3J1bnRpbWVfdmFyaWFudFwiXG5leHRlcm5hbCBydW50aW1lX3BhcmFtZXRlcnMgOiB1bml0IC0+IHN0cmluZyA9IFwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcIlxuXG5leHRlcm5hbCBmaWxlX2V4aXN0czogc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3lzX2ZpbGVfZXhpc3RzXCJcbmV4dGVybmFsIGlzX2RpcmVjdG9yeSA6IHN0cmluZyAtPiBib29sID0gXCJjYW1sX3N5c19pc19kaXJlY3RvcnlcIlxuZXh0ZXJuYWwgcmVtb3ZlOiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcmVtb3ZlXCJcbmV4dGVybmFsIHJlbmFtZSA6IHN0cmluZyAtPiBzdHJpbmcgLT4gdW5pdCA9IFwiY2FtbF9zeXNfcmVuYW1lXCJcbmV4dGVybmFsIGdldGVudjogc3RyaW5nIC0+IHN0cmluZyA9IFwiY2FtbF9zeXNfZ2V0ZW52XCJcblxubGV0IGdldGVudl9vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKGdldGVudiBzKVxuICB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG5cbmV4dGVybmFsIGNvbW1hbmQ6IHN0cmluZyAtPiBpbnQgPSBcImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXCJcbmV4dGVybmFsIHRpbWU6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX3N5c190aW1lXCIgXCJjYW1sX3N5c190aW1lX3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2hkaXI6IHN0cmluZyAtPiB1bml0ID0gXCJjYW1sX3N5c19jaGRpclwiXG5leHRlcm5hbCBnZXRjd2Q6IHVuaXQgLT4gc3RyaW5nID0gXCJjYW1sX3N5c19nZXRjd2RcIlxuZXh0ZXJuYWwgcmVhZGRpciA6IHN0cmluZyAtPiBzdHJpbmcgYXJyYXkgPSBcImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5XCJcblxubGV0IGludGVyYWN0aXZlID0gcmVmIGZhbHNlXG5cbnR5cGUgc2lnbmFsX2JlaGF2aW9yID1cbiAgICBTaWduYWxfZGVmYXVsdFxuICB8IFNpZ25hbF9pZ25vcmVcbiAgfCBTaWduYWxfaGFuZGxlIG9mIChpbnQgLT4gdW5pdClcblxuZXh0ZXJuYWwgc2lnbmFsIDogaW50IC0+IHNpZ25hbF9iZWhhdmlvciAtPiBzaWduYWxfYmVoYXZpb3JcbiAgICAgICAgICAgICAgICA9IFwiY2FtbF9pbnN0YWxsX3NpZ25hbF9oYW5kbGVyXCJcblxubGV0IHNldF9zaWduYWwgc2lnX251bSBzaWdfYmVoID0gaWdub3JlKHNpZ25hbCBzaWdfbnVtIHNpZ19iZWgpXG5cbmxldCBzaWdhYnJ0ID0gLTFcbmxldCBzaWdhbHJtID0gLTJcbmxldCBzaWdmcGUgPSAtM1xubGV0IHNpZ2h1cCA9IC00XG5sZXQgc2lnaWxsID0gLTVcbmxldCBzaWdpbnQgPSAtNlxubGV0IHNpZ2tpbGwgPSAtN1xubGV0IHNpZ3BpcGUgPSAtOFxubGV0IHNpZ3F1aXQgPSAtOVxubGV0IHNpZ3NlZ3YgPSAtMTBcbmxldCBzaWd0ZXJtID0gLTExXG5sZXQgc2lndXNyMSA9IC0xMlxubGV0IHNpZ3VzcjIgPSAtMTNcbmxldCBzaWdjaGxkID0gLTE0XG5sZXQgc2lnY29udCA9IC0xNVxubGV0IHNpZ3N0b3AgPSAtMTZcbmxldCBzaWd0c3RwID0gLTE3XG5sZXQgc2lndHRpbiA9IC0xOFxubGV0IHNpZ3R0b3UgPSAtMTlcbmxldCBzaWd2dGFscm0gPSAtMjBcbmxldCBzaWdwcm9mID0gLTIxXG5sZXQgc2lnYnVzID0gLTIyXG5sZXQgc2lncG9sbCA9IC0yM1xubGV0IHNpZ3N5cyA9IC0yNFxubGV0IHNpZ3RyYXAgPSAtMjVcbmxldCBzaWd1cmcgPSAtMjZcbmxldCBzaWd4Y3B1ID0gLTI3XG5sZXQgc2lneGZzeiA9IC0yOFxuXG5leGNlcHRpb24gQnJlYWtcblxubGV0IGNhdGNoX2JyZWFrIG9uID1cbiAgaWYgb24gdGhlblxuICAgIHNldF9zaWduYWwgc2lnaW50IChTaWduYWxfaGFuZGxlKGZ1biBfIC0+IHJhaXNlIEJyZWFrKSlcbiAgZWxzZVxuICAgIHNldF9zaWduYWwgc2lnaW50IFNpZ25hbF9kZWZhdWx0XG5cblxuZXh0ZXJuYWwgZW5hYmxlX3J1bnRpbWVfd2FybmluZ3M6IGJvb2wgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1wiXG5leHRlcm5hbCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQ6IHVuaXQgLT4gYm9vbCA9XG4gIFwiY2FtbF9tbF9ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcIlxuXG4oKiBUaGUgdmVyc2lvbiBzdHJpbmcgaXMgZm91bmQgaW4gZmlsZSAuLi9WRVJTSU9OICopXG5cbmxldCBvY2FtbF92ZXJzaW9uID0gXCI0LjA2LjBcIlxuXG4oKiBPcHRpbWl6YXRpb24gKilcblxuZXh0ZXJuYWwgb3BhcXVlX2lkZW50aXR5IDogJ2EgLT4gJ2EgPSBcIiVvcGFxdWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDY0XTogNjQtYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50NjQgLT4gaW50IC0+IGludDY0ID0gXCIlaW50NjRfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF90b19mbG9hdFwiIFwiY2FtbF9pbnQ2NF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyIDogaW50MzIgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnQzMlwiXG5leHRlcm5hbCB0b19pbnQzMiA6IGludDY0IC0+IGludDMyID0gXCIlaW50NjRfdG9faW50MzJcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5cbmxldCB6ZXJvID0gMExcbmxldCBvbmUgPSAxTFxubGV0IG1pbnVzX29uZSA9IC0xTFxubGV0IHN1Y2MgbiA9IGFkZCBuIDFMXG5sZXQgcHJlZCBuID0gc3ViIG4gMUxcbmxldCBhYnMgbiA9IGlmIG4gPj0gMEwgdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBtaW5faW50ID0gMHg4MDAwMDAwMDAwMDAwMDAwTFxubGV0IG1heF9pbnQgPSAweDdGRkZGRkZGRkZGRkZGRkZMXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFMKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDY0ID0gXCJjYW1sX2ludDY0X29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5cblxuZXh0ZXJuYWwgYml0c19vZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbnR5cGUgdCA9IGludDY0XG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBQZXJ2YXNpdmVzLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3IgbGV4ZXJzIGdlbmVyYXRlZCBieSBjYW1sbGV4ICopXG5cbnR5cGUgcG9zaXRpb24gPSB7XG4gIHBvc19mbmFtZSA6IHN0cmluZztcbiAgcG9zX2xudW0gOiBpbnQ7XG4gIHBvc19ib2wgOiBpbnQ7XG4gIHBvc19jbnVtIDogaW50O1xufVxuXG5sZXQgZHVtbXlfcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDA7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IC0xO1xufVxuXG50eXBlIGxleGJ1ZiA9XG4gIHsgcmVmaWxsX2J1ZmYgOiBsZXhidWYgLT4gdW5pdDtcbiAgICBtdXRhYmxlIGxleF9idWZmZXIgOiBieXRlcztcbiAgICBtdXRhYmxlIGxleF9idWZmZXJfbGVuIDogaW50O1xuICAgIG11dGFibGUgbGV4X2Fic19wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2N1cnJfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfcG9zIDogaW50O1xuICAgIG11dGFibGUgbGV4X2xhc3RfYWN0aW9uIDogaW50O1xuICAgIG11dGFibGUgbGV4X2VvZl9yZWFjaGVkIDogYm9vbDtcbiAgICBtdXRhYmxlIGxleF9tZW0gOiBpbnQgYXJyYXk7XG4gICAgbXV0YWJsZSBsZXhfc3RhcnRfcCA6IHBvc2l0aW9uO1xuICAgIG11dGFibGUgbGV4X2N1cnJfcCA6IHBvc2l0aW9uO1xuICB9XG5cbnR5cGUgbGV4X3RhYmxlcyA9XG4gIHsgbGV4X2Jhc2U6IHN0cmluZztcbiAgICBsZXhfYmFja3Ryazogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0OiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrOiBzdHJpbmc7XG4gICAgbGV4X2Jhc2VfY29kZSA6IHN0cmluZztcbiAgICBsZXhfYmFja3Rya19jb2RlIDogc3RyaW5nO1xuICAgIGxleF9kZWZhdWx0X2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X3RyYW5zX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NoZWNrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2NvZGU6IHN0cmluZzt9XG5cbmV4dGVybmFsIGNfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludCA9IFwiY2FtbF9sZXhfZW5naW5lXCJcbmV4dGVybmFsIGNfbmV3X2VuZ2luZSA6IGxleF90YWJsZXMgLT4gaW50IC0+IGxleGJ1ZiAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9uZXdfbGV4X2VuZ2luZVwiXG5cbmxldCBlbmdpbmUgdGJsIHN0YXRlIGJ1ZiA9XG4gIGxldCByZXN1bHQgPSBjX2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbGV4X3JlZmlsbCByZWFkX2Z1biBhdXhfYnVmZmVyIGxleGJ1ZiA9XG4gIGxldCByZWFkID1cbiAgICByZWFkX2Z1biBhdXhfYnVmZmVyIChCeXRlcy5sZW5ndGggYXV4X2J1ZmZlcikgaW5cbiAgbGV0IG4gPVxuICAgIGlmIHJlYWQgPiAwXG4gICAgdGhlbiByZWFkXG4gICAgZWxzZSAobGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlOyAwKSBpblxuICAoKiBDdXJyZW50IHN0YXRlIG9mIHRoZSBidWZmZXI6XG4gICAgICAgIDwtLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLT5cbiAgICAgICAgfCAganVuayB8ICAgICAgdmFsaWQgZGF0YSAgICAgfCAgIGp1bmsgICAgfFxuICAgICAgICBeICAgICAgIF4gICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICBeXG4gICAgICAgIDAgICAgc3RhcnRfcG9zICAgICAgICAgICAgIGJ1ZmZlcl9lbmQgICAgQnl0ZXMubGVuZ3RoIGJ1ZmZlclxuICAqKVxuICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gKyBuID4gQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyIHRoZW4gYmVnaW5cbiAgICAoKiBUaGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgblxuICAgICAgIDw9IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlclxuICAgIHRoZW4gYmVnaW5cbiAgICAgICgqIEJ1dCB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaWYgd2UgcmVjbGFpbSB0aGUganVuayBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICBvZiB0aGUgYnVmZmVyICopXG4gICAgICBCeXRlcy5ibGl0IGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zXG4gICAgICAgICAgICAgICAgICBsZXhidWYubGV4X2J1ZmZlciAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICgqIFdlIG11c3QgZ3JvdyB0aGUgYnVmZmVyLiAgRG91YmxpbmcgaXRzIHNpemUgd2lsbCBwcm92aWRlIGVub3VnaFxuICAgICAgICAgc3BhY2Ugc2luY2UgbiA8PSBTdHJpbmcubGVuZ3RoIGF1eF9idWZmZXIgPD0gU3RyaW5nLmxlbmd0aCBidWZmZXIuXG4gICAgICAgICBXYXRjaCBvdXQgZm9yIHN0cmluZyBsZW5ndGggb3ZlcmZsb3csIHRob3VnaC4gKilcbiAgICAgIGxldCBuZXdsZW4gPVxuICAgICAgICBtaW4gKDIgKiBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXIpIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBpblxuICAgICAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MgKyBuID4gbmV3bGVuXG4gICAgICB0aGVuIGZhaWx3aXRoIFwiTGV4aW5nLmxleF9yZWZpbGw6IGNhbm5vdCBncm93IGJ1ZmZlclwiO1xuICAgICAgbGV0IG5ld2J1ZiA9IEJ5dGVzLmNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgICgqIENvcHkgdGhlIHZhbGlkIGRhdGEgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbmV3YnVmIDBcbiAgICAgICAgICAgICAgICAgIChsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3Bvcyk7XG4gICAgICBsZXhidWYubGV4X2J1ZmZlciA8LSBuZXdidWZcbiAgICBlbmQ7XG4gICAgKCogUmVhbGxvY2F0aW9uIG9yIG5vdCwgd2UgaGF2ZSBzaGlmdGVkIHRoZSBkYXRhIGxlZnQgYnlcbiAgICAgICBzdGFydF9wb3MgY2hhcmFjdGVyczsgdXBkYXRlIHRoZSBwb3NpdGlvbnMgKilcbiAgICBsZXQgcyA9IGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gICAgbGV4YnVmLmxleF9hYnNfcG9zIDwtIGxleGJ1Zi5sZXhfYWJzX3BvcyArIHM7XG4gICAgbGV4YnVmLmxleF9jdXJyX3BvcyA8LSBsZXhidWYubGV4X2N1cnJfcG9zIC0gcztcbiAgICBsZXhidWYubGV4X3N0YXJ0X3BvcyA8LSAwO1xuICAgIGxleGJ1Zi5sZXhfbGFzdF9wb3MgPC0gbGV4YnVmLmxleF9sYXN0X3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIHMgO1xuICAgIGxldCB0ID0gbGV4YnVmLmxleF9tZW0gaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQtMSBkb1xuICAgICAgbGV0IHYgPSB0LihpKSBpblxuICAgICAgaWYgdiA+PSAwIHRoZW5cbiAgICAgICAgdC4oaSkgPC0gdi1zXG4gICAgZG9uZVxuICBlbmQ7XG4gICgqIFRoZXJlIGlzIG5vdyBlbm91Z2ggc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyICopXG4gIEJ5dGVzLmJsaXQgYXV4X2J1ZmZlciAwIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiBuO1xuICBsZXhidWYubGV4X2J1ZmZlcl9sZW4gPC0gbGV4YnVmLmxleF9idWZmZXJfbGVuICsgblxuXG5sZXQgemVyb19wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMTtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gMDtcbn1cblxubGV0IGZyb21fZnVuY3Rpb24gZiA9XG4gIHsgcmVmaWxsX2J1ZmYgPSBsZXhfcmVmaWxsIGYgKEJ5dGVzLmNyZWF0ZSA1MTIpO1xuICAgIGxleF9idWZmZXIgPSBCeXRlcy5jcmVhdGUgMTAyNDtcbiAgICBsZXhfYnVmZmVyX2xlbiA9IDA7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IGZhbHNlO1xuICAgIGxleF9zdGFydF9wID0gemVyb19wb3M7XG4gICAgbGV4X2N1cnJfcCA9IHplcm9fcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICBmcm9tX2Z1bmN0aW9uIChmdW4gYnVmIG4gLT4gaW5wdXQgaWMgYnVmIDAgbilcblxubGV0IGZyb21fc3RyaW5nIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSB6ZXJvX3BvcztcbiAgICBsZXhfY3Vycl9wID0gemVyb19wb3M7XG4gIH1cblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBsZXQgbGVuID0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGluXG4gIEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3MgbGVuXG5cbmxldCBzdWJfbGV4ZW1lIGxleGJ1ZiBpMSBpMiA9XG4gIGxldCBsZW4gPSBpMi1pMSBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGkxIGxlblxuXG5sZXQgc3ViX2xleGVtZV9vcHQgbGV4YnVmIGkxIGkyID1cbiAgaWYgaTEgPj0gMCB0aGVuIGJlZ2luXG4gICAgbGV0IGxlbiA9IGkyLWkxIGluXG4gICAgU29tZSAoQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW4pXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgTm9uZVxuICBlbmRcblxubGV0IHN1Yl9sZXhlbWVfY2hhciBsZXhidWYgaSA9IEJ5dGVzLmdldCBsZXhidWYubGV4X2J1ZmZlciBpXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXJfb3B0IGxleGJ1ZiBpID1cbiAgaWYgaSA+PSAwIHRoZW5cbiAgICBTb21lIChCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaSlcbiAgZWxzZVxuICAgIE5vbmVcblxuXG5sZXQgbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPVxuICBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgKGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgaSlcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3AucG9zX2NudW1cbmxldCBsZXhlbWVfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19jbnVtXG5cbmxldCBsZXhlbWVfc3RhcnRfcCBsZXhidWYgPSBsZXhidWYubGV4X3N0YXJ0X3BcbmxldCBsZXhlbWVfZW5kX3AgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3BcblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxldCBsY3AgPSBsZXhidWYubGV4X2N1cnJfcCBpblxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7IGxjcCB3aXRoXG4gICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgIHBvc19ib2wgPSBsY3AucG9zX2NudW07XG4gIH1cblxuXG5cbigqIERpc2NhcmQgZGF0YSBsZWZ0IGluIGxleGVyIGJ1ZmZlci4gKilcblxubGV0IGZsdXNoX2lucHV0IGxiID1cbiAgbGIubGV4X2N1cnJfcG9zIDwtIDA7XG4gIGxiLmxleF9hYnNfcG9zIDwtIDA7XG4gIGxiLmxleF9jdXJyX3AgPC0ge2xiLmxleF9jdXJyX3Agd2l0aCBwb3NfY251bSA9IDB9O1xuICBsYi5sZXhfYnVmZmVyX2xlbiA8LSAwO1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljc1xuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAoKiBUb29scyB0byBtYW5pcHVsYXRlIHNjYW5uaW5nIHNldCBvZiBjaGFycyAoc2VlICVbLi4uXSkgKilcblxudHlwZSBtdXRhYmxlX2NoYXJfc2V0ID0gYnl0ZXNcblxuKCogQ3JlYXRlIGEgZnJlc2gsIGVtcHR5LCBtdXRhYmxlIGNoYXIgc2V0LiAqKVxubGV0IGNyZWF0ZV9jaGFyX3NldCAoKSA9IEJ5dGVzLm1ha2UgMzIgJ1xcMDAwJ1xuXG4oKiBBZGQgYSBjaGFyIGluIGEgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyA9XG4gIGxldCBpbmQgPSBpbnRfb2ZfY2hhciBjIGluXG4gIGxldCBzdHJfaW5kID0gaW5kIGxzciAzIGFuZCBtYXNrID0gMSBsc2wgKGluZCBsYW5kIDBiMTExKSBpblxuICBCeXRlcy5zZXQgY2hhcl9zZXQgc3RyX2luZFxuICAgIChjaGFyX29mX2ludCAoaW50X29mX2NoYXIgKEJ5dGVzLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsb3IgbWFzaykpXG5cbmxldCBmcmVlemVfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBCeXRlcy50b19zdHJpbmcgY2hhcl9zZXRcblxuKCogQ29tcHV0ZSB0aGUgY29tcGxlbWVudCBvZiBhIGNoYXIgc2V0LiAqKVxubGV0IHJldl9jaGFyX3NldCBjaGFyX3NldCA9XG4gIGxldCBjaGFyX3NldCcgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgZm9yIGkgPSAwIHRvIDMxIGRvXG4gICAgQnl0ZXMuc2V0IGNoYXJfc2V0JyBpXG4gICAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IGkpIGx4b3IgMHhGRikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGNoYXJfc2V0J1xuXG4oKiBSZXR1cm4gdHJ1ZSBpZiBhIGBjJyBpcyBpbiBgY2hhcl9zZXQnLiAqKVxubGV0IGlzX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgKGludF9vZl9jaGFyIChTdHJpbmcuZ2V0IGNoYXJfc2V0IHN0cl9pbmQpIGxhbmQgbWFzaykgPD4gMFxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogSWdub3JlZCBwYXJhbSBjb252ZXJzaW9uICopXG5cbigqIEdBRFQgdXNlZCB0byBhYnN0cmFjdCBhbiBleGlzdGVudGlhbCB0eXBlIHBhcmFtZXRlci4gKilcbigqIFNlZSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiID0gUGFyYW1fZm9ybWF0X0VCQiA6XG4gICAgKCd4IC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYXJhbV9mb3JtYXRfZWJiXG5cbigqIENvbXB1dGUgYSBwYWRkaW5nIGFzc29jaWF0ZWQgdG8gYSBwYWRfb3B0aW9uIChzZWUgXCIlXzQyZFwiKS4gKilcbmxldCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wYWRkaW5nXG4gIHwgU29tZSB3aWR0aCAtPiBMaXRfcGFkZGluZyAoUmlnaHQsIHdpZHRoKVxuXG4oKiBDb21wdXRlIGEgcHJlY2lzaW9uIGFzc29jaWF0ZWQgdG8gYSBwcmVjX29wdGlvbiAoc2VlIFwiJV8uNDJmXCIpLiAqKVxubGV0IHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQgPSBtYXRjaCBwcmVjX29wdCB3aXRoXG4gIHwgTm9uZSAtPiBOb19wcmVjaXNpb25cbiAgfCBTb21lIG5kZWMgLT4gTGl0X3ByZWNpc2lvbiBuZGVjXG5cbigqIFR1cm4gYW4gaWdub3JlZCBwYXJhbSBpbnRvIGl0cyBlcXVpdmFsZW50IG5vdC1pZ25vcmVkIGZvcm1hdCBub2RlLiAqKVxuKCogVXNlZCBmb3IgZm9ybWF0IHByZXR0eS1wcmludGluZyBhbmQgU2NhbmYuICopXG5sZXQgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+ICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYXJhbV9mb3JtYXRfZWJiID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2hhciBmbXQpXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChDYW1sX2NoYXIgZm10KVxuICB8IElnbm9yZWRfc3RyaW5nIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEludCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2ludDMyIChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoSW50MzIgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChOYXRpdmVpbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQ2NCAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDY0IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfZmxvYXQgKHBhZF9vcHQsIHByZWNfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGbG9hdCAoRmxvYXRfZiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgcHJlY19vZl9wcmVjX29wdCBwcmVjX29wdCwgZm10KSlcbiAgfCBJZ25vcmVkX2Jvb2wgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKEJvb2wgKHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgZm10KSlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChSZWFkZXIgZm10KVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXQpKVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9uZXh0X2NoYXIgZm10KVxuXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUeXBlcyAqKVxuXG50eXBlICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlbiA9XG4gIHwgQWNjX29wZW5fdGFnIG9mICgnYiwgJ2MpIGFjY1xuICB8IEFjY19vcGVuX2JveCBvZiAoJ2IsICdjKSBhY2NcblxuKCogUmV2ZXJzZWQgbGlzdCBvZiBwcmludGluZyBhdG9tcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBwcmludGYgYXJndW1lbnRzLiAqKVxuYW5kICgnYiwgJ2MpIGFjYyA9XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IG9mICgnYiwgJ2MpIGFjYyAqIGZvcm1hdHRpbmdfbGl0XG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gb2YgKCdiLCAnYykgYWNjICogKCdiLCAnYykgYWNjX2Zvcm1hdHRpbmdfZ2VuXG4gICAgICAoKiBTcGVjaWFsIGZtdHRpbmcgKGJveCkgKilcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBMaXRlcmFsIHN0cmluZyAqKVxuICB8IEFjY19jaGFyX2xpdGVyYWwgICBvZiAoJ2IsICdjKSBhY2MgKiBjaGFyICAgICAgICgqIExpdGVyYWwgY2hhciAqKVxuICB8IEFjY19kYXRhX3N0cmluZyAgICBvZiAoJ2IsICdjKSBhY2MgKiBzdHJpbmcgICAgICgqIEdlbmVyYXRlZCBzdHJpbmcgKilcbiAgfCBBY2NfZGF0YV9jaGFyICAgICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBHZW5lcmF0ZWQgY2hhciAqKVxuICB8IEFjY19kZWxheSAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgKiAoJ2IgLT4gJ2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBEZWxheWVkIHByaW50aW5nICglYSwgJXQpICopXG4gIHwgQWNjX2ZsdXNoICAgICAgICAgIG9mICgnYiwgJ2MpIGFjYyAgICAgICAgICAgICAgKCogRmx1c2ggKilcbiAgfCBBY2NfaW52YWxpZF9hcmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nXG4gICAgICAoKiBSYWlzZSBJbnZhbGlkX2FyZ3VtZW50IG1zZyAqKVxuICB8IEVuZF9vZl9hY2NcblxuKCogTGlzdCBvZiBoZXRlcm9nZW5lb3VzIHZhbHVlcy4gKilcbigqIFVzZWQgdG8gYWNjdW11bGF0ZSBzY2FuZiBjYWxsYmFjayBhcmd1bWVudHMuICopXG50eXBlICgnYSwgJ2IpIGhldGVyX2xpc3QgPVxuICB8IENvbnMgOiAnYyAqICgnYSwgJ2IpIGhldGVyX2xpc3QgLT4gKCdjIC0+ICdhLCAnYikgaGV0ZXJfbGlzdFxuICB8IE5pbCA6ICgnYiwgJ2IpIGhldGVyX2xpc3RcblxuKCogRXhpc3RlbnRpYWwgQmxhY2sgQm94ZXMuICopXG4oKiBVc2VkIHRvIGFic3RyYWN0IHNvbWUgZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRkaW5nIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkZGluZ19mbXR0eV9lYmIgPSBQYWRkaW5nX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXR0eS4gKilcbigqIFNlZSB0aGUgdHlwZV9wYWRwcmVjIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFkcHJlY19mbXR0eV9lYmIgPSBQYWRwcmVjX2ZtdHR5X0VCQiA6XG4gICAgICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksICd6KSBwcmVjaXNpb24gKiAoJ3osICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHBhZGRpbmcgYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZGRpbmdfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiID0gUGFkZGluZ19mbXRfRUJCIDpcbiAgICAgKF8sICd4IC0+ICdhKSBwYWRkaW5nICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwYWRkaW5nX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcHJlY2lzaW9uIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wcmVjaXNpb25fZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmIgPSBQcmVjaXNpb25fZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3gsICdiLCAnYywgJ2UsICdmKSBwcmVjaXNpb25fZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcGFkcHJlY19mbXRfZWJiIGFuZCBwYXJzZV9mb3JtYXQgZnVuY3Rpb25zLiAqKVxudHlwZSAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmIgPSBQYWRwcmVjX2ZtdF9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAncCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAoJ3AsICdiLCAnYywgJ2UsICdmKSBwYWRwcmVjX2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgdGhlICdhIGFuZCAnZCBwYXJhbWV0ZXJzIG9mIGFuIGZtdC4gKilcbigqIE91dHB1dCB0eXBlIG9mIHRoZSBmb3JtYXQgcGFyc2luZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiID0gRm10X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdiLCAnYywgJ2UsICdmKSBmbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2Zvcm1hdF9nZW4gZnVuY3Rpb24uICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiID0gRm10X2ZtdHR5X0VCQiA6XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ3ksICd4KSBmbXQgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10dHkgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGFuIGZtdHR5IGFuZCBhbiBmbXQuICopXG4oKiBTZWUgdGhlIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYiA9IEZtdHR5X2ZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10dHkgKlxuICAgICAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10X2ZtdHR5X2ViYiAtPlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfZm10X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgZm10dHkgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIGZvcm1hdCB0eXBlcy4gKilcbnR5cGUgZm10dHlfZWJiID0gRm10dHlfRUJCIDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+IGZtdHR5X2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcGFkZGluZyB0eXBlIHBhcmFtZXRlcnMuICopXG4oKiBVc2VkIHRvIGNvbXBhcmUgcGFkZGluZ3MuICopXG50eXBlIHBhZGRpbmdfZWJiID0gUGFkZGluZ19FQkIgOiAoJ2EsICdiKSBwYWRkaW5nIC0+IHBhZGRpbmdfZWJiXG5cbigqIEFic3RyYWN0IGFsbCBwcmVjaXNpb24gdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHByZWNpc2lvbnMuICopXG50eXBlIHByZWNpc2lvbl9lYmIgPSBQcmVjaXNpb25fRUJCIDogKCdhLCAnYikgcHJlY2lzaW9uIC0+IHByZWNpc2lvbl9lYmJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBDb25zdGFudHMgKilcblxuKCogRGVmYXVsdCBwcmVjaXNpb24gZm9yIGZsb2F0IHByaW50aW5nLiAqKVxubGV0IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uID0gLTZcbiAgKCogRm9yICVoIGFuZCAlSCBmb3JtYXRzLCBhIG5lZ2F0aXZlIHByZWNpc2lvbiBtZWFucyBcImFzIG1hbnkgZGlnaXRzIGFzXG4gICAgIG5lY2Vzc2FyeVwiLiAgRm9yIHRoZSBvdGhlciBGUCBmb3JtYXRzLCB3ZSB0YWtlIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgICBvZiB0aGUgcHJlY2lzaW9uLCBoZW5jZSA2IGRpZ2l0cyBieSBkZWZhdWx0LiAqKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEV4dGVybmFscyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQ6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxuZXh0ZXJuYWwgZm9ybWF0X2ludDMyOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfbmF0aXZlaW50OiBzdHJpbmcgLT4gbmF0aXZlaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9uYXRpdmVpbnRfZm9ybWF0XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQ2NDogc3RyaW5nIC0+IGludDY0IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQ2NF9mb3JtYXRcIlxuZXh0ZXJuYWwgaGV4c3RyaW5nX29mX2Zsb2F0OiBmbG9hdCAtPiBpbnQgLT4gY2hhciAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0XCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICgqIFRvb2xzIHRvIHByZXR0eS1wcmludCBmb3JtYXRzICopXG5cbigqIFR5cGUgb2YgZXh0ZW5zaWJsZSBjaGFyYWN0ZXIgYnVmZmVycy4gKilcbnR5cGUgYnVmZmVyID0ge1xuICBtdXRhYmxlIGluZCA6IGludDtcbiAgbXV0YWJsZSBieXRlcyA6IGJ5dGVzO1xufVxuXG4oKiBDcmVhdGUgYSBmcmVzaCBidWZmZXIuICopXG5sZXQgYnVmZmVyX2NyZWF0ZSBpbml0X3NpemUgPSB7IGluZCA9IDA7IGJ5dGVzID0gQnl0ZXMuY3JlYXRlIGluaXRfc2l6ZSB9XG5cbigqIENoZWNrIHNpemUgb2YgdGhlIGJ1ZmZlciBhbmQgZ3JvdyBpdCBpZiBuZWVkZWQuICopXG5sZXQgYnVmZmVyX2NoZWNrX3NpemUgYnVmIG92ZXJoZWFkID1cbiAgbGV0IGxlbiA9IEJ5dGVzLmxlbmd0aCBidWYuYnl0ZXMgaW5cbiAgbGV0IG1pbl9sZW4gPSBidWYuaW5kICsgb3ZlcmhlYWQgaW5cbiAgaWYgbWluX2xlbiA+IGxlbiB0aGVuIChcbiAgICBsZXQgbmV3X2xlbiA9IG1heCAobGVuICogMikgbWluX2xlbiBpblxuICAgIGxldCBuZXdfc3RyID0gQnl0ZXMuY3JlYXRlIG5ld19sZW4gaW5cbiAgICBCeXRlcy5ibGl0IGJ1Zi5ieXRlcyAwIG5ld19zdHIgMCBsZW47XG4gICAgYnVmLmJ5dGVzIDwtIG5ld19zdHI7XG4gIClcblxuKCogQWRkIHRoZSBjaGFyYWN0ZXIgYGMnIHRvIHRoZSBidWZmZXIgYGJ1ZicuICopXG5sZXQgYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjID1cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIDE7XG4gIEJ5dGVzLnNldCBidWYuYnl0ZXMgYnVmLmluZCBjO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyAxXG5cbigqIEFkZCB0aGUgc3RyaW5nIGBzJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzID1cbiAgbGV0IHN0cl9sZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgYnVmZmVyX2NoZWNrX3NpemUgYnVmIHN0cl9sZW47XG4gIFN0cmluZy5ibGl0IHMgMCBidWYuYnl0ZXMgYnVmLmluZCBzdHJfbGVuO1xuICBidWYuaW5kIDwtIGJ1Zi5pbmQgKyBzdHJfbGVuXG5cbigqIEdldCB0aGUgY29udGVudCBvZiB0aGUgYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jb250ZW50cyBidWYgPVxuICBCeXRlcy5zdWJfc3RyaW5nIGJ1Zi5ieXRlcyAwIGJ1Zi5pbmRcblxuKCoqKilcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIGNvbnZlcnNpb24gdG8gY2hhci4gKilcbmxldCBjaGFyX29mX2ljb252IGljb252ID0gbWF0Y2ggaWNvbnYgd2l0aFxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkIC0+ICdkJyB8IEludF9pIHwgSW50X3BpIHwgSW50X3NpIC0+ICdpJ1xuICB8IEludF94IHwgSW50X0N4IC0+ICd4JyB8IEludF9YIHwgSW50X0NYIC0+ICdYJyB8IEludF9vIHwgSW50X0NvIC0+ICdvJ1xuICB8IEludF91IC0+ICd1J1xuXG4oKiBDb252ZXJ0IGEgZmxvYXQgY29udmVyc2lvbiB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgZmNvbnYgPSBtYXRjaCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X3BmIHwgRmxvYXRfc2YgLT4gJ2YnIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgLT4gJ0UnIHwgRmxvYXRfZyB8IEZsb2F0X3BnIHwgRmxvYXRfc2cgLT4gJ2cnXG4gIHwgRmxvYXRfRyB8IEZsb2F0X3BHIHwgRmxvYXRfc0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiAnRidcbiAgfCBGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCAtPiAnaCcgfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCAtPiAnSCdcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgSW50X2QgfCBJbnRfaSB8IEludF94IHwgSW50X1ggfCBJbnRfbyB8IEludF91IC0+ICgpXG5cbigqIFByaW50IGFuIGNvbXBsZXRlIGludCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUzLipkXCIpLiAqKVxubGV0IGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2ljb252IGljb252KVxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgZm9ybWF0IGluIGEgYnVmZmVyLiAqKVxubGV0IGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyBjID1cbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gIGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnY7XG4gIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7XG4gIGJwcmludF9wcmVjaXNpb24gYnVmIHByZWM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCoqKilcblxuKCogUHJpbnQgdGhlIG9wdGlvbmFsICcrJyBhc3NvY2lhdGVkIHRvIGEgZmxvYXQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfZmNvbnZfZmxhZyBidWYgZmNvbnYgPSBtYXRjaCBmY29udiB3aXRoXG4gIHwgRmxvYXRfcGYgfCBGbG9hdF9wZSB8IEZsb2F0X3BFXG4gIHwgRmxvYXRfcGcgfCBGbG9hdF9wRyB8IEZsb2F0X3BoIHwgRmxvYXRfcEggLT5cbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcrJ1xuICB8IEZsb2F0X3NmIHwgRmxvYXRfc2UgfCBGbG9hdF9zRVxuICB8IEZsb2F0X3NnIHwgRmxvYXRfc0cgfCBGbG9hdF9zaCB8IEZsb2F0X3NIIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnICdcbiAgfCBGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0VcbiAgfCBGbG9hdF9nIHwgRmxvYXRfRyB8IEZsb2F0X0YgfCBGbG9hdF9oIHwgRmxvYXRfSCAtPlxuICAgICgpXG5cbigqIFByaW50IGEgY29tcGxldGUgZmxvYXQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlKyouM2ZcIikuICopXG5sZXQgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9mY29udiBmY29udilcblxuKCogQ29tcHV0ZSB0aGUgbGl0ZXJhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmb3JtYXR0aW5nX2xpdC4gKilcbigqIEFsc28gdXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqIENvbXB1dGUgdGhlIGxpdGVyYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZm9ybWF0dGluZy4gKilcbigqIEFsc28gdXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmb3JtYXR0aW5nX2dlbiAtPiBzdHJpbmcgPVxuICBmdW4gZm9ybWF0dGluZ19nZW4gLT4gbWF0Y2ggZm9ybWF0dGluZ19nZW4gd2l0aFxuICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+IHN0clxuICB8IE9wZW5fYm94IChGb3JtYXQgKF8sIHN0cikpIC0+IHN0clxuXG4oKioqKVxuXG4oKiBQcmludCBhIGxpdGVyYWwgY2hhciBpbiBhIGJ1ZmZlciwgZXNjYXBlICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyID0gbWF0Y2ggY2hyIHdpdGhcbiAgfCAnJScgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSVcIlxuICB8IF8gLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiBjaHJcblxuKCogUHJpbnQgYSBsaXRlcmFsIHN0cmluZyBpbiBhIGJ1ZmZlciwgZXNjYXBlIGFsbCAnJScgYnkgXCIlJVwiLiAqKVxubGV0IGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgc3RyID1cbiAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc3RyIC0gMSBkb1xuICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIHN0ci5baV1cbiAgZG9uZVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgcHJldHR5LXByaW50aW5nICopXG5cbigqIFByaW50IGEgY29tcGxldGUgZm9ybWF0IHR5cGUgKGFuIGZtdHR5KSBpbiBhIGJ1ZmZlci4gKilcbmxldCByZWMgYnByaW50X2ZtdHR5IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCAuXG4gICAgYnVmZmVyIC0+IChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKSBmbXR0eV9yZWwgLT4gdW5pdCA9XG5mdW4gYnVmIGZtdHR5IC0+IG1hdGNoIGZtdHR5IHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlY1wiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFN0cmluZ190eSByZXN0ICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVzXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWlcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQzMl90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlbGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IE5hdGl2ZWludF90eSByZXN0IC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVuaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUxpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBGbG9hdF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlZlwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEJvb2xfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVCXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJWFcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBUaGV0YV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIldFwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEFueV90eSByZXN0ICAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiU/XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgUmVhZGVyX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlX3JcIjtcbiAgICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHksIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXtcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJX1cIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5LCBfLCByZXN0KSAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUoXCI7IGJwcmludF9mbXR0eSBidWYgc3ViX2ZtdHR5O1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUpXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEVuZF9vZl9mbXR0eSAtPiAoKVxuXG4oKioqKVxuXG5sZXQgcmVjIGludF9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIGEgYiBjIC5cbiAgKGEsIGIsIGMpIGN1c3RvbV9hcml0eSAtPiBpbnQgPVxuICBmdW5jdGlvblxuICB8IEN1c3RvbV96ZXJvIC0+IDBcbiAgfCBDdXN0b21fc3VjYyB4IC0+IDEgKyBpbnRfb2ZfY3VzdG9tX2FyaXR5IHhcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgaW4gYSBidWZmZXIuICopXG5sZXQgYnByaW50X2ZtdCBidWYgZm10ID1cbiAgbGV0IHJlYyBmbXRpdGVyIDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGJvb2wgLT4gdW5pdCA9XG4gIGZ1biBmbXQgaWduX2ZsYWcgLT4gbWF0Y2ggZm10IHdpdGhcbiAgICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnUyc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9pbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdsJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnbic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9hbHRpbnRfZm10IGJ1ZiBpZ25fZmxhZyBpY29udiBwYWQgcHJlYyAnTCc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgIGJwcmludF9mbG9hdF9mbXQgYnVmIGlnbl9mbGFnIGZjb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ2MnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEJvb2wgKHBhZCwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRkaW5nIGJ1ZiBwYWQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJ0InO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYSc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFRoZXRhIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3QnOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgZm9yIF9pID0gMSB0byBpbnRfb2ZfY3VzdG9tX2FyaXR5IGFyaXR5IGRvXG4gICAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnPyc7XG4gICAgICBkb25lO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgUmVhZGVyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ3InOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlIVwiO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9jaGFyX2xpdGVyYWwgYnVmIGNocjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcblxuICAgIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAneyc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnfSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHBhZF9vcHQ7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJygnO1xuICAgICAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyknO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZF9vcHQgYnVmIHdpZHRoX29wdDsgYnByaW50X2NoYXJfc2V0IGJ1ZiBjaGFyX3NldDtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2NvdW50ZXIgY291bnRlcik7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIFwiMGNcIjsgZm10aXRlciByZXN0IGZhbHNlO1xuXG4gICAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgICBmbXRpdGVyIGZtdCcgdHJ1ZTtcblxuICAgIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCk7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG4gICAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCJAe1wiO1xuICAgICAgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfZ2VuIGZtdGluZ19nZW4pO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT4gZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKEJvb2xfdHkgKGZtdHR5X29mX2ZtdCByZXN0KSlcbiAgfCBBbHBoYSByZXN0ICAgICAgICAgICAgICAgICAtPiBBbHBoYV90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgVGhldGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gVGhldGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpICAgIC0+IGZtdHR5X29mX2N1c3RvbSBhcml0eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgUmVhZGVyIHJlc3QgICAgICAgICAgICAgICAgLT4gUmVhZGVyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmdfdHkgKHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBGb3JtYXRfc3Vic3QgKF8sIHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHksIHR5LCBmbXR0eV9vZl9mbXQgcmVzdClcblxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuXG4gIHwgU2Nhbl9jaGFyX3NldCAoXywgXywgcmVzdCkgLT4gU3RyaW5nX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPiBJbnRfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgICAgICAgIC0+IENoYXJfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgIC0+IGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0XG4gIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoZm10aW5nX2dlbiwgcmVzdCkgIC0+XG4gICAgY29uY2F0X2ZtdHR5IChmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiBmbXRpbmdfZ2VuKSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBFbmRfb2ZfZm9ybWF0ICAgICAgICAgICAgICAtPiBFbmRfb2ZfZm10dHlcblxuYW5kIGZtdHR5X29mX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGEsIHgsIHkpIGN1c3RvbV9hcml0eSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgKHksIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBhcml0eSBmbXR0eSAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gZm10dHlcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPiBBbnlfdHkgKGZtdHR5X29mX2N1c3RvbSBhcml0eSBmbXR0eSlcblxuKCogRXh0cmFjdCB0aGUgZm10dHkgb2YgYW4gaWdub3JlZCBwYXJhbWV0ZXIgZm9sbG93ZWQgYnkgdGhlIHJlc3Qgb2ZcbiAgIHRoZSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfaWdub3JlZF9mb3JtYXQgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBpZ24gZm10IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBjb25jYXRfZm10dHkgZm10dHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBJZ25vcmVkX3JlYWRlcl90eSAoZm10dHlfb2ZfZm10IGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IGZtdHR5X29mX2ZtdCBmbXRcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHBhZGRpbmcgaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUqc1wiKS4gKilcbmFuZCBmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IDogdHlwZSB4IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgYSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHBhZCBmbXR0eSAtPiBtYXRjaCBwYWQgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICAtPiBmbXR0eVxuICAgIHwgTGl0X3BhZGRpbmcgXyAtPiBmbXR0eVxuICAgIHwgQXJnX3BhZGRpbmcgXyAtPiBJbnRfdHkgZm10dHlcblxuKCogQWRkIGFuIEludF90eSBub2RlIGlmIHByZWNpc2lvbiBpcyB0YWtlbiBhcyBhbiBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKS4qKVxuYW5kIGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHByZWNpc2lvbiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKHgsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbiAgZnVuIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gICAgfCBOb19wcmVjaXNpb24gICAgLT4gZm10dHlcbiAgICB8IExpdF9wcmVjaXNpb24gXyAtPiBmbXR0eVxuICAgIHwgQXJnX3ByZWNpc2lvbiAgIC0+IEludF90eSBmbXR0eVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCB0eXBpbmcgKilcblxuKCogRXhjZXB0aW9uIHJhaXNlZCB3aGVuIGEgZm9ybWF0IGRvZXMgbm90IG1hdGNoIGEgZ2l2ZW4gZm9ybWF0IHR5cGUuICopXG5leGNlcHRpb24gVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgcGFkZGluZy4gKilcbigqIFRha2UgYW4gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIHRoZSBpbnRlZ2VyIHNob3VsZCBiZSBrZXB0IGFzIGFyZ3VtZW50LiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRkaW5nIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgLlxuICAgICh4LCB5KSBwYWRkaW5nIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZGRpbmdfZm10dHlfZWJiID1cbmZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkLCBmbXR0eSB3aXRoXG4gIHwgTm9fcGFkZGluZywgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTm9fcGFkZGluZywgZm10dHkpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgXyAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoTGl0X3BhZGRpbmcgKHBhZHR5LHcpLGZtdHR5KVxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBJbnRfdHkgcmVzdCAtPiBQYWRkaW5nX2ZtdHR5X0VCQiAoQXJnX3BhZGRpbmcgcGFkdHkscmVzdClcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogQ29udmVydCBhICh1cGFkZGluZywgdXByZWNpc2lvbikgdG8gYSAocGFkZGluZywgcHJlY2lzaW9uKS4gKilcbigqIFRha2Ugb25lIG9yIHR3byBJbnRfdHkgZnJvbSB0aGUgZm10dHkgaWYgbmVlZGVkLiAqKVxuKCogUmFpc2UgVHlwZV9taXNtYXRjaCBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgdHlwZV9wYWRwcmVjIDogdHlwZSBhIGIgYyBkIGUgZiB4IHkgeiAuXG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6KSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIHBhZHByZWNfZm10dHlfZWJiID1cbmZ1biBwYWQgcHJlYyBmbXR0eSAtPiBtYXRjaCBwcmVjLCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgfCBOb19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTm9fcHJlY2lzaW9uLCByZXN0KVxuICB8IExpdF9wcmVjaXNpb24gcCwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgcmVzdCkgLT5cbiAgICBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBMaXRfcHJlY2lzaW9uIHAsIHJlc3QpXG4gIHwgQXJnX3ByZWNpc2lvbiwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgSW50X3R5IHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgQXJnX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBfLCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUeXBlIGEgZm9ybWF0IGFjY29yZGluZyB0byBhbiBmbXR0eS4gKilcbigqIElmIHR5cGluZyBzdWNjZWVkLCBnZW5lcmF0ZSBhIGNvcHkgb2YgdGhlIGZvcm1hdCB3aXRoIHRoZSBzYW1lXG4gICAgdHlwZSBwYXJhbWV0ZXJzIGFzIHRoZSBmbXR0eS4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGFuIGVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHJlYyB0eXBlX2Zvcm1hdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMiAgLlxuICAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eVxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSB3aXRoXG4gIHwgRm10X2ZtdHR5X0VCQiAoZm10JywgRW5kX29mX2ZtdHR5KSAtPiBmbXQnXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdF9nZW4gOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGZtdCBmbXR0eSAtPiBtYXRjaCBmbXQsIGZtdHR5IHdpdGhcbiAgfCBDaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhciBmbXQnLCBmbXR0eScpXG4gIHwgQ2FtbF9jaGFyIGZtdF9yZXN0LCBDaGFyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9jaGFyIGZtdCcsIGZtdHR5JylcbiAgfCBTdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQ2FtbF9zdHJpbmcgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIFN0cmluZ190eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQ2FtbF9zdHJpbmcgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnQzMl90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoSW50MzIgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50NjRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDY0IChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBGbG9hdF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoRmxvYXQgKGZjb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgQm9vbCAocGFkLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkZGluZyBwYWQgZm10dHkgd2l0aFxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKHBhZCwgQm9vbF90eSBmbXR0eV9yZXN0KSAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgICAgRm10X2ZtdHR5X0VCQiAoQm9vbCAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEZsdXNoIGZtdF9yZXN0LCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZsdXNoIGZtdCcsIGZtdHR5JylcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXQnKSwgZm10dHknKVxuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoQ2hhcl9saXRlcmFsIChjaHIsIGZtdCcpLCBmbXR0eScpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHksIGZtdF9yZXN0KSxcbiAgICBGb3JtYXRfYXJnX3R5IChzdWJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWJfZm10dHkgPD4gRm10dHlfRUJCIHN1Yl9mbXR0eScgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHknLCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHkxLCBfc3ViX2ZtdHR5MiwgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1Yl9mbXR0eTEpIHRoZW5cbiAgICAgIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPVxuICAgICAgdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IChlcmFzZV9yZWwgZm10dHlfcmVzdClcbiAgICBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5MSwgZm10JyksIGZtdHR5JylcbiAgKCogUHJpbnRmIGFuZCBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IEFscGhhIGZtdF9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEFscGhhIGZtdCcsIGZtdHR5JylcbiAgfCBUaGV0YSBmbXRfcmVzdCwgVGhldGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChUaGV0YSBmbXQnLCBmbXR0eScpXG5cbiAgKCogRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgRm9ybWF0dGluZ19nZW4gKGZvcm1hdHRpbmdfZ2VuLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2Zvcm1hdHRpbmdfZ2VuIGZvcm1hdHRpbmdfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3RcblxuICAoKiBTY2FuZiBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgUmVhZGVyIGZtdF9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChSZWFkZXIgZm10JywgZm10dHknKVxuICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdF9yZXN0KSwgU3RyaW5nX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10JyksIGZtdHR5JylcbiAgfCBTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXRfcmVzdCksIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCcpLCBmbXR0eScpXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSwgZm10dHlfcmVzdCAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbSBpZ24gcmVzdCBmbXR0eV9yZXN0XG5cbiAgfCBFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0IC0+IEZtdF9mbXR0eV9FQkIgKEVuZF9vZl9mb3JtYXQsIGZtdHR5X3Jlc3QpXG5cbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuYW5kIHR5cGVfZm9ybWF0dGluZ19nZW4gOiB0eXBlIGExIGEzIGIxIGIzIGMxIGMzIGQxIGQzIGUxIGUyIGUzIGYxIGYyIGYzIC5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoZjEsIGIxLCBjMSwgZTEsIGUyLCBmMikgZm10IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdHR5IC0+XG4gICAgKGEzLCBiMywgYzMsIGQzLCBlMywgZjMpIGZtdF9mbXR0eV9lYmIgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIGZtdDAgZm10dHkwIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQxLCBzdHIpKSAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQyLCBmbXR0eTIpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDEgZm10dHkwIGluXG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDMsIGZtdHR5MykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MCBmbXR0eTIgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10Miwgc3RyKSksIGZtdDMpLCBmbXR0eTMpXG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuXG4oKiBUeXBlIGFuIElnbm9yZWRfcGFyYW0gbm9kZSBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG5hbmQgdHlwZV9pZ25vcmVkX3BhcmFtIDogdHlwZSBwIHEgeCB5IHogdCB1IHYgYSBiIGMgZCBlIGYgLlxuICAgICh4LCB5LCB6LCB0LCBxLCBwKSBpZ25vcmVkIC0+XG4gICAgKHAsIHksIHosIHEsIHUsIHYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXRfZm10dHlfZWJiID1cbmZ1biBpZ24gZm10IGZtdHR5IC0+IG1hdGNoIGlnbiB3aXRoXG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQgXyAgICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQzMiBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgXyAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9pbnQ2NCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mbG9hdCBfICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgYXMgaWduJyAtPiB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIGlnbicgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpIC0+XG4gICAgdHlwZV9pZ25vcmVkX3BhcmFtX29uZSAoSWdub3JlZF9mb3JtYXRfYXJnIChwYWRfb3B0LCBzdWJfZm10dHkpKSBmbXQgZm10dHlcbiAgfCBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHknLCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHkgZm10IGZtdHR5IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdHR5JylcbiAgfCBJZ25vcmVkX3JlYWRlciAtPiAoXG4gICAgbWF0Y2ggZm10dHkgd2l0aFxuICAgIHwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXQnKSwgZm10dHknKVxuICAgIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcblxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgOiB0eXBlIGExIGEyIGIxIGIyIGMxIGMyIGQxIGQyIGUxIGUyIGYxIGYyIC5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGQyLCBhMikgaWdub3JlZCAtPlxuICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXQgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHkgLT5cbiAgICAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10X2ZtdHR5X2ViYlxuPSBmdW4gaWduIGZtdCBmbXR0eSAtPlxuICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgaW5cbiAgRm10X2ZtdHR5X0VCQiAoSWdub3JlZF9wYXJhbSAoaWduLCBmbXQnKSwgZm10dHknKVxuXG4oKiBUeXBpbmcgb2YgdGhlIGNvbXBsZXggY2FzZTogXCIlXyguLi4lKVwiLiAqKVxuYW5kIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIDogdHlwZSB3IHggeSB6IHAgcyB0IHUgYSBiIGMgZCBlIGYgLlxuICAgICh3LCB4LCB5LCB6LCBzLCBwKSBmbXR0eSAtPlxuICAgIChwLCB4LCB5LCBzLCB0LCB1KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5X2ZtdF9lYmIgPVxuZnVuIHN1Yl9mbXR0eSBmbXQgZm10dHkgLT4gbWF0Y2ggc3ViX2ZtdHR5LCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSBzdWJfZm10dHlfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChDaGFyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QsIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChTdHJpbmdfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludF90eSBzdWJfZm10dHlfcmVzdCwgSW50X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgSW50MzJfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludDMyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIE5hdGl2ZWludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChOYXRpdmVpbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDY0X3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQ2NF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgRmxvYXRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEZsb2F0X3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBCb29sX3R5IHN1Yl9mbXR0eV9yZXN0LCBCb29sX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEJvb2xfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEFscGhhX3R5IHN1Yl9mbXR0eV9yZXN0LCBBbHBoYV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChBbHBoYV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgVGhldGFfdHkgc3ViX2ZtdHR5X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIFJlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChSZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJZ25vcmVkX3JlYWRlcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG5cbiAgfCBGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5LCBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIHN1YjJfZm10dHkgPD4gRm10dHlfRUJCIHN1YjJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBzdWJfZm10dHlfcmVzdCBmbXQgZm10dHlfcmVzdCBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBzdWJfZm10dHlfcmVzdCcpLCBmbXQnKVxuICB8IEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eSwgIHN1YjJfZm10dHksICBzdWJfZm10dHlfcmVzdCksXG4gICAgRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsIGZtdHR5X3Jlc3QpIC0+XG4gICAgKCogVE9ETyBkZWZpbmUgRm10dHlfcmVsX0VCQiB0byByZW1vdmUgdGhvc2UgZXJhc2VfcmVsICopXG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eSkgPD4gRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViMV9mbXR0eScpXG4gICAgdGhlbiByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjJfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgc3ViX2ZtdHR5JyA9IHRyYW5zIChzeW1tIHN1YjFfZm10dHknKSBzdWIyX2ZtdHR5JyBpblxuICAgIGxldCBfLCBmMiwgXywgZjQgPSBmbXR0eV9yZWxfZGV0IHN1Yl9mbXR0eScgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKSA9XG4gICAgICB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiAoZXJhc2VfcmVsIHN1Yl9mbXR0eV9yZXN0KSBmbXQgZm10dHlfcmVzdFxuICAgIGluXG4gICAgRm10dHlfZm10X0VCQiAoRm9ybWF0X3N1YnN0X3R5IChzdWIxX2ZtdHR5Jywgc3ViMl9mbXR0eScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1tIHN1Yl9mbXR0eV9yZXN0JyksXG4gICAgICAgICAgICAgICAgICAgZm10JylcbiAgfCBFbmRfb2ZfZm10dHksIGZtdHR5IC0+XG4gICAgRm10dHlfZm10X0VCQiAoRW5kX29mX2ZtdHR5LCB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5KVxuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG4oKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIGByZWNhc3RgIGlzIGEgYml0IGRpc2FwcG9pbnRpbmcuIFRoZVxuICAgaW52YXJpYW50IHByb3ZpZGVkIGJ5IHRoZSB0eXBlIGFyZSB2ZXJ5IHN0cm9uZzogdGhlIGlucHV0IGZvcm1hdCdzXG4gICB0eXBlIGlzIGluIHJlbGF0aW9uIHRvIHRoZSBvdXRwdXQgdHlwZSdzIGFzIHdpdG5lc3NlZCBieSB0aGVcbiAgIGZtdHR5X3JlbCBhcmd1bWVudC4gT25lIHdvdWxkIGF0IGZpcnN0IGV4cGVjdCB0aGlzIGZ1bmN0aW9uIHRvIGJlXG4gICB0b3RhbCwgYW5kIGltcGxlbWVudGFibGUgYnkgZXhoYXVzdGl2ZSBwYXR0ZXJuIG1hdGNoaW5nLiBJbnN0ZWFkLFxuICAgd2UgcmV1c2UgdGhlIGhpZ2hseSBwYXJ0aWFsIGFuZCBtdWNoIGxlc3Mgd2VsbC1kZWZpbmVkIGZ1bmN0aW9uXG4gICBgdHlwZV9mb3JtYXRgIHRoYXQgaGFzIGxvc3QgYWxsIGtub3dsZWRnZSBvZiB0aGUgY29ycmVzcG9uZGVuY2VcbiAgIGJldHdlZW4gdGhlIGFyZ3VtZW50J3MgdHlwZXMuXG5cbiAgIEJlc2lkZXMgdGhlIGZhY3QgdGhhdCB0aGlzIGZ1bmN0aW9uIHJldXNlcyBhIGxvdCBvZiB0aGVcbiAgIGB0eXBlX2Zvcm1hdGAgbG9naWMgKGVnLjogc2VlaW5nIEludF90eSBpbiB0aGUgZm10dHkgcGFyYW1ldGVyIGRvZXNcbiAgIG5vdCBsZXQgeW91IG1hdGNoIG9uIEludCBvbmx5LCBhcyB5b3UgbWF5IGluIGZhY3QgaGF2ZSBGbG9hdFxuICAgKEFyZ19wYWRkaW5nLCAuLi4pIChcIiUuKmRcIikgYmVnaW5uaW5nIHdpdGggYW4gSW50X3R5KSwgaXQgaXMgYWxzb1xuICAgYSBwYXJ0aWFsIGZ1bmN0aW9uLCBiZWNhdXNlIHRoZSB0eXBpbmcgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgaXNcbiAgIG5vdCBxdWl0ZSBlbm91Z2ggdG8gcmVjb25zdHJ1Y3QgaXQgdW5hbWJpZ3VvdXNseS4gRm9yIGV4YW1wbGUsIHRoZVxuICAgZm9ybWF0IHR5cGVzIG9mIFwiJWQlX3JcIiBhbmQgXCIlX3IlZFwiIGhhdmUgdGhlIHNhbWUgZm9ybWF0NlxuICAgcGFyYW1ldGVycywgYnV0IHRoZXkgYXJlIG5vdCBhdCBhbGwgZXhjaGFuZ2VhYmxlLCBhbmQgcHV0dGluZyBvbmVcbiAgIGluIHBsYWNlIG9mIHRoZSBvdGhlciBtdXN0IHJlc3VsdCBpbiBhIGR5bmFtaWMgZmFpbHVyZS5cblxuICAgR2l2ZW4gdGhhdDpcbiAgIC0gd2UnZCBoYXZlIHRvIGR1cGxpY2F0ZSBhIGxvdCBvZiBub24tdHJpdmlhbCB0eXBpbmcgbG9naWMgZnJvbSB0eXBlX2Zvcm1hdFxuICAgLSB0aGlzIHdvdWxkbid0IGV2ZW4gZWxpbWluYXRlIChhbGwpIHRoZSBkeW5hbWljIGZhaWx1cmVzXG4gICB3ZSBkZWNpZGVkIHRvIGp1c3QgcmV1c2UgdHlwZV9mb3JtYXQgZGlyZWN0bHkgZm9yIG5vdy5cbiopXG5sZXQgcmVjYXN0IDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyXG4gIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10XG49IGZ1biBmbXQgZm10dHkgLT5cbiAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBQcmludGluZyB0b29scyAqKVxuXG4oKiBBZGQgcGFkZGluZyBzcGFjZXMgYXJvdW5kIGEgc3RyaW5nLiAqKVxubGV0IGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoIHN0ciA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGgsIHBhZHR5ID1cbiAgICBhYnMgd2lkdGgsXG4gICAgKCogd2hpbGUgbGl0ZXJhbCBwYWRkaW5nIHdpZHRocyBhcmUgYWx3YXlzIG5vbi1uZWdhdGl2ZSxcbiAgICAgICBkeW5hbWljYWxseS1zZXQgd2lkdGhzIChBcmdfcGFkZGluZywgZWcuICUqZCkgbWF5IGJlIG5lZ2F0aXZlO1xuICAgICAgIHdlIGludGVycHJldCB0aG9zZSBhcyBzcGVjaWZ5aW5nIGEgcGFkZGluZy10by10aGUtbGVmdDsgdGhpc1xuICAgICAgIG1lYW5zIHRoYXQgJzAnIG1heSBnZXQgZHJvcHBlZCBldmVuIGlmIGl0IHdhcyBleHBsaWNpdGx5IHNldCxcbiAgICAgICBidXQ6XG4gICAgICAgLSB0aGlzIGlzIHdoYXQgdGhlIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBkb2VzLCBhbmRcbiAgICAgICAgIHdlIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgaWYgcG9zc2libGVcbiAgICAgICAtIHdlIGNvdWxkIG9ubHkgc2lnbmFsIHRoaXMgaXNzdWUgYnkgZmFpbGluZyBhdCBydW50aW1lLFxuICAgICAgICAgd2hpY2ggaXMgbm90IHZlcnkgbmljZS4uLiAqKVxuICAgIGlmIHdpZHRoIDwgMCB0aGVuIExlZnQgZWxzZSBwYWR0eSBpblxuICBpZiB3aWR0aCA8PSBsZW4gdGhlbiBzdHIgZWxzZVxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHdpZHRoIChpZiBwYWR0eSA9IFplcm9zIHRoZW4gJzAnIGVsc2UgJyAnKSBpblxuICAgIGJlZ2luIG1hdGNoIHBhZHR5IHdpdGhcbiAgICB8IExlZnQgIC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAwIGxlblxuICAgIHwgUmlnaHQgLT4gU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDAgJiYgKHN0ci5bMF0gPSAnKycgfHwgc3RyLlswXSA9ICctJyB8fCBzdHIuWzBdID0gJyAnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAwIHN0ci5bMF07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHdpZHRoIC0gbGVuICsgMSkgKGxlbiAtIDEpXG4gICAgfCBaZXJvcyB3aGVuIGxlbiA+IDEgJiYgc3RyLlswXSA9ICcwJyAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHdpZHRoIC0gbGVuICsgMikgKGxlbiAtIDIpXG4gICAgfCBaZXJvcyAtPlxuICAgICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzICh3aWR0aCAtIGxlbikgbGVuXG4gICAgZW5kO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEFkZCAnMCcgcGFkZGluZyB0byBpbnQsIGludDMyLCBuYXRpdmVpbnQgb3IgaW50NjQgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqKVxubGV0IGZpeF9pbnRfcHJlY2lzaW9uIHByZWMgc3RyID1cbiAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbWF0Y2ggc3RyLlswXSB3aXRoXG4gIHwgKCcrJyB8ICctJyB8ICcgJykgYXMgYyB3aGVuIHByZWMgKyAxID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAxKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDAgYztcbiAgICBTdHJpbmcuYmxpdCBzdHIgMSByZXMgKHByZWMgLSBsZW4gKyAyKSAobGVuIC0gMSk7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgd2hlbiBwcmVjICsgMiA+IGxlbiAmJiBsZW4gPiAxICYmIChzdHIuWzFdID0gJ3gnIHx8IHN0ci5bMV0gPSAnWCcpIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKHByZWMgKyAyKSAnMCcgaW5cbiAgICBCeXRlcy5zZXQgcmVzIDEgc3RyLlsxXTtcbiAgICBTdHJpbmcuYmxpdCBzdHIgMiByZXMgKHByZWMgLSBsZW4gKyA0KSAobGVuIC0gMik7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgd2hlbiBwcmVjID4gbGVuIC0+XG4gICAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgcHJlYyAnMCcgaW5cbiAgICBTdHJpbmcuYmxpdCBzdHIgMCByZXMgKHByZWMgLSBsZW4pIGxlbjtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuICB8IF8gLT5cbiAgICBzdHJcblxuKCogRXNjYXBlIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgT0NhbWwgbGV4aW5nIGNvbnZlbnRpb24uICopXG5sZXQgc3RyaW5nX3RvX2NhbWxfc3RyaW5nIHN0ciA9XG4gIGxldCBzdHIgPSBTdHJpbmcuZXNjYXBlZCBzdHIgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXFwiJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9pbnQvaW50MzIvbmF0aXZlaW50L2ludDY0IGZpcnN0IGFyZ3VtZW50XG4gICBmcm9tIGFuIGludF9jb252LiAqKVxubGV0IGZvcm1hdF9vZl9pY29udiA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlZFwiIHwgSW50X3BkIC0+IFwiJStkXCIgfCBJbnRfc2QgLT4gXCIlIGRcIlxuICB8IEludF9pIC0+IFwiJWlcIiB8IEludF9waSAtPiBcIiUraVwiIHwgSW50X3NpIC0+IFwiJSBpXCJcbiAgfCBJbnRfeCAtPiBcIiV4XCIgfCBJbnRfQ3ggLT4gXCIlI3hcIlxuICB8IEludF9YIC0+IFwiJVhcIiB8IEludF9DWCAtPiBcIiUjWFwiXG4gIHwgSW50X28gLT4gXCIlb1wiIHwgSW50X0NvIC0+IFwiJSNvXCJcbiAgfCBJbnRfdSAtPiBcIiV1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udkwgPSBmdW5jdGlvblxuICB8IEludF9kIC0+IFwiJUxkXCIgfCBJbnRfcGQgLT4gXCIlK0xkXCIgfCBJbnRfc2QgLT4gXCIlIExkXCJcbiAgfCBJbnRfaSAtPiBcIiVMaVwiIHwgSW50X3BpIC0+IFwiJStMaVwiIHwgSW50X3NpIC0+IFwiJSBMaVwiXG4gIHwgSW50X3ggLT4gXCIlTHhcIiB8IEludF9DeCAtPiBcIiUjTHhcIlxuICB8IEludF9YIC0+IFwiJUxYXCIgfCBJbnRfQ1ggLT4gXCIlI0xYXCJcbiAgfCBJbnRfbyAtPiBcIiVMb1wiIHwgSW50X0NvIC0+IFwiJSNMb1wiXG4gIHwgSW50X3UgLT4gXCIlTHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252bCA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgLT4gXCIlbGRcIiB8IEludF9wZCAtPiBcIiUrbGRcIiB8IEludF9zZCAtPiBcIiUgbGRcIlxuICB8IEludF9pIC0+IFwiJWxpXCIgfCBJbnRfcGkgLT4gXCIlK2xpXCIgfCBJbnRfc2kgLT4gXCIlIGxpXCJcbiAgfCBJbnRfeCAtPiBcIiVseFwiIHwgSW50X0N4IC0+IFwiJSNseFwiXG4gIHwgSW50X1ggLT4gXCIlbFhcIiB8IEludF9DWCAtPiBcIiUjbFhcIlxuICB8IEludF9vIC0+IFwiJWxvXCIgfCBJbnRfQ28gLT4gXCIlI2xvXCJcbiAgfCBJbnRfdSAtPiBcIiVsdVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZuID0gZnVuY3Rpb25cbiAgfCBJbnRfZCAtPiBcIiVuZFwiIHwgSW50X3BkIC0+IFwiJStuZFwiIHwgSW50X3NkIC0+IFwiJSBuZFwiXG4gIHwgSW50X2kgLT4gXCIlbmlcIiB8IEludF9waSAtPiBcIiUrbmlcIiB8IEludF9zaSAtPiBcIiUgbmlcIlxuICB8IEludF94IC0+IFwiJW54XCIgfCBJbnRfQ3ggLT4gXCIlI254XCJcbiAgfCBJbnRfWCAtPiBcIiVuWFwiIHwgSW50X0NYIC0+IFwiJSNuWFwiXG4gIHwgSW50X28gLT4gXCIlbm9cIiB8IEludF9DbyAtPiBcIiUjbm9cIlxuICB8IEludF91IC0+IFwiJW51XCJcblxuKCogR2VuZXJhdGUgdGhlIGZvcm1hdF9mbG9hdCBmaXJzdCBhcmd1bWVudCBmb3JtIGEgZmxvYXRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYyA9XG4gIGlmIGZjb252ID0gRmxvYXRfRiB0aGVuIFwiJS4xMmdcIiBlbHNlXG4gICAgbGV0IHByZWMgPSBhYnMgcHJlYyBpblxuICAgIGxldCBzeW1iID0gY2hhcl9vZl9mY29udiBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoc3RyaW5nX29mX2ludCBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKiBDb252ZXJ0IGFuIGludGVnZXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIGEgY29udmVyc2lvbi4gKilcbmxldCBjb252ZXJ0X2ludCBpY29udiBuID0gZm9ybWF0X2ludCAoZm9ybWF0X29mX2ljb252IGljb252KSBuXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID0gZm9ybWF0X2ludDMyIChmb3JtYXRfb2ZfaWNvbnZsIGljb252KSBuXG5sZXQgY29udmVydF9uYXRpdmVpbnQgaWNvbnYgbiA9IGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG5cbmxldCBjb252ZXJ0X2ludDY0IGljb252IG4gPSBmb3JtYXRfaW50NjQgKGZvcm1hdF9vZl9pY29udkwgaWNvbnYpIG5cblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIG1hdGNoIGZjb252IHdpdGhcbiAgfCBGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIIC0+XG4gICAgbGV0IHNpZ24gPVxuICAgICAgbWF0Y2ggZmNvbnYgd2l0aFxuICAgICAgfCBGbG9hdF9waCB8IEZsb2F0X3BIIC0+ICcrJ1xuICAgICAgfCBGbG9hdF9zaCB8IEZsb2F0X3NIIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGxldCBzdHIgPSBoZXhzdHJpbmdfb2ZfZmxvYXQgeCBwcmVjIHNpZ24gaW5cbiAgICBiZWdpbiBtYXRjaCBmY29udiB3aXRoXG4gICAgfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCAtPiBTdHJpbmcudXBwZXJjYXNlX2FzY2lpIHN0clxuICAgIHwgXyAtPiBzdHJcbiAgICBlbmRcbiAgfCBfIC0+XG4gICAgbGV0IHN0ciA9IGZvcm1hdF9mbG9hdCAoZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMpIHggaW5cbiAgICBpZiBmY29udiA8PiBGbG9hdF9GIHRoZW4gc3RyIGVsc2VcbiAgICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgICAgbGV0IHJlYyBpc192YWxpZCBpID1cbiAgICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgICBtYXRjaCBzdHIuW2ldIHdpdGhcbiAgICAgICAgICB8ICcuJyB8ICdlJyB8ICdFJyAtPiB0cnVlXG4gICAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSlcbiAgICAgIGluXG4gICAgICBtYXRjaCBjbGFzc2lmeV9mbG9hdCB4IHdpdGhcbiAgICAgIHwgRlBfbm9ybWFsIHwgRlBfc3Vibm9ybWFsIHwgRlBfemVybyAtPlxuICAgICAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCJcbiAgICAgIHwgRlBfaW5maW5pdGUgLT5cbiAgICAgICAgaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICAgIHwgRlBfbmFuIC0+IFwibmFuXCJcblxuKCogQ29udmVydCBhIGNoYXIgdG8gYSBzdHJpbmcgYWNjb3JkaW5nIHRvIHRoZSBPQ2FtbCBsZXhpY2FsIGNvbnZlbnRpb24uICopXG5sZXQgZm9ybWF0X2NhbWxfY2hhciBjID1cbiAgbGV0IHN0ciA9IENoYXIuZXNjYXBlZCBjIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFwnJyBpblxuICBTdHJpbmcudW5zYWZlX2JsaXQgc3RyIDAgcmVzIDEgbDtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcblxuKCogQ29udmVydCBhIGZvcm1hdCB0eXBlIHRvIHN0cmluZyAqKVxubGV0IHN0cmluZ19vZl9mbXR0eSBmbXR0eSA9XG4gIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gIGJwcmludF9mbXR0eSBidWYgZm10dHk7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24gKilcblxuKCogTWFrZSBhIGdlbmVyaWMgcHJpbnRpbmcgZnVuY3Rpb24uICopXG4oKiBVc2VkIHRvIGdlbmVyYXRlIFByaW50ZiBhbmQgRm9ybWF0IHByaW50aW5nIGZ1bmN0aW9ucy4gKilcbigqIFBhcmFtZXRlcnM6XG4gICAgIGs6IGEgY29udGludWF0aW9uIGZpbmFsbHkgYXBwbGllZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIGFjY3VtdWxhdG9yLlxuICAgICBvOiB0aGUgb3V0cHV0IHN0cmVhbSAoc2VlIGssICVhIGFuZCAldCkuXG4gICAgIGFjYzogcmV2IGxpc3Qgb2YgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1c2gsIGZvcm1hdHRpbmcsIC4uLikuXG4gICAgIGZtdDogdGhlIGZvcm1hdC4gKilcbmxldCByZWMgbWFrZV9wcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBDaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIG8gYWNjIHJlc3QgcGFkIChmdW4gc3RyIC0+IHN0cilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIG8gYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQgaWNvbnZcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQzMiBpY29udlxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9pbnQ2NCBpY29udlxuICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gayBvIGFjYyByZXN0IHBhZCBwcmVjIGZjb252XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIG1ha2VfcGFkZGluZyBrIG8gYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayBvIChBY2NfZGVsYXkgKGFjYywgZnVuIG8gLT4gZiBvIHgpKSByZXN0XG4gIHwgVGhldGEgcmVzdCAtPlxuICAgIGZ1biBmIC0+IG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RlbGF5IChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBtYWtlX2N1c3RvbSBrIG8gYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2ZsdXNoIGFjYykgcmVzdFxuXG4gIHwgU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19zdHJpbmdfbGl0ZXJhbCAoYWNjLCBzdHIpKSByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayBvIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCB0eSkpIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT4gbWFrZV9wcmludGYgayBvIGFjY1xuICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgIGxldCBuZXdfYWNjID0gQWNjX2ludmFsaWRfYXJnIChhY2MsIFwiUHJpbnRmOiBiYWQgY29udmVyc2lvbiAlW1wiKSBpblxuICAgIGZ1biBfIC0+IG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIG5ld19hY2MgcmVzdFxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9jaGFyIChhY2MsIGMpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIG1ha2VfaWdub3JlZF9wYXJhbSBrIG8gYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19mb3JtYXR0aW5nX2xpdCAoYWNjLCBmbXRpbmdfbGl0KSkgcmVzdFxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgbGV0IGsnIGtvYyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsga29jIChBY2NfZm9ybWF0dGluZ19nZW4gKGFjYywgQWNjX29wZW5fdGFnIGthY2MpKSByZXN0IGluXG4gICAgbWFrZV9wcmludGYgaycgbyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrb2Mga2FjYyA9XG4gICAgICBtYWtlX3ByaW50ZiBrIGtvYyAoQWNjX2Zvcm1hdHRpbmdfZ2VuIChhY2MsIEFjY19vcGVuX2JveCBrYWNjKSkgcmVzdCBpblxuICAgIG1ha2VfcHJpbnRmIGsnIG8gRW5kX29mX2FjYyBmbXQnXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgayBvIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGlnbm9yZWQgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgbyBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIG8gYWNjIGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgXyAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBvIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIHksIHgpIGZtdHR5IC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPiBhID1cbmZ1biBrIG8gYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBTdHJpbmdfdHkgcmVzdCAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEludF90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEludDY0X3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBCb29sX3R5IHJlc3QgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEFscGhhX3R5IHJlc3QgICAgICAgICAgIC0+IGZ1biBfIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBvIGFjYyByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgIC0+IGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIHJlc3QgZm10XG4gIHwgUmVhZGVyX3R5IF8gICAgICAgICAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgXyAgICAgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgRm9ybWF0X2FyZ190eSAoXywgcmVzdCkgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgbyBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgbyBhY2MgZm10XG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEpIHR5MiBpblxuICAgIGZ1biBfIC0+IG1ha2VfZnJvbV9mbXR0eSBrIG8gYWNjIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIEluc2VydCBhbiBBY2NfaW52YWxpZF9hcmcgaW4gdGhlIGFjY3VtdWxhdG9yIGFuZCBjb250aW51ZSB0byBnZW5lcmF0ZVxuICAgY2xvc3VyZXMgdG8gZ2V0IHRoZSByZW1haW5pbmcgYXJndW1lbnRzLiAqKVxuYW5kIG1ha2VfaW52YWxpZF9hcmcgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAoYiAtPiAoYiwgYykgYWNjIC0+IGYpIC0+IGIgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBvIGFjYyBmbXQgLT5cbiAgbWFrZV9wcmludGYgayBvIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB6IC0+IGEpIHBhZGRpbmcgLT4gKHogLT4gc3RyaW5nKSAtPiB4ID1cbiAgZnVuIGsgbyBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfc3RyaW5nIChhY2MsIGZpeF9wYWRkaW5nIHBhZHR5IHdpZHRoICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyBuZXdfYWNjIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZml4X3BhZGRpbmcgcGFkdHkgdyAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgIChiIC0+IChiLCBjKSBhY2MgLT4gZikgLT4gYiAtPiAoYiwgYykgYWNjIC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiAoaW50X2NvbnYgLT4geiAtPiBzdHJpbmcpIC0+XG4gICAgaW50X2NvbnYgLT4geCA9XG4gIGZ1biBrIG8gYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIGZsb2F0IC0+IGEpIHByZWNpc2lvbiAtPiBmbG9hdF9jb252IC0+IHggPVxuICBmdW4gayBvIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgZGVmYXVsdF9mbG9hdF9wcmVjaXNpb24geCBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIHggaW5cbiAgICAgIGxldCBzdHInID0gZml4X3BhZGRpbmcgcGFkdHkgdyBzdHIgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cicpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGNvbnZlcnRfZmxvYXQgZmNvbnYgcCB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHInKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbyAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgcCB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG8gKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKGIgLT4gKGIsIGMpIGFjYyAtPiBmKSAtPiBiIC0+IChiLCBjKSBhY2MgLT5cbiAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHggLT4geSA9XG4gIGZ1biBrIG8gYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayBvIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b21fc3VjYyBhcml0eSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBtYWtlX2N1c3RvbSBrIG8gYWNjIHJlc3QgYXJpdHkgKGYgeClcblxubGV0IGNvbnN0IHggXyA9IHhcblxubGV0IHJlYyBtYWtlX2lwcmludGYgOiB0eXBlIGEgYiBjIGQgZSBmLlxuICAoYiAtPiBmKSAtPiBiIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYSA9XG4gIGZ1biBrIG8gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBDaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IENhbWxfc3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKExpdF9wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX3N0cmluZyAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgTmF0aXZlaW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBJbnQ2NCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgRmxvYXQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEJvb2wgKE5vX3BhZGRpbmcsIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBCb29sIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoQXJnX3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgQWxwaGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBUaGV0YSByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9jdXN0b21fYXJpdHkgayBvIHJlc3QgYXJpdHlcbiAgICB8IFJlYWRlciBfIC0+XG4gICAgICAgICgqIFRoaXMgY2FzZSBpcyBpbXBvc3NpYmxlLCBieSB0eXBpbmcgb2YgZm9ybWF0cy4gIFNlZSB0aGVcbiAgICAgICAgICAgbm90ZSBpbiB0aGUgY29ycmVzcG9uZGluZyBjYXNlIGZvciBtYWtlX3ByaW50Zi4gKilcbiAgICAgICAgYXNzZXJ0IGZhbHNlXG4gICAgfCBGbHVzaCByZXN0IC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBGb3JtYXRfc3Vic3QgKF8sIGZtdHR5LCByZXN0KSAtPlxuICAgICAgICBmdW4gKEZvcm1hdCAoZm10LCBfKSkgLT5cbiAgICAgICAgICBtYWtlX2lwcmludGYgayBvXG4gICAgICAgICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcbiAgICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lnbm9yZWRfcGFyYW0gKGZ1biB4IF8gLT4gayB4KSBvIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZi5cbiAgKGIgLT4gZikgLT4gYiAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPiB4ID1cbiAgZnVuIGsgbyBmbXQgcGFkIHByZWMgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAsIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTm9fcGFkZGluZyAgICwgQXJnX3ByZWNpc2lvbiAgIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBMaXRfcHJlY2lzaW9uIF8gLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBBcmdfcGFkZGluZyBfLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpKSlcbmFuZCBmbl9vZl9jdXN0b21fYXJpdHkgOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChiIC0+IGYpIC0+IGIgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgKCkgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayAoKSBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPSBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIChnZXRfcGx1cyAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZmxvYXQgKGdldF9wYWRfb3B0ICdfJywgZ2V0X3ByZWNfb3B0ICgpKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChGbG9hdCAoZmNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2InIHwgJ0InIC0+XG4gICAgICBsZXQgcGFkID0gY2hlY2tfbm9fMCBzeW1iIChnZXRfcGFkcHJlYyAoKSkgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Jvb2wgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKEJvb2wgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnYScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChBbHBoYSBmbXRfcmVzdClcbiAgICB8ICd0JyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKFRoZXRhIGZtdF9yZXN0KVxuICAgIHwgJ3InIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfcmVhZGVyLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlIEZtdF9FQkIgKFJlYWRlciBmbXRfcmVzdClcbiAgICB8ICchJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKEZsdXNoIGZtdF9yZXN0KVxuICAgIHwgKCclJyB8ICdAJykgYXMgYyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoYywgZm10X3Jlc3QpKVxuICAgIHwgJ3snIC0+XG4gICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIHN0cl9pbmQgZW5kX2luZCAnfScgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICBsZXQgc3ViX2ZtdHR5ID0gZm10dHlfb2ZfZm10IHN1Yl9mbXQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfZm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X2FyZyAoZ2V0X3BhZF9vcHQgJ3snLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICcoJyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJyknIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgc3ViX2VuZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJ18nLCBzdWJfZm10dHkpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoRm9ybWF0X3N1YnN0IChnZXRfcGFkX29wdCAnKCcsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpKVxuICAgIHwgJ1snIC0+XG4gICAgICBsZXQgbmV4dF9pbmQsIGNoYXJfc2V0ID0gcGFyc2VfY2hhcl9zZXQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ18nLCBjaGFyX3NldCkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBGbXRfRUJCIChTY2FuX2NoYXJfc2V0IChnZXRfcGFkX29wdCAnWycsIGNoYXJfc2V0LCBmbXRfcmVzdCkpXG4gICAgfCAnLScgfCAnKycgfCAnIycgfCAnICcgfCAnXycgLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGZsYWcgJUMgaXMgb25seSBhbGxvd2VkIGFmdGVyIHRoZSAnJSUnLCBiZWZvcmUgcGFkZGluZyBhbmQgcHJlY2lzaW9uXCJcbiAgICAgICAgc3RyIHBjdF9pbmQgc3ltYlxuICAgIHwgXyAtPlxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCBcXFxuICAgICAgICAgaW52YWxpZCBjb252ZXJzaW9uIFxcXCIlJSVjXFxcIlwiIHN0ciAoc3RyX2luZCAtIDEpIHN5bWJcbiAgICBpblxuICAgICgqIENoZWNrIGZvciB1bnVzZWQgb3B0aW9ucywgYW5kIHJlamVjdCB0aGVtIGFzIGluY29tcGF0aWJsZS5cblxuICAgICAgIFN1Y2ggY2hlY2tzIG5lZWQgdG8gYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsIGFzIHRoZSBsZWdhY3lcbiAgICAgICBwYXJzZXIgc2lsZW50bHkgaWdub3JlZCBpbmNvbXBhdGlibGUgZmxhZ3MuICopXG4gICAgaWYgbm90IGxlZ2FjeV9iZWhhdmlvciB0aGVuIGJlZ2luXG4gICAgaWYgbm90ICFwbHVzX3VzZWQgJiYgcGx1cyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiO1xuICAgIGlmIG5vdCAhaGFzaF91c2VkICYmIGhhc2ggdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInIydcIjtcbiAgICBpZiBub3QgIXNwYWNlX3VzZWQgJiYgc3BhY2UgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInICdcIjtcbiAgICBpZiBub3QgIXBhZF91c2VkICAmJiBQYWRkaW5nX0VCQiBwYWQgPD4gUGFkZGluZ19FQkIgTm9fcGFkZGluZyB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcImBwYWRkaW5nJ1wiO1xuICAgIGlmIG5vdCAhcHJlY191c2VkICYmIFByZWNpc2lvbl9FQkIgcHJlYyA8PiBQcmVjaXNpb25fRUJCIE5vX3ByZWNpc2lvbiB0aGVuXG4gICAgICBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgKGlmIGlnbiB0aGVuICdfJyBlbHNlIHN5bWIpXG4gICAgICAgIFwiYHByZWNpc2lvbidcIjtcbiAgICBpZiBpZ24gJiYgcGx1cyB0aGVuIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnXycgXCInKydcIjtcbiAgICBlbmQ7XG4gICAgKCogdGhpcyBsYXN0IHRlc3QgbXVzdCBub3QgYmUgZGlzYWJsZWQgaW4gbGVnYWN5IG1vZGUsXG4gICAgICAgYXMgaWdub3JpbmcgaXQgd291bGQgdHlwaWNhbGx5IHJlc3VsdCBpbiBhIGRpZmZlcmVudCB0eXBpbmdcbiAgICAgICB0aGFuIHdoYXQgdGhlIGxlZ2FjeSBwYXJzZXIgdXNlZCAqKVxuICAgIGlmIG5vdCAhaWduX3VzZWQgJiYgaWduIHRoZW5cbiAgICAgIGJlZ2luIG1hdGNoIHN5bWIgd2l0aFxuICAgICAgICAoKiBhcmd1bWVudC1sZXNzIGZvcm1hdHMgY2FuIHNhZmVseSBiZSBpZ25vcmVkIGluIGxlZ2FjeSBtb2RlICopXG4gICAgICAgIHwgKCdAJyB8ICclJyB8ICchJyB8ICcsJykgd2hlbiBsZWdhY3lfYmVoYXZpb3IgLT4gKClcbiAgICAgICAgfCBfIC0+XG4gICAgICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInXydcIlxuICAgICAgZW5kO1xuICAgIGZtdF9yZXN1bHRcblxuICAoKiBQYXJzZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9ucyAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gIGFuZCBjaGVja19vcGVuX2JveCA6IHR5cGUgYSBiIGMgZCBlIGYgLiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IHVuaXQgPVxuICBmdW4gZm10IC0+IG1hdGNoIGZtdCB3aXRoXG4gICAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBFbmRfb2ZfZm9ybWF0KSAtPiAoXG4gICAgICB0cnkgaWdub3JlIChvcGVuX2JveF9vZl9zdHJpbmcgc3RyKSB3aXRoIEZhaWx1cmUgXyAtPlxuICAgICAgICAoKCogRW1pdCB3YXJuaW5nOiBpbnZhbGlkIG9wZW4gYm94ICopKVxuICAgIClcbiAgICB8IF8gLT4gKClcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgb3B0aW9uYWwgPG5hbWU+IGFmdGVyIFwiQHtcIiBvciBcIkBbXCIuICopXG4gIGFuZCBwYXJzZV90YWcgOiB0eXBlIGUgZiAuIGJvb2wgLT4gaW50IC0+IGludCAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBpc19vcGVuX3RhZyBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICB0cnlcbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBsZXQgaW5kID0gU3RyaW5nLmluZGV4X2Zyb20gc3RyIChzdHJfaW5kICsgMSkgJz4nIGluXG4gICAgICAgIGlmIGluZCA+PSBlbmRfaW5kIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICBsZXQgc3ViX3N0ciA9IFN0cmluZy5zdWIgc3RyIHN0cl9pbmQgKGluZCAtIHN0cl9pbmQgKyAxKSBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChpbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIChpbmQgKyAxKSBpblxuICAgICAgICBsZXQgc3ViX2Zvcm1hdCA9IEZvcm1hdCAoc3ViX2ZtdCwgc3ViX3N0cikgaW5cbiAgICAgICAgbGV0IGZvcm1hdHRpbmcgPSBpZiBpc19vcGVuX3RhZyB0aGVuIE9wZW5fdGFnIHN1Yl9mb3JtYXQgZWxzZSAoXG4gICAgICAgICAgY2hlY2tfb3Blbl9ib3ggc3ViX2ZtdDtcbiAgICAgICAgICBPcGVuX2JveCBzdWJfZm9ybWF0KSBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgZmxvYXRfY29udi4gKilcbiAgYW5kIGNvbXB1dGVfZmxvYXRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBzcGFjZSBzeW1iID1cbiAgbWF0Y2ggcGx1cywgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCAnZicgLT4gRmxvYXRfZiAgfCBmYWxzZSwgZmFsc2UsICdlJyAtPiBGbG9hdF9lXG4gICAgfCBmYWxzZSwgIHRydWUsICdmJyAtPiBGbG9hdF9zZiB8IGZhbHNlLCAgdHJ1ZSwgJ2UnIC0+IEZsb2F0X3NlXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdmJyAtPiBGbG9hdF9wZiB8ICB0cnVlLCBmYWxzZSwgJ2UnIC0+IEZsb2F0X3BlXG4gICAgfCBmYWxzZSwgZmFsc2UsICdFJyAtPiBGbG9hdF9FICB8IGZhbHNlLCBmYWxzZSwgJ2cnIC0+IEZsb2F0X2dcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0UnIC0+IEZsb2F0X3NFIHwgZmFsc2UsICB0cnVlLCAnZycgLT4gRmxvYXRfc2dcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ0UnIC0+IEZsb2F0X3BFIHwgIHRydWUsIGZhbHNlLCAnZycgLT4gRmxvYXRfcGdcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgJ0cnIC0+IEZsb2F0X3NHXG4gICAgfCAgdHJ1ZSwgZmFsc2UsICdHJyAtPiBGbG9hdF9wR1xuICAgIHwgZmFsc2UsIGZhbHNlLCAnaCcgLT4gRmxvYXRfaFxuICAgIHwgZmFsc2UsICB0cnVlLCAnaCcgLT4gRmxvYXRfc2hcbiAgICB8ICB0cnVlLCBmYWxzZSwgJ2gnIC0+IEZsb2F0X3BoXG4gICAgfCBmYWxzZSwgZmFsc2UsICdIJyAtPiBGbG9hdF9IXG4gICAgfCBmYWxzZSwgIHRydWUsICdIJyAtPiBGbG9hdF9zSFxuICAgIHwgIHRydWUsIGZhbHNlLCAnSCcgLT4gRmxvYXRfcEhcbiAgICB8IGZhbHNlLCBmYWxzZSwgJ0YnIC0+IEZsb2F0X0ZcbiAgICB8ICB0cnVlLCAgdHJ1ZSwgXyAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgKCogcGx1cyBhbmQgc3BhY2U6IGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBwcmVmZXJzIHBsdXMgKilcbiAgICAgICAgY29tcHV0ZV9mbG9hdF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGZhbHNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICcgJyBcIicrJ1wiXG4gICAgfCBmYWxzZSwgIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCAgdHJ1ZSwgZmFsc2UsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIHNwYWNlIHN5bWJcbiAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIlxuICAgIHwgZmFsc2UsIGZhbHNlLCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG5sZXQgcHJpbnRlcnMgPSByZWYgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdG9fc3RyaW5nIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIHRyeSBoZCB4IHdpdGggXyAtPiBOb25lIHdpdGhcbiAgICAgICAgfCBTb21lIHMgLT4gc1xuICAgICAgICB8IE5vbmUgLT4gY29udiB0bClcbiAgICB8IFtdIC0+XG4gICAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgICAgICAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgICAgICAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICAgICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgICAgICAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgICAgICAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICAgICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KSBpblxuICBjb252ICFwcmludGVyc1xuXG5sZXQgcHJpbnQgZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGZsdXNoIHN0ZGVycjtcbiAgICByYWlzZSB4XG5cbmxldCBjYXRjaCBmY3QgYXJnID1cbiAgdHJ5XG4gICAgZmN0IGFyZ1xuICB3aXRoIHggLT5cbiAgICBmbHVzaCBzdGRvdXQ7XG4gICAgZXByaW50ZiBcIlVuY2F1Z2h0IGV4Y2VwdGlvbjogJXNcXG5cIiAodG9fc3RyaW5nIHgpO1xuICAgIGV4aXQgMlxuXG50eXBlIHJhd19iYWNrdHJhY2Vfc2xvdFxudHlwZSByYXdfYmFja3RyYWNlXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlOlxuICB1bml0IC0+IHJhd19iYWNrdHJhY2UgPSBcImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlXCJcblxuZXh0ZXJuYWwgcmFpc2Vfd2l0aF9iYWNrdHJhY2U6IGV4biAtPiByYXdfYmFja3RyYWNlIC0+ICdhXG4gID0gXCIlcmFpc2Vfd2l0aF9iYWNrdHJhY2VcIlxuXG50eXBlIGJhY2t0cmFjZV9zbG90ID1cbiAgfCBLbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSAgICA6IGJvb2w7XG4gICAgICBmaWxlbmFtZSAgICA6IHN0cmluZztcbiAgICAgIGxpbmVfbnVtYmVyIDogaW50O1xuICAgICAgc3RhcnRfY2hhciAgOiBpbnQ7XG4gICAgICBlbmRfY2hhciAgICA6IGludDtcbiAgICAgIGlzX2lubGluZSAgIDogYm9vbDtcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlIH07XG4gICAgICAgICBVbmtub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZSB9XVxuXG5leHRlcm5hbCBjb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdDpcbiAgcmF3X2JhY2t0cmFjZV9zbG90IC0+IGJhY2t0cmFjZV9zbG90ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZV9zbG90XCJcblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlOlxuICByYXdfYmFja3RyYWNlIC0+IGJhY2t0cmFjZV9zbG90IGFycmF5ID0gXCJjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZVwiXG5cbmxldCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgYnQgPVxuICB0cnkgU29tZSAoY29udmVydF9yYXdfYmFja3RyYWNlIGJ0KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgcG9zIHNsb3QgPVxuICBsZXQgaW5mbyBpc19yYWlzZSA9XG4gICAgaWYgaXNfcmFpc2UgdGhlblxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGF0XCIgZWxzZSBcIlJlLXJhaXNlZCBhdFwiXG4gICAgZWxzZVxuICAgICAgaWYgcG9zID0gMCB0aGVuIFwiUmFpc2VkIGJ5IHByaW1pdGl2ZSBvcGVyYXRpb24gYXRcIiBlbHNlIFwiQ2FsbGVkIGZyb21cIlxuICBpblxuICBtYXRjaCBzbG90IHdpdGhcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIGlmIGwuaXNfcmFpc2UgdGhlblxuICAgICAgICAoKiBjb21waWxlci1pbnNlcnRlZCByZS1yYWlzZSwgc2tpcHBlZCAqKSBOb25lXG4gICAgICBlbHNlXG4gICAgICAgIFNvbWUgKHNwcmludGYgXCIlcyB1bmtub3duIGxvY2F0aW9uXCIgKGluZm8gZmFsc2UpKVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT5cbiAgICAgIFNvbWUgKHNwcmludGYgXCIlcyBmaWxlIFxcXCIlc1xcXCIlcywgbGluZSAlZCwgY2hhcmFjdGVycyAlZC0lZFwiXG4gICAgICAgICAgICAgIChpbmZvIGwuaXNfcmFpc2UpIGwuZmlsZW5hbWVcbiAgICAgICAgICAgICAgKGlmIGwuaXNfaW5saW5lIHRoZW4gXCIgKGlubGluZWQpXCIgZWxzZSBcIlwiKVxuICAgICAgICAgICAgICBsLmxpbmVfbnVtYmVyIGwuc3RhcnRfY2hhciBsLmVuZF9jaGFyKVxuXG5sZXQgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIGJhY2t0cmFjZSA9XG4gIG1hdGNoIGJhY2t0cmFjZSB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICAgZnByaW50ZiBvdXRjaGFuXG4gICAgICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGZwcmludGYgb3V0Y2hhbiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lXG5cbmxldCBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gcmF3X2JhY2t0cmFjZSA9XG4gIHByaW50X2V4Y2VwdGlvbl9iYWNrdHJhY2Ugb3V0Y2hhbiAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOiBwcmludHMgdGhlIGdsb2JhbCBjdXJyZW50IGJhY2t0cmFjZSAqKVxubGV0IHByaW50X2JhY2t0cmFjZSBvdXRjaGFuID1cbiAgcHJpbnRfcmF3X2JhY2t0cmFjZSBvdXRjaGFuIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxubGV0IGJhY2t0cmFjZV90b19zdHJpbmcgYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgIFwiKFByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBjYW5ub3QgcHJpbnQgc3RhY2sgYmFja3RyYWNlKVxcblwiXG4gIHwgU29tZSBhIC0+XG4gICAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTAyNCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBhIC0gMSBkb1xuICAgICAgICBtYXRjaCBmb3JtYXRfYmFja3RyYWNlX3Nsb3QgaSBhLihpKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIHN0ciAtPiBicHJpbnRmIGIgXCIlc1xcblwiIHN0clxuICAgICAgZG9uZTtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG5cbmxldCByYXdfYmFja3RyYWNlX3RvX3N0cmluZyByYXdfYmFja3RyYWNlID1cbiAgYmFja3RyYWNlX3RvX3N0cmluZyAoY29udmVydF9yYXdfYmFja3RyYWNlIHJhd19iYWNrdHJhY2UpXG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX3JhaXNlXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX2lubGluZSA9IGZ1bmN0aW9uXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPiBsLmlzX2lubGluZVxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuXG50eXBlIGxvY2F0aW9uID0ge1xuICBmaWxlbmFtZSA6IHN0cmluZztcbiAgbGluZV9udW1iZXIgOiBpbnQ7XG4gIHN0YXJ0X2NoYXIgOiBpbnQ7XG4gIGVuZF9jaGFyIDogaW50O1xufVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24gPSBmdW5jdGlvblxuICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBOb25lXG4gIHwgS25vd25fbG9jYXRpb24gbCAtPlxuICAgIFNvbWUge1xuICAgICAgZmlsZW5hbWUgICAgPSBsLmZpbGVuYW1lO1xuICAgICAgbGluZV9udW1iZXIgPSBsLmxpbmVfbnVtYmVyO1xuICAgICAgc3RhcnRfY2hhciAgPSBsLnN0YXJ0X2NoYXI7XG4gICAgICBlbmRfY2hhciAgICA9IGwuZW5kX2NoYXI7XG4gICAgfVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RzIHJhd19iYWNrdHJhY2UgPVxuICAoKiBUaGUgZG9jdW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdGhhdCBTb21lIGlzXG4gICAgIHJldHVybmVkIG9ubHkgaWYgYSBwYXJ0IG9mIHRoZSB0cmFjZSBpcyB1c2FibGUuIFRoaXMgZ2l2ZXMgdXNcbiAgICAgYSBiaXQgbW9yZSB3b3JrIHRoYW4ganVzdCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UsIGJ1dCBpdCBtYWtlcyB0aGVcbiAgICAgQVBJIG1vcmUgdXNlci1mcmllbmRseSAtLSBvdGhlcndpc2UgbW9zdCB1c2VycyB3b3VsZCBoYXZlIHRvXG4gICAgIHJlaW1wbGVtZW50IHRoZSBcIlByb2dyYW0gbm90IGxpbmtlZCB3aXRoIC1nLCBzb3JyeVwiIGxvZ2ljXG4gICAgIHRoZW1zZWx2ZXMuICopXG4gIG1hdGNoIGNvbnZlcnRfcmF3X2JhY2t0cmFjZSByYXdfYmFja3RyYWNlIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSBiYWNrdHJhY2UgLT5cbiAgICAgIGxldCB1c2FibGVfc2xvdCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG4gICAgICAgIHwgS25vd25fbG9jYXRpb24gXyAtPiB0cnVlIGluXG4gICAgICBsZXQgcmVjIGV4aXN0c191c2FibGUgPSBmdW5jdGlvblxuICAgICAgICB8ICgtMSkgLT4gZmFsc2VcbiAgICAgICAgfCBpIC0+IHVzYWJsZV9zbG90IGJhY2t0cmFjZS4oaSkgfHwgZXhpc3RzX3VzYWJsZSAoaSAtIDEpIGluXG4gICAgICBpZiBleGlzdHNfdXNhYmxlIChBcnJheS5sZW5ndGggYmFja3RyYWNlIC0gMSlcbiAgICAgIHRoZW4gU29tZSBiYWNrdHJhY2VcbiAgICAgIGVsc2UgTm9uZVxuXG5tb2R1bGUgU2xvdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBiYWNrdHJhY2Vfc2xvdFxuICBsZXQgZm9ybWF0ID0gZm9ybWF0X2JhY2t0cmFjZV9zbG90XG4gIGxldCBpc19yYWlzZSA9IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlXG4gIGxldCBpc19pbmxpbmUgPSBiYWNrdHJhY2Vfc2xvdF9pc19pbmxpbmVcbiAgbGV0IGxvY2F0aW9uID0gYmFja3RyYWNlX3Nsb3RfbG9jYXRpb25cbmVuZFxuXG5leHRlcm5hbCByYXdfYmFja3RyYWNlX2xlbmd0aCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbGVuZ3RoXCIgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgZ2V0X3Jhd19iYWNrdHJhY2Vfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2UgLT4gaW50IC0+IHJhd19iYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX3Nsb3RcIlxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9uZXh0X3Nsb3QgOlxuICByYXdfYmFja3RyYWNlX3Nsb3QgLT4gcmF3X2JhY2t0cmFjZV9zbG90IG9wdGlvblxuICA9IFwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdFwiXG5cbigqIGNvbmZ1c2luZ2x5IG5hbWVkOlxuICAgcmV0dXJucyB0aGUgKnN0cmluZyogY29ycmVzcG9uZGluZyB0byB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgZ2V0X2JhY2t0cmFjZSAoKSA9IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIChnZXRfcmF3X2JhY2t0cmFjZSAoKSlcblxuZXh0ZXJuYWwgcmVjb3JkX2JhY2t0cmFjZTogYm9vbCAtPiB1bml0ID0gXCJjYW1sX3JlY29yZF9iYWNrdHJhY2VcIlxuZXh0ZXJuYWwgYmFja3RyYWNlX3N0YXR1czogdW5pdCAtPiBib29sID0gXCJjYW1sX2JhY2t0cmFjZV9zdGF0dXNcIlxuXG5sZXQgcmVnaXN0ZXJfcHJpbnRlciBmbiA9XG4gIHByaW50ZXJzIDo9IGZuIDo6ICFwcmludGVyc1xuXG5leHRlcm5hbCBnZXRfY2FsbHN0YWNrOiBpbnQgLT4gcmF3X2JhY2t0cmFjZSA9IFwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2tcIlxuXG5sZXQgZXhuX3Nsb3QgeCA9XG4gIGxldCB4ID0gT2JqLnJlcHIgeCBpblxuICBpZiBPYmoudGFnIHggPSAwIHRoZW4gT2JqLmZpZWxkIHggMCBlbHNlIHhcblxubGV0IGV4bl9zbG90X2lkIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDEpIDogaW50KVxuXG5sZXQgZXhuX3Nsb3RfbmFtZSB4ID1cbiAgbGV0IHNsb3QgPSBleG5fc2xvdCB4IGluXG4gIChPYmoub2JqIChPYmouZmllbGQgc2xvdCAwKSA6IHN0cmluZylcblxuXG5sZXQgdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgPSByZWYgTm9uZVxuXG5sZXQgc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGZuID0gdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgOj0gU29tZSBmblxuXG5sZXQgZW1wdHlfYmFja3RyYWNlIDogcmF3X2JhY2t0cmFjZSA9IE9iai5vYmogKE9iai5uZXdfYmxvY2sgT2JqLmFic3RyYWN0X3RhZyAwKVxuXG5sZXQgdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpID1cbiAgdHJ5XG4gICAgZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgd2l0aCBfICgqIE91dF9vZl9tZW1vcnk/ICopIC0+XG4gICAgZW1wdHlfYmFja3RyYWNlXG5cbmxldCBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uJyBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgKCogR2V0IHRoZSBiYWNrdHJhY2Ugbm93LCBpbiBjYXNlIG9uZSBvZiB0aGUgW2F0X2V4aXRdIGZ1bmN0aW9uXG4gICAgICAgZGVzdHJveXMgaXQuICopXG4gICAgbGV0IHJhd19iYWNrdHJhY2UgPVxuICAgICAgaWYgZGVidWdnZXJfaW5fdXNlICgqIFNhbWUgdGVzdCBhcyBpbiBbYnl0ZXJ1bi9wcmludGV4Yy5jXSAqKSB0aGVuXG4gICAgICAgIGVtcHR5X2JhY2t0cmFjZVxuICAgICAgZWxzZVxuICAgICAgICB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKClcbiAgICBpblxuICAgICh0cnkgUGVydmFzaXZlcy5kb19hdF9leGl0ICgpIHdpdGggXyAtPiAoKSk7XG4gICAgbWF0Y2ggIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHdpdGhcbiAgICB8IE5vbmUgLT5cbiAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2U7XG4gICAgICAgIGZsdXNoIHN0ZGVyclxuICAgIHwgU29tZSBoYW5kbGVyIC0+XG4gICAgICAgIHRyeVxuICAgICAgICAgIGhhbmRsZXIgZXhuIHJhd19iYWNrdHJhY2VcbiAgICAgICAgd2l0aCBleG4nIC0+XG4gICAgICAgICAgbGV0IHJhd19iYWNrdHJhY2UnID0gdHJ5X2dldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICAgICAgZXByaW50ZiBcIkZhdGFsIGVycm9yOiBleGNlcHRpb24gJXNcXG5cIiAodG9fc3RyaW5nIGV4bik7XG4gICAgICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgICAgICBlcHJpbnRmIFwiRmF0YWwgZXJyb3IgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXI6IGV4Y2VwdGlvbiAlc1xcblwiXG4gICAgICAgICAgICAodG9fc3RyaW5nIGV4bicpO1xuICAgICAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgICAgIGZsdXNoIHN0ZGVyclxuICB3aXRoXG4gICAgfCBPdXRfb2ZfbWVtb3J5IC0+XG4gICAgICAgIHByZXJyX2VuZGxpbmVcbiAgICAgICAgICBcIkZhdGFsIGVycm9yOiBvdXQgb2YgbWVtb3J5IGluIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyXCJcblxuKCogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgW2NhbWxfZmF0YWxfdW5jYXVnaHRfZXhjZXB0aW9uXSBpblxuICAgW2J5dGVydW4vcHJpbnRleGMuY10gd2hpY2ggZXhwZWN0cyBubyBleGNlcHRpb24gaXMgcmFpc2VkLiAqKVxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24gZXhuIGRlYnVnZ2VyX2luX3VzZSA9XG4gIHRyeVxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2VcbiAgd2l0aCBfIC0+XG4gICAgKCogVGhlcmUgaXMgbm90IG11Y2ggd2UgY2FuIGRvIGF0IHRoaXMgcG9pbnQgKilcbiAgICAoKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0ICgpID1cbiAgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgXCJQcmludGV4Yy5oYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXCJcbiAgICBoYW5kbGVfdW5jYXVnaHRfZXhjZXB0aW9uXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgWGF2aWVyIExlcm95IGFuZCBEYW1pZW4gRG9saWdleiwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmxldCBnZW5lcmljX3F1b3RlIHF1b3RlcXVvdGUgcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgaWYgcy5baV0gPSAnXFwnJ1xuICAgIHRoZW4gQnVmZmVyLmFkZF9zdHJpbmcgYiBxdW90ZXF1b3RlXG4gICAgZWxzZSBCdWZmZXIuYWRkX2NoYXIgYiAgcy5baV1cbiAgZG9uZTtcbiAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcJyc7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMV1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9iYXNlbmFtZS5odG1sXG4gIEluIHN0ZXAgMSBvZiBbWzFdXSwgd2UgY2hvb3NlIHRvIHJldHVybiBcIi5cIiBmb3IgZW1wdHkgaW5wdXQuXG4gICAgKGZvciBjb21wYXRpYmlsaXR5IHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgT0NhbWwpXG4gIEluIHN0ZXAgMiwgd2UgY2hvb3NlIHRvIHByb2Nlc3MgXCIvL1wiIG5vcm1hbGx5LlxuICBTdGVwIDYgaXMgbm90IGltcGxlbWVudGVkOiB3ZSBjb25zaWRlciB0aGF0IHRoZSBbc3VmZml4XSBvcGVyYW5kIGlzXG4gICAgYWx3YXlzIGFic2VudC4gIFN1ZmZpeGVzIGFyZSBoYW5kbGVkIGJ5IFtjaG9wX3N1ZmZpeF0gYW5kIFtjaG9wX2V4dGVuc2lvbl0uXG4qKVxubGV0IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lIG5hbWUgPVxuICBsZXQgcmVjIGZpbmRfZW5kIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBmaW5kX2VuZCAobiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyBuIChuICsgMSlcbiAgYW5kIGZpbmRfYmVnIG4gcCA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCBwXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIFN0cmluZy5zdWIgbmFtZSAobiArIDEpIChwIC0gbiAtIDEpXG4gICAgZWxzZSBmaW5kX2JlZyAobiAtIDEpIHBcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgZmluZF9lbmQgKFN0cmluZy5sZW5ndGggbmFtZSAtIDEpXG5cbigqIFRoaXMgZnVuY3Rpb24gaW1wbGVtZW50cyB0aGUgT3BlbiBHcm91cCBzcGVjaWZpY2F0aW9uIGZvdW5kIGhlcmU6XG4gIFtbMl1dIGh0dHA6Ly9wdWJzLm9wZW5ncm91cC5vcmcvb25saW5lcHVicy85Njk5OTE5Nzk5L3V0aWxpdGllcy9kaXJuYW1lLmh0bWxcbiAgSW4gc3RlcCA2IG9mIFtbMl1dLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4qKVxubGV0IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgdHJhaWxpbmdfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiB0cmFpbGluZ19zZXAgKG4gLSAxKVxuICAgIGVsc2UgYmFzZSBuXG4gIGFuZCBiYXNlIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIG5cbiAgICBlbHNlIGJhc2UgKG4gLSAxKVxuICBhbmQgaW50ZXJtZWRpYXRlX3NlcCBuID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIDFcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gaW50ZXJtZWRpYXRlX3NlcCAobiAtIDEpXG4gICAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAobiArIDEpXG4gIGluXG4gIGlmIG5hbWUgPSBcIlwiXG4gIHRoZW4gY3VycmVudF9kaXJfbmFtZVxuICBlbHNlIHRyYWlsaW5nX3NlcCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubW9kdWxlIFVuaXggPSBzdHJ1Y3RcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCIvXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gcy5baV0gPSAnLydcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPSBTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJ1xuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgICBTdHJpbmcuc3ViIG5hbWUgKFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZilcbiAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgPSBzdWZmXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyID0gc3RydWN0XG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiXFxcXFwiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IGxldCBjID0gcy5baV0gaW4gYyA9ICcvJyB8fCBjID0gJ1xcXFwnIHx8IGMgPSAnOidcbiAgbGV0IGlzX3JlbGF0aXZlIG4gPVxuICAgIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICcvJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnXFxcXCcpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgbi5bMV0gPD4gJzonKVxuICBsZXQgaXNfaW1wbGljaXQgbiA9XG4gICAgaXNfcmVsYXRpdmUgblxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAyIHx8IFN0cmluZy5zdWIgbiAwIDIgPD4gXCIuXFxcXFwiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi5cXFxcXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgIFN0cmluZy5sZW5ndGggbmFtZSA+PSBTdHJpbmcubGVuZ3RoIHN1ZmYgJiZcbiAgIChsZXQgcyA9IFN0cmluZy5zdWIgbmFtZSAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gU3RyaW5nLmxlbmd0aCBzdWZmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpIGluXG4gICAgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmKVxuICBsZXQgdGVtcF9kaXJfbmFtZSA9XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJURU1QXCIgd2l0aCBOb3RfZm91bmQgLT4gXCIuXCJcbiAgbGV0IHF1b3RlIHMgPVxuICAgIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInIGVsc2VcbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJ1xcXCInIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAwIGk7XG4gICAgICB8IGMgICAgLT4gQnVmZmVyLmFkZF9jaGFyIGIgYzsgbG9vcCAoaSsxKTtcbiAgICBhbmQgbG9vcF9icyBuIGkgPVxuICAgICAgaWYgaSA9IGwgdGhlbiBiZWdpblxuICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gICAgICAgIGFkZF9icyBuO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgICB8ICdcXFwiJyAtPiBhZGRfYnMgKDIqbisxKTsgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInOyBsb29wIChpKzEpO1xuICAgICAgICB8ICdcXFxcJyAtPiBsb29wX2JzIChuKzEpIChpKzEpO1xuICAgICAgICB8IF8gICAgLT4gYWRkX2JzIG47IGxvb3AgaVxuICAgICAgZW5kXG4gICAgYW5kIGFkZF9icyBuID0gZm9yIF9qID0gMSB0byBuIGRvIEJ1ZmZlci5hZGRfY2hhciBiICdcXFxcJzsgZG9uZVxuICAgIGluXG4gICAgbG9vcCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA9IHN0cnVjdFxuICBsZXQgY3VycmVudF9kaXJfbmFtZSA9IFwiLlwiXG4gIGxldCBwYXJlbnRfZGlyX25hbWUgPSBcIi4uXCJcbiAgbGV0IGRpcl9zZXAgPSBcIi9cIlxuICBsZXQgaXNfZGlyX3NlcCA9IFdpbjMyLmlzX2Rpcl9zZXBcbiAgbGV0IGlzX3JlbGF0aXZlID0gV2luMzIuaXNfcmVsYXRpdmVcbiAgbGV0IGlzX2ltcGxpY2l0ID0gV2luMzIuaXNfaW1wbGljaXRcbiAgbGV0IGNoZWNrX3N1ZmZpeCA9IFdpbjMyLmNoZWNrX3N1ZmZpeFxuICBsZXQgdGVtcF9kaXJfbmFtZSA9IFVuaXgudGVtcF9kaXJfbmFtZVxuICBsZXQgcXVvdGUgPSBVbml4LnF1b3RlXG4gIGxldCBiYXNlbmFtZSA9IGdlbmVyaWNfYmFzZW5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG4gIGxldCBkaXJuYW1lID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuZW5kXG5cbmxldCAoY3VycmVudF9kaXJfbmFtZSwgcGFyZW50X2Rpcl9uYW1lLCBkaXJfc2VwLCBpc19kaXJfc2VwLFxuICAgICBpc19yZWxhdGl2ZSwgaXNfaW1wbGljaXQsIGNoZWNrX3N1ZmZpeCwgdGVtcF9kaXJfbmFtZSwgcXVvdGUsIGJhc2VuYW1lLFxuICAgICBkaXJuYW1lKSA9XG4gIG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgfCBcIldpbjMyXCIgLT5cbiAgICAgIChXaW4zMi5jdXJyZW50X2Rpcl9uYW1lLCBXaW4zMi5wYXJlbnRfZGlyX25hbWUsIFdpbjMyLmRpcl9zZXAsXG4gICAgICAgV2luMzIuaXNfZGlyX3NlcCxcbiAgICAgICBXaW4zMi5pc19yZWxhdGl2ZSwgV2luMzIuaXNfaW1wbGljaXQsIFdpbjMyLmNoZWNrX3N1ZmZpeCxcbiAgICAgICBXaW4zMi50ZW1wX2Rpcl9uYW1lLCBXaW4zMi5xdW90ZSwgV2luMzIuYmFzZW5hbWUsIFdpbjMyLmRpcm5hbWUpXG4gIHwgXCJDeWd3aW5cIiAtPlxuICAgICAgKEN5Z3dpbi5jdXJyZW50X2Rpcl9uYW1lLCBDeWd3aW4ucGFyZW50X2Rpcl9uYW1lLCBDeWd3aW4uZGlyX3NlcCxcbiAgICAgICBDeWd3aW4uaXNfZGlyX3NlcCxcbiAgICAgICBDeWd3aW4uaXNfcmVsYXRpdmUsIEN5Z3dpbi5pc19pbXBsaWNpdCwgQ3lnd2luLmNoZWNrX3N1ZmZpeCxcbiAgICAgICBDeWd3aW4udGVtcF9kaXJfbmFtZSwgQ3lnd2luLnF1b3RlLCBDeWd3aW4uYmFzZW5hbWUsIEN5Z3dpbi5kaXJuYW1lKVxuICB8IF8gLT4gKCogbm9ybWFsbHkgXCJVbml4XCIgKilcbiAgICAgIChVbml4LmN1cnJlbnRfZGlyX25hbWUsIFVuaXgucGFyZW50X2Rpcl9uYW1lLCBVbml4LmRpcl9zZXAsXG4gICAgICAgVW5peC5pc19kaXJfc2VwLFxuICAgICAgIFVuaXguaXNfcmVsYXRpdmUsIFVuaXguaXNfaW1wbGljaXQsIFVuaXguY2hlY2tfc3VmZml4LFxuICAgICAgIFVuaXgudGVtcF9kaXJfbmFtZSwgVW5peC5xdW90ZSwgVW5peC5iYXNlbmFtZSwgVW5peC5kaXJuYW1lKVxuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuXG4oKiBGbG9hdCBjb252ZXJzaW9uLiAqKVxudHlwZSBmbG9hdF9jb252ID1cbiAgfCBGbG9hdF9mIHwgRmxvYXRfcGYgfCBGbG9hdF9zZiAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgfCBGbG9hdF9wZSB8IEZsb2F0X3NlICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZyAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgfCBGbG9hdF9wRyB8IEZsb2F0X3NHICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiAgICAgICAgICAgICAgKilcbiAgfCBGbG9hdF9oIHwgRmxvYXRfcGggfCBGbG9hdF9zaCAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggfCBGbG9hdF9wSCB8IEZsb2F0X3NIICAoKiAgJUggfCAlK0ggfCAlIEggICopXG5cbigqKiopXG5cbigqIENoYXIgc2V0cyAoc2VlICVbLi4uXSkgYXJlIGJpdG1hcHMgaW1wbGVtZW50ZWQgYXMgMzItY2hhciBzdHJpbmdzLiAqKVxudHlwZSBjaGFyX3NldCA9IHN0cmluZ1xuXG4oKioqKVxuXG4oKiBDb3VudGVyIHVzZWQgaW4gU2NhbmYuICopXG50eXBlIGNvdW50ZXIgPVxuICB8IExpbmVfY291bnRlciAgICAgKCogICVsICAgICAgKilcbiAgfCBDaGFyX2NvdW50ZXIgICAgICgqICAlbiAgICAgICopXG4gIHwgVG9rZW5fY291bnRlciAgICAoKiAgJU4sICVMICAqKVxuXG4oKioqKVxuXG4oKiBQYWRkaW5nIG9mIHN0cmluZ3MgYW5kIG51bWJlcnMuICopXG50eXBlICgnYSwgJ2IpIHBhZGRpbmcgPVxuICAoKiBObyBwYWRkaW5nIChleDogXCIlZFwiKSAqKVxuICB8IE5vX3BhZGRpbmcgIDogKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBMaXRlcmFsIHBhZGRpbmcgKGV4OiBcIiU4ZFwiKSAqKVxuICB8IExpdF9wYWRkaW5nIDogcGFkdHkgKiBpbnQgLT4gKCdhLCAnYSkgcGFkZGluZ1xuICAoKiBQYWRkaW5nIGFzIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKmRcIikgKilcbiAgfCBBcmdfcGFkZGluZyA6IHBhZHR5IC0+IChpbnQgLT4gJ2EsICdhKSBwYWRkaW5nXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2QsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcGFkZGluZyBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwYWRfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBQcmVjaXNpb24gb2YgZmxvYXRzIGFuZCAnMCctcGFkZGluZyBvZiBpbnRlZ2Vycy4gKilcbnR5cGUgKCdhLCAnYikgcHJlY2lzaW9uID1cbiAgKCogTm8gcHJlY2lzaW9uIChleDogXCIlZlwiKSAqKVxuICB8IE5vX3ByZWNpc2lvbiA6ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBMaXRlcmFsIHByZWNpc2lvbiAoZXg6IFwiJS4zZlwiKSAqKVxuICB8IExpdF9wcmVjaXNpb24gOiBpbnQgLT4gKCdhLCAnYSkgcHJlY2lzaW9uXG4gICgqIFByZWNpc2lvbiBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJS4qZlwiKSAqKVxuICB8IEFyZ19wcmVjaXNpb24gOiAoaW50IC0+ICdhLCAnYSkgcHJlY2lzaW9uXG5cbigqIFNvbWUgZm9ybWF0cywgc3VjaCBhcyAlX2YsXG4gICBvbmx5IGFjY2VwdCBhbiBvcHRpb25hbCBudW1iZXIgYXMgcHJlY2lzaW9uIG9wdGlvbiAobm8gZXh0cmEgYXJndW1lbnQpICopXG50eXBlIHByZWNfb3B0aW9uID0gaW50IG9wdGlvblxuXG4oKiBzZWUgdGhlIEN1c3RvbSBmb3JtYXQgY29tYmluYXRvciAqKVxudHlwZSAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5ID1cbiAgfCBDdXN0b21femVybyA6ICgnYSwgc3RyaW5nLCAnYSkgY3VzdG9tX2FyaXR5XG4gIHwgQ3VzdG9tX3N1Y2MgOiAoJ2EsICdiLCAnYykgY3VzdG9tX2FyaXR5IC0+XG4gICAgKCdhLCAneCAtPiAnYiwgJ3ggLT4gJ2MpIGN1c3RvbV9hcml0eVxuXG4oKioqKVxuXG4oKiAgICAgICAgUmVsYXRpb25hbCBmb3JtYXQgdHlwZXNcblxuSW4gdGhlIGZpcnN0IGZvcm1hdCtnYWR0cyBpbXBsZW1lbnRhdGlvbiwgdGhlIHR5cGUgZm9yICUoLi4lKSBpbiB0aGVcbmZtdCBHQURUIHdhcyBhcyBmb2xsb3dzOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICogKCdkMSwgJ3ExLCAnZDIsICdxMikgcmVhZGVyX25iX3VuaWZpZXIgKlxuICAgICgneCwgJ2IsICdjLCAnZDEsICdxMSwgJ3UpIGZtdHR5ICpcbiAgICAoJ3UsICdiLCAnYywgJ3ExLCAnZTEsICdmKSBmbXQgLT5cbiAgICAgICgoJ3gsICdiLCAnYywgJ2QyLCAncTIsICd1KSBmb3JtYXQ2IC0+ICd4LCAnYiwgJ2MsICdkMSwgJ2UxLCAnZikgZm10XG5cbk5vdGljZSB0aGF0IHRoZSAndSBwYXJhbWV0ZXIgaW4gJ2YgcG9zaXRpb24gaW4gdGhlIGZvcm1hdCBhcmd1bWVudFxuKCgneCwgLi4sICd1KSBmb3JtYXQ2IC0+IC4uKSBpcyBlcXVhbCB0byB0aGUgJ3UgcGFyYW1ldGVyIGluICdhXG5wb3NpdGlvbiBpbiB0aGUgZm9ybWF0IHRhaWwgKCgndSwgLi4sICdmKSBmbXQpLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG50eXBlIG9mIHRoZSBleHBlY3RlZCBmb3JtYXQgcGFyYW1ldGVyIGRlcGVuZHMgb2Ygd2hlcmUgdGhlICUoLi4uJSlcbmFyZSBpbiB0aGUgZm9ybWF0IHN0cmluZzpcblxuICAjIFByaW50Zi5wcmludGYgXCIlKCUpXCJcbiAgLSA6ICh1bml0LCBvdXRfY2hhbm5lbCwgdW5pdCwgJ19hLCAnX2EsIHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiB1bml0XG4gID0gPGZ1bj5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKSVkXCJcbiAgLSA6IChpbnQgLT4gdW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCBpbnQgLT4gdW5pdClcbiAgICAgIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2IC0+IGludCAtPiB1bml0XG4gID0gPGZ1bj5cblxuT24gdGhlIGNvbnRyYXJ5LCB0aGUgbGVnYWN5IHR5cGVyIGdpdmVzIGEgY2xldmVyIHR5cGUgdGhhdCBkb2VzIG5vdFxuZGVwZW5kIG9uIHRoZSBwb3NpdGlvbiBvZiAlKC4uJSkgaW4gdGhlIGZvcm1hdCBzdHJpbmcuIEZvciBleGFtcGxlLFxuJSglKSB3aWxsIGhhdmUgdGhlIHBvbHltb3JwaGljIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpOiBpdCBjYW5cbmJlIGNvbmNhdGVuYXRlZCB0byBhbnkgZm9ybWF0IHR5cGUsIGFuZCBvbmx5IGVuZm9yY2VzIHRoZSBjb25zdHJhaW50XG50aGF0IGl0cyAnYSBhbmQgJ2YgcGFyYW1ldGVycyBhcmUgZXF1YWwgKG5vIGZvcm1hdCBhcmd1bWVudHMpIGFuZCAnZFxuYW5kICdlIGFyZSBlcXVhbCAobm8gcmVhZGVyIGFyZ3VtZW50KS5cblxuVGhlIHdlYWtlbmluZyBvZiB0aGlzIHBhcmFtZXRlciB0eXBlIGluIHRoZSBHQURUIHZlcnNpb24gYnJva2UgdXNlclxuY29kZSAoaW4gZmFjdCBpdCBlc3NlbnRpYWxseSBtYWRlICUoLi4uJSkgdW51c2FibGUgZXhjZXB0IGF0IHRoZSBsYXN0XG5wb3NpdGlvbiBvZiBhIGZvcm1hdCkuIEluIHBhcnRpY3VsYXIsIHRoZSBmb2xsb3dpbmcgd291bGQgbm90IHdvcmtcbmFueW1vcmU6XG5cbiAgZnVuIHNlcCAtPlxuICAgIEZvcm1hdC5wcmludGYgXCJmb28lKCUpYmFyJSglKWJhelwiIHNlcCBzZXBcblxuQXMgdGhlIHR5cGUtY2hlY2tlciB3b3VsZCByZXF1aXJlIHR3byAqaW5jb21wYXRpYmxlKiB0eXBlcyBmb3IgdGhlICUoJSlcbmluIGRpZmZlcmVudCBwb3NpdGlvbnMuXG5cblRoZSBzb2x1dGlvbiB0byByZWdhaW4gYSBnZW5lcmFsIHR5cGUgZm9yICUoLi4lKSBpcyB0byBnZW5lcmFsaXplIHRoaXNcbnRlY2huaXF1ZSwgbm90IG9ubHkgb24gdGhlICdkLCAnZSBwYXJhbWV0ZXJzLCBidXQgb24gYWxsIHNpeFxucGFyYW1ldGVycyBvZiBhIGZvcm1hdDogd2UgaW50cm9kdWNlIGEgXCJyZWxhdGlvbmFsXCIgdHlwZVxuICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxud2hvc2UgdmFsdWVzIGFyZSBwcm9vZnMgdGhhdCAoJ2ExLCAuLiwgJ2YxKSBhbmQgKCdhMiwgLi4sICdmMikgbW9yYWxseVxuY29ycmVzcG9uZCB0byB0aGUgc2FtZSBmb3JtYXQgdHlwZTogJ2ExIGlzIG9idGFpbmVkIGZyb20gJ2YxLCdiMSwnYzFcbmluIHRoZSBleGFjdCBzYW1lIHdheSB0aGF0ICdhMiBpcyBvYnRhaW5lZCBmcm9tICdmMiwnYjIsJ2MyLCBldGMuXG5cbkZvciBleGFtcGxlLCB0aGUgcmVsYXRpb24gYmV0d2VlbiB0d28gZm9ybWF0IHR5cGVzIGJlZ2lubmluZyB3aXRoIGEgQ2hhclxucGFyYW1ldGVyIGlzIGFzIGZvbGxvd3M6XG5cbnwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICBjaGFyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5JbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgdGVybSBzdHJ1Y3R1cmUgb2YgZm10dHlfcmVsIGlzIChhbG1vc3RbMV0pXG5pc29tb3JwaGljIHRvIHRoZSBmbXR0eSBvZiB0aGUgcHJldmlvdXMgaW1wbGVtZW50YXRpb246IGV2ZXJ5XG5jb25zdHJ1Y3RvciBpcyByZS1yZWFkIHdpdGggYSBiaW5hcnksIHJlbGF0aW9uYWwgdHlwZSwgaW5zdGVhZCBvZiB0aGVcbnByZXZpb3VzIHVuYXJ5IHR5cGluZy4gZm10dHkgY2FuIHRoZW4gYmUgcmUtZGVmaW5lZCBhcyB0aGUgZGlhZ29uYWwgb2ZcbmZtdHR5X3JlbDpcblxuICB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAgICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X3JlbFxuXG5PbmNlIHdlIGhhdmUgdGhpcyBmbXR0eV9yZWwgdHlwZSBpbiBwbGFjZSwgd2UgY2FuIGdpdmUgdGhlIG1vcmVcbmdlbmVyYWwgdHlwZSB0byAlKC4uLiUpOlxuXG58IEZvcm1hdF9zdWJzdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICBwYWRfb3B0aW9uICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYiwgJ2MsICdqMiwgJ2QsICdhKSBmbXR0eV9yZWwgKlxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuV2UgYWNjZXB0IGFueSBmb3JtYXQgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2KSAodGhpcyBpc1xuY29tcGxldGVseSB1bnJlbGF0ZWQgdG8gdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgZm9ybWF0KSwgYnV0IGFsc29cbnJlcXVpcmUgYSBwcm9vZiB0aGF0IHRoaXMgZm9ybWF0IGlzIGluIHJlbGF0aW9uIHRvIGFub3RoZXIgZm9ybWF0IHRoYXRcbmlzIGNvbmNhdGVuYWJsZSB0byB0aGUgZm9ybWF0IHRhaWwuIFdoZW4gZXhlY3V0aW5nIGEgJSguLi4lKSBmb3JtYXRcbihpbiBjYW1saW50ZXJuYWxGb3JtYXQubWw6bWFrZV9wcmludGYgb3Igc2NhbmYubWw6bWFrZV9zY2FuZiksIHdlXG50cmFuc3R5cGUgdGhlIGZvcm1hdCBhbG9uZyB0aGlzIHJlbGF0aW9uIHVzaW5nIHRoZSAncmVjYXN0JyBmdW5jdGlvblxudG8gdHJhbnNwb3NlIGJldHdlZW4gcmVsYXRlZCBmb3JtYXQgdHlwZXMuXG5cbiAgdmFsIHJlY2FzdCA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxKSBmbXRcbiAgLT4gKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgLT4gKCdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdFxuXG5OT1RFIFsxXTogdGhlIHR5cGluZyBvZiBGb3JtYXRfc3Vic3RfdHkgcmVxdWlyZXMgbm90IG9uZSBmb3JtYXQgdHlwZSwgYnV0XG50d28sIG9uZSB0byBlc3RhYmxpc2ggdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0IGFyZ3VtZW50IGFuZCB0aGVcbmZpcnN0IHNpeCBwYXJhbWV0ZXJzLCBhbmQgdGhlIG90aGVyIGZvciB0aGUgbGluayBiZXR3ZWVuIHRoZSBmb3JtYXRcbmFyZ3VtZW50IGFuZCB0aGUgbGFzdCBzaXggcGFyYW1ldGVycy5cblxufCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzEsICdiMSwgJ2MxLCAnajEsICdkMSwgJ2ExKSBmbXR0eV9yZWwgKlxuICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbldoZW4gd2UgZ2VuZXJhdGUgYSBmb3JtYXQgQVNULCB3ZSBnZW5lcmF0ZSBleGFjdGx5IHRoZSBzYW1lIHdpdG5lc3NcbmZvciBib3RoIHJlbGF0aW9ucywgYW5kIHRoZSB3aXRuZXNzLWNvbnZlcnNpb24gZnVuY3Rpb25zIGluXG5jYW1saW50ZXJuYWxGb3JtYXQgZG8gcmVseSBvbiB0aGlzIGludmFyaWFudC4gRm9yIGV4YW1wbGUsIHRoZVxuZnVuY3Rpb24gdGhhdCBwcm92ZXMgdGhhdCB0aGUgcmVsYXRpb24gaXMgdHJhbnNpdGl2ZVxuXG4gIHZhbCB0cmFucyA6XG4gICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EzLCAnYjMsICdjMywgJ2QzLCAnZTMsICdmMykgZm10dHlfcmVsXG5cbmRvZXMgYXNzdW1lIHRoYXQgdGhlIHR3byBpbnB1dHMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIHRlcm0gc3RydWN0dXJlXG4oYW5kIGlzIG9ubHkgZXZlcnkgdXNlZCBmb3IgYXJndW1lbnQgd2l0bmVzc2VzIG9mIHRoZVxuRm9ybWF0X3N1YnN0X3R5IGNvbnN0cnVjdG9yKS5cbiopXG5cbigqIFR5cGUgb2YgYSBibG9jayB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGJsb2NrX3R5cGUgPVxuICB8IFBwX2hib3ggICAoKiBIb3Jpem9udGFsIGJsb2NrIG5vIGxpbmUgYnJlYWtpbmcgKilcbiAgfCBQcF92Ym94ICAgKCogVmVydGljYWwgYmxvY2sgZWFjaCBicmVhayBsZWFkcyB0byBhIG5ldyBsaW5lICopXG4gIHwgUHBfaHZib3ggICgqIEhvcml6b250YWwtdmVydGljYWwgYmxvY2s6IHNhbWUgYXMgdmJveCwgZXhjZXB0IGlmIHRoaXMgYmxvY2tcbiAgICAgICAgICAgICAgICAgaXMgc21hbGwgZW5vdWdoIHRvIGZpdCBvbiBhIHNpbmdsZSBsaW5lICopXG4gIHwgUHBfaG92Ym94ICgqIEhvcml6b250YWwgb3IgVmVydGljYWwgYmxvY2s6IGJyZWFrcyBsZWFkIHRvIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgIG9ubHkgd2hlbiBuZWNlc3NhcnkgdG8gcHJpbnQgdGhlIGNvbnRlbnQgb2YgdGhlIGJsb2NrICopXG4gIHwgUHBfYm94ICAgICgqIEhvcml6b250YWwgb3IgSW5kZW50IGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jaywgb3JcbiAgICAgICAgICAgICAgICAgd2hlbiBpdCBsZWFkcyB0byBhIG5ldyBpbmRlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBsaW5lICopXG4gIHwgUHBfZml0cyAgICgqIEludGVybmFsIHVzYWdlOiB3aGVuIGEgYmxvY2sgZml0cyBvbiBhIHNpbmdsZSBsaW5lICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlIGZvcm1hdHRpbmdfbGl0ID1cbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF0gICAqKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAfSAgICopXG4gIHwgQnJlYWsgb2Ygc3RyaW5nICogaW50ICogaW50ICAgICAgICAgICgqIEAsIHwgQCAgfCBAOyB8IEA7PD4gKilcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQD8gICAqKVxuICB8IEZvcmNlX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAXFxuICAqKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBALiAgICopXG4gIHwgTWFnaWNfc2l6ZSBvZiBzdHJpbmcgKiBpbnQgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA8bj4gKilcbiAgfCBFc2NhcGVkX2F0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQEAgICAqKVxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAJSUgICopXG4gIHwgU2Nhbl9pbmRpYyBvZiBjaGFyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBYICAgKilcblxuKCogRm9ybWF0dGluZyBlbGVtZW50IHVzZWQgYnkgdGhlIEZvcm1hdCBwcmV0dHktcHJpbnRlci4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuID1cbiAgfCBPcGVuX3RhZyA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQHsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuICB8IE9wZW5fYm94IDogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gICAgICAoKiBAWyAgICopXG4gICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdHRpbmdfZ2VuXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IHR5cGUgZWxlbWVudHMuICopXG4oKiBJbiBwYXJ0aWN1bGFyIHVzZWQgdG8gcmVwcmVzZW50ICUoLi4uJSkgYW5kICV7Li4uJX0gY29udGVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5ID1cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YsXG4gICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcbmFuZCAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsID1cbiAgfCBDaGFyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChjaGFyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBTdHJpbmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChzdHJpbmcgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBzdHJpbmcgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVkICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDMyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDMyIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50MzIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgTmF0aXZlaW50X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVuZCAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAobmF0aXZlaW50IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgbmF0aXZlaW50IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludDY0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTGQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludDY0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgaW50NjQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgRmxvYXRfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVmICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoZmxvYXQgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICBmbG9hdCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBCb29sX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUIgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChib29sIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgYm9vbCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEZvcm1hdF9hcmdfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAley4uLiV9ICopXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcbiAgfCBGb3JtYXRfc3Vic3RfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2QyLCAnYTIpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzEsICdiMSwgJ2MxLCAnajEsICdlMSwgJ2YxLFxuICAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpXG4gICAgICAgICAgIGZtdHR5X3JlbFxuXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9ycy4gKilcbiAgfCBBbHBoYV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWEgICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgoJ2IxIC0+ICd4IC0+ICdjMSkgLT4gJ3ggLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAoJ2IyIC0+ICd4IC0+ICdjMikgLT4gJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgVGhldGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV0ICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAnYzEpIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAnYzIpIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEFueV90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVXNlZCBmb3IgY3VzdG9tIGZvcm1hdHMgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3IuICopXG4gIHwgUmVhZGVyX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ3ggLT4gJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAneCAtPiAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoJ2ExLCAnYjEsICdjMSwgKCdiMSAtPiAneCkgLT4gJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAoJ2IyIC0+ICd4KSAtPiAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuICB8IEVuZF9vZl9mbXR0eSA6XG4gICAgICAoJ2YxLCAnYjEsICdjMSwgJ2QxLCAnZDEsICdmMSxcbiAgICAgICAnZjIsICdiMiwgJ2MyLCAnZDIsICdkMiwgJ2YyKSBmbXR0eV9yZWxcblxuKCoqKilcblxuKCogTGlzdCBvZiBmb3JtYXQgZWxlbWVudHMuICopXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCA9XG4gIHwgQ2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUMgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKGNoYXIgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgQ2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVMgKilcbiAgICAgICgneCwgc3RyaW5nIC0+ICdhKSBwYWRkaW5nICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgSW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDMyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVsW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50MzIgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBOYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbltkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIG5hdGl2ZWludCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludDY0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVMW2RpeFh1b10gKilcbiAgICAgIGludF9jb252ICogKCd4LCAneSkgcGFkZGluZyAqICgneSwgaW50NjQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlW2ZlRWdHRl0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIHR5cGUgJ2Egb3B0aW9uID0gTm9uZSB8IFNvbWUgb2YgJ2EgKilcblxuKCogRXhjZXB0aW9ucyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiAnYSAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCAoKSA9XG4gICgqIGZvciBhc21ydW4vZmFpbC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cblxuZXh0ZXJuYWwgcmFpc2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZVwiXG5leHRlcm5hbCByYWlzZV9ub3RyYWNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2Vfbm90cmFjZVwiXG5cbmxldCBmYWlsd2l0aCBzID0gcmFpc2UoRmFpbHVyZSBzKVxubGV0IGludmFsaWRfYXJnIHMgPSByYWlzZShJbnZhbGlkX2FyZ3VtZW50IHMpXG5cbmV4Y2VwdGlvbiBFeGl0XG5cbigqIENvbXBvc2l0aW9uIG9wZXJhdG9ycyAqKVxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuZXh0ZXJuYWwgKCBAQCApIDogKCdhIC0+ICdiKSAtPiAnYSAtPiAnYiA9IFwiJWFwcGx5XCJcblxuKCogRGVidWdnaW5nICopXG5cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5cbmV4dGVybmFsIF9fTE9DX09GX18gOiAnYSAtPiBzdHJpbmcgKiAnYSA9IFwiJWxvY19MT0NcIlxuZXh0ZXJuYWwgX19MSU5FX09GX18gOiAnYSAtPiBpbnQgKiAnYSA9IFwiJWxvY19MSU5FXCJcbmV4dGVybmFsIF9fUE9TX09GX18gOiAnYSAtPiAoc3RyaW5nICogaW50ICogaW50ICogaW50KSAqICdhID0gXCIlbG9jX1BPU1wiXG5cbigqIENvbXBhcmlzb25zICopXG5cbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxuXG5sZXQgbWluIHggeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5sZXQgbWF4IHggeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG5cbmV4dGVybmFsICggPT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcVwiXG5leHRlcm5hbCAoICE9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXFcIlxuXG4oKiBCb29sZWFuIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuXG4oKiBJbnRlZ2VyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LSApIDogaW50IC0+IGludCA9IFwiJW5lZ2ludFwiXG5leHRlcm5hbCAoIH4rICkgOiBpbnQgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5leHRlcm5hbCAoICsgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYWRkaW50XCJcbmV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgKCAqICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW11bGludFwiXG5leHRlcm5hbCAoIC8gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlZGl2aW50XCJcbmV4dGVybmFsICggbW9kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW1vZGludFwiXG5cbmxldCBhYnMgeCA9IGlmIHggPj0gMCB0aGVuIHggZWxzZSAteFxuXG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG5sZXQgbG5vdCB4ID0geCBseG9yICgtMSlcblxuZXh0ZXJuYWwgKCBsc2wgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNsaW50XCJcbmV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5leHRlcm5hbCAoIGFzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhc3JpbnRcIlxuXG5sZXQgbWF4X2ludCA9ICgtMSkgbHNyIDFcbmxldCBtaW5faW50ID0gbWF4X2ludCArIDFcblxuKCogRmxvYXRpbmctcG9pbnQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYWNvc19mbG9hdFwiIFwiYWNvc1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXNpbl9mbG9hdFwiIFwiYXNpblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBoeXBvdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICA9IFwiY2FtbF9oeXBvdF9mbG9hdFwiIFwiY2FtbF9oeXBvdFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jb3NfZmxvYXRcIiBcImNvc1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5oX2Zsb2F0XCIgXCJzaW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNxcnQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zcXJ0X2Zsb2F0XCIgXCJzcXJ0XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFic19mbG9hdCA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlYWJzZmxvYXRcIlxuZXh0ZXJuYWwgY29weXNpZ24gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgICAgPSBcImNhbWxfY29weXNpZ25fZmxvYXRcIiBcImNhbWxfY29weXNpZ25cIlxuICAgICAgICAgICAgICAgICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZF9mbG9hdCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Ztb2RfZmxvYXRcIiBcImZtb2RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5leHRlcm5hbCBsZGV4cCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiAoaW50IFtAdW50YWdnZWRdKSAtPiAoZmxvYXQgW0B1bmJveGVkXSkgPVxuICBcImNhbWxfbGRleHBfZmxvYXRcIiBcImNhbWxfbGRleHBfZmxvYXRfdW5ib3hlZFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RmIDogZmxvYXQgLT4gZmxvYXQgKiBmbG9hdCA9IFwiY2FtbF9tb2RmX2Zsb2F0XCJcbmV4dGVybmFsIGZsb2F0IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCBmbG9hdF9vZl9pbnQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIHRydW5jYXRlIDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBpbnRfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGZsb2F0X29mX2JpdHMgOiBpbnQ2NCAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzXCIgXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5sZXQgaW5maW5pdHkgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5sZXQgbmVnX2luZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweEZGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5hbiA9XG4gIGZsb2F0X29mX2JpdHMgMHg3Rl9GMF8wMF8wMF8wMF8wMF8wMF8wMUxcbmxldCBtYXhfZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRUZfRkZfRkZfRkZfRkZfRkZfRkZMXG5sZXQgbWluX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDAwXzEwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IGVwc2lsb25fZmxvYXQgPVxuICBmbG9hdF9vZl9iaXRzIDB4M0NfQjBfMDBfMDBfMDBfMDBfMDBfMDBMXG5cbnR5cGUgZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuXG4oKiBTdHJpbmcgYW5kIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZXMgU3RyaW5nIGFuZCBCeXRlcyAqKVxuXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgYnl0ZXNfbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgc3RyaW5nX2JsaXQgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfYmxpdCA6IGJ5dGVzIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5cbmxldCAoIF4gKSBzMSBzMiA9XG4gIGxldCBsMSA9IHN0cmluZ19sZW5ndGggczEgYW5kIGwyID0gc3RyaW5nX2xlbmd0aCBzMiBpblxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSAobDEgKyBsMikgaW5cbiAgc3RyaW5nX2JsaXQgczEgMCBzIDAgbDE7XG4gIHN0cmluZ19ibGl0IHMyIDAgcyBsMSBsMjtcbiAgYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyBzXG5cbigqIENoYXJhY3RlciBvcGVyYXRpb25zIC0tIG1vcmUgaW4gbW9kdWxlIENoYXIgKilcblxuZXh0ZXJuYWwgaW50X29mX2NoYXIgOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaGFyX29mX2ludCA6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50IG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJjaGFyX29mX2ludFwiIGVsc2UgdW5zYWZlX2NoYXJfb2ZfaW50IG5cblxuKCogVW5pdCBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgZnN0IDogJ2EgKiAnYiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCBzbmQgOiAnYSAqICdiIC0+ICdiID0gXCIlZmllbGQxXCJcblxuKCogUmVmZXJlbmNlcyAqKVxuXG50eXBlICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cbmV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgcmVmIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsICggOj0gKSA6ICdhIHJlZiAtPiAnYSAtPiB1bml0ID0gXCIlc2V0ZmllbGQwXCJcbmV4dGVybmFsIGluY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVpbmNyXCJcbmV4dGVybmFsIGRlY3IgOiBpbnQgcmVmIC0+IHVuaXQgPSBcIiVkZWNyXCJcblxuKCogUmVzdWx0IHR5cGUgKilcblxudHlwZSAoJ2EsJ2IpIHJlc3VsdCA9IE9rIG9mICdhIHwgRXJyb3Igb2YgJ2JcblxuKCogU3RyaW5nIGNvbnZlcnNpb24gZnVuY3Rpb25zICopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxubGV0IHN0cmluZ19vZl9ib29sIGIgPVxuICBpZiBiIHRoZW4gXCJ0cnVlXCIgZWxzZSBcImZhbHNlXCJcbmxldCBib29sX29mX3N0cmluZyA9IGZ1bmN0aW9uXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IF8gLT4gaW52YWxpZF9hcmcgXCJib29sX29mX3N0cmluZ1wiXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IFNvbWUgdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBTb21lIGZhbHNlXG4gIHwgXyAtPiBOb25lXG5cbmxldCBzdHJpbmdfb2ZfaW50IG4gPVxuICBmb3JtYXRfaW50IFwiJWRcIiBuXG5cbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxuXG5sZXQgaW50X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5leHRlcm5hbCBzdHJpbmdfZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcblxubGV0IHZhbGlkX2Zsb2F0X2xleGVtIHMgPVxuICBsZXQgbCA9IHN0cmluZ19sZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA+PSBsIHRoZW4gcyBeIFwiLlwiIGVsc2VcbiAgICBtYXRjaCBzdHJpbmdfZ2V0IHMgaSB3aXRoXG4gICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgIHwgXyAtPiBzXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3RyaW5nX29mX2Zsb2F0IGYgPSB2YWxpZF9mbG9hdF9sZXhlbSAoZm9ybWF0X2Zsb2F0IFwiJS4xMmdcIiBmKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcblxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IHByb3ZpZGUgdGhpcyBkaXJlY3RseSBhcyBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZS4gKilcbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbigqIExpc3Qgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBMaXN0ICopXG5cbmxldCByZWMgKCBAICkgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoZCA6OiB0bCAtPiBoZCA6OiAodGwgQCBsMilcblxuKCogSS9PIG9wZXJhdGlvbnMgKilcblxudHlwZSBpbl9jaGFubmVsXG50eXBlIG91dF9jaGFubmVsXG5cbmV4dGVybmFsIG9wZW5fZGVzY3JpcHRvcl9vdXQgOiBpbnQgLT4gb3V0X2NoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFwiXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3JfaW4gOiBpbnQgLT4gaW5fY2hhbm5lbCA9IFwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cIlxuXG5sZXQgc3RkaW4gPSBvcGVuX2Rlc2NyaXB0b3JfaW4gMFxubGV0IHN0ZG91dCA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMVxubGV0IHN0ZGVyciA9IG9wZW5fZGVzY3JpcHRvcl9vdXQgMlxuXG4oKiBHZW5lcmFsIG91dHB1dCBmdW5jdGlvbnMgKilcblxudHlwZSBvcGVuX2ZsYWcgPVxuICAgIE9wZW5fcmRvbmx5IHwgT3Blbl93cm9ubHkgfCBPcGVuX2FwcGVuZFxuICB8IE9wZW5fY3JlYXQgfCBPcGVuX3RydW5jIHwgT3Blbl9leGNsXG4gIHwgT3Blbl9iaW5hcnkgfCBPcGVuX3RleHQgfCBPcGVuX25vbmJsb2NrXG5cbmV4dGVybmFsIG9wZW5fZGVzYyA6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcblxuZXh0ZXJuYWwgc2V0X291dF9jaGFubmVsX25hbWU6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9vdXRfZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0KG9wZW5fZGVzYyBuYW1lIG1vZGUgcGVybSkgaW5cbiAgc2V0X291dF9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX291dCBuYW1lID1cbiAgb3Blbl9vdXRfZ2VuIFtPcGVuX3dyb25seTsgT3Blbl9jcmVhdDsgT3Blbl90cnVuYzsgT3Blbl90ZXh0XSAwbzY2NiBuYW1lXG5cbmxldCBvcGVuX291dF9iaW4gbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fYmluYXJ5XSAwbzY2NiBuYW1lXG5cbmV4dGVybmFsIGZsdXNoIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9mbHVzaFwiXG5cbmV4dGVybmFsIG91dF9jaGFubmVsc19saXN0IDogdW5pdCAtPiBvdXRfY2hhbm5lbCBsaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9vdXRfY2hhbm5lbHNfbGlzdFwiXG5cbmxldCBmbHVzaF9hbGwgKCkgPVxuICBsZXQgcmVjIGl0ZXIgPSBmdW5jdGlvblxuICAgICAgW10gLT4gKClcbiAgICB8IGE6OmwgLT5cbiAgICAgICAgYmVnaW4gdHJ5XG4gICAgICAgICAgICBmbHVzaCBhXG4gICAgICAgIHdpdGggU3lzX2Vycm9yIF8gLT5cbiAgICAgICAgICAoKSAoKiBpZ25vcmUgY2hhbm5lbHMgY2xvc2VkIGR1cmluZyBhIHByZWNlZGluZyBmbHVzaC4gKilcbiAgICAgICAgZW5kO1xuICAgICAgICBpdGVyIGxcbiAgaW4gaXRlciAob3V0X2NoYW5uZWxzX2xpc3QgKCkpXG5cbmV4dGVybmFsIHVuc2FmZV9vdXRwdXQgOiBvdXRfY2hhbm5lbCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0X2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9vdXRwdXRfc3RyaW5nIDogb3V0X2NoYW5uZWwgLT4gc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0cHV0XCJcblxuZXh0ZXJuYWwgb3V0cHV0X2NoYXIgOiBvdXRfY2hhbm5lbCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuXG5sZXQgb3V0cHV0X2J5dGVzIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0IG9jIHMgMCAoYnl0ZXNfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXRfc3RyaW5nIG9jIHMgPVxuICB1bnNhZmVfb3V0cHV0X3N0cmluZyBvYyBzIDAgKHN0cmluZ19sZW5ndGggcylcblxubGV0IG91dHB1dCBvYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dFwiXG4gIGVsc2UgdW5zYWZlX291dHB1dCBvYyBzIG9mcyBsZW5cblxubGV0IG91dHB1dF9zdWJzdHJpbmcgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IHN0cmluZ19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwib3V0cHV0X3N1YnN0cmluZ1wiXG4gIGVsc2UgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyBvZnMgbGVuXG5cbmV4dGVybmFsIG91dHB1dF9ieXRlIDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2NoYXJcIlxuZXh0ZXJuYWwgb3V0cHV0X2JpbmFyeV9pbnQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9vdXRwdXRfaW50XCJcblxuZXh0ZXJuYWwgbWFyc2hhbF90b19jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gJ2EgLT4gdW5pdCBsaXN0IC0+IHVuaXRcbiAgICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmxldCBvdXRwdXRfdmFsdWUgY2hhbiB2ID0gbWFyc2hhbF90b19jaGFubmVsIGNoYW4gdiBbXVxuXG5leHRlcm5hbCBzZWVrX291dCA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XCJcbmV4dGVybmFsIHBvc19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX291dFwiXG5leHRlcm5hbCBvdXRfY2hhbm5lbF9sZW5ndGggOiBvdXRfY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX291dF9jaGFubmVsIDogb3V0X2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9vdXQgb2MgPSBmbHVzaCBvYzsgY2xvc2Vfb3V0X2NoYW5uZWwgb2NcbmxldCBjbG9zZV9vdXRfbm9lcnIgb2MgPVxuICAodHJ5IGZsdXNoIG9jIHdpdGggXyAtPiAoKSk7XG4gICh0cnkgY2xvc2Vfb3V0X2NoYW5uZWwgb2Mgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX291dCA6IG91dF9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBHZW5lcmFsIGlucHV0IGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBzZXRfaW5fY2hhbm5lbF9uYW1lOiBpbl9jaGFubmVsIC0+IHN0cmluZyAtPiB1bml0ID1cbiAgXCJjYW1sX21sX3NldF9jaGFubmVsX25hbWVcIlxuXG5sZXQgb3Blbl9pbl9nZW4gbW9kZSBwZXJtIG5hbWUgPVxuICBsZXQgYyA9IG9wZW5fZGVzY3JpcHRvcl9pbihvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9pbl9jaGFubmVsX25hbWUgYyBuYW1lO1xuICBjXG5cbmxldCBvcGVuX2luIG5hbWUgPVxuICBvcGVuX2luX2dlbiBbT3Blbl9yZG9ubHk7IE9wZW5fdGV4dF0gMCBuYW1lXG5cbmxldCBvcGVuX2luX2JpbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX2JpbmFyeV0gMCBuYW1lXG5cbmV4dGVybmFsIGlucHV0X2NoYXIgOiBpbl9jaGFubmVsIC0+IGNoYXIgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5cbmV4dGVybmFsIHVuc2FmZV9pbnB1dCA6IGluX2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9pbnB1dFwiXG5cbmxldCBpbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcImlucHV0XCJcbiAgZWxzZSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuXG5cbmxldCByZWMgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBsZW4gPD0gMCB0aGVuICgpIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IHVuc2FmZV9pbnB1dCBpYyBzIG9mcyBsZW4gaW5cbiAgICBpZiByID0gMFxuICAgIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICBlbHNlIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyAob2ZzICsgcikgKGxlbiAtIHIpXG4gIGVuZFxuXG5sZXQgcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBieXRlc19sZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwicmVhbGx5X2lucHV0XCJcbiAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyBpYyBsZW4gPVxuICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSBsZW4gaW5cbiAgcmVhbGx5X2lucHV0IGljIHMgMCBsZW47XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG5leHRlcm5hbCBpbnB1dF9zY2FuX2xpbmUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcIlxuXG5sZXQgaW5wdXRfbGluZSBjaGFuID1cbiAgbGV0IHJlYyBidWlsZF9yZXN1bHQgYnVmIHBvcyA9IGZ1bmN0aW9uXG4gICAgW10gLT4gYnVmXG4gIHwgaGQgOjogdGwgLT5cbiAgICAgIGxldCBsZW4gPSBieXRlc19sZW5ndGggaGQgaW5cbiAgICAgIGJ5dGVzX2JsaXQgaGQgMCBidWYgKHBvcyAtIGxlbikgbGVuO1xuICAgICAgYnVpbGRfcmVzdWx0IGJ1ZiAocG9zIC0gbGVuKSB0bCBpblxuICBsZXQgcmVjIHNjYW4gYWNjdSBsZW4gPVxuICAgIGxldCBuID0gaW5wdXRfc2Nhbl9saW5lIGNoYW4gaW5cbiAgICBpZiBuID0gMCB0aGVuIGJlZ2luICAgICAgICAgICAgICAgICAgICgqIG4gPSAwOiB3ZSBhcmUgYXQgRU9GICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmFpc2UgRW5kX29mX2ZpbGVcbiAgICAgIHwgXyAgLT4gYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gYWNjdVxuICAgIGVuZCBlbHNlIGlmIG4gPiAwIHRoZW4gYmVnaW4gICAgICAgICAgKCogbiA+IDA6IG5ld2xpbmUgZm91bmQgaW4gYnVmZmVyICopXG4gICAgICBsZXQgcmVzID0gYnl0ZXNfY3JlYXRlIChuIC0gMSkgaW5cbiAgICAgIGlnbm9yZSAodW5zYWZlX2lucHV0IGNoYW4gcmVzIDAgKG4gLSAxKSk7XG4gICAgICBpZ25vcmUgKGlucHV0X2NoYXIgY2hhbik7ICAgICAgICAgICAoKiBza2lwIHRoZSBuZXdsaW5lICopXG4gICAgICBtYXRjaCBhY2N1IHdpdGhcbiAgICAgICAgW10gLT4gcmVzXG4gICAgICB8ICBfIC0+IGxldCBsZW4gPSBsZW4gKyBuIC0gMSBpblxuICAgICAgICAgICAgICBidWlsZF9yZXN1bHQgKGJ5dGVzX2NyZWF0ZSBsZW4pIGxlbiAocmVzIDo6IGFjY3UpXG4gICAgZW5kIGVsc2UgYmVnaW4gICAgICAgICAgICAgICAgICAgICAgICAoKiBuIDwgMDogbmV3bGluZSBub3QgZm91bmQgKilcbiAgICAgIGxldCBiZWcgPSBieXRlc19jcmVhdGUgKC1uKSBpblxuICAgICAgaWdub3JlKHVuc2FmZV9pbnB1dCBjaGFuIGJlZyAwICgtbikpO1xuICAgICAgc2NhbiAoYmVnIDo6IGFjY3UpIChsZW4gLSBuKVxuICAgIGVuZFxuICBpbiBieXRlc191bnNhZmVfdG9fc3RyaW5nIChzY2FuIFtdIDApXG5cbmV4dGVybmFsIGlucHV0X2J5dGUgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9jaGFyXCJcbmV4dGVybmFsIGlucHV0X2JpbmFyeV9pbnQgOiBpbl9jaGFubmVsIC0+IGludCA9IFwiY2FtbF9tbF9pbnB1dF9pbnRcIlxuZXh0ZXJuYWwgaW5wdXRfdmFsdWUgOiBpbl9jaGFubmVsIC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlXCJcbmV4dGVybmFsIHNlZWtfaW4gOiBpbl9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5cIlxuZXh0ZXJuYWwgcG9zX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfcG9zX2luXCJcbmV4dGVybmFsIGluX2NoYW5uZWxfbGVuZ3RoIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXCJcbmV4dGVybmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0ID0gXCJjYW1sX21sX2Nsb3NlX2NoYW5uZWxcIlxubGV0IGNsb3NlX2luX25vZXJyIGljID0gKHRyeSBjbG9zZV9pbiBpYyB3aXRoIF8gLT4gKCkpXG5leHRlcm5hbCBzZXRfYmluYXJ5X21vZGVfaW4gOiBpbl9jaGFubmVsIC0+IGJvb2wgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX3NldF9iaW5hcnlfbW9kZVwiXG5cbigqIE91dHB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgb3V0cHV0ICopXG5cbmxldCBwcmludF9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRvdXQgY1xubGV0IHByaW50X3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRvdXQgc1xubGV0IHByaW50X2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3Rkb3V0IHNcbmxldCBwcmludF9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJpbnRfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmludF9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZG91dCBzOyBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxubGV0IHByaW50X25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRvdXQgJ1xcbic7IGZsdXNoIHN0ZG91dFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGVycm9yICopXG5cbmxldCBwcmVycl9jaGFyIGMgPSBvdXRwdXRfY2hhciBzdGRlcnIgY1xubGV0IHByZXJyX3N0cmluZyBzID0gb3V0cHV0X3N0cmluZyBzdGRlcnIgc1xubGV0IHByZXJyX2J5dGVzIHMgPSBvdXRwdXRfYnl0ZXMgc3RkZXJyIHNcbmxldCBwcmVycl9pbnQgaSA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfaW50IGkpXG5sZXQgcHJlcnJfZmxvYXQgZiA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIChzdHJpbmdfb2ZfZmxvYXQgZilcbmxldCBwcmVycl9lbmRsaW5lIHMgPVxuICBvdXRwdXRfc3RyaW5nIHN0ZGVyciBzOyBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxubGV0IHByZXJyX25ld2xpbmUgKCkgPSBvdXRwdXRfY2hhciBzdGRlcnIgJ1xcbic7IGZsdXNoIHN0ZGVyclxuXG4oKiBJbnB1dCBmdW5jdGlvbnMgb24gc3RhbmRhcmQgaW5wdXQgKilcblxubGV0IHJlYWRfbGluZSAoKSA9IGZsdXNoIHN0ZG91dDsgaW5wdXRfbGluZSBzdGRpblxubGV0IHJlYWRfaW50ICgpID0gaW50X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2ludF9vcHQgKCkgPSBpbnRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0ICgpID0gZmxvYXRfb2Zfc3RyaW5nKHJlYWRfbGluZSgpKVxubGV0IHJlYWRfZmxvYXRfb3B0ICgpID0gZmxvYXRfb2Zfc3RyaW5nX29wdChyZWFkX2xpbmUoKSlcblxuKCogT3BlcmF0aW9ucyBvbiBsYXJnZSBmaWxlcyAqKVxuXG5tb2R1bGUgTGFyZ2VGaWxlID1cbiAgc3RydWN0XG4gICAgZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfb3V0XzY0XCJcbiAgICBleHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX291dF82NFwiXG4gICAgZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50NjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgICBleHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQ2NCAtPiB1bml0ID0gXCJjYW1sX21sX3NlZWtfaW5fNjRcIlxuICAgIGV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfcG9zX2luXzY0XCJcbiAgICBleHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50NjQgPSBcImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XCJcbiAgZW5kXG5cbigqIEZvcm1hdHMgKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAgPSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcbiAgID0gRm9ybWF0IG9mICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm10XG4gICAgICAgICAgICAgICAqIHN0cmluZ1xuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NCA9ICgnYSwgJ2IsICdjLCAnYywgJ2MsICdkKSBmb3JtYXQ2XG5cbnR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjLCAnYykgZm9ybWF0NFxuXG5sZXQgc3RyaW5nX29mX2Zvcm1hdCAoRm9ybWF0IChfZm10LCBzdHIpKSA9IHN0clxuXG5leHRlcm5hbCBmb3JtYXRfb2Zfc3RyaW5nIDpcbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCBeXiApIChGb3JtYXQgKGZtdDEsIHN0cjEpKSAoRm9ybWF0IChmbXQyLCBzdHIyKSkgPVxuICBGb3JtYXQgKENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5jb25jYXRfZm10IGZtdDEgZm10MixcbiAgICAgICAgICBzdHIxIF4gXCIlLFwiIF4gc3RyMilcblxuKCogTWlzY2VsbGFuZW91cyAqKVxuXG5leHRlcm5hbCBzeXNfZXhpdCA6IGludCAtPiAnYSA9IFwiY2FtbF9zeXNfZXhpdFwiXG5cbmxldCBleGl0X2Z1bmN0aW9uID0gcmVmIGZsdXNoX2FsbFxuXG5sZXQgYXRfZXhpdCBmID1cbiAgbGV0IGcgPSAhZXhpdF9mdW5jdGlvbiBpblxuICBleGl0X2Z1bmN0aW9uIDo9IChmdW4gKCkgLT4gZigpOyBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgKilcblxubGV0IHJlYyBsZW5ndGhfYXV4IGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gbGVuXG4gIHwgXzo6bCAtPiBsZW5ndGhfYXV4IChsZW4gKyAxKSBsXG5cbmxldCBsZW5ndGggbCA9IGxlbmd0aF9hdXggMCBsXG5cbmxldCBjb25zIGEgbCA9IGE6OmxcblxubGV0IGhkID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcImhkXCJcbiAgfCBhOjpfIC0+IGFcblxubGV0IHRsID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWlsd2l0aCBcInRsXCJcbiAgfCBfOjpsIC0+IGxcblxubGV0IG50aCBsIG4gPVxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5udGhcIiBlbHNlXG4gIGxldCByZWMgbnRoX2F1eCBsIG4gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gZmFpbHdpdGggXCJudGhcIlxuICAgIHwgYTo6bCAtPiBpZiBuID0gMCB0aGVuIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IG50aF9vcHQgbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBTb21lIGEgZWxzZSBudGhfYXV4IGwgKG4tMSlcbiAgaW4gbnRoX2F1eCBsIG5cblxubGV0IGFwcGVuZCA9IChAKVxuXG5sZXQgcmVjIHJldl9hcHBlbmQgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBhIDo6IGwgLT4gcmV2X2FwcGVuZCBsIChhIDo6IGwyKVxuXG5sZXQgcmV2IGwgPSByZXZfYXBwZW5kIGwgW11cblxubGV0IHJlYyBpbml0X3RhaWxyZWNfYXV4IGFjYyBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIGFjY1xuICBlbHNlIGluaXRfdGFpbHJlY19hdXggKGYgaSA6OiBhY2MpIChpKzEpIG4gZlxuXG5sZXQgcmVjIGluaXRfYXV4IGkgbiBmID1cbiAgaWYgaSA+PSBuIHRoZW4gW11cbiAgZWxzZVxuICAgIGxldCByID0gZiBpIGluXG4gICAgciA6OiBpbml0X2F1eCAoaSsxKSBuIGZcblxubGV0IGluaXQgbGVuIGYgPVxuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LmluaXRcIiBlbHNlXG4gIGlmIGxlbiA+IDEwXzAwMCB0aGVuIHJldiAoaW5pdF90YWlscmVjX2F1eCBbXSAwIGxlbiBmKVxuICBlbHNlIGluaXRfYXV4IDAgbGVuIGZcblxubGV0IHJlYyBmbGF0dGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGw6OnIgLT4gbCBAIGZsYXR0ZW4gclxuXG5sZXQgY29uY2F0ID0gZmxhdHRlblxuXG5sZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGEgaW4gciA6OiBtYXAgZiBsXG5cbmxldCByZWMgbWFwaSBpIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+IFtdXG4gIHwgYTo6bCAtPiBsZXQgciA9IGYgaSBhIGluIHIgOjogbWFwaSAoaSArIDEpIGYgbFxuXG5sZXQgbWFwaSBmIGwgPSBtYXBpIDAgZiBsXG5cbmxldCByZXZfbWFwIGYgbCA9XG4gIGxldCByZWMgcm1hcF9mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgYTo6bCAtPiBybWFwX2YgKGYgYSA6OiBhY2N1KSBsXG4gIGluXG4gIHJtYXBfZiBbXSBsXG5cblxubGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgIFtdIC0+ICgpXG4gIHwgYTo6bCAtPiBmIGE7IGl0ZXIgZiBsXG5cbmxldCByZWMgaXRlcmkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBpIGE7IGl0ZXJpIChpICsgMSkgZiBsXG5cbmxldCBpdGVyaSBmIGwgPSBpdGVyaSAwIGYgbFxuXG5sZXQgcmVjIGZvbGRfbGVmdCBmIGFjY3UgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+IGFjY3VcbiAgfCBhOjpsIC0+IGZvbGRfbGVmdCBmIChmIGFjY3UgYSkgbFxuXG5sZXQgcmVjIGZvbGRfcmlnaHQgZiBsIGFjY3UgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmIGEgKGZvbGRfcmlnaHQgZiBsIGFjY3UpXG5cbmxldCByZWMgbWFwMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBsZXQgciA9IGYgYTEgYTIgaW4gciA6OiBtYXAyIGYgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0Lm1hcDJcIlxuXG5sZXQgcmV2X21hcDIgZiBsMSBsMiA9XG4gIGxldCByZWMgcm1hcDJfZiBhY2N1IGwxIGwyID1cbiAgICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgfCAoW10sIFtdKSAtPiBhY2N1XG4gICAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHJtYXAyX2YgKGYgYTEgYTIgOjogYWNjdSkgbDEgbDJcbiAgICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QucmV2X21hcDJcIlxuICBpblxuICBybWFwMl9mIFtdIGwxIGwyXG5cblxubGV0IHJlYyBpdGVyMiBmIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+ICgpXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBmIGExIGEyOyBpdGVyMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5pdGVyMlwiXG5cbmxldCByZWMgZm9sZF9sZWZ0MiBmIGFjY3UgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZm9sZF9sZWZ0MiBmIChmIGFjY3UgYTEgYTIpIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb2xkX2xlZnQyXCJcblxubGV0IHJlYyBmb2xkX3JpZ2h0MiBmIGwxIGwyIGFjY3UgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gYWNjdVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMiAoZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1KVxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9yaWdodDJcIlxuXG5sZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gdHJ1ZVxuICB8IGE6OmwgLT4gcCBhICYmIGZvcl9hbGwgcCBsXG5cbmxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBwIGEgfHwgZXhpc3RzIHAgbFxuXG5sZXQgcmVjIGZvcl9hbGwyIHAgbDEgbDIgPVxuICBtYXRjaCAobDEsIGwyKSB3aXRoXG4gICAgKFtdLCBbXSkgLT4gdHJ1ZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiAmJiBmb3JfYWxsMiBwIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5mb3JfYWxsMlwiXG5cbmxldCByZWMgZXhpc3RzMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGZhbHNlXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBwIGExIGEyIHx8IGV4aXN0czIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZXhpc3RzMlwiXG5cbmxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtIHggbFxuXG5sZXQgcmVjIG1lbXEgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFsc2VcbiAgfCBhOjpsIC0+IGEgPT0geCB8fCBtZW1xIHggbFxuXG5sZXQgcmVjIGFzc29jIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGIgZWxzZSBhc3NvYyB4IGxcblxubGV0IHJlYyBhc3NvY19vcHQgeCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gTm9uZVxuICB8IChhLGIpOjpsIC0+IGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIFNvbWUgYiBlbHNlIGFzc29jX29wdCB4IGxcblxubGV0IHJlYyBhc3NxIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IChhLGIpOjpsIC0+IGlmIGEgPT0geCB0aGVuIGIgZWxzZSBhc3NxIHggbFxuXG5sZXQgcmVjIGFzc3Ffb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBTb21lIGIgZWxzZSBhc3NxX29wdCB4IGxcblxubGV0IHJlYyBtZW1fYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gZmFsc2VcbiAgfCAoYSwgXykgOjogbCAtPiBjb21wYXJlIGEgeCA9IDAgfHwgbWVtX2Fzc29jIHggbFxuXG5sZXQgcmVjIG1lbV9hc3NxIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gYSA9PSB4IHx8IG1lbV9hc3NxIHggbFxuXG5sZXQgcmVjIHJlbW92ZV9hc3NvYyB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT5cbiAgICAgIGlmIGNvbXBhcmUgYSB4ID0gMCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NvYyB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBbXVxuICB8IChhLCBfIGFzIHBhaXIpIDo6IGwgLT4gaWYgYSA9PSB4IHRoZW4gbCBlbHNlIHBhaXIgOjogcmVtb3ZlX2Fzc3EgeCBsXG5cbmxldCByZWMgZmluZCBwID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4geCBlbHNlIGZpbmQgcCBsXG5cbmxldCByZWMgZmluZF9vcHQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBTb21lIHggZWxzZSBmaW5kX29wdCBwIGxcblxubGV0IGZpbmRfYWxsIHAgPVxuICBsZXQgcmVjIGZpbmQgYWNjdSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY3VcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gZmluZCAoeCA6OiBhY2N1KSBsIGVsc2UgZmluZCBhY2N1IGwgaW5cbiAgZmluZCBbXVxuXG5sZXQgZmlsdGVyID0gZmluZF9hbGxcblxubGV0IHBhcnRpdGlvbiBwIGwgPVxuICBsZXQgcmVjIHBhcnQgeWVzIG5vID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAocmV2IHllcywgcmV2IG5vKVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBwYXJ0ICh4IDo6IHllcykgbm8gbCBlbHNlIHBhcnQgeWVzICh4IDo6IG5vKSBsIGluXG4gIHBhcnQgW10gW10gbFxuXG5sZXQgcmVjIHNwbGl0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoW10sIFtdKVxuICB8ICh4LHkpOjpsIC0+XG4gICAgICBsZXQgKHJ4LCByeSkgPSBzcGxpdCBsIGluICh4OjpyeCwgeTo6cnkpXG5cbmxldCByZWMgY29tYmluZSBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gKGExLCBhMikgOjogY29tYmluZSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuY29tYmluZVwiXG5cbigqKiBzb3J0aW5nICopXG5cbmxldCByZWMgbWVyZ2UgY21wIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbDIgLT4gbDJcbiAgfCBsMSwgW10gLT4gbDFcbiAgfCBoMSA6OiB0MSwgaDIgOjogdDIgLT5cbiAgICAgIGlmIGNtcCBoMSBoMiA8PSAwXG4gICAgICB0aGVuIGgxIDo6IG1lcmdlIGNtcCB0MSBsMlxuICAgICAgZWxzZSBoMiA6OiBtZXJnZSBjbXAgbDEgdDJcblxuXG5sZXQgcmVjIGNob3AgayBsID1cbiAgaWYgayA9IDAgdGhlbiBsIGVsc2UgYmVnaW5cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IF86OnQgLT4gY2hvcCAoay0xKSB0XG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBlbmRcblxuXG5sZXQgc3RhYmxlX3NvcnQgY21wIGwgPVxuICBsZXQgcmVjIHJldl9tZXJnZSBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgaWYgY21wIGgxIGgyID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICBpZiBjbXAgeDIgeDMgPD0gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPD0gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzIDw9IDAgdGhlbiBbeDI7IHgzOyB4MV1cbiAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgZW5kXG4gICAgfCBuLCBsIC0+XG4gICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgIGxldCBsMiA9IGNob3AgbjEgbCBpblxuICAgICAgIGxldCBzMSA9IHJldl9zb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZV9yZXYgczEgczIgW11cbiAgYW5kIHJldl9zb3J0IG4gbCA9XG4gICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAyLCB4MSA6OiB4MiA6OiBfIC0+XG4gICAgICAgaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV1cbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IF8gLT5cbiAgICAgICBpZiBjbXAgeDEgeDIgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGlmIGNtcCB4MiB4MyA+IDAgdGhlbiBbeDE7IHgyOyB4M11cbiAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgZWxzZSBbeDM7IHgxOyB4Ml1cbiAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBpZiBjbXAgeDIgeDMgPiAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgIGVuZFxuICAgIHwgbiwgbCAtPlxuICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICBsZXQgbDIgPSBjaG9wIG4xIGwgaW5cbiAgICAgICBsZXQgczEgPSBzb3J0IG4xIGwgaW5cbiAgICAgICBsZXQgczIgPSBzb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlIHMxIHMyIFtdXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIHNvcnQgbGVuIGxcblxuXG5sZXQgc29ydCA9IHN0YWJsZV9zb3J0XG5sZXQgZmFzdF9zb3J0ID0gc3RhYmxlX3NvcnRcblxuKCogTm90ZTogb24gYSBsaXN0IG9mIGxlbmd0aCBiZXR3ZWVuIGFib3V0IDEwMDAwMCAoZGVwZW5kaW5nIG9uIHRoZSBtaW5vclxuICAgaGVhcCBzaXplIGFuZCB0aGUgdHlwZSBvZiB0aGUgbGlzdCkgYW5kIFN5cy5tYXhfYXJyYXlfc2l6ZSwgaXQgaXNcbiAgIGFjdHVhbGx5IGZhc3RlciB0byB1c2UgdGhlIGZvbGxvd2luZywgYnV0IGl0IG1pZ2h0IGFsc28gdXNlIG1vcmUgbWVtb3J5XG4gICBiZWNhdXNlIHRoZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBkZWFsbG9jYXRlZCBpbmNyZW1lbnRhbGx5LlxuXG4gICBBbHNvLCB0aGVyZSBzZWVtcyB0byBiZSBhIGJ1ZyBpbiB0aGlzIGNvZGUgb3IgaW4gdGhlXG4gICBpbXBsZW1lbnRhdGlvbiBvZiBvYmpfdHJ1bmNhdGUuXG5cbmV4dGVybmFsIG9ial90cnVuY2F0ZSA6ICdhIGFycmF5IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX29ial90cnVuY2F0ZVwiXG5cbmxldCBhcnJheV90b19saXN0X2luX3BsYWNlIGEgPVxuICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGxldCByZWMgbG9vcCBhY2N1IG4gcCA9XG4gICAgaWYgcCA8PSAwIHRoZW4gYWNjdSBlbHNlIGJlZ2luXG4gICAgICBpZiBwID0gbiB0aGVuIGJlZ2luXG4gICAgICAgIG9ial90cnVuY2F0ZSBhIHA7XG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgKG4tMTAwMCkgKHAtMSlcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxvb3AgKGEuKHAtMSkgOjogYWNjdSkgbiAocC0xKVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgW10gKGwtMTAwMCkgbFxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCBhID0gQXJyYXkub2ZfbGlzdCBsIGluXG4gIEFycmF5LnN0YWJsZV9zb3J0IGNtcCBhO1xuICBhcnJheV90b19saXN0X2luX3BsYWNlIGFcblxuKilcblxuXG4oKiogc29ydGluZyArIHJlbW92aW5nIGR1cGxpY2F0ZXMgKilcblxubGV0IHNvcnRfdW5pcSBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZSB0MSB0MiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiByZXZfbWVyZ2UgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZSBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgcmV2X21lcmdlX3JldiBsMSBsMiBhY2N1ID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIGwyIC0+IHJldl9hcHBlbmQgbDIgYWNjdVxuICAgIHwgbDEsIFtdIC0+IHJldl9hcHBlbmQgbDEgYWNjdVxuICAgIHwgaDE6OnQxLCBoMjo6dDIgLT5cbiAgICAgICAgbGV0IGMgPSBjbXAgaDEgaDIgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByZXZfbWVyZ2VfcmV2IHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjID4gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZV9yZXYgdDEgbDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIHJldl9tZXJnZV9yZXYgbDEgdDIgKGgyOjphY2N1KVxuICBpblxuICBsZXQgcmVjIHNvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXVxuICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgIGxldCBzMiA9IHJldl9zb3J0IG4yIGwyIGluXG4gICAgICAgcmV2X21lcmdlX3JldiBzMSBzMiBbXVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IF8gLT5cbiAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxXVxuICAgICAgIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgfCAzLCB4MSA6OiB4MiA6OiB4MyA6OiBfIC0+XG4gICAgICAgbGV0IGMgPSBjbXAgeDEgeDIgaW5cbiAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4M10gZWxzZSBbeDM7IHgyXVxuICAgICAgIGVuZCBlbHNlIGlmIGMgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICBlbHNlIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgZWxzZSBsZXQgYyA9IGNtcCB4MiB4MyBpblxuICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDI7IHgxXVxuICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICBlbmRcbiAgICB8IG4sIGwgLT5cbiAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgbGV0IGwyID0gY2hvcCBuMSBsIGluXG4gICAgICAgbGV0IHMxID0gc29ydCBuMSBsIGluXG4gICAgICAgbGV0IHMyID0gc29ydCBuMiBsMiBpblxuICAgICAgIHJldl9tZXJnZSBzMSBzMiBbXVxuICBpblxuICBsZXQgbGVuID0gbGVuZ3RoIGwgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIGwgZWxzZSBzb3J0IGxlbiBsXG5cbmxldCByZWMgY29tcGFyZV9sZW5ndGhzIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgW10gLT4gMFxuICB8IFtdLCBfIC0+IC0xXG4gIHwgXywgW10gLT4gMVxuICB8IF8gOjogbDEsIF8gOjogbDIgLT4gY29tcGFyZV9sZW5ndGhzIGwxIGwyXG47O1xuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCBuID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT5cbiAgICBpZiBuID0gMCB0aGVuIDAgZWxzZVxuICAgICAgaWYgbiA+IDAgdGhlbiAtMSBlbHNlIDFcbiAgfCBfIDo6IGwgLT5cbiAgICBpZiBuIDw9IDAgdGhlbiAxIGVsc2VcbiAgICAgIGNvbXBhcmVfbGVuZ3RoX3dpdGggbCAobi0xKVxuOztcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQ2hhcmFjdGVyIG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hyOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcblxubGV0IGNociBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiQ2hhci5jaHJcIiBlbHNlIHVuc2FmZV9jaHIgblxuXG5leHRlcm5hbCBieXRlc19jcmVhdGU6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfYnl0ZXNcIlxuZXh0ZXJuYWwgYnl0ZXNfdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfdG9fc3RyaW5nIDogYnl0ZXMgLT4gc3RyaW5nID0gXCIlYnl0ZXNfdG9fc3RyaW5nXCJcblxubGV0IGVzY2FwZWQgPSBmdW5jdGlvblxuICB8ICdcXCcnIC0+IFwiXFxcXCdcIlxuICB8ICdcXFxcJyAtPiBcIlxcXFxcXFxcXCJcbiAgfCAnXFxuJyAtPiBcIlxcXFxuXCJcbiAgfCAnXFx0JyAtPiBcIlxcXFx0XCJcbiAgfCAnXFxyJyAtPiBcIlxcXFxyXCJcbiAgfCAnXFxiJyAtPiBcIlxcXFxiXCJcbiAgfCAnICcgLi4gJ34nIGFzIGMgLT5cbiAgICAgIGxldCBzID0gYnl0ZXNfY3JlYXRlIDEgaW5cbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAwIGM7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcbiAgfCBjIC0+XG4gICAgICBsZXQgbiA9IGNvZGUgYyBpblxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgNCBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgJ1xcXFwnO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDEgKHVuc2FmZV9jaHIgKDQ4ICsgbiAvIDEwMCkpO1xuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDIgKHVuc2FmZV9jaHIgKDQ4ICsgKG4gLyAxMCkgbW9kIDEwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMyAodW5zYWZlX2NociAoNDggKyBuIG1vZCAxMCkpO1xuICAgICAgdW5zYWZlX3RvX3N0cmluZyBzXG5cbmxldCBsb3dlcmNhc2UgYyA9XG4gIGlmIChjID49ICdBJyAmJiBjIDw9ICdaJylcbiAgfHwgKGMgPj0gJ1xcMTkyJyAmJiBjIDw9ICdcXDIxNCcpXG4gIHx8IChjID49ICdcXDIxNicgJiYgYyA8PSAnXFwyMjInKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIGVsc2UgY1xuXG5sZXQgdXBwZXJjYXNlIGMgPVxuICBpZiAoYyA+PSAnYScgJiYgYyA8PSAneicpXG4gIHx8IChjID49ICdcXDIyNCcgJiYgYyA8PSAnXFwyNDYnKVxuICB8fCAoYyA+PSAnXFwyNDgnICYmIGMgPD0gJ1xcMjU0JylcbiAgdGhlbiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICBlbHNlIGNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSBjID1cbiAgaWYgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKVxuICB0aGVuIHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIGVsc2UgY1xuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIGMgPVxuICBpZiAoYyA+PSAnYScgJiYgYyA8PSAneicpXG4gIHRoZW4gdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgZWxzZSBjXG5cbnR5cGUgdCA9IGNoYXJcblxubGV0IGNvbXBhcmUgYzEgYzIgPSBjb2RlIGMxIC0gY29kZSBjMlxubGV0IGVxdWFsIChjMTogdCkgKGMyOiB0KSA9IGNvbXBhcmUgYzEgYzIgPSAwXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sIGZvclxuICAgZWZmaWNpZW5jeSByZWFzb25zLiBXaGVuIHlvdSBtb2RpZnkgdGhlIG9uZSBpbiB0aGlzIGZpbGUgeW91IG5lZWQgdG9cbiAgIG1vZGlmeSBpdHMgZHVwbGljYXRlIGluIHN0cmluZy5tbC5cbiAgIFRoZXNlIGZ1bmN0aW9ucyBoYXZlIGEgXCJkdXBsaWNhdGVkXCIgY29tbWVudCBhYm92ZSB0aGVpciBkZWZpbml0aW9uLlxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogYnl0ZXMgLT4gaW50ID0gXCIlYnl0ZXNfbGVuZ3RoXCJcbmV4dGVybmFsIHN0cmluZ19sZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG5leHRlcm5hbCBnZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciA9IFwiJWJ5dGVzX3Vuc2FmZV9nZXRcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9maWxsIDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2ZpbGxfYnl0ZXNcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdW5zYWZlX3RvX3N0cmluZyA6IGJ5dGVzIC0+IHN0cmluZyA9IFwiJWJ5dGVzX3RvX3N0cmluZ1wiXG5leHRlcm5hbCB1bnNhZmVfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGJ5dGVzID0gXCIlYnl0ZXNfb2Zfc3RyaW5nXCJcblxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9ibGl0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbmxldCBtYWtlIG4gYyA9XG4gIGxldCBzID0gY3JlYXRlIG4gaW5cbiAgdW5zYWZlX2ZpbGwgcyAwIG4gYztcbiAgc1xuXG5sZXQgaW5pdCBuIGYgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgcyBpIChmIGkpXG4gIGRvbmU7XG4gIHNcblxubGV0IGVtcHR5ID0gY3JlYXRlIDBcblxubGV0IGNvcHkgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgdW5zYWZlX2JsaXQgcyAwIHIgMCBsZW47XG4gIHJcblxubGV0IHRvX3N0cmluZyBiID0gdW5zYWZlX3RvX3N0cmluZyAoY29weSBiKVxubGV0IG9mX3N0cmluZyBzID0gY29weSAodW5zYWZlX29mX3N0cmluZyBzKVxuXG5sZXQgc3ViIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLnN1YiAvIEJ5dGVzLnN1YlwiXG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBzIG9mcyByIDAgbGVuO1xuICAgIHJcbiAgZW5kXG5cbmxldCBzdWJfc3RyaW5nIGIgb2ZzIGxlbiA9IHVuc2FmZV90b19zdHJpbmcgKHN1YiBiIG9mcyBsZW4pXG5cbigqIGFkZGl0aW9uIHdpdGggYW4gb3ZlcmZsb3cgY2hlY2sgKilcbmxldCAoKyspIGEgYiA9XG4gIGxldCBjID0gYSArIGIgaW5cbiAgbWF0Y2ggYSA8IDAsIGIgPCAwLCBjIDwgMCB3aXRoXG4gIHwgdHJ1ZSAsIHRydWUgLCBmYWxzZVxuICB8IGZhbHNlLCBmYWxzZSwgdHJ1ZSAgLT4gaW52YWxpZF9hcmcgXCJCeXRlcy5leHRlbmRcIiAoKiBvdmVyZmxvdyAqKVxuICB8IF8gLT4gY1xuXG5sZXQgZXh0ZW5kIHMgbGVmdCByaWdodCA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyArKyBsZWZ0ICsrIHJpZ2h0IGluXG4gIGxldCByID0gY3JlYXRlIGxlbiBpblxuICBsZXQgKHNyY29mZiwgZHN0b2ZmKSA9IGlmIGxlZnQgPCAwIHRoZW4gLWxlZnQsIDAgZWxzZSAwLCBsZWZ0IGluXG4gIGxldCBjcHlsZW4gPSBtaW4gKGxlbmd0aCBzIC0gc3Jjb2ZmKSAobGVuIC0gZHN0b2ZmKSBpblxuICBpZiBjcHlsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgcyBzcmNvZmYgciBkc3RvZmYgY3B5bGVuO1xuICByXG5cbmxldCBmaWxsIHMgb2ZzIGxlbiBjID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuZmlsbCAvIEJ5dGVzLmZpbGxcIlxuICBlbHNlIHVuc2FmZV9maWxsIHMgb2ZzIGxlbiBjXG5cbmxldCBibGl0IHMxIG9mczEgczIgb2ZzMiBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IG9mczEgPCAwIHx8IG9mczEgPiBsZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCeXRlcy5ibGl0XCJcbiAgZWxzZSB1bnNhZmVfYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbmxldCBibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gc3RyaW5nX2xlbmd0aCBzMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggczIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5ibGl0IC8gQnl0ZXMuYmxpdF9zdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9ibGl0X3N0cmluZyBzMSBvZnMxIHMyIG9mczIgbGVuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpdGVyaSBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgaSAodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGVuc3VyZV9nZSAoeDppbnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJCeXRlcy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IGVtcHR5XG4gIHwgbCAtPiBsZXQgc2VwbGVuID0gbGVuZ3RoIHNlcCBpblxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKGNyZWF0ZSAoc3VtX2xlbmd0aHMgMCBzZXBsZW4gbCkpXG4gICAgICAgICAgICAwIHNlcCBzZXBsZW4gbFxuXG5sZXQgY2F0IHMxIHMyID1cbiAgbGV0IGwxID0gbGVuZ3RoIHMxIGluXG4gIGxldCBsMiA9IGxlbmd0aCBzMiBpblxuICBsZXQgciA9IGNyZWF0ZSAobDEgKyBsMikgaW5cbiAgdW5zYWZlX2JsaXQgczEgMCByIDAgbDE7XG4gIHVuc2FmZV9ibGl0IHMyIDAgciBsMSBsMjtcbiAgclxuXG5cbmV4dGVybmFsIGNoYXJfY29kZTogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBjaGFyX2NocjogaW50IC0+IGNoYXIgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19zcGFjZSA9IGZ1bmN0aW9uXG4gIHwgJyAnIHwgJ1xcMDEyJyB8ICdcXG4nIHwgJ1xccicgfCAnXFx0JyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgdHJpbSBzID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBzIGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBsZW4gJiYgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAhaSkgZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgbGV0IGogPSByZWYgKGxlbiAtIDEpIGluXG4gIHdoaWxlICFqID49ICFpICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWopIGRvXG4gICAgZGVjciBqXG4gIGRvbmU7XG4gIGlmICFqID49ICFpIHRoZW5cbiAgICBzdWIgcyAhaSAoIWogLSAhaSArIDEpXG4gIGVsc2VcbiAgICBlbXB0eVxuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgbiA6PSAhbiArXG4gICAgICAobWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gMlxuICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgfCBfIC0+IDQpXG4gIGRvbmU7XG4gIGlmICFuID0gbGVuZ3RoIHMgdGhlbiBjb3B5IHMgZWxzZSBiZWdpblxuICAgIGxldCBzJyA9IGNyZWF0ZSAhbiBpblxuICAgIG4gOj0gMDtcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgICBiZWdpbiBtYXRjaCB1bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICduJ1xuICAgICAgfCAnXFx0JyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICdiJ1xuICAgICAgfCAoJyAnIC4uICd+JykgYXMgYyAtPiB1bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGxldCBhID0gY2hhcl9jb2RlIGMgaW5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSAvIDEwMCkpO1xuICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuIChjaGFyX2NociAoNDggKyAoYSAvIDEwKSBtb2QgMTApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgYSBtb2QgMTApKTtcbiAgICAgIGVuZDtcbiAgICAgIGluY3IgblxuICAgIGRvbmU7XG4gICAgcydcbiAgZW5kXG5cbmxldCBtYXAgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgcyBpKSkgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwaSBmIHMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGwgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkbyB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID0gbWFwIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbmxldCBhcHBseTEgZiBzID1cbiAgaWYgbGVuZ3RoIHMgPSAwIHRoZW4gcyBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjb3B5IHMgaW5cbiAgICB1bnNhZmVfc2V0IHIgMCAoZih1bnNhZmVfZ2V0IHMgMCkpO1xuICAgIHJcbiAgZW5kXG5cbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2VfYXNjaWkgc1xubGV0IHVuY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlX2FzY2lpIHNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleCBzIGMgPSBpbmRleF9yZWMgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJlYyBpbmRleF9yZWNfb3B0IHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gTm9uZSBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIFNvbWUgaSBlbHNlIGluZGV4X3JlY19vcHQgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbSAvIEJ5dGVzLmluZGV4X2Zyb21cIiBlbHNlXG4gIGluZGV4X3JlYyBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiIGVsc2VcbiAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4IHMgYyA9IHJpbmRleF9yZWMgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfb3B0IHMgYyA9IHJpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuXG50eXBlIHQgPSBieXRlc1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbCA9IFwiY2FtbF9ieXRlc19lcXVhbFwiXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID0gbWFwIENoYXIudXBwZXJjYXNlIHNcbmxldCBsb3dlcmNhc2UgcyA9IG1hcCBDaGFyLmxvd2VyY2FzZSBzXG5cbmxldCBjYXBpdGFsaXplIHMgPSBhcHBseTEgQ2hhci51cHBlcmNhc2Ugc1xubGV0IHVuY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIubG93ZXJjYXNlIHNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBuZWVkc19lc2NhcGUgaSA9XG4gICAgaWYgaSA+PSBsZW5ndGggcyB0aGVuIGZhbHNlIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcbicgfCAnXFx0JyB8ICdcXHInIHwgJ1xcYicgLT4gdHJ1ZVxuICAgICAgfCAnICcgLi4gJ34nIC0+IG5lZWRzX2VzY2FwZSAoaSsxKVxuICAgICAgfCBfIC0+IHRydWVcbiAgaW5cbiAgaWYgbmVlZHNfZXNjYXBlIDAgdGhlblxuICAgIGJ0cyAoQi5lc2NhcGVkIChib3MgcykpXG4gIGVsc2VcbiAgICBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiIGVsc2VcbiAgaW5kZXhfcmVjX29wdCBzIGwgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleCBzIGMgPSByaW5kZXhfcmVjIHMgKGxlbmd0aCBzIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X2Zyb20gcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb20gLyBCeXRlcy5yaW5kZXhfZnJvbVwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjIHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmluZGV4X29wdCBzIGMgPSByaW5kZXhfcmVjX29wdCBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tX29wdCBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5yaW5kZXhfZnJvbV9vcHRcIlxuICBlbHNlXG4gICAgcmluZGV4X3JlY19vcHQgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zX2Zyb20gcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb250YWluc19mcm9tIC8gQnl0ZXMuY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChpbmRleF9yZWMgcyBsIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGNvbnRhaW5zIHMgYyA9IGNvbnRhaW5zX2Zyb20gcyAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5sZXQgdXBwZXJjYXNlX2FzY2lpIHMgPVxuICBCLnVwcGVyY2FzZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xubGV0IGxvd2VyY2FzZV9hc2NpaSBzID1cbiAgQi5sb3dlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBjYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLmNhcGl0YWxpemVfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9XG4gIEIudW5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5cbnR5cGUgdCA9IHN0cmluZ1xuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCJcblxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVyZ2luZyBhbmQgc29ydGluZyAqKVxuXG5vcGVuIEFycmF5XG5cbmxldCByZWMgbWVyZ2Ugb3JkZXIgbDEgbDIgPVxuICBtYXRjaCBsMSB3aXRoXG4gICAgW10gLT4gbDJcbiAgfCBoMSA6OiB0MSAtPlxuICAgICAgbWF0Y2ggbDIgd2l0aFxuICAgICAgICBbXSAtPiBsMVxuICAgICAgfCBoMiA6OiB0MiAtPlxuICAgICAgICAgIGlmIG9yZGVyIGgxIGgyXG4gICAgICAgICAgdGhlbiBoMSA6OiBtZXJnZSBvcmRlciB0MSBsMlxuICAgICAgICAgIGVsc2UgaDIgOjogbWVyZ2Ugb3JkZXIgbDEgdDJcblxubGV0IGxpc3Qgb3JkZXIgbCA9XG4gIGxldCByZWMgaW5pdGxpc3QgPSBmdW5jdGlvblxuICAgICAgW10gLT4gW11cbiAgICB8IFtlXSAtPiBbW2VdXVxuICAgIHwgZTE6OmUyOjpyZXN0IC0+XG4gICAgICAgIChpZiBvcmRlciBlMSBlMiB0aGVuIFtlMTtlMl0gZWxzZSBbZTI7ZTFdKSA6OiBpbml0bGlzdCByZXN0IGluXG4gIGxldCByZWMgbWVyZ2UyID0gZnVuY3Rpb25cbiAgICAgIGwxOjpsMjo6cmVzdCAtPiBtZXJnZSBvcmRlciBsMSBsMiA6OiBtZXJnZTIgcmVzdFxuICAgIHwgeCAtPiB4IGluXG4gIGxldCByZWMgbWVyZ2VhbGwgPSBmdW5jdGlvblxuICAgICAgW10gLT4gW11cbiAgICB8IFtsXSAtPiBsXG4gICAgfCBsbGlzdCAtPiBtZXJnZWFsbCAobWVyZ2UyIGxsaXN0KSBpblxuICBtZXJnZWFsbChpbml0bGlzdCBsKVxuXG5sZXQgc3dhcCBhcnIgaSBqID1cbiAgbGV0IHRtcCA9IHVuc2FmZV9nZXQgYXJyIGkgaW5cbiAgdW5zYWZlX3NldCBhcnIgaSAodW5zYWZlX2dldCBhcnIgaik7XG4gIHVuc2FmZV9zZXQgYXJyIGogdG1wXG5cbigqIFRoZXJlIGlzIGEga25vd24gcGVyZm9ybWFuY2UgYnVnIGluIHRoZSBjb2RlIGJlbG93LiAgSWYgeW91IGZpbmRcbiAgIGl0LCBkb24ndCBib3RoZXIgcmVwb3J0aW5nIGl0LiAgWW91J3JlIG5vdCBzdXBwb3NlZCB0byB1c2UgdGhpc1xuICAgbW9kdWxlIGFueXdheS4gKilcbmxldCBhcnJheSBjbXAgYXJyID1cbiAgbGV0IHJlYyBxc29ydCBsbyBoaSA9XG4gICAgaWYgaGkgLSBsbyA+PSA2IHRoZW4gYmVnaW5cbiAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgbHNyIDEgaW5cbiAgICAgICgqIFNlbGVjdCBtZWRpYW4gdmFsdWUgZnJvbSBhbW9uZyBMTywgTUlELCBhbmQgSEkuIFJlYXJyYW5nZVxuICAgICAgICAgTE8gYW5kIEhJIHNvIHRoZSB0aHJlZSB2YWx1ZXMgYXJlIHNvcnRlZC4gVGhpcyBsb3dlcnMgdGhlXG4gICAgICAgICBwcm9iYWJpbGl0eSBvZiBwaWNraW5nIGEgcGF0aG9sb2dpY2FsIHBpdm90LiAgSXQgYWxzb1xuICAgICAgICAgYXZvaWRzIGV4dHJhIGNvbXBhcmlzb25zIG9uIGkgYW5kIGogaW4gdGhlIHR3byB0aWdodCBcIndoaWxlXCJcbiAgICAgICAgIGxvb3BzIGJlbG93LiAqKVxuICAgICAgaWYgY21wICh1bnNhZmVfZ2V0IGFyciBtaWQpICh1bnNhZmVfZ2V0IGFyciBsbykgdGhlbiBzd2FwIGFyciBtaWQgbG87XG4gICAgICBpZiBjbXAgKHVuc2FmZV9nZXQgYXJyIGhpKSAodW5zYWZlX2dldCBhcnIgbWlkKSB0aGVuIGJlZ2luXG4gICAgICAgIHN3YXAgYXJyIG1pZCBoaTtcbiAgICAgICAgaWYgY21wICh1bnNhZmVfZ2V0IGFyciBtaWQpICh1bnNhZmVfZ2V0IGFyciBsbykgdGhlbiBzd2FwIGFyciBtaWQgbG9cbiAgICAgIGVuZDtcbiAgICAgIGxldCBwaXZvdCA9IHVuc2FmZV9nZXQgYXJyIG1pZCBpblxuICAgICAgbGV0IGkgPSByZWYgKGxvICsgMSkgYW5kIGogPSByZWYgKGhpIC0gMSkgaW5cbiAgICAgIGlmIG5vdCAoY21wIHBpdm90ICh1bnNhZmVfZ2V0IGFyciBoaSkpXG4gICAgICAgICB8fCBub3QgKGNtcCAodW5zYWZlX2dldCBhcnIgbG8pIHBpdm90KVxuICAgICAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIlNvcnQuYXJyYXlcIik7XG4gICAgICB3aGlsZSAhaSA8ICFqIGRvXG4gICAgICAgIHdoaWxlIG5vdCAoY21wIHBpdm90ICh1bnNhZmVfZ2V0IGFyciAhaSkpIGRvIGluY3IgaSBkb25lO1xuICAgICAgICB3aGlsZSBub3QgKGNtcCAodW5zYWZlX2dldCBhcnIgIWopIHBpdm90KSBkbyBkZWNyIGogZG9uZTtcbiAgICAgICAgaWYgIWkgPCAhaiB0aGVuIHN3YXAgYXJyICFpICFqO1xuICAgICAgICBpbmNyIGk7IGRlY3IgalxuICAgICAgZG9uZTtcbiAgICAgICgqIFJlY3Vyc2lvbiBvbiBzbWFsbGVyIGhhbGYsIHRhaWwtY2FsbCBvbiBsYXJnZXIgaGFsZiAqKVxuICAgICAgaWYgIWogLSBsbyA8PSBoaSAtICFpIHRoZW4gYmVnaW5cbiAgICAgICAgcXNvcnQgbG8gIWo7IHFzb3J0ICFpIGhpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBxc29ydCAhaSBoaTsgcXNvcnQgbG8gIWpcbiAgICAgIGVuZFxuICAgIGVuZCBpblxuICBxc29ydCAwIChBcnJheS5sZW5ndGggYXJyIC0gMSk7XG4gICgqIEZpbmlzaCBzb3J0aW5nIGJ5IGluc2VydGlvbiBzb3J0ICopXG4gIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyIC0gMSBkb1xuICAgIGxldCB2YWxfaSA9ICh1bnNhZmVfZ2V0IGFyciBpKSBpblxuICAgIGlmIG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciAoaSAtIDEpKSB2YWxfaSkgdGhlbiBiZWdpblxuICAgICAgdW5zYWZlX3NldCBhcnIgaSAodW5zYWZlX2dldCBhcnIgKGkgLSAxKSk7XG4gICAgICBsZXQgaiA9IHJlZiAoaSAtIDEpIGluXG4gICAgICB3aGlsZSAhaiA+PSAxICYmIG5vdCAoY21wICh1bnNhZmVfZ2V0IGFyciAoIWogLSAxKSkgdmFsX2kpIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYXJyICFqICh1bnNhZmVfZ2V0IGFyciAoIWogLSAxKSk7XG4gICAgICAgIGRlY3IgalxuICAgICAgZG9uZTtcbiAgICAgIHVuc2FmZV9zZXQgYXJyICFqIHZhbF9pXG4gICAgZW5kXG4gIGRvbmVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAnYnl0ZXJ1bi9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fc3RyaW5nOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBzdHJpbmdcbiAgICA9IFwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nXCJcbmV4dGVybmFsIHRvX2J1ZmZlcl91bnNhZmU6XG4gICAgICBieXRlcyAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IGludFxuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19idWZmZXJcIlxuXG5sZXQgdG9fYnVmZmVyIGJ1ZmYgb2ZzIGxlbiB2IGZsYWdzID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IEJ5dGVzLmxlbmd0aCBidWZmIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLnRvX2J1ZmZlcjogc3Vic3RyaW5nIG91dCBvZiBib3VuZHNcIlxuICBlbHNlIHRvX2J1ZmZlcl91bnNhZmUgYnVmZiBvZnMgbGVuIHYgZmxhZ3NcblxuKCogVGhlIGZ1bmN0aW9ucyBiZWxvdyB1c2UgYnl0ZSBzZXF1ZW5jZXMgYXMgaW5wdXQsIG5ldmVyIHVzaW5nIGFueVxuICAgbXV0YXRpb24uIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBub24tbXV0YXRlZCBbYnl0ZXNdIHJhdGhlciB0aGFuXG4gICBbc3RyaW5nXSwgYmVjYXVzZSB3ZSByZWFsbHkgd29yayB3aXRoIHNlcXVlbmNlcyBvZiBieXRlcywgbm90XG4gICBhIHRleHQgcmVwcmVzZW50YXRpb24uXG4qKVxuXG5leHRlcm5hbCBmcm9tX2NoYW5uZWw6IGluX2NoYW5uZWwgLT4gJ2EgPSBcImNhbWxfaW5wdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZnJvbV9ieXRlc191bnNhZmU6IGJ5dGVzIC0+IGludCAtPiAnYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmdcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIlxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCBuZXdfYmxvY2sgOiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfb2JqX2Jsb2NrXCJcbmV4dGVybmFsIGR1cCA6IHQgLT4gdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIHRydW5jYXRlIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuZXh0ZXJuYWwgYWRkX29mZnNldCA6IHQgLT4gSW50MzIudCAtPiB0ID0gXCJjYW1sX29ial9hZGRfb2Zmc2V0XCJcblxubGV0IG1hcnNoYWwgKG9iaiA6IHQpID1cbiAgTWFyc2hhbC50b19ieXRlcyBvYmogW11cbmxldCB1bm1hcnNoYWwgc3RyIHBvcyA9XG4gIChNYXJzaGFsLmZyb21fYnl0ZXMgc3RyIHBvcywgcG9zICsgTWFyc2hhbC50b3RhbF9zaXplIHN0ciBwb3MpXG5cbmxldCBmaXJzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMFxubGV0IGxhc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yX3RhZyA9IDI0NVxuXG5sZXQgbGF6eV90YWcgPSAyNDZcbmxldCBjbG9zdXJlX3RhZyA9IDI0N1xubGV0IG9iamVjdF90YWcgPSAyNDhcbmxldCBpbmZpeF90YWcgPSAyNDlcbmxldCBmb3J3YXJkX3RhZyA9IDI1MFxuXG5sZXQgbm9fc2Nhbl90YWcgPSAyNTFcblxubGV0IGFic3RyYWN0X3RhZyA9IDI1MVxubGV0IHN0cmluZ190YWcgPSAyNTJcbmxldCBkb3VibGVfdGFnID0gMjUzXG5sZXQgZG91YmxlX2FycmF5X3RhZyA9IDI1NFxubGV0IGN1c3RvbV90YWcgPSAyNTVcbmxldCBmaW5hbF90YWcgPSBjdXN0b21fdGFnXG5cblxubGV0IGludF90YWcgPSAxMDAwXG5sZXQgb3V0X29mX2hlYXBfdGFnID0gMTAwMVxubGV0IHVuYWxpZ25lZF90YWcgPSAxMDAyXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgeCA9XG4gIGxldCB4ID0gcmVwciB4IGluXG4gIGxldCBzbG90ID1cbiAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICBlbHNlIHhcbiAgaW5cbiAgbGV0IG5hbWUgPVxuICAgIGlmIChpc19ibG9jayBzbG90KSAmJiAodGFnIHNsb3QpID0gb2JqZWN0X3RhZyB0aGVuIGZpZWxkIHNsb3QgMFxuICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcbiAgaW5cbiAgICBpZiAodGFnIG5hbWUpID0gc3RyaW5nX3RhZyB0aGVuIChvYmogc2xvdCA6IGV4dGVuc2lvbl9jb25zdHJ1Y3RvcilcbiAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG5cbmxldCBbQGlubGluZSBhbHdheXNdIGV4dGVuc2lvbl9uYW1lIChzbG90IDogZXh0ZW5zaW9uX2NvbnN0cnVjdG9yKSA9XG4gIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBleHRlbnNpb25faWQgKHNsb3QgOiBleHRlbnNpb25fY29uc3RydWN0b3IpID1cbiAgKG9iaiAoZmllbGQgKHJlcHIgc2xvdCkgMSkgOiBpbnQpXG5cbm1vZHVsZSBFcGhlbWVyb24gPSBzdHJ1Y3RcbiAgdHlwZSBvYmpfdCA9IHRcblxuICB0eXBlIHQgKCoqIGVwaGVtZXJvbiAqKVxuXG4gIGV4dGVybmFsIGNyZWF0ZTogaW50IC0+IHQgPSBcImNhbWxfZXBoZV9jcmVhdGVcIlxuXG4gIGxldCBsZW5ndGggeCA9IHNpemUocmVwciB4KSAtIDJcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgZXh0ZXJuYWwgZ2V0X2tleV9jb3B5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcIlxuICBleHRlcm5hbCBzZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2tleVwiXG4gIGV4dGVybmFsIHVuc2V0X2tleTogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2tleVwiXG4gIGV4dGVybmFsIGNoZWNrX2tleTogdCAtPiBpbnQgLT4gYm9vbCA9IFwiY2FtbF9lcGhlX2NoZWNrX2tleVwiXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBleHRlcm5hbCBnZXRfZGF0YTogdCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfZGF0YVwiXG4gIGV4dGVybmFsIGdldF9kYXRhX2NvcHk6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVwiXG4gIGV4dGVybmFsIHNldF9kYXRhOiB0IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfZGF0YVwiXG4gIGV4dGVybmFsIHVuc2V0X2RhdGE6IHQgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3Vuc2V0X2RhdGFcIlxuICBleHRlcm5hbCBjaGVja19kYXRhOiB0IC0+IGJvb2wgPSBcImNhbWxfZXBoZV9jaGVja19kYXRhXCJcbiAgZXh0ZXJuYWwgYmxpdF9kYXRhIDogdCAtPiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9ibGl0X2RhdGFcIlxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBcnJheSBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5leHRlcm5hbCBnZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5leHRlcm5hbCBtYWtlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIGNyZWF0ZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCB1bnNhZmVfc3ViIDogJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9zdWJcIlxuZXh0ZXJuYWwgYXBwZW5kX3ByaW0gOiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9hcHBlbmRcIlxuZXh0ZXJuYWwgY29uY2F0IDogJ2EgYXJyYXkgbGlzdCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9jb25jYXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZXh0ZXJuYWwgY3JlYXRlX2Zsb2F0OiBpbnQgLT4gZmxvYXQgYXJyYXkgPSBcImNhbWxfbWFrZV9mbG9hdF92ZWN0XCJcbmxldCBtYWtlX2Zsb2F0ID0gY3JlYXRlX2Zsb2F0XG5cbm1vZHVsZSBGbG9hdGFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBmbG9hdGFycmF5ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgbGVuZ3RoIDogZmxvYXRhcnJheSAtPiBpbnQgPSBcIiVmbG9hdGFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIGdldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfc2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXRcbiAgICAgID0gXCIlZmxvYXRhcnJheV91bnNhZmVfc2V0XCJcbmVuZFxuXG5sZXQgaW5pdCBsIGYgPVxuICBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZVxuICBpZiBsIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuaW5pdFwiXG4gICgqIFNlZSAjNjU3NS4gV2UgY291bGQgYWxzbyBjaGVjayBmb3IgbWF4aW11bSBhcnJheSBzaXplLCBidXQgdGhpcyBkZXBlbmRzXG4gICAgIG9uIHdoZXRoZXIgd2UgY3JlYXRlIGEgZmxvYXQgYXJyYXkgb3IgYSByZWd1bGFyIG9uZS4uLiAqKVxuICBlbHNlXG4gICBsZXQgcmVzID0gY3JlYXRlIGwgKGYgMCkgaW5cbiAgIGZvciBpID0gMSB0byBwcmVkIGwgZG9cbiAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgZG9uZTtcbiAgIHJlc1xuXG5sZXQgbWFrZV9tYXRyaXggc3ggc3kgaW5pdCA9XG4gIGxldCByZXMgPSBjcmVhdGUgc3ggW3x8XSBpblxuICBmb3IgeCA9IDAgdG8gcHJlZCBzeCBkb1xuICAgIHVuc2FmZV9zZXQgcmVzIHggKGNyZWF0ZSBzeSBpbml0KVxuICBkb25lO1xuICByZXNcblxubGV0IGNyZWF0ZV9tYXRyaXggPSBtYWtlX21hdHJpeFxuXG5sZXQgY29weSBhID1cbiAgbGV0IGwgPSBsZW5ndGggYSBpbiBpZiBsID0gMCB0aGVuIFt8fF0gZWxzZSB1bnNhZmVfc3ViIGEgMCBsXG5cbmxldCBhcHBlbmQgYTEgYTIgPVxuICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgaWYgbDEgPSAwIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGxlbmd0aCBhMiA9IDAgdGhlbiB1bnNhZmVfc3ViIGExIDAgbDFcbiAgZWxzZSBhcHBlbmRfcHJpbSBhMSBhMlxuXG5sZXQgc3ViIGEgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuc3ViXCJcbiAgZWxzZSB1bnNhZmVfc3ViIGEgb2ZzIGxlblxuXG5sZXQgZmlsbCBhIG9mcyBsZW4gdiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggYSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuZmlsbFwiXG4gIGVsc2UgZm9yIGkgPSBvZnMgdG8gb2ZzICsgbGVuIC0gMSBkbyB1bnNhZmVfc2V0IGEgaSB2IGRvbmVcblxubGV0IGJsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IGxlbmd0aCBhMSAtIGxlblxuICAgICAgICAgICAgIHx8IG9mczIgPCAwIHx8IG9mczIgPiBsZW5ndGggYTIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmJsaXRcIlxuICBlbHNlIHVuc2FmZV9ibGl0IGExIG9mczEgYTIgb2ZzMiBsZW5cblxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBpdGVyMiBmIGEgYiA9XG4gIGlmIGxlbmd0aCBhIDw+IGxlbmd0aCBiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lml0ZXIyOiBhcnJheXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiXG4gIGVsc2VcbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSAodW5zYWZlX2dldCBiIGkpIGRvbmVcblxubGV0IG1hcCBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZih1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZih1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgbWFwMiBmIGEgYiA9XG4gIGxldCBsYSA9IGxlbmd0aCBhIGluXG4gIGxldCBsYiA9IGxlbmd0aCBiIGluXG4gIGlmIGxhIDw+IGxiIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIkFycmF5Lm1hcDI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZSBiZWdpblxuICAgIGlmIGxhID0gMCB0aGVuIFt8fF0gZWxzZSBiZWdpblxuICAgICAgbGV0IHIgPSBjcmVhdGUgbGEgKGYgKHVuc2FmZV9nZXQgYSAwKSAodW5zYWZlX2dldCBiIDApKSBpblxuICAgICAgZm9yIGkgPSAxIHRvIGxhIC0gMSBkb1xuICAgICAgICB1bnNhZmVfc2V0IHIgaSAoZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkpXG4gICAgICBkb25lO1xuICAgICAgclxuICAgIGVuZFxuICBlbmRcblxubGV0IGl0ZXJpIGYgYSA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG5sZXQgbWFwaSBmIGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbCAoZiAwICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgZm9yIGkgPSAxIHRvIGwgLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IHIgaSAoZiBpICh1bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG4gIGVuZFxuXG5sZXQgdG9fbGlzdCBhID1cbiAgbGV0IHJlYyB0b2xpc3QgaSByZXMgPVxuICAgIGlmIGkgPCAwIHRoZW4gcmVzIGVsc2UgdG9saXN0IChpIC0gMSkgKHVuc2FmZV9nZXQgYSBpIDo6IHJlcykgaW5cbiAgdG9saXN0IChsZW5ndGggYSAtIDEpIFtdXG5cbigqIENhbm5vdCB1c2UgTGlzdC5sZW5ndGggaGVyZSBiZWNhdXNlIHRoZSBMaXN0IG1vZHVsZSBkZXBlbmRzIG9uIEFycmF5LiAqKVxubGV0IHJlYyBsaXN0X2xlbmd0aCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2N1XG4gIHwgXzo6dCAtPiBsaXN0X2xlbmd0aCAoc3VjYyBhY2N1KSB0XG5cbmxldCBvZl9saXN0ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbfHxdXG4gIHwgaGQ6OnRsIGFzIGwgLT5cbiAgICAgIGxldCBhID0gY3JlYXRlIChsaXN0X2xlbmd0aCAwIGwpIGhkIGluXG4gICAgICBsZXQgcmVjIGZpbGwgaSA9IGZ1bmN0aW9uXG4gICAgICAgICAgW10gLT4gYVxuICAgICAgICB8IGhkOjp0bCAtPiB1bnNhZmVfc2V0IGEgaSBoZDsgZmlsbCAoaSsxKSB0bCBpblxuICAgICAgZmlsbCAxIHRsXG5cbmxldCBmb2xkX2xlZnQgZiB4IGEgPVxuICBsZXQgciA9IHJlZiB4IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhclxuXG5sZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSBsZW5ndGggYSAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICBkb25lO1xuICAhclxuXG5sZXQgZXhpc3RzIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gZmFsc2VcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBmb3JfYWxsIHAgYSA9XG4gIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gbG9vcCAoc3VjYyBpKVxuICAgIGVsc2UgZmFsc2UgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gUGVydmFzaXZlcy5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpZmY6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIHN1YnNldDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGVsdCAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgICB2YWwgbWFwOiAoZWx0IC0+IGVsdCkgLT4gdCAtPiB0XG4gICAgdmFsIGZvbGQ6IChlbHQgLT4gJ2EgLT4gJ2EpIC0+IHQgLT4gJ2EgLT4gJ2FcbiAgICB2YWwgZm9yX2FsbDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGVsdCAtPiBib29sKSAtPiB0IC0+IHQgKiB0XG4gICAgdmFsIGNhcmRpbmFsOiB0IC0+IGludFxuICAgIHZhbCBlbGVtZW50czogdCAtPiBlbHQgbGlzdFxuICAgIHZhbCBtaW5fZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtaW5fZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG1heF9lbHQ6IHQgLT4gZWx0XG4gICAgdmFsIG1heF9lbHRfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiB0IC0+IGVsdFxuICAgIHZhbCBjaG9vc2Vfb3B0OiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGVsdCAtPiB0IC0+IHQgKiBib29sICogdFxuICAgIHZhbCBmaW5kOiBlbHQgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9vcHQ6IGVsdCAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2ZpcnN0X29wdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdCBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfbGFzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIG9mX2xpc3Q6IGVsdCBsaXN0IC0+IHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID1cbiAgc3RydWN0XG4gICAgdHlwZSBlbHQgPSBPcmQudFxuICAgIHR5cGUgdCA9IEVtcHR5IHwgTm9kZSBvZiB7bDp0OyB2OmVsdDsgcjp0OyBoOmludH1cblxuICAgICgqIFNldHMgYXJlIHJlcHJlc2VudGVkIGJ5IGJhbGFuY2VkIGJpbmFyeSB0cmVlcyAodGhlIGhlaWdodHMgb2YgdGhlXG4gICAgICAgY2hpbGRyZW4gZGlmZmVyIGJ5IGF0IG1vc3QgMiAqKVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgICAgV2UgbXVzdCBoYXZlIGFsbCBlbGVtZW50cyBvZiBsIDwgdiA8IGFsbCBlbGVtZW50cyBvZiByLlxuICAgICAgIGwgYW5kIHIgbXVzdCBiZSBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi5cbiAgICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gICAgbGV0IGNyZWF0ZSBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgTm9kZXtsOyB2OyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSwgYnV0IHBlcmZvcm1zIG9uZSBzdGVwIG9mIHJlYmFsYW5jaW5nIGlmIG5lY2Vzc2FyeS5cbiAgICAgICBBc3N1bWVzIGwgYW5kIHIgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDMuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgICAgd2hlcmUgbm8gcmViYWxhbmNpbmcgaXMgcmVxdWlyZWQuICopXG5cbiAgICBsZXQgYmFsIGwgdiByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPWxybDsgdj1scnY7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBscmwpIGxydiAoY3JlYXRlIGxyciB2IHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9cmxsOyB2PXJsdjsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgICBsZXQgcmVjIGFkZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cbiAgICAgIHwgTm9kZXtsOyB2OyByfSBhcyB0IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIHQgZWxzZVxuICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGwgaW5cbiAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0IGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0IGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHNpbmdsZXRvbiB4ID0gTm9kZXtsPUVtcHR5OyB2PXg7IHI9RW1wdHk7IGg9MX1cblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgdiBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBlbGVtZW50cyBpbiB0aGUgdHJlZTsgaXRcbiAgICAgICBkb2VzIG5vdCB0ZXN0IGZvciBlcXVhbGl0eSB3aXRoIHRoZSBjdXJyZW50IG1pbiAob3IgbWF4KSBlbGVtZW50LlxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fZWxlbWVudCB4IGwpIHYgclxuXG4gICAgbGV0IHJlYyBhZGRfbWF4X2VsZW1lbnQgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiB4XG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgKGFkZF9tYXhfZWxlbWVudCB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9lbGVtZW50IHYgclxuICAgICAgfCAoXywgRW1wdHkpIC0+IGFkZF9tYXhfZWxlbWVudCB2IGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgcj1scjsgaD1saH0sIE5vZGV7bD1ybDsgdj1ydjsgcj1ycjsgaD1yaH0pIC0+XG4gICAgICAgICAgaWYgbGggPiByaCArIDIgdGhlbiBiYWwgbGwgbHYgKGpvaW4gbHIgdiByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IHJsKSBydiByciBlbHNlXG4gICAgICAgICAgY3JlYXRlIGwgdiByXG5cbiAgICAoKiBTbWFsbGVzdCBhbmQgZ3JlYXRlc3QgZWxlbWVudCBvZiBhIHNldCAqKVxuXG4gICAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gdlxuICAgICAgfCBOb2Rle2x9IC0+IG1pbl9lbHQgbFxuXG4gICAgbGV0IHJlYyBtaW5fZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyB2fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0X29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9lbHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiB2XG4gICAgICB8IE5vZGV7cn0gLT4gbWF4X2VsdCByXG5cbiAgICBsZXQgcmVjIG1heF9lbHRfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2Rle3Y7IHI9RW1wdHl9IC0+IFNvbWUgdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHRfb3B0IHJcblxuICAgICgqIFJlbW92ZSB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc2V0ICopXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHJ9IC0+IHJcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBiYWwgKHJlbW92ZV9taW5fZWx0IGwpIHYgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIEFzc3VtZSB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLiAqKVxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT4gYmFsIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS5cbiAgICAgICBBbGwgZWxlbWVudHMgb2YgbCBtdXN0IHByZWNlZGUgdGhlIGVsZW1lbnRzIG9mIHIuXG4gICAgICAgTm8gYXNzdW1wdGlvbiBvbiB0aGUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IGNvbmNhdCB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGpvaW4gdDEgKG1pbl9lbHQgdDIpIChyZW1vdmVfbWluX2VsdCB0MilcblxuICAgICgqIFNwbGl0dGluZy4gIHNwbGl0IHggcyByZXR1cm5zIGEgdHJpcGxlIChsLCBwcmVzZW50LCByKSB3aGVyZVxuICAgICAgICAtIGwgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlIDwgeFxuICAgICAgICAtIHIgaXMgdGhlIHNldCBvZiBlbGVtZW50cyBvZiBzIHRoYXQgYXJlID4geFxuICAgICAgICAtIHByZXNlbnQgaXMgZmFsc2UgaWYgcyBjb250YWlucyBubyBlbGVtZW50IGVxdWFsIHRvIHgsXG4gICAgICAgICAgb3IgdHJ1ZSBpZiBzIGNvbnRhaW5zIGFuIGVsZW1lbnQgZXF1YWwgdG8geC4gKilcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBmYWxzZSwgRW1wdHkpXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIHRydWUsIHIpXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgKGxsLCBwcmVzLCBybCkgPSBzcGxpdCB4IGwgaW4gKGxsLCBwcmVzLCBqb2luIHJsIHYgcilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgKGxyLCBwcmVzLCBycikgPSBzcGxpdCB4IHIgaW4gKGpvaW4gbCB2IGxyLCBwcmVzLCBycilcblxuICAgICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gICAgbGV0IGVtcHR5ID0gRW1wdHlcblxuICAgIGxldCBpc19lbXB0eSA9IGZ1bmN0aW9uIEVtcHR5IC0+IHRydWUgfCBfIC0+IGZhbHNlXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gZmFsc2VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgKE5vZGV7bDsgdjsgcn0gYXMgdCkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluXG4gICAgICAgICAgICAgIGlmIGwgPT0gbGwgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGxsIHYgclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluXG4gICAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgYmFsIGwgdiByclxuXG4gICAgbGV0IHJlYyB1bmlvbiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdDIpIC0+IHQyXG4gICAgICB8ICh0MSwgRW1wdHkpIC0+IHQxXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjE7IGg9aDF9LCBOb2Rle2w9bDI7IHY9djI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGlmIGgyID0gMSB0aGVuIGFkZCB2MiBzMSBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIGxldCAobDIsIF8sIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICAgIGpvaW4gKHVuaW9uIGwxIGwyKSB2MSAodW5pb24gcjEgcjIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBoMSA9IDEgdGhlbiBhZGQgdjEgczIgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwxLCBfLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBFbXB0eVxuICAgICAgfCAoXywgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBtYXRjaCBzcGxpdCB2MSB0MiB3aXRoXG4gICAgICAgICAgICAobDIsIGZhbHNlLCByMikgLT5cbiAgICAgICAgICAgICAgY29uY2F0IChpbnRlciBsMSBsMikgKGludGVyIHIxIHIyKVxuICAgICAgICAgIHwgKGwyLCB0cnVlLCByMikgLT5cbiAgICAgICAgICAgICAgam9pbiAoaW50ZXIgbDEgbDIpIHYxIChpbnRlciByMSByMilcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcbiAgZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGNvbXBhcmU6IHQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgKydhIHRcbiAgICB2YWwgZW1wdHk6ICdhIHRcbiAgICB2YWwgaXNfZW1wdHk6ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBtZW06ICBrZXkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGFkZDoga2V5IC0+ICdhIC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1cGRhdGU6IGtleSAtPiAoJ2Egb3B0aW9uIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHNpbmdsZXRvbjoga2V5IC0+ICdhIC0+ICdhIHRcbiAgICB2YWwgcmVtb3ZlOiBrZXkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG1lcmdlOlxuICAgICAgICAgIChrZXkgLT4gJ2Egb3B0aW9uIC0+ICdiIG9wdGlvbiAtPiAnYyBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdCAtPiAnYyB0XG4gICAgdmFsIHVuaW9uOiAoa2V5IC0+ICdhIC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgY29tcGFyZTogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICAgIHZhbCBlcXVhbDogKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQ6IChrZXkgLT4gJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgLT4gJ2JcbiAgICB2YWwgZm9yX2FsbDogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgZXhpc3RzOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBmaWx0ZXI6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHBhcnRpdGlvbjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgKiAnYSB0XG4gICAgdmFsIGNhcmRpbmFsOiAnYSB0IC0+IGludFxuICAgIHZhbCBiaW5kaW5nczogJ2EgdCAtPiAoa2V5ICogJ2EpIGxpc3RcbiAgICB2YWwgbWluX2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtaW5fYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWF4X2JpbmRpbmc6ICdhIHQgLT4gKGtleSAqICdhKVxuICAgIHZhbCBtYXhfYmluZGluZ19vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgY2hvb3NlOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgY2hvb3NlX29wdDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBzcGxpdDoga2V5IC0+ICdhIHQgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgICB2YWwgZmluZDoga2V5IC0+ICdhIHQgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6IGtleSAtPiAnYSB0IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2ZpcnN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICAgIHZhbCBmaW5kX2xhc3Q6IChrZXkgLT4gYm9vbCkgLT4gJ2EgdCAtPiBrZXkgKiAnYVxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgbWFwOiAoJ2EgLT4gJ2IpIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBtYXBpOiAoa2V5IC0+ICdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG5cbiAgICB0eXBlIGtleSA9IE9yZC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIG9mIHtsOidhIHQ7IHY6a2V5OyBkOidhOyByOidhIHQ7IGg6aW50fVxuXG4gICAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7aH0gLT4gaFxuXG4gICAgbGV0IGNyZWF0ZSBsIHggZCByID1cbiAgICAgIGxldCBobCA9IGhlaWdodCBsIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICBOb2Rle2w7IHY9eDsgZDsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgbGV0IHNpbmdsZXRvbiB4IGQgPSBOb2Rle2w9RW1wdHk7IHY9eDsgZDsgcj1FbXB0eTsgaD0xfVxuXG4gICAgbGV0IGJhbCBsIHggZCByID1cbiAgICAgIGxldCBobCA9IG1hdGNoIGwgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgbGV0IGhyID0gbWF0Y2ggciB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBpZiBobCA+IGhyICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPWxsOyB2PWx2OyBkPWxkOyByPWxyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsciB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSBsbCBsdiBsZCAoY3JlYXRlIGxyIHggZCByKVxuICAgICAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBtYXRjaCBsciB3aXRoXG4gICAgICAgICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICAgICAgfCBOb2Rle2w9bHJsOyB2PWxydjsgZD1scmQ7IHI9bHJyfS0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBscmwpIGxydiBscmQgKGNyZWF0ZSBscnIgeCBkIHIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlIGlmIGhyID4gaGwgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmwpIHJ2IHJkIHJyXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIHJsIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1ybGw7IHY9cmx2OyBkPXJsZDsgcj1ybHJ9IC0+XG4gICAgICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybGwpIHJsdiBybGQgKGNyZWF0ZSBybHIgcnYgcmQgcnIpXG4gICAgICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgZW1wdHkgPSBFbXB0eVxuXG4gICAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb24gRW1wdHkgLT4gdHJ1ZSB8IF8gLT4gZmFsc2VcblxuICAgIGxldCByZWMgYWRkIHggZGF0YSA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuXG4gICAgICAgICAgICBpZiBkID09IGRhdGEgdGhlbiBtIGVsc2UgTm9kZXtsOyB2PXg7IGQ9ZGF0YTsgcjsgaH1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IGFkZCB4IGRhdGEgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCBkYXRhIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGZpbmQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGRcbiAgICAgICAgICBlbHNlIGZpbmQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYwIGQwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHRfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgKHYwLCBkMClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdCBmIHJcblxuICAgIGxldCByZWMgZmluZF9sYXN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X29wdCBmIGxcblxuICAgIGxldCByZWMgZmluZF9vcHQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBTb21lIGRcbiAgICAgICAgICBlbHNlIGZpbmRfb3B0IHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgYyA9IDAgfHwgbWVtIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w9RW1wdHk7IHY7IGR9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfSAtPiBtaW5fYmluZGluZyBsXG5cbiAgICBsZXQgcmVjIG1pbl9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7bH0tPiBtaW5fYmluZGluZ19vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2RlIHt2OyBkOyByPUVtcHR5fSAtPiAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmcgclxuXG4gICAgbGV0IHJlYyBtYXhfYmluZGluZ19vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+IFNvbWUgKHYsIGQpXG4gICAgICB8IE5vZGUge3J9IC0+IG1heF9iaW5kaW5nX29wdCByXG5cbiAgICBsZXQgcmVjIHJlbW92ZV9taW5fYmluZGluZyA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgcn0gLT4gclxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiYWwgKHJlbW92ZV9taW5fYmluZGluZyBsKSB2IGQgclxuXG4gICAgbGV0IG1lcmdlIHQxIHQyID1cbiAgICAgIG1hdGNoICh0MSwgdDIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCB0KSAtPiB0XG4gICAgICB8ICh0LCBFbXB0eSkgLT4gdFxuICAgICAgfCAoXywgXykgLT5cbiAgICAgICAgICBsZXQgKHgsIGQpID0gbWluX2JpbmRpbmcgdDIgaW5cbiAgICAgICAgICBiYWwgdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgcmVjIHJlbW92ZSB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCAoTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSkgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSByZW1vdmUgeCBsIGluIGlmIGwgPT0gbGwgdGhlbiBtIGVsc2UgYmFsIGxsIHYgZCByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpbiBpZiByID09IHJyIHRoZW4gbSBlbHNlIGJhbCBsIHYgZCByclxuXG4gICAgbGV0IHJlYyB1cGRhdGUgeCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBFbXB0eVxuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IE5vZGV7bD1FbXB0eTsgdj14OyBkPWRhdGE7IHI9RW1wdHk7IGg9MX1cbiAgICAgICAgICBlbmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gYXMgbSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBiZWdpblxuICAgICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbWVyZ2UgbCByXG4gICAgICAgICAgICB8IFNvbWUgZGF0YSAtPlxuICAgICAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVuZCBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHVwZGF0ZSB4IGYgbCBpblxuICAgICAgICAgICAgaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSB1cGRhdGUgeCBmIHIgaW5cbiAgICAgICAgICAgIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIGl0ZXIgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaXRlciBmIGw7IGYgdiBkOyBpdGVyIGYgclxuXG4gICAgbGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgaH0gLT5cbiAgICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiBkIGluXG4gICAgICAgICAgbGV0IHInID0gbWFwIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgbWFwaSBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcGkgZiBsIGluXG4gICAgICAgICAgbGV0IGQnID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXBpIGYgciBpblxuICAgICAgICAgIE5vZGV7bD1sJzsgdjsgZD1kJzsgcj1yJzsgaH1cblxuICAgIGxldCByZWMgZm9sZCBmIG0gYWNjdSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGZvbGQgZiByIChmIHYgZCAoZm9sZCBmIGwgYWNjdSkpXG5cbiAgICBsZXQgcmVjIGZvcl9hbGwgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHRydWVcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT4gcCB2IGQgJiYgZm9yX2FsbCBwIGwgJiYgZm9yX2FsbCBwIHJcblxuICAgIGxldCByZWMgZXhpc3RzIHAgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCB8fCBleGlzdHMgcCBsIHx8IGV4aXN0cyBwIHJcblxuICAgICgqIEJld2FyZTogdGhvc2UgdHdvIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCB0aGUgYWRkZWQgayBpcyAqc3RyaWN0bHkqXG4gICAgICAgc21hbGxlciAob3IgYmlnZ2VyKSB0aGFuIGFsbCB0aGUgcHJlc2VudCBrZXlzIGluIHRoZSB0cmVlOyBpdFxuICAgICAgIGRvZXMgbm90IHRlc3QgZm9yIGVxdWFsaXR5IHdpdGggdGhlIGN1cnJlbnQgbWluIChvciBtYXgpIGtleS5cblxuICAgICAgIEluZGVlZCwgdGhleSBhcmUgb25seSB1c2VkIGR1cmluZyB0aGUgXCJqb2luXCIgb3BlcmF0aW9uIHdoaWNoXG4gICAgICAgcmVzcGVjdHMgdGhpcyBwcmVjb25kaXRpb24uXG4gICAgKilcblxuICAgIGxldCByZWMgYWRkX21pbl9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2JpbmRpbmcgayB4IGwpIHYgZCByXG5cbiAgICBsZXQgcmVjIGFkZF9tYXhfYmluZGluZyBrIHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24gayB4XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgIGJhbCBsIHYgZCAoYWRkX21heF9iaW5kaW5nIGsgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgZCByID1cbiAgICAgIG1hdGNoIChsLCByKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gYWRkX21pbl9iaW5kaW5nIHYgZCByXG4gICAgICB8IChfLCBFbXB0eSkgLT4gYWRkX21heF9iaW5kaW5nIHYgZCBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgTm9kZSB7bD1sMjsgdj12MjsgZD1kMjsgcj1yMjsgaD1oMn0pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDIgdGhlblxuICAgICAgICAgICAgbGV0IChsMiwgZDIsIHIyKSA9IHNwbGl0IHYxIHMyIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMiB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYxIGQxIHJcbiAgICAgICAgICAgIHwgU29tZSBkMiAtPiBjb25jYXRfb3Jfam9pbiBsIHYxIChmIHYxIGQxIGQyKSByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsMSwgZDEsIHIxKSA9IHNwbGl0IHYyIHMxIGluXG4gICAgICAgICAgICBsZXQgbCA9IHVuaW9uIGYgbDEgbDIgYW5kIHIgPSB1bmlvbiBmIHIxIHIyIGluXG4gICAgICAgICAgICBtYXRjaCBkMSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gam9pbiBsIHYyIGQyIHJcbiAgICAgICAgICAgIHwgU29tZSBkMSAtPiBjb25jYXRfb3Jfam9pbiBsIHYyIChmIHYyIGQxIGQyKSByXG5cbiAgICBsZXQgcmVjIGZpbHRlciBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gRW1wdHlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gYXMgbSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyIHAgbCBpblxuICAgICAgICAgIGxldCBwdmQgPSBwIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IGZpbHRlciBwIHIgaW5cbiAgICAgICAgICBpZiBwdmQgdGhlbiBpZiBsPT1sJyAmJiByPT1yJyB0aGVuIG0gZWxzZSBqb2luIGwnIHYgZCByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSAnYSB0ID0geyBtdXRhYmxlIGMgOiAnYSBsaXN0OyBtdXRhYmxlIGxlbiA6IGludDsgfVxuXG5leGNlcHRpb24gRW1wdHlcblxubGV0IGNyZWF0ZSAoKSA9IHsgYyA9IFtdOyBsZW4gPSAwOyB9XG5cbmxldCBjbGVhciBzID0gcy5jIDwtIFtdOyBzLmxlbiA8LSAwXG5cbmxldCBjb3B5IHMgPSB7IGMgPSBzLmM7IGxlbiA9IHMubGVuOyB9XG5cbmxldCBwdXNoIHggcyA9IHMuYyA8LSB4IDo6IHMuYzsgcy5sZW4gPC0gcy5sZW4gKyAxXG5cbmxldCBwb3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6OnRsIC0+IHMuYyA8LSB0bDsgcy5sZW4gPC0gcy5sZW4gLSAxOyBoZFxuICB8IFtdICAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wIHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjpfIC0+IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBpc19lbXB0eSBzID0gKHMuYyA9IFtdKVxuXG5sZXQgbGVuZ3RoIHMgPSBzLmxlblxuXG5sZXQgaXRlciBmIHMgPSBMaXN0Lml0ZXIgZiBzLmNcblxubGV0IGZvbGQgZiBhY2MgcyA9IExpc3QuZm9sZF9sZWZ0IGYgYWNjIHMuY1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBGcmFuY29pcyBQb3R0aWVyLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICBKZXJlbWllIERpbWlubywgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leGNlcHRpb24gRW1wdHlcblxudHlwZSAnYSBjZWxsID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHsgY29udGVudDogJ2E7IG11dGFibGUgbmV4dDogJ2EgY2VsbCB9XG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBsZW5ndGg6IGludDtcbiAgbXV0YWJsZSBmaXJzdDogJ2EgY2VsbDtcbiAgbXV0YWJsZSBsYXN0OiAnYSBjZWxsXG59XG5cbmxldCBjcmVhdGUgKCkgPSB7XG4gIGxlbmd0aCA9IDA7XG4gIGZpcnN0ID0gTmlsO1xuICBsYXN0ID0gTmlsXG59XG5cbmxldCBjbGVhciBxID1cbiAgcS5sZW5ndGggPC0gMDtcbiAgcS5maXJzdCA8LSBOaWw7XG4gIHEubGFzdCA8LSBOaWxcblxubGV0IGFkZCB4IHEgPVxuICBsZXQgY2VsbCA9IENvbnMge1xuICAgIGNvbnRlbnQgPSB4O1xuICAgIG5leHQgPSBOaWxcbiAgfSBpblxuICBtYXRjaCBxLmxhc3Qgd2l0aFxuICB8IE5pbCAtPlxuICAgIHEubGVuZ3RoIDwtIDE7XG4gICAgcS5maXJzdCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG4gIHwgQ29ucyBsYXN0IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggKyAxO1xuICAgIGxhc3QubmV4dCA8LSBjZWxsO1xuICAgIHEubGFzdCA8LSBjZWxsXG5cbmxldCBwdXNoID1cbiAgYWRkXG5cbmxldCBwZWVrIHEgPVxuICBtYXRjaCBxLmZpcnN0IHdpdGhcbiAgfCBOaWwgLT4gcmFpc2UgRW1wdHlcbiAgfCBDb25zIHsgY29udGVudCB9IC0+IGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCBwb3AgPVxuICB0YWtlXG5cbmxldCBjb3B5ID1cbiAgbGV0IHJlYyBjb3B5IHFfcmVzIHByZXYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gcV9yZXMubGFzdCA8LSBwcmV2OyBxX3Jlc1xuICAgIHwgQ29ucyB7IGNvbnRlbnQ7IG5leHQgfSAtPlxuICAgICAgbGV0IHJlcyA9IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gaW5cbiAgICAgIGJlZ2luIG1hdGNoIHByZXYgd2l0aFxuICAgICAgfCBOaWwgLT4gcV9yZXMuZmlyc3QgPC0gcmVzXG4gICAgICB8IENvbnMgcCAtPiBwLm5leHQgPC0gcmVzXG4gICAgICBlbmQ7XG4gICAgICBjb3B5IHFfcmVzIHJlcyBuZXh0XG4gIGluXG4gIGZ1biBxIC0+IGNvcHkgeyBsZW5ndGggPSBxLmxlbmd0aDsgZmlyc3QgPSBOaWw7IGxhc3QgPSBOaWwgfSBOaWwgcS5maXJzdFxuXG5sZXQgaXNfZW1wdHkgcSA9XG4gIHEubGVuZ3RoID0gMFxuXG5sZXQgbGVuZ3RoIHEgPVxuICBxLmxlbmd0aFxuXG5sZXQgaXRlciA9XG4gIGxldCByZWMgaXRlciBmIGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+ICgpXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBmIGNvbnRlbnQ7XG4gICAgICBpdGVyIGYgbmV4dFxuICBpblxuICBmdW4gZiBxIC0+IGl0ZXIgZiBxLmZpcnN0XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBmb2xkIGYgYWNjdSBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBhY2N1XG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgYWNjdSA9IGYgYWNjdSBjb250ZW50IGluXG4gICAgICBmb2xkIGYgYWNjdSBuZXh0XG4gIGluXG4gIGZ1biBmIGFjY3UgcSAtPiBmb2xkIGYgYWNjdSBxLmZpcnN0XG5cbmxldCB0cmFuc2ZlciBxMSBxMiA9XG4gIGlmIHExLmxlbmd0aCA+IDAgdGhlblxuICAgIG1hdGNoIHEyLmxhc3Qgd2l0aFxuICAgIHwgTmlsIC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTEubGVuZ3RoO1xuICAgICAgcTIuZmlyc3QgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuICAgIHwgQ29ucyBsYXN0IC0+XG4gICAgICBxMi5sZW5ndGggPC0gcTIubGVuZ3RoICsgcTEubGVuZ3RoO1xuICAgICAgbGFzdC5uZXh0IDwtIHExLmZpcnN0O1xuICAgICAgcTIubGFzdCA8LSBxMS5sYXN0O1xuICAgICAgY2xlYXIgcTFcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogSW50ZXJuYWxzIG9mIGZvcmNpbmcgbGF6eSB2YWx1ZXMuICopXG5cbmV4Y2VwdGlvbiBVbmRlZmluZWRcblxubGV0IHJhaXNlX3VuZGVmaW5lZCA9IE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgVW5kZWZpbmVkKVxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICB0cnlcbiAgICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAgICgqIGRvIHNldF9maWVsZCBCRUZPUkUgc2V0X3RhZyAqKVxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgcmVzdWx0KTtcbiAgICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSBPYmouZm9yd2FyZF90YWc7XG4gICAgcmVzdWx0XG4gIHdpdGggZSAtPlxuICAgIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCAoT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBlKSk7XG4gICAgcmFpc2UgZVxuXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV92YWxfbGF6eV9ibG9jayAoYmxrIDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IGNsb3N1cmUgPSAoT2JqLm9iaiAoT2JqLmZpZWxkIChPYmoucmVwciBibGspIDApIDogdW5pdCAtPiAnYXJnKSBpblxuICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgcmFpc2VfdW5kZWZpbmVkO1xuICBsZXQgcmVzdWx0ID0gY2xvc3VyZSAoKSBpblxuICAoKiBkbyBzZXRfZmllbGQgQkVGT1JFIHNldF90YWcgKilcbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIChPYmoucmVwciByZXN1bHQpO1xuICBPYmouc2V0X3RhZyAoT2JqLnJlcHIgYmxrKSAoT2JqLmZvcndhcmRfdGFnKTtcbiAgcmVzdWx0XG5cblxuKCogW2ZvcmNlXSBpcyBub3QgdXNlZCwgc2luY2UgW0xhenkuZm9yY2VdIGlzIGRlY2xhcmVkIGFzIGEgcHJpbWl0aXZlXG4gICB3aG9zZSBjb2RlIGlubGluZXMgdGhlIHRhZyB0ZXN0cyBvZiBpdHMgYXJndW1lbnQuICBUaGlzIGZ1bmN0aW9uIGlzXG4gICBoZXJlIGZvciB0aGUgc2FrZSBvZiBjb21wbGV0ZW5lc3MsIGFuZCBmb3IgZGVidWdnaW5nIHB1cnBvc2UuICopXG5cbmxldCBmb3JjZSAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV9sYXp5X2Jsb2NrIGx6dlxuXG5cbmxldCBmb3JjZV92YWwgKGx6diA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCB4ID0gT2JqLnJlcHIgbHp2IGluXG4gIGxldCB0ID0gT2JqLnRhZyB4IGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgdGhlbiAoT2JqLm9iaiAoT2JqLmZpZWxkIHggMCkgOiAnYXJnKSBlbHNlXG4gIGlmIHQgPD4gT2JqLmxhenlfdGFnIHRoZW4gKE9iai5vYmogeCA6ICdhcmcpXG4gIGVsc2UgZm9yY2VfdmFsX2xhenlfYmxvY2sgbHp2XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbTGF6eV06IGRlZmVycmVkIGNvbXB1dGF0aW9ucyAqKVxuXG5cbigqXG4gICBXQVJOSU5HOiBzb21lIHB1cnBsZSBtYWdpYyBpcyBnb2luZyBvbiBoZXJlLiAgRG8gbm90IHRha2UgdGhpcyBmaWxlXG4gICBhcyBhbiBleGFtcGxlIG9mIGhvdyB0byBwcm9ncmFtIGluIE9DYW1sLlxuKilcblxuXG4oKiBXZSBtYWtlIHVzZSBvZiB0d28gc3BlY2lhbCB0YWdzIHByb3ZpZGVkIGJ5IHRoZSBydW50aW1lOlxuICAgW2xhenlfdGFnXSBhbmQgW2ZvcndhcmRfdGFnXS5cblxuICAgQSB2YWx1ZSBvZiB0eXBlIFsnYSBMYXp5LnRdIGNhbiBiZSBvbmUgb2YgdGhyZWUgdGhpbmdzOlxuICAgMS4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2xhenlfdGFnXS4gIEl0cyBmaWVsZCBpcyBhIGNsb3N1cmUgb2ZcbiAgICAgIHR5cGUgW3VuaXQgLT4gJ2FdIHRoYXQgY29tcHV0ZXMgdGhlIHZhbHVlLlxuICAgMi4gQSBibG9jayBvZiBzaXplIDEgd2l0aCB0YWcgW2ZvcndhcmRfdGFnXS4gIEl0cyBmaWVsZCBpcyB0aGUgdmFsdWVcbiAgICAgIG9mIHR5cGUgWydhXSB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIDMuIEFueXRoaW5nIGVsc2UgZXhjZXB0IGEgZmxvYXQuICBUaGlzIGhhcyB0eXBlIFsnYV0gYW5kIGlzIHRoZSB2YWx1ZVxuICAgICAgdGhhdCB3YXMgY29tcHV0ZWQuXG4gICBFeGNlcHRpb25zIGFyZSBzdG9yZWQgaW4gZm9ybWF0ICgxKS5cbiAgIFRoZSBHQyB3aWxsIG1hZ2ljYWxseSBjaGFuZ2UgdGhpbmdzIGZyb20gKDIpIHRvICgzKSBhY2NvcmRpbmcgdG8gaXRzXG4gICBmYW5jeS5cblxuICAgSWYgT0NhbWwgd2FzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgLWZsYXQtZmxvYXQtYXJyYXkgb3B0aW9uICh3aGljaCBpc1xuICAgY3VycmVudGx5IHRoZSBkZWZhdWx0KSwgdGhlIGZvbGxvd2luZyBpcyBhbHNvIHRydWU6XG4gICBXZSBjYW5ub3QgdXNlIHJlcHJlc2VudGF0aW9uICgzKSBmb3IgYSBbZmxvYXQgTGF6eS50XSBiZWNhdXNlXG4gICBbY2FtbF9tYWtlX2FycmF5XSBhc3N1bWVzIHRoYXQgb25seSBhIFtmbG9hdF0gdmFsdWUgY2FuIGhhdmUgdGFnXG4gICBbRG91YmxlX3RhZ10uXG5cbiAgIFdlIGhhdmUgdG8gdXNlIHRoZSBidWlsdC1pbiB0eXBlIGNvbnN0cnVjdG9yIFtsYXp5X3RdIHRvXG4gICBsZXQgdGhlIGNvbXBpbGVyIGltcGxlbWVudCB0aGUgc3BlY2lhbCB0eXBpbmcgYW5kIGNvbXBpbGF0aW9uXG4gICBydWxlcyBmb3IgdGhlIFtsYXp5XSBrZXl3b3JkLlxuKilcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90XG5cbmV4Y2VwdGlvbiBVbmRlZmluZWQgPSBDYW1saW50ZXJuYWxMYXp5LlVuZGVmaW5lZFxuXG5leHRlcm5hbCBtYWtlX2ZvcndhcmQgOiAnYSAtPiAnYSBsYXp5X3QgPSBcImNhbWxfbGF6eV9tYWtlX2ZvcndhcmRcIlxuXG5leHRlcm5hbCBmb3JjZSA6ICdhIHQgLT4gJ2EgPSBcIiVsYXp5X2ZvcmNlXCJcblxuKCogbGV0IGZvcmNlID0gZm9yY2UgKilcblxubGV0IGZvcmNlX3ZhbCA9IENhbWxpbnRlcm5hbExhenkuZm9yY2VfdmFsXG5cbmxldCBmcm9tX2Z1biAoZiA6IHVuaXQgLT4gJ2FyZykgPVxuICBsZXQgeCA9IE9iai5uZXdfYmxvY2sgT2JqLmxhenlfdGFnIDEgaW5cbiAgT2JqLnNldF9maWVsZCB4IDAgKE9iai5yZXByIGYpO1xuICAoT2JqLm9iaiB4IDogJ2FyZyB0KVxuXG5cbmxldCBmcm9tX3ZhbCAodiA6ICdhcmcpID1cbiAgbGV0IHQgPSBPYmoudGFnIChPYmoucmVwciB2KSBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHx8IHQgPSBPYmoubGF6eV90YWcgfHwgdCA9IE9iai5kb3VibGVfdGFnIHRoZW4gYmVnaW5cbiAgICBtYWtlX2ZvcndhcmQgdlxuICBlbmQgZWxzZSBiZWdpblxuICAgIChPYmoubWFnaWMgdiA6ICdhcmcgdClcbiAgZW5kXG5cblxubGV0IGlzX3ZhbCAobCA6ICdhcmcgdCkgPSBPYmoudGFnIChPYmoucmVwciBsKSA8PiBPYmoubGF6eV90YWdcblxubGV0IGxhenlfZnJvbV9mdW4gPSBmcm9tX2Z1blxuXG5sZXQgbGF6eV9mcm9tX3ZhbCA9IGZyb21fdmFsXG5cbmxldCBsYXp5X2lzX3ZhbCA9IGlzX3ZhbFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICBEYW5pZWwgZGUgUmF1Z2xhdWRyZSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSAnYSBjZWxsIG9wdGlvblxuYW5kICdhIGNlbGwgPSB7IG11dGFibGUgY291bnQgOiBpbnQ7IG11dGFibGUgZGF0YSA6ICdhIGRhdGEgfVxuYW5kICdhIGRhdGEgPVxuICAgIFNlbXB0eVxuICB8IFNjb25zIG9mICdhICogJ2EgZGF0YVxuICB8IFNhcHAgb2YgJ2EgZGF0YSAqICdhIGRhdGFcbiAgfCBTbGF6eSBvZiAnYSBkYXRhIExhenkudFxuICB8IFNnZW4gb2YgJ2EgZ2VuXG4gIHwgU2J1ZmZpbyA6IGJ1ZmZpbyAtPiBjaGFyIGRhdGFcbmFuZCAnYSBnZW4gPSB7IG11dGFibGUgY3VyciA6ICdhIG9wdGlvbiBvcHRpb247IGZ1bmMgOiBpbnQgLT4gJ2Egb3B0aW9uIH1cbmFuZCBidWZmaW8gPVxuICB7IGljIDogaW5fY2hhbm5lbDsgYnVmZiA6IGJ5dGVzOyBtdXRhYmxlIGxlbiA6IGludDsgbXV0YWJsZSBpbmQgOiBpbnQgfVxuXG5leGNlcHRpb24gRmFpbHVyZVxuZXhjZXB0aW9uIEVycm9yIG9mIHN0cmluZ1xuXG5sZXQgY291bnQgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gMFxuICB8IFNvbWUgeyBjb3VudCB9IC0+IGNvdW50XG5sZXQgZGF0YSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiBTZW1wdHlcbiAgfCBTb21lIHsgZGF0YSB9IC0+IGRhdGFcblxubGV0IGZpbGxfYnVmZiBiID1cbiAgYi5sZW4gPC0gaW5wdXQgYi5pYyBiLmJ1ZmYgMCAoQnl0ZXMubGVuZ3RoIGIuYnVmZik7IGIuaW5kIDwtIDBcblxuXG5sZXQgcmVjIGdldF9kYXRhIDogdHlwZSB2LiBpbnQgLT4gdiBkYXRhIC0+IHYgZGF0YSA9IGZ1biBjb3VudCBkIC0+IG1hdGNoIGQgd2l0aFxuICgqIFJldHVybnMgZWl0aGVyIFNlbXB0eSBvciBTY29ucyhhLCBfKSBldmVuIHdoZW4gZCBpcyBhIGdlbmVyYXRvclxuICAgIG9yIGEgYnVmZmVyLiBJbiB0aG9zZSBjYXNlcywgdGhlIGl0ZW0gYSBpcyBzZWVuIGFzIGV4dHJhY3RlZCBmcm9tXG4gdGhlIGdlbmVyYXRvci9idWZmZXIuXG4gVGhlIGNvdW50IHBhcmFtZXRlciBpcyB1c2VkIGZvciBjYWxsaW5nIGBTZ2VuLWZ1bmN0aW9ucycuICAqKVxuICAgU2VtcHR5IHwgU2NvbnMgKF8sIF8pIC0+IGRcbiB8IFNhcHAgKGQxLCBkMikgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZ2V0X2RhdGEgY291bnQgZDEgd2l0aFxuICAgICAgIFNjb25zIChhLCBkMTEpIC0+IFNjb25zIChhLCBTYXBwIChkMTEsIGQyKSlcbiAgICAgfCBTZW1wdHkgLT4gZ2V0X2RhdGEgY291bnQgZDJcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNnZW4ge2N1cnIgPSBTb21lIE5vbmV9IC0+IFNlbXB0eVxuIHwgU2dlbiAoe2N1cnIgPSBTb21lKFNvbWUgYSl9IGFzIGcpIC0+XG4gICAgIGcuY3VyciA8LSBOb25lOyBTY29ucyhhLCBkKVxuIHwgU2dlbiBnIC0+XG4gICAgIGJlZ2luIG1hdGNoIGcuZnVuYyBjb3VudCB3aXRoXG4gICAgICAgTm9uZSAtPiBnLmN1cnIgPC0gU29tZShOb25lKTsgU2VtcHR5XG4gICAgIHwgU29tZSBhIC0+IFNjb25zKGEsIGQpXG4gICAgICAgICAoKiBXYXJuaW5nOiBhbnlvbmUgdXNpbmcgZyB0aGlua3MgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIHJlYWQgKilcbiAgICAgZW5kXG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIFNlbXB0eSBlbHNlXG4gICAgICAgbGV0IHIgPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZiBiLmluZCBpblxuICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICAgIGIuaW5kIDwtIHN1Y2MgYi5pbmQ7IFNjb25zKHIsIGQpXG4gfCBTbGF6eSBmIC0+IGdldF9kYXRhIGNvdW50IChMYXp5LmZvcmNlIGYpXG5cblxubGV0IHJlYyBwZWVrX2RhdGEgOiB0eXBlIHYuIHYgY2VsbCAtPiB2IG9wdGlvbiA9IGZ1biBzIC0+XG4gKCogY29uc3VsdCB0aGUgZmlyc3QgaXRlbSBvZiBzICopXG4gbWF0Y2ggcy5kYXRhIHdpdGhcbiAgIFNlbXB0eSAtPiBOb25lXG4gfCBTY29ucyAoYSwgXykgLT4gU29tZSBhXG4gfCBTYXBwIChfLCBfKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBzLmNvdW50IHMuZGF0YSB3aXRoXG4gICAgICAgU2NvbnMoYSwgXykgYXMgZCAtPiBzLmRhdGEgPC0gZDsgU29tZSBhXG4gICAgIHwgU2VtcHR5IC0+IE5vbmVcbiAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICAgICBlbmRcbiB8IFNsYXp5IGYgLT4gcy5kYXRhIDwtIChMYXp5LmZvcmNlIGYpOyBwZWVrX2RhdGEgc1xuIHwgU2dlbiB7Y3VyciA9IFNvbWUgYX0gLT4gYVxuIHwgU2dlbiBnIC0+IGxldCB4ID0gZy5mdW5jIHMuY291bnQgaW4gZy5jdXJyIDwtIFNvbWUgeDsgeFxuIHwgU2J1ZmZpbyBiIC0+XG4gICAgIGlmIGIuaW5kID49IGIubGVuIHRoZW4gZmlsbF9idWZmIGI7XG4gICAgIGlmIGIubGVuID09IDAgdGhlbiBiZWdpbiBzLmRhdGEgPC0gU2VtcHR5OyBOb25lIGVuZFxuICAgICBlbHNlIFNvbWUgKEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kKVxuXG5cbmxldCBwZWVrID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHMgLT4gcGVla19kYXRhIHNcblxuXG5sZXQgcmVjIGp1bmtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHVuaXQgPSBmdW4gcyAtPlxuICBtYXRjaCBzLmRhdGEgd2l0aFxuICAgIFNjb25zIChfLCBkKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBzLmRhdGEgPC0gZFxuICB8IFNnZW4gKHtjdXJyID0gU29tZSBffSBhcyBnKSAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBnLmN1cnIgPC0gTm9uZVxuICB8IFNidWZmaW8gYiAtPiBzLmNvdW50IDwtIChzdWNjIHMuY291bnQpOyBiLmluZCA8LSBzdWNjIGIuaW5kXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuXG5sZXQgY3JlYXRlIG4gPVxuIGxldCBuID0gaWYgbiA8IDEgdGhlbiAxIGVsc2UgbiBpblxuIGxldCBuID0gaWYgbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuIFN5cy5tYXhfc3RyaW5nX2xlbmd0aCBlbHNlIG4gaW5cbiBsZXQgcyA9IEJ5dGVzLmNyZWF0ZSBuIGluXG4ge2J1ZmZlciA9IHM7IHBvc2l0aW9uID0gMDsgbGVuZ3RoID0gbjsgaW5pdGlhbF9idWZmZXIgPSBzfVxuXG5sZXQgY29udGVudHMgYiA9IEJ5dGVzLnN1Yl9zdHJpbmcgYi5idWZmZXIgMCBiLnBvc2l0aW9uXG5sZXQgdG9fYnl0ZXMgYiA9IEJ5dGVzLnN1YiBiLmJ1ZmZlciAwIGIucG9zaXRpb25cblxubGV0IHN1YiBiIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYi5wb3NpdGlvbiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLnN1YlwiXG4gIGVsc2UgQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciBvZnMgbGVuXG5cblxubGV0IGJsaXQgc3JjIHNyY29mZiBkc3QgZHN0b2ZmIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgc3Jjb2ZmIDwgMCB8fCBzcmNvZmYgPiBzcmMucG9zaXRpb24gLSBsZW5cbiAgICAgICAgICAgICB8fCBkc3RvZmYgPCAwIHx8IGRzdG9mZiA+IChCeXRlcy5sZW5ndGggZHN0KSAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnVmZmVyLmJsaXRcIlxuICBlbHNlXG4gICAgQnl0ZXMudW5zYWZlX2JsaXQgc3JjLmJ1ZmZlciBzcmNvZmYgZHN0IGRzdG9mZiBsZW5cblxuXG5sZXQgbnRoIGIgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPj0gYi5wb3NpdGlvbiB0aGVuXG4gICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5udGhcIlxuICBlbHNlIEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgb2ZzXG5cblxubGV0IGxlbmd0aCBiID0gYi5wb3NpdGlvblxuXG5sZXQgY2xlYXIgYiA9IGIucG9zaXRpb24gPC0gMFxuXG5sZXQgcmVzZXQgYiA9XG4gIGIucG9zaXRpb24gPC0gMDsgYi5idWZmZXIgPC0gYi5pbml0aWFsX2J1ZmZlcjtcbiAgYi5sZW5ndGggPC0gQnl0ZXMubGVuZ3RoIGIuYnVmZmVyXG5cbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IGxlbiA9IGIubGVuZ3RoIGluXG4gIGxldCBuZXdfbGVuID0gcmVmIGxlbiBpblxuICB3aGlsZSBiLnBvc2l0aW9uICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBiLnBvc2l0aW9uICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxuIGxldCBhZGRfdXRmXzhfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgIGFkZF9jaGFyIGIgKENoYXIudW5zYWZlX2NociB1KVxuIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhDMCBsb3IgKHUgbHNyIDYpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAzID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAzO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RTAgbG9yICh1IGxzciAxMikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgM1xuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEYwIGxvciAodSBsc3IgMTgpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHMgb2Zmc2V0IGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX3N1YmJ5dGVzIGIgcyBvZmZzZXQgbGVuID1cbiAgYWRkX3N1YnN0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpIG9mZnNldCBsZW5cblxubGV0IGFkZF9zdHJpbmcgYiBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIGxlbiBpblxuICBpZiBuZXdfcG9zaXRpb24gPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIGxlbjtcbiAgQnl0ZXMuYmxpdF9zdHJpbmcgcyAwIGIuYnVmZmVyIGIucG9zaXRpb24gbGVuO1xuICBiLnBvc2l0aW9uIDwtIG5ld19wb3NpdGlvblxuXG5sZXQgYWRkX2J5dGVzIGIgcyA9IGFkZF9zdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKVxuXG5sZXQgYWRkX2J1ZmZlciBiIGJzID1cbiAgYWRkX3N1YmJ5dGVzIGIgYnMuYnVmZmVyIDAgYnMucG9zaXRpb25cblxuKCogcmVhZCB1cCB0byBbbGVuXSBieXRlcyBmcm9tIFtpY10gaW50byBbYl0uICopXG5sZXQgcmVjIGFkZF9jaGFubmVsX3JlYyBiIGljIGxlbiA9XG4gIGlmIGxlbiA+IDAgdGhlbiAoXG4gICAgbGV0IG4gPSBpbnB1dCBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAgIGIucG9zaXRpb24gPC0gYi5wb3NpdGlvbiArIG47XG4gICAgaWYgbiA9IDAgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZVxuICAgIGVsc2UgYWRkX2NoYW5uZWxfcmVjIGIgaWMgKGxlbi1uKSAgICgqIG4gPD0gbGVuICopXG4gIClcblxubGV0IGFkZF9jaGFubmVsIGIgaWMgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBsZW4gPiBTeXMubWF4X3N0cmluZ19sZW5ndGggdGhlbiAgICgqIFBSIzUwMDQgKilcbiAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci5hZGRfY2hhbm5lbFwiO1xuICBpZiBiLnBvc2l0aW9uICsgbGVuID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIGFkZF9jaGFubmVsX3JlYyBiIGljIGxlblxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgWGF2aWVyIExlcm95IGFuZCBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbmxldCBrZnByaW50ZiBrIG8gKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX3ByaW50ZiAoZnVuIG8gYWNjIC0+IG91dHB1dF9hY2MgbyBhY2M7IGsgbykgbyBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYiBhY2MgLT4gYnVmcHV0X2FjYyBiIGFjYzsgayBiKSBiIEVuZF9vZl9hY2MgZm10XG5sZXQgaWtmcHJpbnRmIGsgb2MgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBtYWtlX2lwcmludGYgayBvYyBmbXRcblxubGV0IGZwcmludGYgb2MgZm10ID0ga2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IGJwcmludGYgYiBmbXQgPSBrYnByaW50ZiBpZ25vcmUgYiBmbXRcbmxldCBpZnByaW50ZiBvYyBmbXQgPSBpa2ZwcmludGYgaWdub3JlIG9jIGZtdFxubGV0IHByaW50ZiBmbXQgPSBmcHJpbnRmIHN0ZG91dCBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkZXJyIGZtdFxuXG5sZXQga3NwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIGxldCBrJyAoKSBhY2MgPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDY0IGluXG4gICAgc3RycHV0X2FjYyBidWYgYWNjO1xuICAgIGsgKEJ1ZmZlci5jb250ZW50cyBidWYpIGluXG4gIG1ha2VfcHJpbnRmIGsnICgpIEVuZF9vZl9hY2MgZm10XG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGtwcmludGYgPSBrc3ByaW50ZlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIGtleSA9IHN0cmluZ1xudHlwZSBkb2MgPSBzdHJpbmdcbnR5cGUgdXNhZ2VfbXNnID0gc3RyaW5nXG50eXBlIGFub25fZnVuID0gKHN0cmluZyAtPiB1bml0KVxuXG50eXBlIHNwZWMgPVxuICB8IFVuaXQgb2YgKHVuaXQgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggdW5pdCBhcmd1bWVudCAqKVxuICB8IEJvb2wgb2YgKGJvb2wgLT4gdW5pdCkgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBib29sIGFyZ3VtZW50ICopXG4gIHwgU2V0IG9mIGJvb2wgcmVmICAgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdHJ1ZSAqKVxuICB8IENsZWFyIG9mIGJvb2wgcmVmICAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIGZhbHNlICopXG4gIHwgU3RyaW5nIG9mIChzdHJpbmcgLT4gdW5pdCkgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IFNldF9zdHJpbmcgb2Ygc3RyaW5nIHJlZiAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBzdHJpbmcgYXJndW1lbnQgKilcbiAgfCBJbnQgb2YgKGludCAtPiB1bml0KSAgICAgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGFuIGludCBhcmd1bWVudCAqKVxuICB8IFNldF9pbnQgb2YgaW50IHJlZiAgICAgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBpbnQgYXJndW1lbnQgKilcbiAgfCBGbG9hdCBvZiAoZmxvYXQgLT4gdW5pdCkgICAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBTZXRfZmxvYXQgb2YgZmxvYXQgcmVmICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0aGUgZmxvYXQgYXJndW1lbnQgKilcbiAgfCBUdXBsZSBvZiBzcGVjIGxpc3QgICAgICAgICAoKiBUYWtlIHNldmVyYWwgYXJndW1lbnRzIGFjY29yZGluZyB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjIGxpc3QgKilcbiAgfCBTeW1ib2wgb2Ygc3RyaW5nIGxpc3QgKiAoc3RyaW5nIC0+IHVuaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVGFrZSBvbmUgb2YgdGhlIHN5bWJvbHMgYXMgYXJndW1lbnQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3ltYm9sLiAqKVxuICB8IFJlc3Qgb2YgKHN0cmluZyAtPiB1bml0KSAgICgqIFN0b3AgaW50ZXJwcmV0aW5nIGtleXdvcmRzIGFuZCBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHdpdGggZWFjaCByZW1haW5pbmcgYXJndW1lbnQgKilcbiAgfCBFeHBhbmQgb2YgKHN0cmluZyAtPiBzdHJpbmcgYXJyYXkpICgqIElmIHRoZSByZW1haW5pbmcgYXJndW1lbnRzIHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBvZiB0aGUgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1tcIi1mb29cIjsgXCJhcmdcIl0gQCByZXN0XSB3aGVyZSBcImZvb1wiIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlcmVkIGFzIFtFeHBhbmQgZl0sIHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHMgW2YgXCJhcmdcIiBAIHJlc3RdIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLiBPbmx5IGFsbG93ZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY10uICopXG5cbmV4Y2VwdGlvbiBCYWQgb2Ygc3RyaW5nXG5leGNlcHRpb24gSGVscCBvZiBzdHJpbmdcblxudHlwZSBlcnJvciA9XG4gIHwgVW5rbm93biBvZiBzdHJpbmdcbiAgfCBXcm9uZyBvZiBzdHJpbmcgKiBzdHJpbmcgKiBzdHJpbmcgICgqIG9wdGlvbiwgYWN0dWFsLCBleHBlY3RlZCAqKVxuICB8IE1pc3Npbmcgb2Ygc3RyaW5nXG4gIHwgTWVzc2FnZSBvZiBzdHJpbmdcblxuZXhjZXB0aW9uIFN0b3Agb2YgZXJyb3IgKCogdXNlZCBpbnRlcm5hbGx5ICopXG5cbm9wZW4gUHJpbnRmXG5cbmxldCByZWMgYXNzb2MzIHggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8ICh5MSwgeTIsIF8pIDo6IF8gd2hlbiB5MSA9IHggLT4geTJcbiAgfCBfIDo6IHQgLT4gYXNzb2MzIHggdFxuXG5cbmxldCBzcGxpdCBzID1cbiAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnPScgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBTdHJpbmcuc3ViIHMgMCBpLCBTdHJpbmcuc3ViIHMgKGkrMSkgKGxlbi0oaSsxKSlcblxuXG5sZXQgbWFrZV9zeW1saXN0IHByZWZpeCBzZXAgc3VmZml4IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBcIjxub25lPlwiXG4gIHwgaDo6dCAtPiAoTGlzdC5mb2xkX2xlZnQgKGZ1biB4IHkgLT4geCBeIHNlcCBeIHkpIChwcmVmaXggXiBoKSB0KSBeIHN1ZmZpeFxuXG5cbmxldCBwcmludF9zcGVjIGJ1ZiAoa2V5LCBzcGVjLCBkb2MpID1cbiAgaWYgU3RyaW5nLmxlbmd0aCBkb2MgPiAwIHRoZW5cbiAgICBtYXRjaCBzcGVjIHdpdGhcbiAgICB8IFN5bWJvbCAobCwgXykgLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzJXNcXG5cIiBrZXkgKG1ha2Vfc3ltbGlzdCBcIntcIiBcInxcIiBcIn1cIiBsKSBkb2NcbiAgICB8IF8gLT5cbiAgICAgICAgYnByaW50ZiBidWYgXCIgICVzICVzXFxuXCIga2V5IGRvY1xuXG5cbmxldCBoZWxwX2FjdGlvbiAoKSA9IHJhaXNlIChTdG9wIChVbmtub3duIFwiLWhlbHBcIikpXG5cbmxldCBhZGRfaGVscCBzcGVjbGlzdCA9XG4gIGxldCBhZGQxID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItaGVscFwiIHNwZWNsaXN0KTsgW11cbiAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgW1wiLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBhbmQgYWRkMiA9XG4gICAgdHJ5IGlnbm9yZSAoYXNzb2MzIFwiLS1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItLWhlbHBcIiwgVW5pdCBoZWxwX2FjdGlvbiwgXCIgRGlzcGxheSB0aGlzIGxpc3Qgb2Ygb3B0aW9uc1wiXVxuICBpblxuICBzcGVjbGlzdCBAIChhZGQxIEAgYWRkMilcblxuXG5sZXQgdXNhZ2VfYiBidWYgc3BlY2xpc3QgZXJybXNnID1cbiAgYnByaW50ZiBidWYgXCIlc1xcblwiIGVycm1zZztcbiAgTGlzdC5pdGVyIChwcmludF9zcGVjIGJ1ZikgKGFkZF9oZWxwIHNwZWNsaXN0KVxuXG5cbmxldCB1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnID1cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDIwMCBpblxuICB1c2FnZV9iIGIgc3BlY2xpc3QgZXJybXNnO1xuICBCdWZmZXIuY29udGVudHMgYlxuXG5cbmxldCB1c2FnZSBzcGVjbGlzdCBlcnJtc2cgPVxuICBlcHJpbnRmIFwiJXNcIiAodXNhZ2Vfc3RyaW5nIHNwZWNsaXN0IGVycm1zZylcblxuXG5sZXQgY3VycmVudCA9IHJlZiAwXG5cbmxldCBib29sX29mX3N0cmluZ19vcHQgeCA9XG4gIHRyeSBTb21lIChib29sX29mX3N0cmluZyB4KVxuICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG5cbmxldCBpbnRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgeClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZmxvYXRfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGZsb2F0X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggYWxsb3dfZXhwYW5kIGN1cnJlbnQgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIGxldCBpbml0cG9zID0gIWN1cnJlbnQgaW5cbiAgbGV0IGNvbnZlcnRfZXJyb3IgZXJyb3IgPVxuICAgICgqIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXJyb3IgdG8gYSBCYWQvSGVscCBleGNlcHRpb25cbiAgICAgICAqb3IqIGFkZCB0aGUgcHJvZ3JhbSBuYW1lIGFzIGEgcHJlZml4IGFuZCB0aGUgdXNhZ2UgbWVzc2FnZSBhcyBhIHN1ZmZpeFxuICAgICAgIHRvIGFuIHVzZXItcmFpc2VkIEJhZCBleGNlcHRpb24uXG4gICAgKilcbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gICAgbGV0IHByb2duYW1lID0gaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gZiAoKTtcbiAgICAgICAgfCBCb29sIGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBib29sX29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGJvb2xlYW5cIikpKVxuICAgICAgICAgICAgfCBTb21lIHMgLT4gZiBzXG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTZXQgciAtPiBub19hcmcgKCk7IHIgOj0gdHJ1ZTtcbiAgICAgICAgfCBDbGVhciByIC0+IG5vX2FyZyAoKTsgciA6PSBmYWxzZTtcbiAgICAgICAgfCBTdHJpbmcgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGYgYXJnO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU3ltYm9sIChzeW1iLCBmKSAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGlmIExpc3QubWVtIGFyZyBzeW1iIHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwib25lIG9mOiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXiAobWFrZV9zeW1saXN0IFwiXCIgXCIgXCIgXCJcIiBzeW1iKSkpKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgU2V0X3N0cmluZyByIC0+XG4gICAgICAgICAgICByIDo9IGdldF9hcmcgKCk7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBJbnQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9pbnQgciAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGludF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYW4gaW50ZWdlclwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEZsb2F0IGYgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiBmIHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldF9mbG9hdCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggZmxvYXRfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgZmxvYXRcIikpKVxuICAgICAgICAgICAgfCBTb21lIHggLT4gciA6PSB4XG4gICAgICAgICAgICBlbmQ7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBUdXBsZSBzcGVjcyAtPlxuICAgICAgICAgICAgTGlzdC5pdGVyIHRyZWF0X2FjdGlvbiBzcGVjcztcbiAgICAgICAgfCBSZXN0IGYgLT5cbiAgICAgICAgICAgIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgLSAxIGRvXG4gICAgICAgICAgICAgIGYgIWFyZ3YuKCFjdXJyZW50ICsgMSk7XG4gICAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICAgICAgZG9uZTtcbiAgICAgICAgfCBFeHBhbmQgZiAtPlxuICAgICAgICAgICAgaWYgbm90IGFsbG93X2V4cGFuZCB0aGVuXG4gICAgICAgICAgICAgIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiQXJnLkV4cGFuZCBpcyBpcyBvbmx5IGFsbG93ZWQgd2l0aCBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID0gQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpICgoQXJyYXkubGVuZ3RoICFhcmd2KSAtICFjdXJyZW50IC0gMSkgaW5cbiAgICAgICAgICAgIGFyZ3Y6PSBBcnJheS5jb25jYXQgW2JlZm9yZTtuZXdhcmc7YWZ0ZXJdO1xuICAgICAgICBpblxuICAgICAgICB0cmVhdF9hY3Rpb24gYWN0aW9uIGVuZFxuICAgICAgZWxzZSBhbm9uZnVuIHNcbiAgICB3aXRoIHwgQmFkIG0gLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgKE1lc3NhZ2UgbSkpO1xuICAgICAgICAgfCBTdG9wIGUgLT4gcmFpc2UgKGNvbnZlcnRfZXJyb3IgZSk7XG4gICAgZW5kO1xuICAgIGluY3IgY3VycmVudFxuICBkb25lXG5cbmxldCBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggdHJ1ZSBjdXJyZW50IGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxubGV0IHBhcnNlX2FyZ3ZfZHluYW1pYyA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBmYWxzZSBjdXJyZW50IChyZWYgYXJndikgc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChtYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gbWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gIChCdWZmZXIuY29udGVudHMgYnVmKSBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGxldCByZWMgcmVhZCAoKSA9XG4gICAgdHJ5XG4gICAgICBsZXQgYyA9IGlucHV0X2NoYXIgaWMgaW5cbiAgICAgIGlmIGMgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgICBzdGFzaCAoKTsgcmVhZCAoKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjOyByZWFkICgpXG4gICAgICBlbmRcbiAgICB3aXRoIEVuZF9vZl9maWxlIC0+XG4gICAgICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlblxuICAgICAgICBzdGFzaCAoKSBpblxuICByZWFkICgpO1xuICBjbG9zZV9pbiBpYztcbiAgQXJyYXkub2ZfbGlzdCAoTGlzdC5yZXYgIXdvcmRzKVxuXG5sZXQgcmVhZF9hcmcgPSByZWFkX2F1eCB0cnVlICdcXG4nXG5cbmxldCByZWFkX2FyZzAgPSByZWFkX2F1eCBmYWxzZSAnXFx4MDAnXG5cbmxldCB3cml0ZV9hdXggc2VwIGZpbGUgYXJncyA9XG4gIGxldCBvYyA9IG9wZW5fb3V0X2JpbiBmaWxlIGluXG4gIEFycmF5Lml0ZXIgKGZ1biBzIC0+IGZwcmludGYgb2MgXCIlcyVjXCIgcyBzZXApIGFyZ3M7XG4gIGNsb3NlX291dCBvY1xuXG5sZXQgd3JpdGVfYXJnID0gd3JpdGVfYXV4ICdcXG4nXG5cbmxldCB3cml0ZV9hcmcwID0gd3JpdGVfYXV4ICdcXHgwMCdcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBzdGF0ID0ge1xuICBtaW5vcl93b3JkcyA6IGZsb2F0O1xuICBwcm9tb3RlZF93b3JkcyA6IGZsb2F0O1xuICBtYWpvcl93b3JkcyA6IGZsb2F0O1xuICBtaW5vcl9jb2xsZWN0aW9ucyA6IGludDtcbiAgbWFqb3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIGhlYXBfd29yZHMgOiBpbnQ7XG4gIGhlYXBfY2h1bmtzIDogaW50O1xuICBsaXZlX3dvcmRzIDogaW50O1xuICBsaXZlX2Jsb2NrcyA6IGludDtcbiAgZnJlZV93b3JkcyA6IGludDtcbiAgZnJlZV9ibG9ja3MgOiBpbnQ7XG4gIGxhcmdlc3RfZnJlZSA6IGludDtcbiAgZnJhZ21lbnRzIDogaW50O1xuICBjb21wYWN0aW9ucyA6IGludDtcbiAgdG9wX2hlYXBfd29yZHMgOiBpbnQ7XG4gIHN0YWNrX3NpemUgOiBpbnQ7XG59XG5cbnR5cGUgY29udHJvbCA9IHtcbiAgbXV0YWJsZSBtaW5vcl9oZWFwX3NpemUgOiBpbnQ7XG4gIG11dGFibGUgbWFqb3JfaGVhcF9pbmNyZW1lbnQgOiBpbnQ7XG4gIG11dGFibGUgc3BhY2Vfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgdmVyYm9zZSA6IGludDtcbiAgbXV0YWJsZSBtYXhfb3ZlcmhlYWQgOiBpbnQ7XG4gIG11dGFibGUgc3RhY2tfbGltaXQgOiBpbnQ7XG4gIG11dGFibGUgYWxsb2NhdGlvbl9wb2xpY3kgOiBpbnQ7XG4gIHdpbmRvd19zaXplIDogaW50O1xufVxuXG5leHRlcm5hbCBzdGF0IDogdW5pdCAtPiBzdGF0ID0gXCJjYW1sX2djX3N0YXRcIlxuZXh0ZXJuYWwgcXVpY2tfc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19xdWlja19zdGF0XCJcbmV4dGVybmFsIGNvdW50ZXJzIDogdW5pdCAtPiAoZmxvYXQgKiBmbG9hdCAqIGZsb2F0KSA9IFwiY2FtbF9nY19jb3VudGVyc1wiXG5leHRlcm5hbCBtaW5vcl93b3JkcyA6IHVuaXQgLT4gKGZsb2F0IFtAdW5ib3hlZF0pXG4gID0gXCJjYW1sX2djX21pbm9yX3dvcmRzXCIgXCJjYW1sX2djX21pbm9yX3dvcmRzX3VuYm94ZWRcIlxuZXh0ZXJuYWwgZ2V0IDogdW5pdCAtPiBjb250cm9sID0gXCJjYW1sX2djX2dldFwiXG5leHRlcm5hbCBzZXQgOiBjb250cm9sIC0+IHVuaXQgPSBcImNhbWxfZ2Nfc2V0XCJcbmV4dGVybmFsIG1pbm9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX21pbm9yXCJcbmV4dGVybmFsIG1ham9yX3NsaWNlIDogaW50IC0+IGludCA9IFwiY2FtbF9nY19tYWpvcl9zbGljZVwiXG5leHRlcm5hbCBtYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19tYWpvclwiXG5leHRlcm5hbCBmdWxsX21ham9yIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2djX2Z1bGxfbWFqb3JcIlxuZXh0ZXJuYWwgY29tcGFjdCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19jb21wYWN0aW9uXCJcbmV4dGVybmFsIGdldF9taW5vcl9mcmVlIDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21pbm9yX2ZyZWVcIlxuZXh0ZXJuYWwgZ2V0X2J1Y2tldCA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2J1Y2tldFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBnZXRfY3JlZGl0IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2V0X21ham9yX2NyZWRpdFwiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBodWdlX2ZhbGxiYWNrX2NvdW50IDogdW5pdCAtPiBpbnQgPSBcImNhbWxfZ2NfaHVnZV9mYWxsYmFja19jb3VudFwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBzdHJpbmdfb2ZfaW50IHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gUGVydmFzaXZlcy5mbG9hdCAoYml0cyBzKVxuICAgIGFuZCByMiA9IFBlcnZhc2l2ZXMuZmxvYXQgKGJpdHMgcylcbiAgICBpbiAocjEgLy4gc2NhbGUgKy4gcjIpIC8uIHNjYWxlXG5cblxuICBsZXQgZmxvYXQgcyBib3VuZCA9IHJhd2Zsb2F0IHMgKi4gYm91bmRcblxuICBsZXQgYm9vbCBzID0gKGJpdHMgcyBsYW5kIDEgPSAwKVxuXG5lbmRcblxuKCogVGhpcyBpcyB0aGUgc3RhdGUgeW91IGdldCB3aXRoIFtpbml0IDI3MTgyODE4XSBhbmQgdGhlbiBhcHBseWluZ1xuICAgdGhlIFwibGFuZCAweDNGRkZGRkZGXCIgZmlsdGVyIHRvIHRoZW0uICBTZWUgIzU1NzUsICM1NzkzLCAjNTk3Ny4gKilcbmxldCBkZWZhdWx0ID0ge1xuICBTdGF0ZS5zdCA9IFt8XG4gICAgICAweDNhZTI1MjJiOyAweDFkOGQ0NjM0OyAweDE1YjRmYWQwOyAweDE4YjE0YWNlOyAweDEyZjhhM2M0OyAweDNiMDg2YzQ3O1xuICAgICAgMHgxNmQ0NjdkNjsgMHgxMDFkOTFjNzsgMHgzMjFkZjE3NzsgMHgwMTc2YzE5MzsgMHgxZmY3MmJmMTsgMHgxZTg4OTEwOTtcbiAgICAgIDB4MGI0NjRiMTg7IDB4MmI4NmI5N2M7IDB4MDg5MWRhNDg7IDB4MDMxMzc0NjM7IDB4MDg1YWM1YTE7IDB4MTVkNjFmMmY7XG4gICAgICAweDNiY2VkMzU5OyAweDI5YzFjMTMyOyAweDNhODY3NjZlOyAweDM2NmQ4Yzg2OyAweDFmNWI2MjIyOyAweDNjZTFiNTlmO1xuICAgICAgMHgyZWJmNzhlMTsgMHgyN2NkMWI4NjsgMHgyNThmM2RjMzsgMHgzODlhODE5NDsgMHgwMmU0YzQ0YzsgMHgxOGM0M2Y3ZDtcbiAgICAgIDB4MGY2ZTUzNGY7IDB4MWU3ZGYzNTk7IDB4MDU1ZDBiN2U7IDB4MTBlODRlN2U7IDB4MTI2MTk4ZTQ7IDB4MGU3NzIyY2I7XG4gICAgICAweDFjYmVkZTI4OyAweDMzOTFiOTY0OyAweDNkNDBlOTJhOyAweDBjNTk5MzNkOyAweDBiOGNkMGI3OyAweDI0ZWZmZjFjO1xuICAgICAgMHgyODAzZmRhYTsgMHgwOGViYzcyZTsgMHgwZjUyMmUzMjsgMHgwNTM5OGVkYzsgMHgyMTQ0YTA0YzsgMHgwYWVmM2NiZDtcbiAgICAgIDB4MDFhZDQ3MTk7IDB4MzViOTNjZDY7IDB4MmE1NTlkNGY7IDB4MWU2ZmQ3Njg7IDB4MjZlMjdmMzY7IDB4MTg2ZjE4YzM7XG4gICAgICAweDJmYmY5NjdhO1xuICAgIHxdO1xuICBTdGF0ZS5pZHggPSAwO1xufVxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgZGVmYXVsdFxubGV0IGludCBib3VuZCA9IFN0YXRlLmludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50MzIgYm91bmQgPSBTdGF0ZS5pbnQzMiBkZWZhdWx0IGJvdW5kXG5sZXQgbmF0aXZlaW50IGJvdW5kID0gU3RhdGUubmF0aXZlaW50IGRlZmF1bHQgYm91bmRcbmxldCBpbnQ2NCBib3VuZCA9IFN0YXRlLmludDY0IGRlZmF1bHQgYm91bmRcbmxldCBmbG9hdCBzY2FsZSA9IFN0YXRlLmZsb2F0IGRlZmF1bHQgc2NhbGVcbmxldCBib29sICgpID0gU3RhdGUuYm9vbCBkZWZhdWx0XG5cbmxldCBmdWxsX2luaXQgc2VlZCA9IFN0YXRlLmZ1bGxfaW5pdCBkZWZhdWx0IHNlZWRcbmxldCBpbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBbfCBzZWVkIHxdXG5sZXQgc2VsZl9pbml0ICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCgpKVxuXG4oKiBNYW5pcHVsYXRpbmcgdGhlIGN1cnJlbnQgc3RhdGUuICopXG5cbmxldCBnZXRfc3RhdGUgKCkgPSBTdGF0ZS5jb3B5IGRlZmF1bHRcbmxldCBzZXRfc3RhdGUgcyA9IFN0YXRlLmFzc2lnbiBkZWZhdWx0IHNcblxuKCoqKioqKioqKioqKioqKioqKioqXG5cbigqIFRlc3QgZnVuY3Rpb25zLiAgTm90IGluY2x1ZGVkIGluIHRoZSBsaWJyYXJ5LlxuICAgVGhlIFtjaGlzcXVhcmVdIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBuID4gMTByLlxuICAgSXQgcmV0dXJucyBhIHRyaXBsZSAobG93LCBhY3R1YWwsIGhpZ2gpLlxuICAgSWYgbG93IDw9IGFjdHVhbCA8PSBoaWdoLCB0aGUgW2ddIGZ1bmN0aW9uIHBhc3NlZCB0aGUgdGVzdCxcbiAgIG90aGVyd2lzZSBpdCBmYWlsZWQuXG5cbiAgU29tZSByZXN1bHRzOlxuXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDUwMDBcbmluaXQgMjcxODI4MTg7IGNoaXNxdWFyZSBpbnQgMTAwMDAwMCAxMDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCAxMDI0XG5pbml0IDI5OTc5MjY0MzsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAxNDE0MjEzNjsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMjQ7IGNoaXNxdWFyZSBkaWZmIDEwMDAwMCAxMDI0XG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYgMTAwOyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBpbml0X2RpZmYyIDEwMjQ7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDE0MTQyMTM2OyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbmluaXQgMjk5NzkyNjQzOyBpbml0X2RpZmYyIDEwMDsgY2hpc3F1YXJlIGRpZmYyIDEwMDAwMCAxMDBcbi0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTk3LjUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4OS43NDAwMDAwMDAwMDUyMzg3LCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDQ4NTguNTc4NjQzNzYyNjksIDUwNDUuNSwgNTE0MS40MjEzNTYyMzczMSlcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9XG4oOTM2Ljc1NDQ0Njc5NjYzMjQ2NSwgOTQ0LjgwNTk5OTk5OTk4MjMwNSwgMTA2My4yNDU1NTMyMDMzNjc1NClcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDE5LjE5NzQ0MDAwMDAwMzU1LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU5LjMxNzc2MDAwMDAwNTM2LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDM5Ljk4NDYzOTk5OTk5NTEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDU0LjM4MjA3OTk5OTk5NTc3LCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDkwLjA5NjAwMDAwMDAwNSwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg5NjAuLCAxMDc2Ljc4NzIwMDAwMDAwNjEyLCAxMDg4LilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDg1LjE3NjAwMDAwMDAwNjc1MjEsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4yMTYwMDAwMDAwMDAzNDkyLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODAuNjIyMDAwMDAwMDAzMDI2OCwgMTIwLilcblxuKilcblxuKCogUmV0dXJuIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdltpMCxpMVsgKilcbmxldCByZWMgc3Vtc3EgdiBpMCBpMSA9XG4gIGlmIGkwID49IGkxIHRoZW4gMC4wXG4gIGVsc2UgaWYgaTEgPSBpMCArIDEgdGhlbiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKSAqLiBQZXJ2YXNpdmVzLmZsb2F0IHYuKGkwKVxuICBlbHNlIHN1bXNxIHYgaTAgKChpMCtpMSkvMikgKy4gc3Vtc3EgdiAoKGkwK2kxKS8yKSBpMVxuXG5cbmxldCBjaGlzcXVhcmUgZyBuIHIgPVxuICBpZiBuIDw9IDEwICogciB0aGVuIGludmFsaWRfYXJnIFwiY2hpc3F1YXJlXCI7XG4gIGxldCBmID0gQXJyYXkubWFrZSByIDAgaW5cbiAgZm9yIGkgPSAxIHRvIG4gZG9cbiAgICBsZXQgdCA9IGcgciBpblxuICAgIGYuKHQpIDwtIGYuKHQpICsgMVxuICBkb25lO1xuICBsZXQgdCA9IHN1bXNxIGYgMCByXG4gIGFuZCByID0gUGVydmFzaXZlcy5mbG9hdCByXG4gIGFuZCBuID0gUGVydmFzaXZlcy5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG9sZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaF91bml2X3BhcmFtXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbigqIFdlIGRvIGR5bmFtaWMgaGFzaGluZywgYW5kIHJlc2l6ZSB0aGUgdGFibGUgYW5kIHJlaGFzaCB0aGUgZWxlbWVudHNcbiAgIHdoZW4gYnVja2V0cyBiZWNvbWUgdG9vIGxvbmcuICopXG5cbnR5cGUgKCdhLCAnYikgdCA9XG4gIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICBtdXRhYmxlIGRhdGE6ICgnYSwgJ2IpIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgc2VlZDogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIGZvciByYW5kb21pemF0aW9uICopXG4gICAgbXV0YWJsZSBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gIH1cblxuYW5kICgnYSwgJ2IpIGJ1Y2tldGxpc3QgPVxuICAgIEVtcHR5XG4gIHwgQ29ucyBvZiB7IG11dGFibGUga2V5OiAnYTtcbiAgICAgICAgICAgICAgbXV0YWJsZSBkYXRhOiAnYjtcbiAgICAgICAgICAgICAgbXV0YWJsZSBuZXh0OiAoJ2EsICdiKSBidWNrZXRsaXN0IH1cblxuKCogVGhlIHNpZ24gb2YgaW5pdGlhbF9zaXplIGVuY29kZXMgdGhlIGZhY3QgdGhhdCBhIHRyYXZlcnNhbCBpc1xuICAgb25nb2luZyBvciBub3QuXG5cbiAgIFRoaXMgZGlzYWJsZXMgdGhlIGVmZmljaWVudCBpbiBwbGFjZSBpbXBsZW1lbnRhdGlvbiBvZiByZXNpemluZy5cbiopXG5cbmxldCBvbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgT2JqLnNpemUgKE9iai5yZXByIGgpIDwgNCAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIHx8IGguaW5pdGlhbF9zaXplIDwgMFxuXG5sZXQgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoID1cbiAgaC5pbml0aWFsX3NpemUgPC0gLSBoLmluaXRpYWxfc2l6ZVxuXG4oKiBUbyBwaWNrIHJhbmRvbSBzZWVkcyBpZiByZXF1ZXN0ZWQgKilcblxubGV0IHJhbmRvbWl6ZWRfZGVmYXVsdCA9XG4gIGxldCBwYXJhbXMgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgdHJ5IFN5cy5nZXRlbnYgXCJDQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPiBcIlwiIGluXG4gIFN0cmluZy5jb250YWlucyBwYXJhbXMgJ1InXG5cbmxldCByYW5kb21pemVkID0gcmVmIHJhbmRvbWl6ZWRfZGVmYXVsdFxuXG5sZXQgcmFuZG9taXplICgpID0gcmFuZG9taXplZCA6PSB0cnVlXG5sZXQgaXNfcmFuZG9taXplZCAoKSA9ICFyYW5kb21pemVkXG5cbmxldCBwcm5nID0gbGF6eSAoUmFuZG9tLlN0YXRlLm1ha2Vfc2VsZl9pbml0KCkpXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGguc2l6ZSA8LSAwO1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgZG9uZVxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4gaCBrZXkgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBpbnBsYWNlIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgICAgZG9uZTtcbiAgZW5kXG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSAzXG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSAob2xkX2hhc2hfcGFyYW0gMTAgMTAwIGtleSkgbW9kIChBcnJheS5sZW5ndGggaC5kYXRhKVxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCogRnVuY3RvcmlhbCBpbnRlcmZhY2UgKilcblxubW9kdWxlIHR5cGUgSGFzaGVkVHlwZSA9XG4gIHNpZ1xuICAgIHR5cGUgdFxuICAgIHZhbCBlcXVhbDogdCAtPiB0IC0+IGJvb2xcbiAgICB2YWwgaGFzaDogdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IGludCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZTogaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weTogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCByZW1vdmU6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbDogJ2EgdCAtPiBrZXkgLT4gJ2EgbGlzdFxuICAgIHZhbCByZXBsYWNlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgLT4gdW5pdFxuICAgIHZhbCBtZW0gOiAnYSB0IC0+IGtleSAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgc3RhdHM6ICdhIHQgLT4gc3RhdGlzdGljc1xuICBlbmRcblxubW9kdWxlIHR5cGUgU2VlZGVkUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSAnYSB0XG4gICAgdmFsIGNyZWF0ZSA6ID9yYW5kb206Ym9vbCAtPiBpbnQgLT4gJ2EgdFxuICAgIHZhbCBjbGVhciA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCByZXNldCA6ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBjb3B5IDogJ2EgdCAtPiAnYSB0XG4gICAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gdW5pdFxuICAgIHZhbCBmaW5kIDogJ2EgdCAtPiBrZXkgLT4gJ2FcbiAgICB2YWwgZmluZF9vcHQ6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICAgIHZhbCBmaW5kX2FsbCA6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyIDogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZmlsdGVyX21hcF9pbnBsYWNlOiAoa2V5IC0+ICdhIC0+ICdhIG9wdGlvbikgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZvbGQgOiAoa2V5IC0+ICdhIC0+ICdiIC0+ICdiKSAtPiAnYSB0IC0+ICdiIC0+ICdiXG4gICAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgZW5kXG5cbm1vZHVsZSBNYWtlU2VlZGVkKEg6IFNlZWRlZEhhc2hlZFR5cGUpOiAoU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50KSA9XG4gIHN0cnVjdFxuICAgIHR5cGUga2V5ID0gSC50XG4gICAgdHlwZSAnYSBoYXNodGJsID0gKGtleSwgJ2EpIHRcbiAgICB0eXBlICdhIHQgPSAnYSBoYXNodGJsXG4gICAgbGV0IGNyZWF0ZSA9IGNyZWF0ZVxuICAgIGxldCBjbGVhciA9IGNsZWFyXG4gICAgbGV0IHJlc2V0ID0gcmVzZXRcbiAgICBsZXQgY29weSA9IGNvcHlcblxuICAgIGxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAgICAgKEguaGFzaCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBhZGQgaCBrZXkgZGF0YSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnN7a2V5OyBkYXRhOyBuZXh0PWguZGF0YS4oaSl9IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuXG4gICAgbGV0IHJlYyByZW1vdmVfYnVja2V0IGggaSBrZXkgcHJlYyA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgKClcbiAgICAgIHwgKENvbnMge2tleT1rOyBuZXh0fSkgYXMgYyAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICAgIG1hdGNoIHByZWMgd2l0aFxuICAgICAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBuZXh0XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlYyBrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBkYXRhIGVsc2UgZmluZF9yZWMga2V5IG5leHRcblxuICAgIGxldCBmaW5kIGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMSB0aGVuIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMiB0aGVuIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazMgdGhlbiBkMyBlbHNlIGZpbmRfcmVjIGtleSBuZXh0M1xuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgayB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBTb21lIGQxIGVsc2VcbiAgICAgICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBTb21lIGQyIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gU29tZSBkMyBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dDNcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBbXVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhPWQ7IG5leHR9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrIGtleVxuICAgICAgICAgIHRoZW4gZCA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICAgICAgZWxzZSBmaW5kX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIChzbG90LmtleSA8LSBrZXk7IHNsb3QuZGF0YSA8LSBkYXRhOyBmYWxzZSlcbiAgICAgICAgICBlbHNlIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIG5leHRcblxuICAgIGxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgICAgIGguZGF0YS4oaSkgPC0gQ29uc3trZXk7IGRhdGE7IG5leHQ9bH07XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gICAgICBlbmRcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgICAgIEguZXF1YWwgayBrZXkgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGgga2V5KVxuXG4gICAgbGV0IGl0ZXIgPSBpdGVyXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSA9IGZpbHRlcl9tYXBfaW5wbGFjZVxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgc3RhdHMgPSBzdGF0c1xuICBlbmRcblxubW9kdWxlIE1ha2UoSDogSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogV2VhayBhcnJheSBvcGVyYXRpb25zICopXG5cbnR5cGUgJ2EgdFxuXG5leHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gJ2EgdCA9IFwiY2FtbF93ZWFrX2NyZWF0ZVwiXG5cbigqKiBudW1iZXIgb2YgYWRkaXRpb25hbCB2YWx1ZXMgaW4gYSB3ZWFrIHBvaW50ZXIgKilcbmxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcblxubGV0IGxlbmd0aCB4ID0gT2JqLnNpemUoT2JqLnJlcHIgeCkgLSBhZGRpdGlvbmFsX3ZhbHVlc1xuXG5leHRlcm5hbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gLT4gdW5pdCA9IFwiY2FtbF93ZWFrX3NldFwiXG5leHRlcm5hbCBnZXQgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRcIlxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5leHRlcm5hbCBjaGVjayA6ICdhIHQgLT4gaW50IC0+IGJvb2wgPSBcImNhbWxfd2Vha19jaGVja1wiXG5leHRlcm5hbCBibGl0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfd2Vha19ibGl0XCJcbigqIGJsaXQ6IHNyYyBzcmNvZmYgZHN0IGRzdG9mZiBsZW4gKilcblxubGV0IGZpbGwgYXIgb2ZzIGxlbiB4ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhclxuICB0aGVuIHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiV2Vhay5maWxsXCIpXG4gIGVsc2UgYmVnaW5cbiAgICBmb3IgaSA9IG9mcyB0byAob2ZzICsgbGVuIC0gMSkgZG9cbiAgICAgIHNldCBhciBpIHhcbiAgICBkb25lXG4gIGVuZFxuXG5cbigqKiBXZWFrIGhhc2ggdGFibGVzICopXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSBkYXRhXG4gIHR5cGUgdFxuICB2YWwgY3JlYXRlIDogaW50IC0+IHRcbiAgdmFsIGNsZWFyIDogdCAtPiB1bml0XG4gIHZhbCBtZXJnZSA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBhZGQgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgcmVtb3ZlIDogdCAtPiBkYXRhIC0+IHVuaXRcbiAgdmFsIGZpbmQgOiB0IC0+IGRhdGEgLT4gZGF0YVxuICB2YWwgZmluZF9vcHQgOiB0IC0+IGRhdGEgLT4gZGF0YSBvcHRpb25cbiAgdmFsIGZpbmRfYWxsIDogdCAtPiBkYXRhIC0+IGRhdGEgbGlzdFxuICB2YWwgbWVtIDogdCAtPiBkYXRhIC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAoZGF0YSAtPiB1bml0KSAtPiB0IC0+IHVuaXRcbiAgdmFsIGZvbGQgOiAoZGF0YSAtPiAnYSAtPiAnYSkgLT4gdCAtPiAnYSAtPiAnYVxuICB2YWwgY291bnQgOiB0IC0+IGludFxuICB2YWwgc3RhdHMgOiB0IC0+IGludCAqIGludCAqIGludCAqIGludCAqIGludCAqIGludFxuZW5kXG5cbm1vZHVsZSBNYWtlIChIIDogSGFzaHRibC5IYXNoZWRUeXBlKSA6IChTIHdpdGggdHlwZSBkYXRhID0gSC50KSA9IHN0cnVjdFxuXG4gIHR5cGUgJ2Egd2Vha190ID0gJ2EgdFxuICBsZXQgd2Vha19jcmVhdGUgPSBjcmVhdGVcbiAgbGV0IGVtcHR5YnVja2V0ID0gd2Vha19jcmVhdGUgMFxuXG4gIHR5cGUgZGF0YSA9IEgudFxuXG4gIHR5cGUgdCA9IHtcbiAgICBtdXRhYmxlIHRhYmxlIDogZGF0YSB3ZWFrX3QgYXJyYXk7XG4gICAgbXV0YWJsZSBoYXNoZXMgOiBpbnQgYXJyYXkgYXJyYXk7XG4gICAgbXV0YWJsZSBsaW1pdCA6IGludDsgICAgICAgICAgICAgICAoKiBidWNrZXQgc2l6ZSBsaW1pdCAqKVxuICAgIG11dGFibGUgb3ZlcnNpemUgOiBpbnQ7ICAgICAgICAgICAgKCogbnVtYmVyIG9mIG92ZXJzaXplIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHJvdmVyIDogaW50OyAgICAgICAgICAgICAgICgqIGZvciBpbnRlcm5hbCBib29ra2VlcGluZyAqKVxuICB9XG5cbiAgbGV0IGdldF9pbmRleCB0IGggPSAoaCBsYW5kIG1heF9pbnQpIG1vZCAoQXJyYXkubGVuZ3RoIHQudGFibGUpXG5cbiAgbGV0IGxpbWl0ID0gN1xuICBsZXQgb3Zlcl9saW1pdCA9IDJcblxuICBsZXQgY3JlYXRlIHN6ID1cbiAgICBsZXQgc3ogPSBpZiBzeiA8IDcgdGhlbiA3IGVsc2Ugc3ogaW5cbiAgICBsZXQgc3ogPSBpZiBzeiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gU3lzLm1heF9hcnJheV9sZW5ndGggZWxzZSBzeiBpblxuICAgIHtcbiAgICAgIHRhYmxlID0gQXJyYXkubWFrZSBzeiBlbXB0eWJ1Y2tldDtcbiAgICAgIGhhc2hlcyA9IEFycmF5Lm1ha2Ugc3ogW3wgfF07XG4gICAgICBsaW1pdCA9IGxpbWl0O1xuICAgICAgb3ZlcnNpemUgPSAwO1xuICAgICAgcm92ZXIgPSAwO1xuICAgIH1cblxuICBsZXQgY2xlYXIgdCA9XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgICAgdC50YWJsZS4oaSkgPC0gZW1wdHlidWNrZXQ7XG4gICAgICB0Lmhhc2hlcy4oaSkgPC0gW3wgfF07XG4gICAgZG9uZTtcbiAgICB0LmxpbWl0IDwtIGxpbWl0O1xuICAgIHQub3ZlcnNpemUgPC0gMFxuXG5cbiAgbGV0IGZvbGQgZiB0IGluaXQgPVxuICAgIGxldCByZWMgZm9sZF9idWNrZXQgaSBiIGFjY3UgPVxuICAgICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIChmIHYgYWNjdSlcbiAgICAgIHwgTm9uZSAtPiBmb2xkX2J1Y2tldCAoaSsxKSBiIGFjY3VcbiAgICBpblxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGZvbGRfYnVja2V0IDApIHQudGFibGUgaW5pdFxuXG5cbiAgbGV0IGl0ZXIgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggZ2V0IGIgaSB3aXRoXG4gICAgICB8IFNvbWUgdiAtPiBmIHY7IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICAgIHwgTm9uZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBiXG4gICAgaW5cbiAgICBBcnJheS5pdGVyIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgaXRlcl93ZWFrIGYgdCA9XG4gICAgbGV0IHJlYyBpdGVyX2J1Y2tldCBpIGogYiA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gKCkgZWxzZVxuICAgICAgbWF0Y2ggY2hlY2sgYiBpIHdpdGhcbiAgICAgIHwgdHJ1ZSAtPiBmIGIgdC5oYXNoZXMuKGopIGk7IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgICAgfCBmYWxzZSAtPiBpdGVyX2J1Y2tldCAoaSsxKSBqIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXJpIChpdGVyX2J1Y2tldCAwKSB0LnRhYmxlXG5cblxuICBsZXQgcmVjIGNvdW50X2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgaWYgaSA+PSBsZW5ndGggYiB0aGVuIGFjY3UgZWxzZVxuICAgIGNvdW50X2J1Y2tldCAoaSsxKSBiIChhY2N1ICsgKGlmIGNoZWNrIGIgaSB0aGVuIDEgZWxzZSAwKSlcblxuXG4gIGxldCBjb3VudCB0ID1cbiAgICBBcnJheS5mb2xkX3JpZ2h0IChjb3VudF9idWNrZXQgMCkgdC50YWJsZSAwXG5cblxuICBsZXQgbmV4dF9zeiBuID0gbWluICgzICogbiAvIDIgKyAzKSBTeXMubWF4X2FycmF5X2xlbmd0aFxuICBsZXQgcHJldl9zeiBuID0gKChuIC0gMykgKiAyICsgMikgLyAzXG5cbiAgbGV0IHRlc3Rfc2hyaW5rX2J1Y2tldCB0ID1cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4odC5yb3ZlcikgaW5cbiAgICBsZXQgaGJ1Y2tldCA9IHQuaGFzaGVzLih0LnJvdmVyKSBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHByZXZfbGVuID0gcHJldl9zeiBsZW4gaW5cbiAgICBsZXQgbGl2ZSA9IGNvdW50X2J1Y2tldCAwIGJ1Y2tldCAwIGluXG4gICAgaWYgbGl2ZSA8PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgcmVjIGxvb3AgaSBqID1cbiAgICAgICAgaWYgaiA+PSBwcmV2X2xlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgY2hlY2sgYnVja2V0IGkgdGhlbiBsb29wIChpICsgMSkgalxuICAgICAgICAgIGVsc2UgaWYgY2hlY2sgYnVja2V0IGogdGhlbiBiZWdpblxuICAgICAgICAgICAgYmxpdCBidWNrZXQgaiBidWNrZXQgaSAxO1xuICAgICAgICAgICAgaGJ1Y2tldC4oaSkgPC0gaGJ1Y2tldC4oaik7XG4gICAgICAgICAgICBsb29wIChpICsgMSkgKGogLSAxKTtcbiAgICAgICAgICBlbmQgZWxzZSBsb29wIGkgKGogLSAxKTtcbiAgICAgICAgZW5kO1xuICAgICAgaW5cbiAgICAgIGxvb3AgMCAobGVuZ3RoIGJ1Y2tldCAtIDEpO1xuICAgICAgaWYgcHJldl9sZW4gPSAwIHRoZW4gYmVnaW5cbiAgICAgICAgdC50YWJsZS4odC5yb3ZlcikgPC0gZW1wdHlidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLih0LnJvdmVyKSA8LSBbfCB8XTtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgYnVja2V0KSAocHJldl9sZW4gKyBhZGRpdGlvbmFsX3ZhbHVlcyk7XG4gICAgICAgIE9iai50cnVuY2F0ZSAoT2JqLnJlcHIgaGJ1Y2tldCkgcHJldl9sZW47XG4gICAgICBlbmQ7XG4gICAgICBpZiBsZW4gPiB0LmxpbWl0ICYmIHByZXZfbGVuIDw9IHQubGltaXQgdGhlbiB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgLSAxO1xuICAgIGVuZDtcbiAgICB0LnJvdmVyIDwtICh0LnJvdmVyICsgMSkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuXG4gIGxldCByZWMgcmVzaXplIHQgPVxuICAgIGxldCBvbGRsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICAgIGxldCBuZXdsZW4gPSBuZXh0X3N6IG9sZGxlbiBpblxuICAgIGlmIG5ld2xlbiA+IG9sZGxlbiB0aGVuIGJlZ2luXG4gICAgICBsZXQgbmV3dCA9IGNyZWF0ZSBuZXdsZW4gaW5cbiAgICAgIGxldCBhZGRfd2VhayBvYiBvaCBvaSA9XG4gICAgICAgIGxldCBzZXR0ZXIgbmIgbmkgXyA9IGJsaXQgb2Igb2kgbmIgbmkgMSBpblxuICAgICAgICBsZXQgaCA9IG9oLihvaSkgaW5cbiAgICAgICAgYWRkX2F1eCBuZXd0IHNldHRlciBOb25lIGggKGdldF9pbmRleCBuZXd0IGgpO1xuICAgICAgaW5cbiAgICAgIGl0ZXJfd2VhayBhZGRfd2VhayB0O1xuICAgICAgdC50YWJsZSA8LSBuZXd0LnRhYmxlO1xuICAgICAgdC5oYXNoZXMgPC0gbmV3dC5oYXNoZXM7XG4gICAgICB0LmxpbWl0IDwtIG5ld3QubGltaXQ7XG4gICAgICB0Lm92ZXJzaXplIDwtIG5ld3Qub3ZlcnNpemU7XG4gICAgICB0LnJvdmVyIDwtIHQucm92ZXIgbW9kIEFycmF5Lmxlbmd0aCBuZXd0LnRhYmxlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB0LmxpbWl0IDwtIG1heF9pbnQ7ICAgICAgICAgICAgICgqIG1heGltdW0gc2l6ZSBhbHJlYWR5IHJlYWNoZWQgKilcbiAgICAgIHQub3ZlcnNpemUgPC0gMDtcbiAgICBlbmRcblxuICBhbmQgYWRkX2F1eCB0IHNldHRlciBkIGggaW5kZXggPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5ld3N6ID1cbiAgICAgICAgICBtaW4gKDMgKiBzeiAvIDIgKyAzKSAoU3lzLm1heF9hcnJheV9sZW5ndGggLSBhZGRpdGlvbmFsX3ZhbHVlcylcbiAgICAgICAgaW5cbiAgICAgICAgaWYgbmV3c3ogPD0gc3ogdGhlbiBmYWlsd2l0aCBcIldlYWsuTWFrZTogaGFzaCBidWNrZXQgY2Fubm90IGdyb3cgbW9yZVwiO1xuICAgICAgICBsZXQgbmV3YnVja2V0ID0gd2Vha19jcmVhdGUgbmV3c3ogaW5cbiAgICAgICAgbGV0IG5ld2hhc2hlcyA9IEFycmF5Lm1ha2UgbmV3c3ogMCBpblxuICAgICAgICBibGl0IGJ1Y2tldCAwIG5ld2J1Y2tldCAwIHN6O1xuICAgICAgICBBcnJheS5ibGl0IGhhc2hlcyAwIG5ld2hhc2hlcyAwIHN6O1xuICAgICAgICBzZXR0ZXIgbmV3YnVja2V0IHN6IGQ7XG4gICAgICAgIG5ld2hhc2hlcy4oc3opIDwtIGg7XG4gICAgICAgIHQudGFibGUuKGluZGV4KSA8LSBuZXdidWNrZXQ7XG4gICAgICAgIHQuaGFzaGVzLihpbmRleCkgPC0gbmV3aGFzaGVzO1xuICAgICAgICBpZiBzeiA8PSB0LmxpbWl0ICYmIG5ld3N6ID4gdC5saW1pdCB0aGVuIGJlZ2luXG4gICAgICAgICAgdC5vdmVyc2l6ZSA8LSB0Lm92ZXJzaXplICsgMTtcbiAgICAgICAgICBmb3IgX2kgPSAwIHRvIG92ZXJfbGltaXQgZG8gdGVzdF9zaHJpbmtfYnVja2V0IHQgZG9uZTtcbiAgICAgICAgZW5kO1xuICAgICAgICBpZiB0Lm92ZXJzaXplID4gQXJyYXkubGVuZ3RoIHQudGFibGUgLyBvdmVyX2xpbWl0IHRoZW4gcmVzaXplIHQ7XG4gICAgICBlbmQgZWxzZSBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGJlZ2luXG4gICAgICAgIGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0dGVyIGJ1Y2tldCBpIGQ7XG4gICAgICAgIGhhc2hlcy4oaSkgPC0gaDtcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGFkZCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggKGdldF9pbmRleCB0IGgpXG5cblxuICBsZXQgZmluZF9vciB0IGQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmQgaCBpbmRleFxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgbWVyZ2UgdCBkID1cbiAgICBmaW5kX29yIHQgZCAoZnVuIGggaW5kZXggLT4gYWRkX2F1eCB0IHNldCAoU29tZSBkKSBoIGluZGV4OyBkKVxuXG5cbiAgbGV0IGZpbmQgdCBkID0gZmluZF9vciB0IGQgKGZ1biBfaCBfaW5kZXggLT4gcmFpc2UgTm90X2ZvdW5kKVxuXG4gIGxldCBmaW5kX29wdCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBOb25lXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSBfIGFzIHYgLT4gdlxuICAgICAgICAgICAgICB8IE5vbmUgLT4gbG9vcCAoaSArIDEpXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IGZpbmRfc2hhZG93IHQgZCBpZmZvdW5kIGlmbm90Zm91bmQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBpZm5vdGZvdW5kXG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkIC0+IGlmZm91bmQgYnVja2V0IGlcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCByZW1vdmUgdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gdyBpIC0+IHNldCB3IGkgTm9uZSkgKClcblxuXG4gIGxldCBtZW0gdCBkID0gZmluZF9zaGFkb3cgdCBkIChmdW4gX3cgX2kgLT4gdHJ1ZSkgZmFsc2VcblxuXG4gIGxldCBmaW5kX2FsbCB0IGQgPVxuICAgIGxldCBoID0gSC5oYXNoIGQgaW5cbiAgICBsZXQgaW5kZXggPSBnZXRfaW5kZXggdCBoIGluXG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpIGFjY3UgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGFjY3VcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gbG9vcCAoaSArIDEpICh2IDo6IGFjY3UpXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgYWNjdVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSkgYWNjdVxuICAgIGluXG4gICAgbG9vcCAwIFtdXG5cblxuICBsZXQgc3RhdHMgdCA9XG4gICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGxlbnMgPSBBcnJheS5tYXAgbGVuZ3RoIHQudGFibGUgaW5cbiAgICBBcnJheS5zb3J0IGNvbXBhcmUgbGVucztcbiAgICBsZXQgdG90bGVuID0gQXJyYXkuZm9sZF9sZWZ0ICggKyApIDAgbGVucyBpblxuICAgIChsZW4sIGNvdW50IHQsIHRvdGxlbiwgbGVucy4oMCksIGxlbnMuKGxlbi8yKSwgbGVucy4obGVuLTEpKVxuXG5cbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBBIHByZXR0eS1wcmludGluZyBmYWNpbGl0eSBhbmQgZGVmaW5pdGlvbiBvZiBmb3JtYXR0ZXJzIGZvciAncGFyYWxsZWwnXG4gICAoaS5lLiB1bnJlbGF0ZWQgb3IgaW5kZXBlbmRlbnQpIHByZXR0eS1wcmludGluZyBvbiBtdWx0aXBsZSBvdXQgY2hhbm5lbHMuICopXG5cbigqXG4gICBUaGUgcHJldHR5LXByaW50aW5nIGVuZ2luZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4qKVxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxudHlwZSBzaXplXG5cbmV4dGVybmFsIHNpemVfb2ZfaW50IDogaW50IC0+IHNpemUgPSBcIiVpZGVudGl0eVwiXG5cbmV4dGVybmFsIGludF9vZl9zaXplIDogc2l6ZSAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cblxuKCogVGhlIHByZXR0eS1wcmludGluZyBib3hlcyBkZWZpbml0aW9uOlxuICAgYSBwcmV0dHktcHJpbnRpbmcgYm94IGlzIGVpdGhlclxuICAgLSBoYm94OiBob3Jpem9udGFsIGJveCAobm8gbGluZSBzcGxpdHRpbmcpXG4gICAtIHZib3g6IHZlcnRpY2FsIGJveCAoZXZlcnkgYnJlYWsgaGludCBzcGxpdHMgdGhlIGxpbmUpXG4gICAtIGh2Ym94OiBob3Jpem9udGFsL3ZlcnRpY2FsIGJveFxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgYm94IGlmIGl0IGZpdHMgb25cbiAgICAgIHRoZSBjdXJyZW50IGxpbmUsIG90aGVyd2lzZSB0aGUgYm94IGJlaGF2ZXMgYXMgYSB2ZXJ0aWNhbCBib3gpXG4gICAtIGhvdmJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveFxuICAgICAodGhlIGJveCBpcyBjb21wYWN0aW5nIG1hdGVyaWFsLCBwcmludGluZyBhcyBtdWNoIG1hdGVyaWFsIGFzIHBvc3NpYmxlXG4gICAgICBvbiBldmVyeSBsaW5lcylcbiAgIC0gYm94OiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGNvbXBhY3RpbmcgYm94IHdpdGggZW5oYW5jZWQgYm94IHN0cnVjdHVyZVxuICAgICAodGhlIGJveCBiZWhhdmVzIGFzIGFuIGhvcml6b250YWwgb3IgdmVydGljYWwgYm94IGJ1dCBicmVhayBoaW50cyBzcGxpdFxuICAgICAgdGhlIGxpbmUgaWYgc3BsaXR0aW5nIHdvdWxkIG1vdmUgdG8gdGhlIGxlZnQpXG4qKVxudHlwZSBib3hfdHlwZSA9IENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5ibG9ja190eXBlID1cbiAgfCBQcF9oYm94IHwgUHBfdmJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0c1xuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgdG9rZW5zIGRlZmluaXRpb246XG4gICBhcmUgZWl0aGVyIHRleHQgdG8gcHJpbnQgb3IgcHJldHR5IHByaW50aW5nXG4gICBlbGVtZW50cyB0aGF0IGRyaXZlIGluZGVudGF0aW9uIGFuZCBsaW5lIHNwbGl0dGluZy4gKilcbnR5cGUgcHBfdG9rZW4gPVxuICB8IFBwX3RleHQgb2Ygc3RyaW5nICAgICAgICAgICgqIG5vcm1hbCB0ZXh0ICopXG4gIHwgUHBfYnJlYWsgb2YgaW50ICogaW50ICAgICAgKCogY29tcGxldGUgYnJlYWsgKilcbiAgfCBQcF90YnJlYWsgb2YgaW50ICogaW50ICAgICAoKiBnbyB0byBuZXh0IHRhYnVsYXRpb24gKilcbiAgfCBQcF9zdGFiICAgICAgICAgICAgICAgICAgICAoKiBzZXQgYSB0YWJ1bGF0aW9uICopXG4gIHwgUHBfYmVnaW4gb2YgaW50ICogYm94X3R5cGUgKCogYmVnaW5uaW5nIG9mIGEgYm94ICopXG4gIHwgUHBfZW5kICAgICAgICAgICAgICAgICAgICAgKCogZW5kIG9mIGEgYm94ICopXG4gIHwgUHBfdGJlZ2luIG9mIHRib3ggICAgICAgICAgKCogYmVnaW5uaW5nIG9mIGEgdGFidWxhdGlvbiBib3ggKilcbiAgfCBQcF90ZW5kICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX25ld2xpbmUgICAgICAgICAgICAgICAgICgqIHRvIGZvcmNlIGEgbmV3bGluZSBpbnNpZGUgYSBib3ggKilcbiAgfCBQcF9pZl9uZXdsaW5lICAgICAgICAgICAgICAoKiB0byBkbyBzb21ldGhpbmcgb25seSBpZiB0aGlzIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lIGhhcyBiZWVuIGJyb2tlbiAqKVxuICB8IFBwX29wZW5fdGFnIG9mIHRhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHRhZyA9IHN0cmluZ1xuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRvIGRlZmluZSB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsIHdlIGZpcnN0IGRlZmluZSBwb2x5bW9ycGhpYyBxdWV1ZXMsXG4gICB0aGVuIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLlxuKilcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOiBwb2x5bW9ycGhpYyBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSAnYSBxdWV1ZV9lbGVtID1cbiAgfCBOaWxcbiAgfCBDb25zIG9mIHtcbiAgICAgIGhlYWQgOiAnYTtcbiAgICAgIG11dGFibGUgdGFpbCA6ICdhIHF1ZXVlX2VsZW07XG4gICAgfVxuXG5cbnR5cGUgJ2EgcXVldWUgPSB7XG4gIG11dGFibGUgaW5zZXJ0IDogJ2EgcXVldWVfZWxlbTtcbiAgbXV0YWJsZSBib2R5IDogJ2EgcXVldWVfZWxlbTtcbn1cblxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgcXVldWU6IHF1ZXVlIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgZWxlbV9zaXplIDogc2l6ZTtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gcXVldWVcblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2s6IHNjYW5uaW5nIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZWxlbWVudCBpcyAobGVmdF90b3RhbCwgcXVldWUgZWxlbWVudCkgd2hlcmUgbGVmdF90b3RhbFxuICAgaXMgdGhlIHZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiBlbnF1ZXVlZC4gKilcbnR5cGUgcHBfc2Nhbl9lbGVtID0gU2Nhbl9lbGVtIG9mIGludCAqIHBwX3F1ZXVlX2VsZW1cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHNjYW5uaW5nIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3NjYW5fc3RhY2sgPSBwcF9zY2FuX2VsZW0gbGlzdFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazpcbiAgIHRoZSBmb3JtYXR0aW5nIHN0YWNrIGNvbnRhaW5zIHRoZSBkZXNjcmlwdGlvbiBvZiBhbGwgdGhlIGN1cnJlbnRseSBhY3RpdmVcbiAgIGJveGVzOyB0aGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBpcyB1c2VkIHRvIHNwbGl0IHRoZSBsaW5lc1xuICAgd2hpbGUgcHJpbnRpbmcgdG9rZW5zLiAqKVxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjazogZm9ybWF0dGluZyBzdGFjayBlbGVtZW50IGRlZmluaXRpb24uXG4gICBFYWNoIHN0YWNrIGVsZW1lbnQgZGVzY3JpYmVzIGEgcHJldHR5LXByaW50aW5nIGJveC4gKilcbnR5cGUgcHBfZm9ybWF0X2VsZW0gPSBGb3JtYXRfZWxlbSBvZiBib3hfdHlwZSAqIGludFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjayBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9mb3JtYXRfc3RhY2sgPSBwcF9mb3JtYXRfZWxlbSBsaXN0XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzZW1hbnRpY3MgdGFnIHN0YWNrIGRlZmluaXRpb24uICopXG50eXBlIHBwX3RhZ19zdGFjayA9IHRhZyBsaXN0XG5cbigqIFRoZSBmb3JtYXR0ZXIgZGVmaW5pdGlvbi5cbiAgIEVhY2ggZm9ybWF0dGVyIHZhbHVlIGlzIGEgcHJldHR5LXByaW50ZXIgaW5zdGFuY2Ugd2l0aCBhbGwgaXRzXG4gICBtYWNoaW5lcnkuICopXG50eXBlIGZvcm1hdHRlciA9IHtcbiAgKCogVGhlIHZhcmlvdXMgc3RhY2tzLiAqKVxuICBtdXRhYmxlIHBwX3NjYW5fc3RhY2sgOiBwcF9zY2FuX3N0YWNrO1xuICBtdXRhYmxlIHBwX2Zvcm1hdF9zdGFjayA6IHBwX2Zvcm1hdF9zdGFjaztcbiAgbXV0YWJsZSBwcF90Ym94X3N0YWNrIDogdGJveCBsaXN0O1xuICBtdXRhYmxlIHBwX3RhZ19zdGFjayA6IHBwX3RhZ19zdGFjaztcbiAgbXV0YWJsZSBwcF9tYXJrX3N0YWNrIDogcHBfdGFnX3N0YWNrO1xuICAoKiBWYWx1ZSBvZiByaWdodCBtYXJnaW4uICopXG4gIG11dGFibGUgcHBfbWFyZ2luIDogaW50O1xuICAoKiBNaW5pbWFsIHNwYWNlIGxlZnQgYmVmb3JlIG1hcmdpbiwgd2hlbiBvcGVuaW5nIGEgYm94LiAqKVxuICBtdXRhYmxlIHBwX21pbl9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBNYXhpbXVtIHZhbHVlIG9mIGluZGVudGF0aW9uOlxuICAgICBubyBib3ggY2FuIGJlIG9wZW5lZCBmdXJ0aGVyLiAqKVxuICBtdXRhYmxlIHBwX21heF9pbmRlbnQgOiBpbnQ7XG4gICgqIFNwYWNlIHJlbWFpbmluZyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxuICBtdXRhYmxlIHBwX3NwYWNlX2xlZnQgOiBpbnQ7XG4gICgqIEN1cnJlbnQgdmFsdWUgb2YgaW5kZW50YXRpb24uICopXG4gIG11dGFibGUgcHBfY3VycmVudF9pbmRlbnQgOiBpbnQ7XG4gICgqIFRydWUgd2hlbiB0aGUgbGluZSBoYXMgYmVlbiBicm9rZW4gYnkgdGhlIHByZXR0eS1wcmludGVyLiAqKVxuICBtdXRhYmxlIHBwX2lzX25ld19saW5lIDogYm9vbDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGFscmVhZHkgcHJpbnRlZC4gKilcbiAgbXV0YWJsZSBwcF9sZWZ0X3RvdGFsIDogaW50O1xuICAoKiBUb3RhbCB3aWR0aCBvZiB0b2tlbnMgZXZlciBwdXQgaW4gcXVldWUuICopXG4gIG11dGFibGUgcHBfcmlnaHRfdG90YWwgOiBpbnQ7XG4gICgqIEN1cnJlbnQgbnVtYmVyIG9mIG9wZW4gYm94ZXMuICopXG4gIG11dGFibGUgcHBfY3Vycl9kZXB0aCA6IGludDtcbiAgKCogTWF4aW11bSBudW1iZXIgb2YgYm94ZXMgd2hpY2ggY2FuIGJlIHNpbXVsdGFuZW91c2x5IG9wZW4uICopXG4gIG11dGFibGUgcHBfbWF4X2JveGVzIDogaW50O1xuICAoKiBFbGxpcHNpcyBzdHJpbmcuICopXG4gIG11dGFibGUgcHBfZWxsaXBzaXMgOiBzdHJpbmc7XG4gICgqIE91dHB1dCBmdW5jdGlvbi4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3RyaW5nIDogc3RyaW5nIC0+IGludCAtPiBpbnQgLT4gdW5pdDtcbiAgKCogRmx1c2hpbmcgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X2ZsdXNoIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgbmV3IGxpbmVzLiAqKVxuICBtdXRhYmxlIHBwX291dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICAoKiBPdXRwdXQgb2YgYnJlYWsgaGludHMgc3BhY2VzLiAqKVxuICBtdXRhYmxlIHBwX291dF9zcGFjZXMgOiBpbnQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGluZGVudGF0aW9uIG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfaW5kZW50IDogaW50IC0+IHVuaXQ7XG4gICgqIEFyZSB0YWdzIHByaW50ZWQgPyAqKVxuICBtdXRhYmxlIHBwX3ByaW50X3RhZ3MgOiBib29sO1xuICAoKiBBcmUgdGFncyBtYXJrZWQgPyAqKVxuICBtdXRhYmxlIHBwX21hcmtfdGFncyA6IGJvb2w7XG4gICgqIEZpbmQgb3BlbmluZyBhbmQgY2xvc2luZyBtYXJrZXJzIG9mIHRhZ3MuICopXG4gIG11dGFibGUgcHBfbWFya19vcGVuX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIG11dGFibGUgcHBfbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIG11dGFibGUgcHBfcHJpbnRfY2xvc2VfdGFnIDogdGFnIC0+IHVuaXQ7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgPSB7XG4gIG1hcmtfb3Blbl90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3RhZyA6IHRhZyAtPiBzdHJpbmc7XG4gIHByaW50X29wZW5fdGFnIDogdGFnIC0+IHVuaXQ7XG4gIHByaW50X2Nsb3NlX3RhZyA6IHRhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIFF1ZXVlcyBhdXhpbGlhcmllcy4gKilcblxubGV0IG1ha2VfcXVldWUgKCkgPSB7IGluc2VydCA9IE5pbDsgYm9keSA9IE5pbDsgfVxuXG5sZXQgY2xlYXJfcXVldWUgcSA9IHEuaW5zZXJ0IDwtIE5pbDsgcS5ib2R5IDwtIE5pbFxuXG5sZXQgYWRkX3F1ZXVlIHggcSA9XG4gIGxldCBjID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gTmlsOyB9IGluXG4gIG1hdGNoIHEgd2l0aFxuICB8IHsgaW5zZXJ0ID0gQ29ucyBjZWxsOyBib2R5ID0gXzsgfSAtPlxuICAgIHEuaW5zZXJ0IDwtIGM7IGNlbGwudGFpbCA8LSBjXG4gICgqIEludmFyaWFudDogd2hlbiBpbnNlcnQgaXMgTmlsIGJvZHkgc2hvdWxkIGJlIE5pbC4gKilcbiAgfCB7IGluc2VydCA9IE5pbDsgYm9keSA9IF87IH0gLT5cbiAgICBxLmluc2VydCA8LSBjOyBxLmJvZHkgPC0gY1xuXG5cbmV4Y2VwdGlvbiBFbXB0eV9xdWV1ZVxuXG5sZXQgcGVla19xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gXzsgfTsgXyB9IC0+IHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG5sZXQgdGFrZV9xdWV1ZSA9IGZ1bmN0aW9uXG4gIHwgeyBib2R5ID0gQ29ucyB7IGhlYWQgPSB4OyB0YWlsID0gdGw7IH07IF8gfSBhcyBxIC0+XG4gICAgcS5ib2R5IDwtIHRsO1xuICAgIGlmIHRsID0gTmlsIHRoZW4gcS5pbnNlcnQgPC0gTmlsOyAoKiBNYWludGFpbiB0aGUgaW52YXJpYW50LiAqKVxuICAgIHhcbiAgfCB7IGJvZHkgPSBOaWw7IGluc2VydCA9IF87IH0gLT4gcmFpc2UgRW1wdHlfcXVldWVcblxuXG4oKiBFbnRlciBhIHRva2VuIGluIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9lbnF1ZXVlIHN0YXRlICh7IGxlbmd0aCA9IGxlbjsgX30gYXMgdG9rZW4pID1cbiAgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gc3RhdGUucHBfcmlnaHRfdG90YWwgKyBsZW47XG4gIGFkZF9xdWV1ZSB0b2tlbiBzdGF0ZS5wcF9xdWV1ZVxuXG5cbmxldCBwcF9jbGVhcl9xdWV1ZSBzdGF0ZSA9XG4gIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gMTsgc3RhdGUucHBfcmlnaHRfdG90YWwgPC0gMTtcbiAgY2xlYXJfcXVldWUgc3RhdGUucHBfcXVldWVcblxuXG4oKiBQcF9pbmZpbml0eTogbGFyZ2UgdmFsdWUgZm9yIGRlZmF1bHQgdG9rZW5zIHNpemUuXG5cbiAgIFBwX2luZmluaXR5IGlzIGRvY3VtZW50ZWQgYXMgYmVpbmcgZ3JlYXRlciB0aGFuIDFlMTA7IHRvIGF2b2lkXG4gICBjb25mdXNpb24gYWJvdXQgdGhlIHdvcmQgJ2dyZWF0ZXInLCB3ZSBjaG9vc2UgcHBfaW5maW5pdHkgZ3JlYXRlclxuICAgdGhhbiAxZTEwICsgMTsgZm9yIGNvcnJlY3QgaGFuZGxpbmcgb2YgdGVzdHMgaW4gdGhlIGFsZ29yaXRobSxcbiAgIHBwX2luZmluaXR5IG11c3QgYmUgZXZlbiBvbmUgbW9yZSB0aGFuIDFlMTAgKyAxOyBsZXQncyBzdGFuZCBvbiB0aGVcbiAgIHNhZmUgc2lkZSBieSBjaG9vc2luZyAxLmUxMCsxMC5cblxuICAgUHBfaW5maW5pdHkgY291bGQgcHJvYmFibHkgYmUgMTA3Mzc0MTgyMyB0aGF0IGlzIDJeMzAgLSAxLCB0aGF0IGlzXG4gICB0aGUgbWluaW1hbCB1cHBlciBib3VuZCBmb3IgaW50ZWdlcnM7IG5vdyB0aGF0IG1heF9pbnQgaXMgZGVmaW5lZCxcbiAgIHRoaXMgbGltaXQgY291bGQgYWxzbyBiZSBkZWZpbmVkIGFzIG1heF9pbnQgLSAxLlxuXG4gICBIb3dldmVyLCBiZWZvcmUgc2V0dGluZyBwcF9pbmZpbml0eSB0byBzb21ldGhpbmcgYXJvdW5kIG1heF9pbnQsIHdlXG4gICBtdXN0IGNhcmVmdWxseSBkb3VibGUtY2hlY2sgYWxsIHRoZSBpbnRlZ2VyIGFyaXRobWV0aWMgb3BlcmF0aW9uc1xuICAgdGhhdCBpbnZvbHZlIHBwX2luZmluaXR5LCBzaW5jZSBhbnkgb3ZlcmZsb3cgd291bGQgd3JlY2sgaGF2b2MgdGhlXG4gICBwcmV0dHktcHJpbnRpbmcgYWxnb3JpdGhtJ3MgaW52YXJpYW50cy4gR2l2ZW4gdGhhdCB0aGlzIGFyaXRobWV0aWNcbiAgIGNvcnJlY3RuZXNzIGNoZWNrIGlzIGRpZmZpY3VsdCBhbmQgZXJyb3IgcHJvbmUgYW5kIGdpdmVuIHRoYXQgMWUxMFxuICAgKyAxIGlzIGluIHByYWN0aWNlIGxhcmdlIGVub3VnaCwgdGhlcmUgaXMgbm8gbmVlZCB0byBhdHRlbXB0IHRvIHNldFxuICAgcHBfaW5maW5pdHkgdG8gdGhlIHRoZW9yZXRpY2FsbHkgbWF4aW11bSBsaW1pdC4gSXQgaXMgbm90IHdvcnRoIHRoZVxuICAgYnVyZGVuICEgKilcbmxldCBwcF9pbmZpbml0eSA9IDEwMDAwMDAwMTBcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBmb3IgdGhlIGZvcm1hdHRlci4gKilcbmxldCBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIHMgPSBzdGF0ZS5wcF9vdXRfc3RyaW5nIHMgMCAoU3RyaW5nLmxlbmd0aCBzKVxuYW5kIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlID0gc3RhdGUucHBfb3V0X25ld2xpbmUgKClcbmFuZCBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfc3BhY2VzIG5cbmFuZCBwcF9vdXRwdXRfaW5kZW50IHN0YXRlIG4gPSBzdGF0ZS5wcF9vdXRfaW5kZW50IG5cblxuKCogVG8gZm9ybWF0IGEgYnJlYWssIGluZGVudGluZyBhIG5ldyBsaW5lLiAqKVxubGV0IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZnNldCB3aWR0aCA9XG4gIHBwX291dHB1dF9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSB0cnVlO1xuICBsZXQgaW5kZW50ID0gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZzZXQgaW5cbiAgKCogRG9uJ3QgaW5kZW50IG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LiAqKVxuICBsZXQgcmVhbF9pbmRlbnQgPSBtaW4gc3RhdGUucHBfbWF4X2luZGVudCBpbmRlbnQgaW5cbiAgc3RhdGUucHBfY3VycmVudF9pbmRlbnQgPC0gcmVhbF9pbmRlbnQ7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfY3VycmVudF9pbmRlbnQ7XG4gIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgc3RhdGUucHBfY3VycmVudF9pbmRlbnRcblxuXG4oKiBUbyBmb3JjZSBhIGxpbmUgYnJlYWsgaW5zaWRlIGEgYm94OiBubyBvZmZzZXQgaXMgYWRkZWQuICopXG5sZXQgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aCA9IGJyZWFrX25ld19saW5lIHN0YXRlIDAgd2lkdGhcblxuKCogVG8gZm9ybWF0IGEgYnJlYWsgdGhhdCBmaXRzIG9uIHRoZSBjdXJyZW50IGxpbmUuICopXG5sZXQgYnJlYWtfc2FtZV9saW5lIHN0YXRlIHdpZHRoID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gd2lkdGg7XG4gIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgd2lkdGhcblxuXG4oKiBUbyBpbmRlbnQgbm8gbW9yZSB0aGFuIHBwX21heF9pbmRlbnQsIGlmIG9uZSB0cmllcyB0byBvcGVuIGEgYm94XG4gICBiZXlvbmQgcHBfbWF4X2luZGVudCwgdGhlbiB0aGUgYm94IGlzIHJlamVjdGVkIG9uIHRoZSBsZWZ0XG4gICBieSBzaW11bGF0aW5nIGEgYnJlYWsuICopXG5sZXQgcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSA9XG4gIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgRm9ybWF0X2VsZW0gKGJsX3R5LCB3aWR0aCkgOjogXyAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICAobWF0Y2ggYmxfdHkgd2l0aFxuICAgICAgIHwgUHBfZml0cyAtPiAoKSB8IFBwX2hib3ggLT4gKClcbiAgICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPlxuICAgICAgICAgYnJlYWtfbGluZSBzdGF0ZSB3aWR0aClcbiAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuXG5cbigqIFRvIHNraXAgYSB0b2tlbiwgaWYgdGhlIHByZXZpb3VzIGxpbmUgaGFzIGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3NraXBfdG9rZW4gc3RhdGUgPVxuICAoKiBXaGVuIGNhbGxpbmcgcHBfc2tpcF90b2tlbiB0aGUgcXVldWUgY2Fubm90IGJlIGVtcHR5LiAqKVxuICBtYXRjaCB0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCB7IGVsZW1fc2l6ZSA9IHNpemU7IGxlbmd0aCA9IGxlbjsgdG9rZW4gPSBfOyB9IC0+XG4gICAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIC0gbGVuO1xuICAgIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCArIGludF9vZl9zaXplIHNpemVcblxuXG4oKlxuXG4gIFRoZSBtYWluIHByZXR0eSBwcmludGluZyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEZvcm1hdHRpbmcgYSB0b2tlbiB3aXRoIGEgZ2l2ZW4gc2l6ZS4gKilcbmxldCBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSA9IGZ1bmN0aW9uXG5cbiAgfCBQcF90ZXh0IHMgLT5cbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgLSBzaXplO1xuICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcztcbiAgICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4gIHwgUHBfYmVnaW4gKG9mZiwgdHkpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBpZiBpbnNlcnRpb25fcG9pbnQgPiBzdGF0ZS5wcF9tYXhfaW5kZW50IHRoZW5cbiAgICAgICgqIGNhbiBub3Qgb3BlbiBhIGJveCByaWdodCB0aGVyZS4gKilcbiAgICAgIGJlZ2luIHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgZW5kO1xuICAgIGxldCBvZmZzZXQgPSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gb2ZmIGluXG4gICAgbGV0IGJsX3R5cGUgPVxuICAgICAgYmVnaW4gbWF0Y2ggdHkgd2l0aFxuICAgICAgfCBQcF92Ym94IC0+IFBwX3Zib3hcbiAgICAgIHwgUHBfaGJveCB8IFBwX2h2Ym94IHwgUHBfaG92Ym94IHwgUHBfYm94IHwgUHBfZml0cyAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIHR5IGVsc2UgUHBfZml0c1xuICAgICAgZW5kIGluXG4gICAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtXG4gICAgICBGb3JtYXRfZWxlbSAoYmxfdHlwZSwgb2Zmc2V0KSA6OiBzdGF0ZS5wcF9mb3JtYXRfc3RhY2tcblxuICB8IFBwX2VuZCAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayA8LSBsc1xuICAgIHwgW10gLT4gKCkgKCogTm8gbW9yZSBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gdGJveCA6OiBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBfIDo6IGxzIC0+IHN0YXRlLnBwX3Rib3hfc3RhY2sgPC0gbHNcbiAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFidWxhdGlvbiBib3ggdG8gY2xvc2UuICopXG4gICAgZW5kXG5cbiAgfCBQcF9zdGFiIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBQcF90Ym94IHRhYnMgOjogXyAtPlxuICAgICAgbGV0IHJlYyBhZGRfdGFiIG4gPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+IFtuXVxuICAgICAgICB8IHggOjogbCBhcyBscyAtPiBpZiBuIDwgeCB0aGVuIG4gOjogbHMgZWxzZSB4IDo6IGFkZF90YWIgbiBsIGluXG4gICAgICB0YWJzIDo9IGFkZF90YWIgKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQpICF0YWJzXG4gICAgfCBbXSAtPiAoKSAoKiBObyBvcGVuIHRhYnVsYXRpb24gYm94LiAqKVxuICAgIGVuZFxuXG4gIHwgUHBfdGJyZWFrIChuLCBvZmYpIC0+XG4gICAgbGV0IGluc2VydGlvbl9wb2ludCA9IHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX3NwYWNlX2xlZnQgaW5cbiAgICBiZWdpbiBtYXRjaCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IFBwX3Rib3ggdGFicyA6OiBfIC0+XG4gICAgICBsZXQgcmVjIGZpbmQgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgeCA6OiBsIC0+IGlmIHggPj0gbiB0aGVuIHggZWxzZSBmaW5kIG4gbFxuICAgICAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZCBpblxuICAgICAgbGV0IHRhYiA9XG4gICAgICAgIG1hdGNoICF0YWJzIHdpdGhcbiAgICAgICAgfCB4IDo6IF8gLT5cbiAgICAgICAgICBiZWdpblxuICAgICAgICAgICAgdHJ5IGZpbmQgaW5zZXJ0aW9uX3BvaW50ICF0YWJzIHdpdGhcbiAgICAgICAgICAgIHwgTm90X2ZvdW5kIC0+IHhcbiAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGluc2VydGlvbl9wb2ludCBpblxuICAgICAgbGV0IG9mZnNldCA9IHRhYiAtIGluc2VydGlvbl9wb2ludCBpblxuICAgICAgaWYgb2Zmc2V0ID49IDBcbiAgICAgIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIChvZmZzZXQgKyBuKVxuICAgICAgZWxzZSBicmVha19uZXdfbGluZSBzdGF0ZSAodGFiICsgb2ZmKSBzdGF0ZS5wcF9tYXJnaW5cbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgZW5kXG5cbiAgfCBQcF9uZXdsaW5lIC0+XG4gICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IEZvcm1hdF9lbGVtIChfLCB3aWR0aCkgOjogXyAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG4gICAgfCBbXSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZSAoKiBObyBvcGVuIGJveC4gKilcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayAobiwgb2ZmKSAtPlxuICAgIGJlZ2luIG1hdGNoIHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gICAgfCBGb3JtYXRfZWxlbSAodHksIHdpZHRoKSA6OiBfIC0+XG4gICAgICBiZWdpbiBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX2hvdmJveCAtPlxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIG4gZWxzZVxuICAgICAgICBpZiBzaXplID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBvZmYgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgblxuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIG9mZiB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBuXG4gICAgICBlbmRcbiAgICB8IFtdIC0+ICgpICgqIE5vIG9wZW4gYm94LiAqKVxuICAgIGVuZFxuXG4gICB8IFBwX29wZW5fdGFnIHRhZ19uYW1lIC0+XG4gICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICBzdGF0ZS5wcF9tYXJrX3N0YWNrIDwtIHRhZ19uYW1lIDo6IHN0YXRlLnBwX21hcmtfc3RhY2tcblxuICAgfCBQcF9jbG9zZV90YWcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgdGFnX25hbWUgOjogdGFncyAtPlxuICAgICAgIGxldCBtYXJrZXIgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyB0YWdfbmFtZSBpblxuICAgICAgIHBwX291dHB1dF9zdHJpbmcgc3RhdGUgbWFya2VyO1xuICAgICAgIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gdGFnc1xuICAgICB8IFtdIC0+ICgpICgqIE5vIG1vcmUgdGFnIHRvIGNsb3NlLiAqKVxuICAgICBlbmRcblxuXG4oKiBQcmludCBpZiB0b2tlbiBzaXplIGlzIGtub3duIGVsc2UgcHJpbnRpbmcgaXMgZGVsYXllZC5cbiAgIFNpemUgaXMga25vd24gd2hlbiBub3QgbmVnYXRpdmUuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS5cblxuICAgTm90ZTogW2FkdmFuY2VfbG9vcF0gbXVzdCBiZSB0YWlsIHJlY3Vyc2l2ZSB0byBwcmV2ZW50IHN0YWNrIG92ZXJmbG93cy4gKilcbmxldCByZWMgYWR2YW5jZV9sb29wIHN0YXRlID1cbiAgbWF0Y2ggcGVla19xdWV1ZSBzdGF0ZS5wcF9xdWV1ZSB3aXRoXG4gIHwge2VsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW59IC0+XG4gICAgbGV0IHNpemUgPSBpbnRfb2Zfc2l6ZSBzaXplIGluXG4gICAgaWYgbm90XG4gICAgICAgICAoc2l6ZSA8IDAgJiZcbiAgICAgICAgICAoc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIDwgc3RhdGUucHBfc3BhY2VfbGVmdCkpXG4gICAgdGhlbiBiZWdpblxuICAgICAgaWdub3JlICh0YWtlX3F1ZXVlIHN0YXRlLnBwX3F1ZXVlKTtcbiAgICAgIGZvcm1hdF9wcF90b2tlbiBzdGF0ZSAoaWYgc2l6ZSA8IDAgdGhlbiBwcF9pbmZpbml0eSBlbHNlIHNpemUpIHRvaztcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIGFkdmFuY2VfbG9vcCBzdGF0ZVxuICAgIGVuZFxuXG5cbmxldCBhZHZhbmNlX2xlZnQgc3RhdGUgPVxuICB0cnkgYWR2YW5jZV9sb29wIHN0YXRlIHdpdGhcbiAgfCBFbXB0eV9xdWV1ZSAtPiAoKVxuXG5cbigqIFRvIGVucXVldWUgYSB0b2tlbiA6IHRyeSB0byBhZHZhbmNlLiAqKVxubGV0IGVucXVldWVfYWR2YW5jZSBzdGF0ZSB0b2sgPSBwcF9lbnF1ZXVlIHN0YXRlIHRvazsgYWR2YW5jZV9sZWZ0IHN0YXRlXG5cbigqIEJ1aWxkaW5nIHByZXR0eS1wcmludGVyIHF1ZXVlIGVsZW1lbnRzLiAqKVxubGV0IG1ha2VfcXVldWVfZWxlbSBzaXplIHRvayBsZW4gPVxuICB7IGVsZW1fc2l6ZSA9IHNpemU7IHRva2VuID0gdG9rOyBsZW5ndGggPSBsZW47IH1cblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgbGV0IGxlbiA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIChtYWtlX3F1ZXVlX2VsZW0gc2l6ZSAoUHBfdGV4dCBzKSBsZW4pXG5cblxubGV0IGVucXVldWVfc3RyaW5nIHN0YXRlIHMgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGVucXVldWVfc3RyaW5nX2FzIHN0YXRlIChzaXplX29mX2ludCBsZW4pIHNcblxuXG4oKiBSb3V0aW5lcyBmb3Igc2NhbiBzdGFja1xuICAgZGV0ZXJtaW5lIHNpemUgb2YgYm94ZXMuICopXG5cbigqIFRoZSBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxubGV0IHNjYW5fc3RhY2tfYm90dG9tID1cbiAgbGV0IHFfZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX3RleHQgXCJcIikgMCBpblxuICBbU2Nhbl9lbGVtICgtMSwgcV9lbGVtKV1cblxuXG4oKiBDbGVhcmluZyB0aGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5sZXQgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSA9IHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gc2Nhbl9zdGFja19ib3R0b21cblxuKCogU2V0dGluZyB0aGUgc2l6ZSBvZiBib3hlcyBvbiBzY2FuIHN0YWNrOlxuICAgaWYgdHkgPSB0cnVlIHRoZW4gc2l6ZSBvZiBicmVhayBpcyBzZXQgZWxzZSBzaXplIG9mIGJveCBpcyBzZXQ7XG4gICBpbiBlYWNoIGNhc2UgcHBfc2Nhbl9zdGFjayBpcyBwb3BwZWQuXG5cbiAgIE5vdGU6XG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHNjYW4gc3RhY2sgaXMgZXhoYXVzdGl2ZSwgc2luY2Ugc2Nhbl9zdGFjayBpcyBuZXZlclxuICAgZW1wdHkuXG4gICBQYXR0ZXJuIG1hdGNoaW5nIG9uIHRva2VuIGluIHNjYW4gc3RhY2sgaXMgYWxzbyBleGhhdXN0aXZlLFxuICAgc2luY2Ugc2Nhbl9wdXNoIGlzIHVzZWQgb24gYnJlYWtzIGFuZCBvcGVuaW5nIG9mIGJveGVzLiAqKVxubGV0IHNldF9zaXplIHN0YXRlIHR5ID1cbiAgbWF0Y2ggc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgU2Nhbl9lbGVtXG4gICAgICAobGVmdF90b3QsXG4gICAgICAgKHsgZWxlbV9zaXplID0gc2l6ZTsgdG9rZW4gPSB0b2s7IGxlbmd0aCA9IF87IH0gYXMgcXVldWVfZWxlbSkpIDo6IHQgLT5cbiAgICBsZXQgc2l6ZSA9IGludF9vZl9zaXplIHNpemUgaW5cbiAgICAoKiB0ZXN0IGlmIHNjYW4gc3RhY2sgY29udGFpbnMgYW55IGRhdGEgdGhhdCBpcyBub3Qgb2Jzb2xldGUuICopXG4gICAgaWYgbGVmdF90b3QgPCBzdGF0ZS5wcF9sZWZ0X3RvdGFsIHRoZW4gY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZSBlbHNlXG4gICAgICBiZWdpbiBtYXRjaCB0b2sgd2l0aFxuICAgICAgfCBQcF9icmVhayAoXywgXykgfCBQcF90YnJlYWsgKF8sIF8pIC0+XG4gICAgICAgIGlmIHR5IHRoZW5cbiAgICAgICAgYmVnaW5cbiAgICAgICAgICBxdWV1ZV9lbGVtLmVsZW1fc2l6ZSA8LSBzaXplX29mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtIHRcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlblxuICAgICAgICBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uZWxlbV9zaXplIDwtIHNpemVfb2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIHN0YXRlLnBwX3NjYW5fc3RhY2sgPC0gdFxuICAgICAgICBlbmRcbiAgICAgIHwgUHBfdGV4dCBfIHwgUHBfc3RhYiB8IFBwX3RiZWdpbiBfIHwgUHBfdGVuZCB8IFBwX2VuZFxuICAgICAgfCBQcF9uZXdsaW5lIHwgUHBfaWZfbmV3bGluZVxuICAgICAgfCBQcF9vcGVuX3RhZyBfIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgICAgICgpICgqIHNjYW5fcHVzaCBpcyBvbmx5IHVzZWQgZm9yIGJyZWFrcyBhbmQgYm94ZXMuICopXG4gICAgICBlbmRcbiAgfCBbXSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rID1cbiAgcHBfZW5xdWV1ZSBzdGF0ZSB0b2s7XG4gIGlmIGIgdGhlbiBzZXRfc2l6ZSBzdGF0ZSB0cnVlO1xuICBzdGF0ZS5wcF9zY2FuX3N0YWNrIDwtXG4gICAgU2Nhbl9lbGVtIChzdGF0ZS5wcF9yaWdodF90b3RhbCwgdG9rKSA6OiBzdGF0ZS5wcF9zY2FuX3N0YWNrXG5cblxuKCogVG8gb3BlbiBhIG5ldyBib3ggOlxuICAgdGhlIHVzZXIgbWF5IHNldCB0aGUgZGVwdGggYm91bmQgcHBfbWF4X2JveGVzXG4gICBhbnkgdGV4dCBuZXN0ZWQgZGVlcGVyIGlzIHByaW50ZWQgYXMgdGhlIGVsbGlwc2lzIHN0cmluZy4gKilcbmxldCBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IGJyX3R5ID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9iZWdpbiAoaW5kZW50LCBicl90eSkpXG4gICAgICAgIDAgaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgZmFsc2UgZWxlbSBlbHNlXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRoZSBib3ggd2hpY2ggaXMgYWx3YXlzIG9wZW4uICopXG5sZXQgcHBfb3Blbl9zeXNfYm94IHN0YXRlID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIDAgUHBfaG92Ym94XG5cbigqIENsb3NlIGEgYm94LCBzZXR0aW5nIHNpemVzIG9mIGl0cyBzdWIgYm94ZXMuICopXG5sZXQgcHBfY2xvc2VfYm94IHN0YXRlICgpID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA+IDEgdGhlblxuICBiZWdpblxuICAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGJlZ2luXG4gICAgICBwcF9lbnF1ZXVlIHN0YXRlXG4gICAgICAgIHsgZWxlbV9zaXplID0gc2l6ZV9vZl9pbnQgMDsgdG9rZW4gPSBQcF9lbmQ7IGxlbmd0aCA9IDA7IH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl90YWcgc3RhdGUgdGFnX25hbWUgPVxuICBpZiBzdGF0ZS5wcF9wcmludF90YWdzIHRoZW5cbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnX25hbWUgOjogc3RhdGUucHBfdGFnX3N0YWNrO1xuICAgIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIHRhZ19uYW1lXG4gIGVuZDtcbiAgaWYgc3RhdGUucHBfbWFya190YWdzIHRoZW5cbiAgICBwcF9lbnF1ZXVlIHN0YXRlIHtcbiAgICAgIGVsZW1fc2l6ZSA9IHNpemVfb2ZfaW50IDA7XG4gICAgICB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lO1xuICAgICAgbGVuZ3RoID0gMDtcbiAgICB9XG5cblxuKCogQ2xvc2UgYSB0YWcsIHBvcHBpbmcgaXQgZnJvbSB0aGUgdGFnIHN0YWNrLiAqKVxubGV0IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7XG4gICAgICBlbGVtX3NpemUgPSBzaXplX29mX2ludCAwO1xuICAgICAgdG9rZW4gPSBQcF9jbG9zZV90YWc7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICBiZWdpblxuICAgIG1hdGNoIHN0YXRlLnBwX3RhZ19zdGFjayB3aXRoXG4gICAgfCB0YWdfbmFtZSA6OiB0YWdzIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWU7XG4gICAgICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gdGFnc1xuICAgIHwgXyAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgZW5kXG5cblxubGV0IHBwX3NldF9wcmludF90YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9wcmludF90YWdzIDwtIGJcbmxldCBwcF9zZXRfbWFya190YWdzIHN0YXRlIGIgPSBzdGF0ZS5wcF9tYXJrX3RhZ3MgPC0gYlxubGV0IHBwX2dldF9wcmludF90YWdzIHN0YXRlICgpID0gc3RhdGUucHBfcHJpbnRfdGFnc1xubGV0IHBwX2dldF9tYXJrX3RhZ3Mgc3RhdGUgKCkgPSBzdGF0ZS5wcF9tYXJrX3RhZ3NcbmxldCBwcF9zZXRfdGFncyBzdGF0ZSBiID1cbiAgcHBfc2V0X3ByaW50X3RhZ3Mgc3RhdGUgYjsgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiXG5cblxuKCogSGFuZGxpbmcgdGFnIGhhbmRsaW5nIGZ1bmN0aW9uczogZ2V0L3NldCBmdW5jdGlvbnMuICopXG5sZXQgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlICgpID0ge1xuICBtYXJrX29wZW5fdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV90YWcgPSBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZztcbiAgcHJpbnRfb3Blbl90YWcgPSBzdGF0ZS5wcF9wcmludF9vcGVuX3RhZztcbiAgcHJpbnRfY2xvc2VfdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgc3RhdGUge1xuICAgICBtYXJrX29wZW5fdGFnID0gbW90O1xuICAgICBtYXJrX2Nsb3NlX3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl90YWcgPSBwb3Q7XG4gICAgIHByaW50X2Nsb3NlX3RhZyA9IHBjdDtcbiAgfSA9XG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gbW90O1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBtY3Q7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHBvdDtcbiAgc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnIDwtIHBjdFxuXG5cbigqIEluaXRpYWxpemUgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfcmluaXQgc3RhdGUgPVxuICBwcF9jbGVhcl9xdWV1ZSBzdGF0ZTtcbiAgY2xlYXJfc2Nhbl9zdGFjayBzdGF0ZTtcbiAgc3RhdGUucHBfZm9ybWF0X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90Ym94X3N0YWNrIDwtIFtdO1xuICBzdGF0ZS5wcF90YWdfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX21hcmtfc3RhY2sgPC0gW107XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgTGlzdC5pdGVyXG4gICAgKGZ1biBfIC0+IHBwX2Nsb3NlX3RhZyBzdGF0ZSAoKSlcbiAgICBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKHNpemVfb2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChzdHJpbmdfb2ZfaW50IGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSAobWFrZV9xdWV1ZV9lbGVtIChzaXplX29mX2ludCAwKSBQcF9uZXdsaW5lIDApXG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgKG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfaWZfbmV3bGluZSAwKVxuXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF9icmVhayAod2lkdGgsIG9mZnNldCkpXG4gICAgICAgIHdpZHRoIGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIHRydWUgZWxlbVxuXG5cbigqIFByaW50IGEgc3BhY2UgOlxuICAgYSBzcGFjZSBpcyBhIGJyZWFrIGhpbnQgdGhhdCBwcmludHMgYSBzaW5nbGUgc3BhY2UgaWYgdGhlIGJyZWFrIGRvZXMgbm90XG4gICBzcGxpdCB0aGUgbGluZTtcbiAgIGEgY3V0IGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBub3RoaW5nIGlmIHRoZSBicmVhayBkb2VzIG5vdCBzcGxpdCB0aGVcbiAgIGxpbmUuICopXG5sZXQgcHBfcHJpbnRfc3BhY2Ugc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAxIDBcbmFuZCBwcF9wcmludF9jdXQgc3RhdGUgKCkgPSBwcF9wcmludF9icmVhayBzdGF0ZSAwIDBcblxuXG4oKiBUYWJ1bGF0aW9uIGJveGVzLiAqKVxubGV0IHBwX29wZW5fdGJveCBzdGF0ZSAoKSA9XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCArIDE7XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgKFBwX3RiZWdpbiAoUHBfdGJveCAocmVmIFtdKSkpIDAgaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfdGVuZCAwIGluXG4gICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSBlbGVtO1xuICAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxXG4gIGVuZFxuXG5cbigqIFByaW50IGEgdGFidWxhdGlvbiBicmVhay4gKilcbmxldCBwcF9wcmludF90YnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IGVsZW0gPVxuICAgICAgbWFrZV9xdWV1ZV9lbGVtXG4gICAgICAgIChzaXplX29mX2ludCAoLSBzdGF0ZS5wcF9yaWdodF90b3RhbCkpXG4gICAgICAgIChQcF90YnJlYWsgKHdpZHRoLCBvZmZzZXQpKVxuICAgICAgICB3aWR0aCBpblxuICAgIHNjYW5fcHVzaCBzdGF0ZSB0cnVlIGVsZW1cblxuXG5sZXQgcHBfcHJpbnRfdGFiIHN0YXRlICgpID0gcHBfcHJpbnRfdGJyZWFrIHN0YXRlIDAgMFxuXG5sZXQgcHBfc2V0X3RhYiBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBlbGVtID1cbiAgICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgMCkgUHBfc3RhYiAwIGluXG4gICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW1cblxuXG4oKlxuXG4gIFByb2NlZHVyZXMgdG8gY29udHJvbCB0aGUgcHJldHR5LXByaW50ZXJzXG5cbiopXG5cbigqIFNldF9tYXhfYm94ZXMuICopXG5sZXQgcHBfc2V0X21heF9ib3hlcyBzdGF0ZSBuID0gaWYgbiA+IDEgdGhlbiBzdGF0ZS5wcF9tYXhfYm94ZXMgPC0gblxuXG4oKiBUbyBrbm93IHRoZSBjdXJyZW50IG1heGltdW0gbnVtYmVyIG9mIGJveGVzIGFsbG93ZWQuICopXG5sZXQgcHBfZ2V0X21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX21heF9ib3hlc1xuXG5sZXQgcHBfb3Zlcl9tYXhfYm94ZXMgc3RhdGUgKCkgPSBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbigqIEVsbGlwc2lzLiAqKVxubGV0IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0YXRlIHMgPSBzdGF0ZS5wcF9lbGxpcHNpcyA8LSBzXG5hbmQgcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgKCkgPSBzdGF0ZS5wcF9lbGxpcHNpc1xuXG5cbigqIFRvIHNldCB0aGUgbWFyZ2luIG9mIHByZXR0eS1wcmludGVyLiAqKVxubGV0IHBwX2xpbWl0IG4gPVxuICBpZiBuIDwgcHBfaW5maW5pdHkgdGhlbiBuIGVsc2UgcHJlZCBwcF9pbmZpbml0eVxuXG5cbigqIEludGVybmFsIHByZXR0eS1wcmludGVyIGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgbiA9XG4gIGlmIG4gPj0gMSB0aGVuXG4gICAgbGV0IG4gPSBwcF9saW1pdCBuIGluXG4gICAgc3RhdGUucHBfbWluX3NwYWNlX2xlZnQgPC0gbjtcbiAgICBzdGF0ZS5wcF9tYXhfaW5kZW50IDwtIHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX3Jpbml0IHN0YXRlXG5cblxuKCogSW5pdGlhbGx5LCB3ZSBoYXZlIDpcbiAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdCwgYW5kXG4gICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luLiAqKVxubGV0IHBwX3NldF9tYXhfaW5kZW50IHN0YXRlIG4gPVxuICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnIHMgPSBcIjxcIiBeIHMgXiBcIj5cIlxubGV0IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWcgcyA9IFwiPC9cIiBeIHMgXiBcIj5cIlxuXG5sZXQgZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyA9IGlnbm9yZVxubGV0IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnID0gaWdub3JlXG5cbigqIEJ1aWxkaW5nIGEgZm9ybWF0dGVyIGdpdmVuIGl0cyBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zLlxuICAgT3RoZXIgZmllbGRzIGdldCByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWVzLiAqKVxubGV0IHBwX21ha2VfZm9ybWF0dGVyIGYgZyBoIGkgaiA9XG4gICgqIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBmb3JtYXR0ZXIgY29udGFpbnMgYSBkdW1teSBib3guICopXG4gIGxldCBwcF9xdWV1ZSA9IG1ha2VfcXVldWUgKCkgaW5cbiAgbGV0IHN5c190b2sgPVxuICAgIG1ha2VfcXVldWVfZWxlbSAoc2l6ZV9vZl9pbnQgKC0xKSkgKFBwX2JlZ2luICgwLCBQcF9ob3Zib3gpKSAwIGluXG4gIGFkZF9xdWV1ZSBzeXNfdG9rIHBwX3F1ZXVlO1xuICBsZXQgc3lzX3NjYW5fc3RhY2sgPVxuICAgIFNjYW5fZWxlbSAoMSwgc3lzX3RvaykgOjogc2Nhbl9zdGFja19ib3R0b20gaW5cbiAgbGV0IHBwX21hcmdpbiA9IDc4XG4gIGFuZCBwcF9taW5fc3BhY2VfbGVmdCA9IDEwIGluXG4gIHtcbiAgICBwcF9zY2FuX3N0YWNrID0gc3lzX3NjYW5fc3RhY2s7XG4gICAgcHBfZm9ybWF0X3N0YWNrID0gW107XG4gICAgcHBfdGJveF9zdGFjayA9IFtdO1xuICAgIHBwX3RhZ19zdGFjayA9IFtdO1xuICAgIHBwX21hcmtfc3RhY2sgPSBbXTtcbiAgICBwcF9tYXJnaW4gPSBwcF9tYXJnaW47XG4gICAgcHBfbWluX3NwYWNlX2xlZnQgPSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9tYXhfaW5kZW50ID0gcHBfbWFyZ2luIC0gcHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfc3BhY2VfbGVmdCA9IHBwX21hcmdpbjtcbiAgICBwcF9jdXJyZW50X2luZGVudCA9IDA7XG4gICAgcHBfaXNfbmV3X2xpbmUgPSB0cnVlO1xuICAgIHBwX2xlZnRfdG90YWwgPSAxO1xuICAgIHBwX3JpZ2h0X3RvdGFsID0gMTtcbiAgICBwcF9jdXJyX2RlcHRoID0gMTtcbiAgICBwcF9tYXhfYm94ZXMgPSBtYXhfaW50O1xuICAgIHBwX2VsbGlwc2lzID0gXCIuXCI7XG4gICAgcHBfb3V0X3N0cmluZyA9IGY7XG4gICAgcHBfb3V0X2ZsdXNoID0gZztcbiAgICBwcF9vdXRfbmV3bGluZSA9IGg7XG4gICAgcHBfb3V0X3NwYWNlcyA9IGk7XG4gICAgcHBfb3V0X2luZGVudCA9IGo7XG4gICAgcHBfcHJpbnRfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfdGFncyA9IGZhbHNlO1xuICAgIHBwX21hcmtfb3Blbl90YWcgPSBkZWZhdWx0X3BwX21hcmtfb3Blbl90YWc7XG4gICAgcHBfbWFya19jbG9zZV90YWcgPSBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnO1xuICAgIHBwX3ByaW50X29wZW5fdGFnID0gZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZztcbiAgICBwcF9wcmludF9jbG9zZV90YWcgPSBkZWZhdWx0X3BwX3ByaW50X2Nsb3NlX3RhZztcbiAgICBwcF9xdWV1ZSA9IHBwX3F1ZXVlO1xuICB9XG5cblxuKCogQnVpbGQgYSBmb3JtYXR0ZXIgb3V0IG9mIGl0cyBvdXQgZnVuY3Rpb25zLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9vdXRfZnVuY3Rpb25zIG91dF9mdW5zID1cbiAgcHBfbWFrZV9mb3JtYXR0ZXJcbiAgICBvdXRfZnVucy5vdXRfc3RyaW5nXG4gICAgb3V0X2Z1bnMub3V0X2ZsdXNoXG4gICAgb3V0X2Z1bnMub3V0X25ld2xpbmVcbiAgICBvdXRfZnVucy5vdXRfc3BhY2VzXG4gICAgb3V0X2Z1bnMub3V0X2luZGVudFxuXG5cbigqIE1ha2UgYSBmb3JtYXR0ZXIgd2l0aCBkZWZhdWx0IGZ1bmN0aW9ucyB0byBvdXRwdXQgc3BhY2VzLFxuICBpbmRlbnRhdGlvbiwgYW5kIG5ldyBsaW5lcy4gKilcbmxldCBtYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggPVxuICBsZXQgcHBmID0gcHBfbWFrZV9mb3JtYXR0ZXIgb3V0cHV0IGZsdXNoIGlnbm9yZSBpZ25vcmUgaWdub3JlIGluXG4gIHBwZi5wcF9vdXRfbmV3bGluZSA8LSBkaXNwbGF5X25ld2xpbmUgcHBmO1xuICBwcGYucHBfb3V0X3NwYWNlcyA8LSBkaXNwbGF5X2JsYW5rcyBwcGY7XG4gIHBwZi5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHBwZjtcbiAgcHBmXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW1BlcnZhc2l2ZS5vdXRfY2hhbm5lbF0gdmFsdWUuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9jaGFubmVsIG9jID1cbiAgbWFrZV9mb3JtYXR0ZXIgKG91dHB1dF9zdWJzdHJpbmcgb2MpIChmdW4gKCkgLT4gZmx1c2ggb2MpXG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3cml0aW5nIHRvIGEgZ2l2ZW4gW0J1ZmZlci50XSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgPVxuICBtYWtlX2Zvcm1hdHRlciAoQnVmZmVyLmFkZF9zdWJzdHJpbmcgYikgaWdub3JlXG5cblxuKCogQWxsb2NhdGluZyBidWZmZXIgZm9yIHByZXR0eS1wcmludGluZyBwdXJwb3Nlcy5cbiAgIERlZmF1bHQgYnVmZmVyIHNpemUgaXMgcHBfYnVmZmVyX3NpemUgb3IgNTEyLlxuKilcbmxldCBwcF9idWZmZXJfc2l6ZSA9IDUxMlxubGV0IHBwX21ha2VfYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSBwcF9idWZmZXJfc2l6ZVxuXG4oKiBUaGUgc3RhbmRhcmQgKHNoYXJlZCkgYnVmZmVyLiAqKVxubGV0IHN0ZGJ1ZiA9IHBwX21ha2VfYnVmZmVyICgpXG5cbigqIFByZWRlZmluZWQgZm9ybWF0dGVycyBzdGFuZGFyZCBmb3JtYXR0ZXIgdG8gcHJpbnRcbiAgIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0sIFtQZXJ2YXNpdmVzLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBQZXJ2YXNpdmVzLnN0ZG91dFxuYW5kIGVycl9mb3JtYXR0ZXIgPSBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgUGVydmFzaXZlcy5zdGRlcnJcbmFuZCBzdHJfZm9ybWF0dGVyID0gZm9ybWF0dGVyX29mX2J1ZmZlciBzdGRidWZcblxuXG4oKiBbZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmXSBmbHVzaGVzIGZvcm1hdHRlciBbcHBmXSxcbiAgIHRoZW4gcmV0dXJucyB0aGUgY29udGVudHMgb2YgYnVmZmVyIFtidWZdIHRoYXQgaXMgcmVzZXQuXG4gICBGb3JtYXR0ZXIgW3BwZl0gaXMgc3VwcG9zZWQgdG8gcHJpbnQgdG8gYnVmZmVyIFtidWZdLCBvdGhlcndpc2UgdGhpc1xuICAgZnVuY3Rpb24gaXMgbm90IHJlYWxseSB1c2VmdWwuICopXG5sZXQgZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBidWYgcHBmID1cbiAgcHBfZmx1c2hfcXVldWUgcHBmIGZhbHNlO1xuICBsZXQgcyA9IEJ1ZmZlci5jb250ZW50cyBidWYgaW5cbiAgQnVmZmVyLnJlc2V0IGJ1ZjtcbiAgc1xuXG5cbigqIEZsdXNoIFtzdHJfZm9ybWF0dGVyXSBhbmQgZ2V0IHRoZSBjb250ZW50cyBvZiBbc3RkYnVmXS4gKilcbmxldCBmbHVzaF9zdHJfZm9ybWF0dGVyICgpID0gZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBzdGRidWYgc3RyX2Zvcm1hdHRlclxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmdcbiopXG5cbigqXG4gIFN5bWJvbGljIHByZXR0eS1wcmludGluZyBpcyBwcmV0dHktcHJpbnRpbmcgd2l0aCBubyBsb3cgbGV2ZWwgb3V0cHV0LlxuXG4gIFdoZW4gdXNpbmcgYSBzeW1ib2xpYyBmb3JtYXR0ZXIsIGFsbCByZWd1bGFyIHByZXR0eS1wcmludGluZyBhY3Rpdml0aWVzXG4gIG9jY3VyIGJ1dCBvdXRwdXQgbWF0ZXJpYWwgaXMgc3ltYm9saWMgYW5kIHN0b3JlZCBpbiBhIGJ1ZmZlciBvZiBvdXRwdXRcbiAgaXRlbXMuIEF0IHRoZSBlbmQgb2YgcHJldHR5LXByaW50aW5nLCBmbHVzaGluZyB0aGUgb3V0cHV0IGJ1ZmZlciBhbGxvd3NcbiAgcG9zdC1wcm9jZXNzaW5nIG9mIHN5bWJvbGljIG91dHB1dCBiZWZvcmUgbG93IGxldmVsIG91dHB1dCBvcGVyYXRpb25zLlxuKilcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfaXRlbSA9XG4gIHwgT3V0cHV0X2ZsdXNoXG4gIHwgT3V0cHV0X25ld2xpbmVcbiAgfCBPdXRwdXRfc3RyaW5nIG9mIHN0cmluZ1xuICB8IE91dHB1dF9zcGFjZXMgb2YgaW50XG4gIHwgT3V0cHV0X2luZGVudCBvZiBpbnRcblxudHlwZSBzeW1ib2xpY19vdXRwdXRfYnVmZmVyID0ge1xuICBtdXRhYmxlIHN5bWJvbGljX291dHB1dF9jb250ZW50cyA6IHN5bWJvbGljX291dHB1dF9pdGVtIGxpc3Q7XG59XG5cbmxldCBtYWtlX3N5bWJvbGljX291dHB1dF9idWZmZXIgKCkgPVxuICB7IHN5bWJvbGljX291dHB1dF9jb250ZW50cyA9IFtdIH1cblxubGV0IGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBbXVxuXG5sZXQgZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgTGlzdC5yZXYgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZmx1c2hfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgPVxuICBsZXQgaXRlbXMgPSBnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2IgaW5cbiAgY2xlYXJfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciBzb2I7XG4gIGl0ZW1zXG5cbmxldCBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIGl0ZW0gPVxuICBzb2Iuc3ltYm9saWNfb3V0cHV0X2NvbnRlbnRzIDwtIGl0ZW0gOjogc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50c1xuXG5sZXQgZm9ybWF0dGVyX29mX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IHN5bWJvbGljX2ZsdXNoIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfZmx1c2hcbiAgYW5kIHN5bWJvbGljX25ld2xpbmUgc29iICgpID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIE91dHB1dF9uZXdsaW5lXG4gIGFuZCBzeW1ib2xpY19zdHJpbmcgc29iIHMgaSBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfc3RyaW5nIChTdHJpbmcuc3ViIHMgaSBuKSlcbiAgYW5kIHN5bWJvbGljX3NwYWNlcyBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3NwYWNlcyBuKVxuICBhbmQgc3ltYm9saWNfaW5kZW50IHNvYiBuID1cbiAgICBhZGRfc3ltYm9saWNfb3V0cHV0X2l0ZW0gc29iIChPdXRwdXRfaW5kZW50IG4pIGluXG5cbiAgbGV0IGYgPSBzeW1ib2xpY19zdHJpbmcgc29iXG4gIGFuZCBnID0gc3ltYm9saWNfZmx1c2ggc29iXG4gIGFuZCBoID0gc3ltYm9saWNfbmV3bGluZSBzb2JcbiAgYW5kIGkgPSBzeW1ib2xpY19zcGFjZXMgc29iXG4gIGFuZCBqID0gc3ltYm9saWNfaW5kZW50IHNvYiBpblxuICBwcF9tYWtlX2Zvcm1hdHRlciBmIGcgaCBpIGpcblxuKCpcblxuICBCYXNpYyBmdW5jdGlvbnMgb24gdGhlICdzdGFuZGFyZCcgZm9ybWF0dGVyXG4gICh0aGUgZm9ybWF0dGVyIHRoYXQgcHJpbnRzIHRvIFtQZXJ2YXNpdmVzLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXhfYm94ZXMgPSBwcF9zZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2JveGVzID0gcHBfZ2V0X21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Zlcl9tYXhfYm94ZXMgPSBwcF9vdmVyX21heF9ib3hlcyBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfZWxsaXBzaXNfdGV4dCA9IHBwX3NldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZWxsaXBzaXNfdGV4dCA9IHBwX2dldF9lbGxpcHNpc190ZXh0IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3RhZyBwcGYgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJylcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX2JveCBhY2MnKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgbGV0IChpbmRlbnQsIGJ0eSkgPSBvcGVuX2JveF9vZl9zdHJpbmcgKGNvbXB1dGVfdGFnIG91dHB1dF9hY2MgYWNjJykgaW5cbiAgICBwcF9vcGVuX2JveF9nZW4gcHBmIGluZGVudCBidHlcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgcztcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9jaGFyIHBwZiBjO1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBmIHBwZjtcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICB8IEFjY19pbnZhbGlkX2FyZyAocCwgbXNnKSAtPiBvdXRwdXRfYWNjIHBwZiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBQcmludGYuYnVmcHV0X2FjYyBieSB0aGUgaW50ZXJwcmV0YXRpb24gb2YgZm9ybWF0dGluZy4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgQ2FtbGludGVybmFsRm9ybWF0Lm1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIHBwZiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChzaXplX29mX2ludCBzaXplKSBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBjKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKHNpemVfb2ZfaW50IHNpemUpIChTdHJpbmcubWFrZSAxIGMpO1xuICB8IEFjY19kZWxheSAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGYpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoc2l6ZV9vZl9pbnQgc2l6ZSkgKGYgKCkpO1xuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZjtcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfb3Blbl90YWcgcHBmIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIGxldCAoaW5kZW50LCBidHkpID0gb3Blbl9ib3hfb2Zfc3RyaW5nIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpIGluXG4gICAgcHBfb3Blbl9ib3hfZ2VuIHBwZiBpbmRlbnQgYnR5XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9zdHJpbmcgcHBmIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAocCwgYylcbiAgfCBBY2NfZGF0YV9jaGFyIChwLCBjKSAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfY2hhciBwcGYgYztcbiAgfCBBY2NfZGVsYXkgKHAsIGYpICAgICAgICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZiAoKSk7XG4gIHwgQWNjX2ZsdXNoIHAgICAgICAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2ZsdXNoIHBwZiAoKTtcbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gc3RycHV0X2FjYyBwcGYgcDsgaW52YWxpZF9hcmcgbXNnO1xuICB8IEVuZF9vZl9hY2MgICAgICAgICAgICAgICAtPiAoKVxuXG4oKlxuXG4gIERlZmluaW5nIFtmcHJpbnRmXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtmcHJpbnRmXS5cblxuKilcblxubGV0IGtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGZcbiAgICAoZnVuIHBwZiBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBwcGYgRW5kX29mX2FjYyBmbXRcblxuYW5kIGlrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIHBwZiBmbXRcblxubGV0IGZwcmludGYgcHBmID0ga2ZwcmludGYgaWdub3JlIHBwZlxubGV0IGlmcHJpbnRmIHBwZiA9IGlrZnByaW50ZiBpZ25vcmUgcHBmXG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3RkX2Zvcm1hdHRlciBmbXRcbmxldCBlcHJpbnRmIGZtdCA9IGZwcmludGYgZXJyX2Zvcm1hdHRlciBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgKCkgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayAoKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAtPiBzKSBmbXRcblxubGV0IGthc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGIgPSBwcF9tYWtlX2J1ZmZlciAoKSBpblxuICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gIGxldCBrIHBwZiBhY2MgPVxuICAgIG91dHB1dF9hY2MgcHBmIGFjYztcbiAgICBrIChmbHVzaF9idWZmZXJfZm9ybWF0dGVyIGIgcHBmKSBpblxuICBtYWtlX3ByaW50ZiBrIHBwZiBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG4oKiBPdXRwdXQgZXZlcnl0aGluZyBsZWZ0IGluIHRoZSBwcmV0dHkgcHJpbnRlciBxdWV1ZSBhdCBlbmQgb2YgZXhlY3V0aW9uLiAqKVxubGV0ICgpID0gYXRfZXhpdCBwcmludF9mbHVzaFxuXG5cbigqXG5cbiAgRGVwcmVjYXRlZCBzdHVmZi5cblxuKilcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX3NldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGVcbiAgICB+b3V0OmYgfmZsdXNoOmcgfm5ld2xpbmU6aCB+c3BhY2VzOmkgPVxuICBwcF9zZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgZiBnO1xuICBzdGF0ZS5wcF9vdXRfbmV3bGluZSA8LSBoO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGlcblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoLFxuICAgc3RhdGUucHBfb3V0X25ld2xpbmUsIHN0YXRlLnBwX291dF9zcGFjZXMpXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IHNldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IHNldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogc3Vic3VtZWQgYnkgZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zICopXG5sZXQgZ2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyA9XG4gIHBwX2dldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5cbigqIERlcHJlY2F0ZWQgOiBlcnJvciBwcm9uZSBmdW5jdGlvbiwgZG8gbm90IHVzZSBpdC5cbiAgIFRoaXMgZnVuY3Rpb24gaXMgbmVpdGhlciBjb21wb3NpdGlvbmFsIG5vciBpbmNyZW1lbnRhbCwgc2luY2UgaXQgZmx1c2hlc1xuICAgdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlIGF0IGVhY2ggY2FsbC5cbiAgIFRvIGdldCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LCBkZWZpbmUgYSBmb3JtYXR0ZXIgb2YgeW91ciBvd24gd3JpdGluZyB0b1xuICAgdGhlIGJ1ZmZlciBhcmd1bWVudCwgYXMgaW5cbiAgIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGJcbiAgIHRoZW4gdXNlIHshZnByaW50ZiBwcGZ9IGFzIHVzdWFsLiAqKVxubGV0IGJwcmludGYgYiAoRm9ybWF0IChmbXQsIF8pIDogKCdhLCBmb3JtYXR0ZXIsIHVuaXQpIGZvcm1hdCkgPVxuICBsZXQgayBwcGYgYWNjID0gb3V0cHV0X2FjYyBwcGYgYWNjOyBwcF9mbHVzaF9xdWV1ZSBwcGYgZmFsc2UgaW5cbiAgbWFrZV9wcmludGYgayAoZm9ybWF0dGVyX29mX2J1ZmZlciBiKSBFbmRfb2ZfYWNjIGZtdFxuXG5cbigqIERlcHJlY2F0ZWQgOiBhbGlhcyBmb3Iga3NwcmludGYuICopXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG4oKiBhbGlhcyB0byBhdm9pZCB3YXJuaW5nIGZvciBhbWJpZ3VpdHkgYmV0d2VlblxuICAgUGVydmFzaXZlcy5mb3JtYXQ2XG4gICBhbmQgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDZcblxuICAgKHRoZSBmb3JtZXIgaXMgaW4gZmFjdCBhbiBhbGlhcyBmb3IgdGhlIGxhdHRlcixcbiAgICBidXQgdGhlIGFtYmlndWl0eSB3YXJuaW5nIGRvZXNuJ3QgY2FyZSlcbiopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID1cbiAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIFBlcnZhc2l2ZXMuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIFtzdGRpYl0gaXMgZXF1aXZhbGVudCB0byBbU2Nhbm5pbmcuZnJvbV9jaGFubmVsIFBlcnZhc2l2ZXMuc3RkaW5dLiAqKVxuXG4gIHZhbCBzdGRpYiA6IGluX2NoYW5uZWxcbiAgKCogQW4gYWxpYXMgZm9yIFtTY2FuZi5zdGRpbl0sIHRoZSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBmcm9tXG4gICAgIFtQZXJ2YXNpdmVzLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBQZXJ2YXNpdmVzLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuXG4gIHZhbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdFxuXG4gIHZhbCBtZW1vX2Zyb21fY2hhbm5lbCA6IFBlcnZhc2l2ZXMuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG4gICgqIE9ic29sZXRlLiAqKVxuXG5lbmRcblxuXG5tb2R1bGUgU2Nhbm5pbmcgOiBTQ0FOTklORyA9IHN0cnVjdFxuXG4gICgqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FuZi4gKilcblxuICB0eXBlIGZpbGVfbmFtZSA9IHN0cmluZ1xuXG4gIHR5cGUgaW5fY2hhbm5lbF9uYW1lID1cbiAgICB8IEZyb21fY2hhbm5lbCBvZiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBQZXJ2YXNpdmVzLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZnVuY3Rpb25cbiAgICB8IEZyb21fc3RyaW5nXG5cblxuICB0eXBlIGluX2NoYW5uZWwgPSB7XG4gICAgbXV0YWJsZSBpY19lb2YgOiBib29sO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyIDogY2hhcjtcbiAgICBtdXRhYmxlIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jaGFyX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfbGluZV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGljX3Rva2VuX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfZ2V0X25leHRfY2hhciA6IHVuaXQgLT4gY2hhcjtcbiAgICBpY190b2tlbl9idWZmZXIgOiBCdWZmZXIudDtcbiAgICBpY19pbnB1dF9uYW1lIDogaW5fY2hhbm5lbF9uYW1lO1xuICB9XG5cblxuICB0eXBlIHNjYW5idWYgPSBpbl9jaGFubmVsXG5cbiAgbGV0IG51bGxfY2hhciA9ICdcXDAwMCdcblxuICAoKiBSZWFkcyBhIG5ldyBjaGFyYWN0ZXIgZnJvbSBpbnB1dCBidWZmZXIuXG4gICAgIE5leHRfY2hhciBuZXZlciBmYWlscywgZXZlbiBpbiBjYXNlIG9mIGVuZCBvZiBpbnB1dDpcbiAgICAgaXQgdGhlbiBzaW1wbHkgc2V0cyB0aGUgZW5kIG9mIGZpbGUgY29uZGl0aW9uLiAqKVxuICBsZXQgbmV4dF9jaGFyIGliID1cbiAgICB0cnlcbiAgICAgIGxldCBjID0gaWIuaWNfZ2V0X25leHRfY2hhciAoKSBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gdHJ1ZTtcbiAgICAgIGliLmljX2NoYXJfY291bnQgPC0gc3VjYyBpYi5pY19jaGFyX2NvdW50O1xuICAgICAgaWYgYyA9ICdcXG4nIHRoZW4gaWIuaWNfbGluZV9jb3VudCA8LSBzdWNjIGliLmljX2xpbmVfY291bnQ7XG4gICAgICBjIHdpdGhcbiAgICB8IEVuZF9vZl9maWxlIC0+XG4gICAgICBsZXQgYyA9IG51bGxfY2hhciBpblxuICAgICAgaWIuaWNfY3VycmVudF9jaGFyIDwtIGM7XG4gICAgICBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2U7XG4gICAgICBpYi5pY19lb2YgPC0gdHJ1ZTtcbiAgICAgIGNcblxuXG4gIGxldCBwZWVrX2NoYXIgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY3VycmVudF9jaGFyXG4gICAgZWxzZSBuZXh0X2NoYXIgaWJcblxuXG4gICgqIFJldHVybnMgYSB2YWxpZCBjdXJyZW50IGNoYXIgZm9yIHRoZSBpbnB1dCBidWZmZXIuIEluIHBhcnRpY3VsYXJcbiAgICAgbm8gaXJyZWxldmFudCBudWxsIGNoYXJhY3RlciAoYXMgc2V0IGJ5IFtuZXh0X2NoYXJdIGluIGNhc2Ugb2YgZW5kXG4gICAgIG9mIGlucHV0KSBpcyByZXR1cm5lZCwgc2luY2UgW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlblxuICAgICBbbmV4dF9jaGFyXSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24gd2hpbGUgdHJ5aW5nIHRvIHJlYWQgYVxuICAgICBuZXcgY2hhcmFjdGVyLiAqKVxuICBsZXQgY2hlY2tlZF9wZWVrX2NoYXIgaWIgPVxuICAgIGxldCBjID0gcGVla19jaGFyIGliIGluXG4gICAgaWYgaWIuaWNfZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGU7XG4gICAgY1xuXG5cbiAgbGV0IGVuZF9vZl9pbnB1dCBpYiA9XG4gICAgaWdub3JlIChwZWVrX2NoYXIgaWIpO1xuICAgIGliLmljX2VvZlxuXG5cbiAgbGV0IGVvZiBpYiA9IGliLmljX2VvZlxuXG4gIGxldCBiZWdpbm5pbmdfb2ZfaW5wdXQgaWIgPSBpYi5pY19jaGFyX2NvdW50ID0gMFxuXG4gIGxldCBuYW1lX29mX2lucHV0IGliID1cbiAgICBtYXRjaCBpYi5pY19pbnB1dF9uYW1lIHdpdGhcbiAgICB8IEZyb21fY2hhbm5lbCBfaWMgLT4gXCJ1bm5hbWVkIFBlcnZhc2l2ZXMgaW5wdXQgY2hhbm5lbFwiXG4gICAgfCBGcm9tX2ZpbGUgKGZuYW1lLCBfaWMpIC0+IGZuYW1lXG4gICAgfCBGcm9tX2Z1bmN0aW9uIC0+IFwidW5uYW1lZCBmdW5jdGlvblwiXG4gICAgfCBGcm9tX3N0cmluZyAtPiBcInVubmFtZWQgY2hhcmFjdGVyIHN0cmluZ1wiXG5cblxuICBsZXQgY2hhcl9jb3VudCBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jaGFyX2NvdW50IC0gMVxuICAgIGVsc2UgaWIuaWNfY2hhcl9jb3VudFxuXG5cbiAgbGV0IGxpbmVfY291bnQgaWIgPSBpYi5pY19saW5lX2NvdW50XG5cbiAgbGV0IHJlc2V0X3Rva2VuIGliID0gQnVmZmVyLnJlc2V0IGliLmljX3Rva2VuX2J1ZmZlclxuXG4gIGxldCBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiA9IGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZVxuXG4gIGxldCB0b2tlbiBpYiA9XG4gICAgbGV0IHRva2VuX2J1ZmZlciA9IGliLmljX3Rva2VuX2J1ZmZlciBpblxuICAgIGxldCB0b2sgPSBCdWZmZXIuY29udGVudHMgdG9rZW5fYnVmZmVyIGluXG4gICAgQnVmZmVyLmNsZWFyIHRva2VuX2J1ZmZlcjtcbiAgICBpYi5pY190b2tlbl9jb3VudCA8LSBzdWNjIGliLmljX3Rva2VuX2NvdW50O1xuICAgIHRva1xuXG5cbiAgbGV0IHRva2VuX2NvdW50IGliID0gaWIuaWNfdG9rZW5fY291bnRcblxuICBsZXQgc2tpcF9jaGFyIHdpZHRoIGliID1cbiAgICBpbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjtcbiAgICB3aWR0aFxuXG5cbiAgbGV0IGlnbm9yZV9jaGFyIHdpZHRoIGliID0gc2tpcF9jaGFyICh3aWR0aCAtIDEpIGliXG5cbiAgbGV0IHN0b3JlX2NoYXIgd2lkdGggaWIgYyA9XG4gICAgQnVmZmVyLmFkZF9jaGFyIGliLmljX3Rva2VuX2J1ZmZlciBjO1xuICAgIGlnbm9yZV9jaGFyIHdpZHRoIGliXG5cblxuICBsZXQgZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSA9IDEwMjRcblxuICBsZXQgY3JlYXRlIGluYW1lIG5leHQgPSB7XG4gICAgaWNfZW9mID0gZmFsc2U7XG4gICAgaWNfY3VycmVudF9jaGFyID0gbnVsbF9jaGFyO1xuICAgIGljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA9IGZhbHNlO1xuICAgIGljX2NoYXJfY291bnQgPSAwO1xuICAgIGljX2xpbmVfY291bnQgPSAwO1xuICAgIGljX3Rva2VuX2NvdW50ID0gMDtcbiAgICBpY19nZXRfbmV4dF9jaGFyID0gbmV4dDtcbiAgICBpY190b2tlbl9idWZmZXIgPSBCdWZmZXIuY3JlYXRlIGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemU7XG4gICAgaWNfaW5wdXRfbmFtZSA9IGluYW1lO1xuICB9XG5cblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA+PSBsZW4gdGhlbiByYWlzZSBFbmRfb2ZfZmlsZSBlbHNlXG4gICAgICBsZXQgYyA9IHMuWyFpXSBpblxuICAgICAgaW5jciBpO1xuICAgICAgYyBpblxuICAgIGNyZWF0ZSBGcm9tX3N0cmluZyBuZXh0XG5cblxuICBsZXQgZnJvbV9mdW5jdGlvbiA9IGNyZWF0ZSBGcm9tX2Z1bmN0aW9uXG5cbiAgKCogU2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsLiAqKVxuXG4gICgqIFBvc2l0aW9uIG9mIHRoZSBwcm9ibGVtOlxuXG4gICAgIFdlIGNhbm5vdCBwcmV2ZW50IHRoZSBzY2FubmluZyBtZWNoYW5pc20gdG8gdXNlIG9uZSBsb29rYWhlYWQgY2hhcmFjdGVyLFxuICAgICBpZiBuZWVkZWQgYnkgdGhlIHNlbWFudGljcyBvZiB0aGUgZm9ybWF0IHN0cmluZyBzcGVjaWZpY2F0aW9ucyAoZS5nLiBhXG4gICAgIHRyYWlsaW5nICdza2lwIHNwYWNlJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBmb3JtYXQgc3RyaW5nKTsgaW4gdGhpcyBjYXNlLFxuICAgICB0aGUgbWFuZGF0b3J5IGxvb2thaGVhZCBjaGFyYWN0ZXIgaXMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgaW5wdXQgYW5kIG5vdFxuICAgICB1c2VkIHRvIHJldHVybiB0aGUgdG9rZW4gcmVhZC4gSXQgaXMgdGh1cyBtYW5kYXRvcnkgdG8gYmUgYWJsZSB0byBzdG9yZVxuICAgICBhbiB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBzb21ld2hlcmUgdG8gZ2V0IGl0IGFzIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAgICAgb2YgdGhlIG5leHQgc2Nhbi5cblxuICAgICBUbyBjaXJjdW12ZW50IHRoaXMgcHJvYmxlbSwgYWxsIHRoZSBzY2FubmluZyBmdW5jdGlvbnMgZ2V0IGEgbG93IGxldmVsXG4gICAgIGlucHV0IGJ1ZmZlciBhcmd1bWVudCB3aGVyZSB0aGV5IHN0b3JlIHRoZSBsb29rYWhlYWQgY2hhcmFjdGVyIHdoZW5cbiAgICAgbmVlZGVkOyBhZGRpdGlvbmFsbHksIHRoZSBpbnB1dCBidWZmZXIgaXMgdGhlIG9ubHkgc291cmNlIG9mIGNoYXJhY3RlciBvZlxuICAgICBhIHNjYW5uZXIuIFRoZSBbc2NhbmJ1Zl0gaW5wdXQgYnVmZmVycyBhcmUgZGVmaW5lZCBpbiBtb2R1bGUgeyFTY2FubmluZ30uXG5cbiAgICAgTm93IHdlIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRoYXQgcmVsYXRlZCBhbmRcbiAgICAgc3VjY2Vzc2l2ZSBjYWxscyB0byBzY2FubmVycyBpbmRlZWQgcmVhZCBmcm9tIHRoZSBzYW1lIGlucHV0IGJ1ZmZlci5cbiAgICAgSW4gZWZmZWN0LCBpZiBhIHNjYW5uZXIgW3NjYW4xXSBpcyByZWFkaW5nIGZyb20gW2liMV0gYW5kIHN0b3JlcyBhblxuICAgICB1bnVzZWQgbG9va2FoZWFkIGNoYXJhY3RlciBbYzFdIGludG8gaXRzIGlucHV0IGJ1ZmZlciBbaWIxXSwgdGhlblxuICAgICBhbm90aGVyIHNjYW5uZXIgW3NjYW4yXSBub3QgcmVhZGluZyBmcm9tIHRoZSBzYW1lIGJ1ZmZlciBbaWIxXSB3aWxsIG1pc3NcbiAgICAgdGhlIGNoYXJhY3RlciBbYzFdLCBzZWVtaW5nbHkgdmFuaXNoZWQgaW4gdGhlIGFpciBmcm9tIHRoZSBwb2ludCBvZiB2aWV3XG4gICAgIG9mIFtzY2FuMl0uXG5cbiAgICAgVGhpcyBtZWNoYW5pc20gd29ya3MgcGVyZmVjdGx5IHRvIHJlYWQgZnJvbSBzdHJpbmdzLCBmcm9tIGZpbGVzLCBhbmQgZnJvbVxuICAgICBmdW5jdGlvbnMsIHNpbmNlIGluIHRob3NlIGNhc2VzLCBhbGxvY2F0aW5nIHR3byBidWZmZXJzIHJlYWRpbmcgZnJvbSB0aGVcbiAgICAgc2FtZSBzb3VyY2UgaXMgdW5uYXR1cmFsLlxuXG4gICAgIFN0aWxsLCB0aGVyZSBpcyBhIGRpZmZpY3VsdHkgaW4gdGhlIGNhc2Ugb2Ygc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dFxuICAgICBjaGFubmVsLiBJbiBlZmZlY3QsIHdoZW4gc2Nhbm5pbmcgZnJvbSBhbiBpbnB1dCBjaGFubmVsIFtpY10sIHRoaXMgY2hhbm5lbFxuICAgICBtYXkgbm90IGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB3aXRoaW4gdGhpcyBsaWJyYXJ5LiBIZW5jZSwgaXQgbWF5IGJlXG4gICAgIHNoYXJlZCAodHdvIGZ1bmN0aW9ucyBvZiB0aGUgdXNlcidzIHByb2dyYW0gbWF5IHN1Y2Nlc3NpdmVseSByZWFkIGZyb21cbiAgICAgW2ljXSkuIFRoaXMgaXMgaGlnaGx5IGVycm9yIHByb25lIHNpbmNlLCBvbmUgb2YgdGhlIGZ1bmN0aW9uIG1heSBzZWVrIHRoZVxuICAgICBpbnB1dCBjaGFubmVsLCB3aGlsZSB0aGUgb3RoZXIgZnVuY3Rpb24gaGFzIHN0aWxsIGFuIHVudXNlZCBsb29rYWhlYWRcbiAgICAgY2hhcmFjdGVyIGluIGl0cyBpbnB1dCBidWZmZXIuIEluIGNvbmNsdXNpb24sIHlvdSBzaG91bGQgbmV2ZXIgbWl4IGRpcmVjdFxuICAgICBsb3cgbGV2ZWwgcmVhZGluZyBhbmQgaGlnaCBsZXZlbCBzY2FubmluZyBmcm9tIHRoZSBzYW1lIGlucHV0IGNoYW5uZWwuXG5cbiAgKilcblxuICAoKiBQZXJmb3JtIGJ1ZmZlcml6ZWQgaW5wdXQgdG8gaW1wcm92ZSBlZmZpY2llbmN5LiAqKVxuICBsZXQgZmlsZV9idWZmZXJfc2l6ZSA9IHJlZiAxMDI0XG5cbiAgKCogVGhlIHNjYW5uZXIgY2xvc2VzIHRoZSBpbnB1dCBjaGFubmVsIGF0IGVuZCBvZiBpbnB1dC4gKilcbiAgbGV0IHNjYW5fY2xvc2VfYXRfZW5kIGljID0gUGVydmFzaXZlcy5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl0uXG4gICAgIE9uZSBjb3VsZCB0cnkgdG8gZGVmaW5lIFtzdGRpYl0gYXMgYSBzY2FubmluZyBidWZmZXIgcmVhZGluZyBhIGNoYXJhY3RlclxuICAgICBhdCBhIHRpbWUgKG5vIGJ1ZmZlcml6YXRpb24gYXQgYWxsKSwgYnV0IHVuZm9ydHVuYXRlbHkgdGhlIHRvcC1sZXZlbFxuICAgICBpbnRlcmFjdGlvbiB3b3VsZCBiZSB3cm9uZy4gVGhpcyBpcyBkdWUgdG8gc29tZSBraW5kIG9mXG4gICAgICdyYWNlIGNvbmRpdGlvbicgd2hlbiByZWFkaW5nIGZyb20gW1BlcnZhc2l2ZXMuc3RkaW5dLFxuICAgICBzaW5jZSB0aGUgaW50ZXJhY3RpdmUgY29tcGlsZXIgYW5kIFtTY2FuZi5zY2FuZl0gd2lsbCBzaW11bHRhbmVvdXNseVxuICAgICByZWFkIHRoZSBtYXRlcmlhbCB0aGV5IG5lZWQgZnJvbSBbUGVydmFzaXZlcy5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFBlcnZhc2l2ZXMuc3RkaW4pKSBQZXJ2YXNpdmVzLnN0ZGluXG5cblxuICBsZXQgc3RkaWIgPSBzdGRpblxuXG4gIGxldCBvcGVuX2luX2ZpbGUgb3Blbl9pbiBmbmFtZSA9XG4gICAgbWF0Y2ggZm5hbWUgd2l0aFxuICAgIHwgXCItXCIgLT4gc3RkaW5cbiAgICB8IGZuYW1lIC0+XG4gICAgICBsZXQgaWMgPSBvcGVuX2luIGZuYW1lIGluXG4gICAgICBmcm9tX2ljX2Nsb3NlX2F0X2VuZCAoRnJvbV9maWxlIChmbmFtZSwgaWMpKSBpY1xuXG5cbiAgbGV0IG9wZW5faW4gPSBvcGVuX2luX2ZpbGUgUGVydmFzaXZlcy5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBQZXJ2YXNpdmVzLm9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fZmlsZSA9IG9wZW5faW5cbiAgbGV0IGZyb21fZmlsZV9iaW4gPSBvcGVuX2luX2JpblxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIGZyb21faWNfcmFpc2VfYXRfZW5kIChGcm9tX2NoYW5uZWwgaWMpIGljXG5cblxuICBsZXQgY2xvc2VfaW4gaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIGljIC0+XG4gICAgICBQZXJ2YXNpdmVzLmNsb3NlX2luIGljXG4gICAgfCBGcm9tX2ZpbGUgKF9mbmFtZSwgaWMpIC0+IFBlcnZhc2l2ZXMuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbUGVydmFzaXZlcy5pbl9jaGFubmVsXS5cbiAgICAgVGhpcyBmdW5jdGlvbiB3YXMgdXNlZCB0byB0cnkgdG8gcHJlc2VydmUgdGhlIHNjYW5uaW5nXG4gICAgIHNlbWFudGljcyBmb3IgdGhlIChub3cgb2Jzb2xldGUpIGZ1bmN0aW9uIFtmc2NhbmZdLlxuICAgICBHaXZlbiB0aGF0IGFsbCBzY2FubmVyIG11c3QgcmVhZCBmcm9tIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdIHNjYW5uaW5nXG4gICAgIGJ1ZmZlciwgW2ZzY2FuZl0gbXVzdCByZWFkIGZyb20gb25lIVxuICAgICBNb3JlIHByZWNpc2VseSwgZ2l2ZW4gW2ljXSwgYWxsIHN1Y2Nlc3NpdmUgY2FsbHMgW2ZzY2FuZiBpY10gbXVzdCByZWFkXG4gICAgIGZyb20gdGhlIHNhbWUgc2Nhbm5pbmcgYnVmZmVyLlxuICAgICBUaGlzIG9ibGlnZWQgdGhpcyBsaWJyYXJ5IHRvIGFsbG9jYXRlZCBzY2FubmluZyBidWZmZXJzIHRoYXQgd2VyZVxuICAgICBub3QgcHJvcGVybHkgZ2FyYmFnZSBjb2xsZWN0YWJsZSwgaGVuY2UgbGVhZGluZyB0byBtZW1vcnkgbGVha3MuXG4gICAgIElmIHlvdSBuZWVkIHRvIHJlYWQgZnJvbSBhIFtQZXJ2YXNpdmVzLmluX2NoYW5uZWxdIGlucHV0IGNoYW5uZWxcbiAgICAgW2ljXSwgc2ltcGx5IGRlZmluZSBhIFtTY2FubmluZy5pbl9jaGFubmVsXSBmb3JtYXR0ZWQgaW5wdXQgY2hhbm5lbCBhcyBpblxuICAgICBbbGV0IGliID0gU2Nhbm5pbmcuZnJvbV9jaGFubmVsIGljXSwgdGhlbiB1c2UgW1NjYW5mLmJzY2FuZiBpYl0gYXMgdXN1YWwuXG4gICopXG4gIGxldCBtZW1vX2Zyb21faWMgPVxuICAgIGxldCBtZW1vID0gcmVmIFtdIGluXG4gICAgKGZ1biBzY2FuX2Nsb3NlX2ljIGljIC0+XG4gICAgIHRyeSBMaXN0LmFzc3EgaWMgIW1lbW8gd2l0aFxuICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgIGxldCBpYiA9XG4gICAgICAgICBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgKEZyb21fY2hhbm5lbCBpYykgaWMgaW5cbiAgICAgICBtZW1vIDo9IChpYywgaWIpIDo6ICFtZW1vO1xuICAgICAgIGliKVxuXG5cbiAgKCogT2Jzb2xldGU6IHNlZSB7IW1lbW9fZnJvbV9pY30gYWJvdmUuICopXG4gIGxldCBtZW1vX2Zyb21fY2hhbm5lbCA9IG1lbW9fZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuXG5lbmRcblxuXG4oKiBGb3JtYXR0ZWQgaW5wdXQgZnVuY3Rpb25zLiAqKVxuXG50eXBlICgnYSwgJ2IsICdjLCAnZCkgc2Nhbm5lciA9XG4gICAgICgnYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgJ2IsICdjLCAnYSAtPiAnZCwgJ2QpIGZvcm1hdDYgLT4gJ2NcblxuXG4oKiBSZXBvcnRpbmcgZXJyb3JzLiAqKVxuZXhjZXB0aW9uIFNjYW5fZmFpbHVyZSBvZiBzdHJpbmdcblxubGV0IGJhZF9pbnB1dCBzID0gcmFpc2UgKFNjYW5fZmFpbHVyZSBzKVxuXG5sZXQgYmFkX2lucHV0X2VzY2FwZSBjID1cbiAgYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImlsbGVnYWwgZXNjYXBlIGNoYXJhY3RlciAlQ1wiIGMpXG5cblxubGV0IGJhZF90b2tlbl9sZW5ndGggbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICB0aGUgc3BlY2lmaWVkIGxlbmd0aCB3YXMgdG9vIHNob3J0IGZvciB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlID1cbiAgYmFkX2lucHV0XG4gICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgXCJzY2FubmluZyBvZiAlcyBmYWlsZWQ6IFxcXG4gICAgICAgIHByZW1hdHVyZSBlbmQgb2YgZmlsZSBvY2N1cnJlZCBiZWZvcmUgZW5kIG9mIHRva2VuXCJcbiAgICAgICBtZXNzYWdlKVxuXG5cbmxldCBiYWRfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJubyBkb3Qgb3IgZXhwb25lbnQgcGFydCBmb3VuZCBpbiBmbG9hdCB0b2tlblwiXG5cblxubGV0IGJhZF9oZXhfZmxvYXQgKCkgPVxuICBiYWRfaW5wdXQgXCJub3QgYSB2YWxpZCBmbG9hdCBpbiBoZXhhZGVjaW1hbCBub3RhdGlvblwiXG5cblxubGV0IGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSA9XG4gIFByaW50Zi5zcHJpbnRmIFwibG9va2luZyBmb3IgJUMsIGZvdW5kICVDXCIgYyBjaVxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaSA9XG4gIGJhZF9pbnB1dCAoY2hhcmFjdGVyX21pc21hdGNoX2VyciBjIGNpKVxuXG5cbmxldCByZWMgc2tpcF93aGl0ZXMgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBub3QgKFNjYW5uaW5nLmVvZiBpYikgdGhlbiBiZWdpblxuICAgIG1hdGNoIGMgd2l0aFxuICAgIHwgJyAnIHwgJ1xcdCcgfCAnXFxuJyB8ICdcXHInIC0+XG4gICAgICBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYjsgc2tpcF93aGl0ZXMgaWJcbiAgICB8IF8gLT4gKClcbiAgZW5kXG5cblxuKCogQ2hlY2tpbmcgdGhhdCBbY10gaXMgaW5kZWVkIGluIHRoZSBpbnB1dCwgdGhlbiBza2lwcyBpdC5cbiAgIEluIHRoaXMgY2FzZSwgdGhlIGNoYXJhY3RlciBbY10gaGFzIGJlZW4gZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlXG4gICBmb3JtYXQgYXMgYmVpbmcgbWFuZGF0b3J5IGluIHRoZSBpbnB1dDsgaGVuY2Ugd2Ugc2hvdWxkIGZhaWwgd2l0aFxuICAgW0VuZF9vZl9maWxlXSBpbiBjYXNlIG9mIGVuZF9vZl9pbnB1dC5cbiAgIChSZW1lbWJlciB0aGF0IFtTY2FuX2ZhaWx1cmVdIGlzIHJhaXNlZCBvbmx5IHdoZW4gKHdlIGNhbiBwcm92ZSBieVxuICAgZXZpZGVuY2UpIHRoYXQgdGhlIGlucHV0IGRvZXMgbm90IG1hdGNoIHRoZSBmb3JtYXQgc3RyaW5nIGdpdmVuLiBXZSBtdXN0XG4gICB0aHVzIGRpZmZlcmVudGlhdGUgW0VuZF9vZl9maWxlXSBhcyBhbiBlcnJvciBkdWUgdG8gbGFjayBvZiBpbnB1dCwgYW5kXG4gICBbU2Nhbl9mYWlsdXJlXSB3aGljaCBpcyBkdWUgdG8gcHJvdmFibHkgd3JvbmcgaW5wdXQuIEkgYW0gbm90IHN1cmUgdGhpcyBpc1xuICAgd29ydGggdGhlIGJ1cmRlbjogaXQgaXMgY29tcGxleCBhbmQgc29tZWhvdyBzdWJsaW1pbmFsOyBzaG91bGQgYmUgY2xlYXJlclxuICAgdG8gZmFpbCB3aXRoIFNjYW5fZmFpbHVyZSBcIk5vdCBlbm91Z2ggaW5wdXQgdG8gY29tcGxldGUgc2Nhbm5pbmdcIiEpXG5cbiAgIFRoYXQncyB3aHksIHdhaXRpbmcgZm9yIGEgYmV0dGVyIHNvbHV0aW9uLCB3ZSB1c2UgY2hlY2tlZF9wZWVrX2NoYXIgaGVyZS5cbiAgIFdlIGFyZSBhbHNvIGNhcmVmdWwgdG8gdHJlYXQgXCJcXHJcXG5cIiBpbiB0aGUgaW5wdXQgYXMgYW4gZW5kIG9mIGxpbmUgbWFya2VyOlxuICAgaXQgYWx3YXlzIG1hdGNoZXMgYSAnXFxuJyBzcGVjaWZpY2F0aW9uIGluIHRoZSBpbnB1dCBmb3JtYXQgc3RyaW5nLiAqKVxubGV0IHJlYyBjaGVja19jaGFyIGliIGMgPVxuICBtYXRjaCBjIHdpdGhcbiAgfCAnICcgLT4gc2tpcF93aGl0ZXMgaWJcbiAgfCAnXFxuJyAtPiBjaGVja19uZXdsaW5lIGliXG4gIHwgYyAtPiBjaGVja190aGlzX2NoYXIgaWIgY1xuXG5hbmQgY2hlY2tfdGhpc19jaGFyIGliIGMgPVxuICBsZXQgY2kgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICBpZiBjaSA9IGMgdGhlbiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYiBlbHNlXG4gIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cbmFuZCBjaGVja19uZXdsaW5lIGliID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggY2kgd2l0aFxuICB8ICdcXG4nIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gIHwgJ1xccicgLT4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IGNoZWNrX3RoaXNfY2hhciBpYiAnXFxuJ1xuICB8IF8gLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXG4nIGNpXG5cblxuKCogRXh0cmFjdGluZyB0b2tlbnMgZnJvbSB0aGUgb3V0cHV0IHRva2VuIGJ1ZmZlci4gKilcblxubGV0IHRva2VuX2NoYXIgaWIgPSAoU2Nhbm5pbmcudG9rZW4gaWIpLlswXVxuXG5sZXQgdG9rZW5fc3RyaW5nID0gU2Nhbm5pbmcudG9rZW5cblxubGV0IHRva2VuX2Jvb2wgaWIgPVxuICBtYXRjaCBTY2FubmluZy50b2tlbiBpYiB3aXRoXG4gIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICB8IFwiZmFsc2VcIiAtPiBmYWxzZVxuICB8IHMgLT4gYmFkX2lucHV0IChQcmludGYuc3ByaW50ZiBcImludmFsaWQgYm9vbGVhbiAnJXMnXCIgcylcblxuXG4oKiBUaGUgdHlwZSBvZiBpbnRlZ2VyIGNvbnZlcnNpb25zLiAqKVxudHlwZSBpbnRlZ2VyX2NvbnZlcnNpb24gPVxuICB8IEJfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBiaW5hcnkgY29udmVyc2lvbiAqKVxuICB8IERfY29udmVyc2lvbiAoKiBTaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgSV9jb252ZXJzaW9uICgqIFNpZ25lZCBpbnRlZ2VyIGNvbnZlcnNpb24gKilcbiAgfCBPX2NvbnZlcnNpb24gKCogVW5zaWduZWQgb2N0YWwgY29udmVyc2lvbiAqKVxuICB8IFVfY29udmVyc2lvbiAoKiBVbnNpZ25lZCBkZWNpbWFsIGNvbnZlcnNpb24gKilcbiAgfCBYX2NvbnZlcnNpb24gKCogVW5zaWduZWQgaGV4YWRlY2ltYWwgY29udmVyc2lvbiAqKVxuXG5cbmxldCBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciA9IGZ1bmN0aW9uXG4gIHwgJ2InIC0+IEJfY29udmVyc2lvblxuICB8ICdkJyAtPiBEX2NvbnZlcnNpb25cbiAgfCAnaScgLT4gSV9jb252ZXJzaW9uXG4gIHwgJ28nIC0+IE9fY29udmVyc2lvblxuICB8ICd1JyAtPiBVX2NvbnZlcnNpb25cbiAgfCAneCcgfCAnWCcgLT4gWF9jb252ZXJzaW9uXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuXG4oKiBFeHRyYWN0IGFuIGludGVnZXIgbGl0ZXJhbCB0b2tlbi5cbiAgIFNpbmNlIHRoZSBmdW5jdGlvbnMgUGVydmFzaXZlcy4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoRmxvYXRfRiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKEZsb2F0X2YgfCBGbG9hdF9wZiB8IEZsb2F0X3NmIHwgRmxvYXRfZSB8IEZsb2F0X3BlIHwgRmxvYXRfc2VcbiAgICAgICAgICAgICAgIHwgRmxvYXRfRSB8IEZsb2F0X3BFIHwgRmxvYXRfc0UgfCBGbG9hdF9nIHwgRmxvYXRfcGcgfCBGbG9hdF9zZ1xuICAgICAgICAgICAgICAgfCBGbG9hdF9HIHwgRmxvYXRfcEcgfCBGbG9hdF9zRyksIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9mbG9hdCB0b2tlbl9mbG9hdFxuICB8IEZsb2F0ICgoRmxvYXRfaCB8IEZsb2F0X3BoIHwgRmxvYXRfc2ggfCBGbG9hdF9IIHwgRmxvYXRfcEggfCBGbG9hdF9zSCksXG4gICAgICAgICAgIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2Nhbl9oZXhfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gXyBfIGliID0gc2Nhbl9ib29sIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9ib29sXG4gIHwgQWxwaGEgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlYVxcXCJcIlxuICB8IFRoZXRhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJXRcXFwiXCJcbiAgfCBDdXN0b20gXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlP1xcXCIgKGN1c3RvbSBjb252ZXJ0ZXIpXCJcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBiZWdpbiBtYXRjaCByZWFkZXJzIHdpdGhcbiAgICB8IENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSAtPlxuICAgICAgICBsZXQgeCA9IHJlYWRlciBpYiBpblxuICAgICAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdF9yZXN0IHJlYWRlcnNfcmVzdClcbiAgICB8IE5pbCAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBtaXNzaW5nIHJlYWRlclwiXG4gICAgZW5kXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIGlmIFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gICAgZWxzZSBiYWRfaW5wdXQgXCJlbmQgb2YgaW5wdXQgbm90IGZvdW5kXCJcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIHN0cjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgY2hyO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG5cbiAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgXyA9IHNjYW5fY2FtbF9zdHJpbmcgKHdpZHRoX29mX3BhZF9vcHQgcGFkX29wdCkgaWIgaW5cbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm10dHkgcyBmbXR0eVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChmbXQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10LCBmbXQnID1cbiAgICAgIHRyeVxuICAgICAgICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdCcgPSBmbXRfZWJiX29mX3N0cmluZyBzIGluXG4gICAgICAgICgqIFRPRE86IGZpbmQgYSB3YXkgdG8gYXZvaWQgcmVwYXJzaW5nIHR3aWNlICopXG5cbiAgICAgICAgKCogVE9ETzogdGhlc2UgdHlwZS1jaGVja3MgYmVsb3cgKmNhbiogZmFpbCBiZWNhdXNlIG9mIHR5cGVcbiAgICAgICAgICAgYW1iaWd1aXR5IGluIHByZXNlbmNlIG9mIGlnbm9yZWQtcmVhZGVyczogXCIlX3IlZFwiIGFuZCBcIiVkJV9yXCJcbiAgICAgICAgICAgYXJlIHR5cGVkIGluIHRoZSBzYW1lIHdheS5cblxuICAgICAgICAgICAjIFNjYW5mLnNzY2FuZiBcIlxcXCIlX3IlZFxcXCIzXCIgXCIlKCVkJV9yJSlcIiBpZ25vcmVcbiAgICAgICAgICAgICAoZnVuIGZtdCBuIC0+IHN0cmluZ19vZl9mb3JtYXQgZm10LCBuKVxuICAgICAgICAgICBFeGNlcHRpb246IENhbWxpbnRlcm5hbEZvcm1hdC5UeXBlX21pc21hdGNoLlxuXG4gICAgICAgICAgIFdlIHNob3VsZCBwcm9wZXJseSBjYXRjaCB0aGlzIGV4Y2VwdGlvbi5cbiAgICAgICAgKilcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10IChlcmFzZV9yZWwgZm10dHkpLFxuICAgICAgICB0eXBlX2Zvcm1hdCBmbXQnIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKVxuICAgICAgd2l0aCBGYWlsdXJlIG1zZyAtPiBiYWRfaW5wdXQgbXNnXG4gICAgaW5cbiAgICBDb25zIChGb3JtYXQgKGZtdCwgcyksXG4gICAgICAgICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkpIC0+XG4gICAgbGV0IHN0cCwgc3RyID0gc3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgbGV0IHdpZHRoID0gd2lkdGhfb2ZfcGFkX29wdCB3aWR0aF9vcHQgaW5cbiAgICBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IChTb21lIHN0cCkgd2lkdGggaWI7XG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgc3RyX3Jlc3QgPSBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgc3RyX3Jlc3QgcmVhZGVycylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCBOb25lIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgQ29ucyAocywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICBsZXQgY291bnQgPSBnZXRfY291bnRlciBpYiBjb3VudGVyIGluXG4gICAgQ29ucyAoY291bnQsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIHJlc3QpIC0+XG4gICAgU3RyaW5nLml0ZXIgKGNoZWNrX2NoYXIgaWIpIChzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm9ybWF0dGluZ19saXQpO1xuICAgIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAneyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGNoZWNrX2NoYXIgaWIgJ0AnOyBjaGVja19jaGFyIGliICdbJztcbiAgICBtYWtlX3NjYW5mIGliIChjb25jYXRfZm10IGZtdCcgcmVzdCkgcmVhZGVyc1xuXG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAtPlxuICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICBiZWdpbiBtYXRjaCBtYWtlX3NjYW5mIGliIGZtdCcgcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChfLCBhcmdfcmVzdCkgLT4gYXJnX3Jlc3RcbiAgICB8IE5pbCAtPiBhc3NlcnQgZmFsc2VcbiAgICBlbmRcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBOaWxcblxuKCogQ2FzZSBhbmFseXNpcyBvbiBwYWRkaW5nIGFuZCBwcmVjaXNpb24uICopXG4oKiBSZWplY3QgZm9ybWF0cyBjb250YWluaW5nIFwiJSpcIiBvciBcIiUuKlwiLiAqKVxuKCogUGFzcyBwYWRkaW5nIGFuZCBwcmVjaXNpb24gdG8gdGhlIGdlbmVyaWMgc2Nhbm5lciBgc2NhbicuICopXG5hbmQgcGFkX3ByZWNfc2NhbmYgOiB0eXBlIGEgYyBkIGUgZiB4IHkgeiB0IC5cbiAgICBTY2FubmluZy5pbl9jaGFubmVsIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChkLCBlKSBoZXRlcl9saXN0IC0+ICh4LCB5KSBwYWRkaW5nIC0+ICh5LCB6IC0+IGEpIHByZWNpc2lvbiAtPlxuICAgICAgKGludCAtPiBpbnQgLT4gU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiB0KSAtPlxuICAgICAgKFNjYW5uaW5nLmluX2NoYW5uZWwgLT4geikgLT5cbiAgICAgICh4LCBmKSBoZXRlcl9saXN0ID1cbmZ1biBpYiBmbXQgcmVhZGVycyBwYWQgcHJlYyBzY2FuIHRva2VuIC0+IG1hdGNoIHBhZCwgcHJlYyB3aXRoXG4gIHwgTm9fcGFkZGluZywgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIG1heF9pbnQgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IHAgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgbWF4X2ludCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIHcpLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gdyBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKExlZnQsIF8pLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUtXFxcIlwiXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgXyksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcbiAgfCBBcmdfcGFkZGluZyBfLCBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgTm9fcGFkZGluZywgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgKCogRGVmaW5pbmcgW3NjYW5mXSBhbmQgdmFyaW91cyBmbGF2b3JzIG9mIFtzY2FuZl0gKilcblxudHlwZSAnYSBrc2NhbmZfcmVzdWx0ID0gQXJncyBvZiAnYSB8IEV4YyBvZiBleG5cblxubGV0IGtzY2FuZiBpYiBlZiAoRm9ybWF0IChmbXQsIHN0cikpID1cbiAgbGV0IHJlYyBhcHBseSA6IHR5cGUgYSBiIC4gYSAtPiAoYSwgYikgaGV0ZXJfbGlzdCAtPiBiID1cbiAgICBmdW4gZiBhcmdzIC0+IG1hdGNoIGFyZ3Mgd2l0aFxuICAgIHwgQ29ucyAoeCwgcikgLT4gYXBwbHkgKGYgeCkgclxuICAgIHwgTmlsIC0+IGZcbiAgaW5cbiAgbGV0IGsgcmVhZGVycyBmID1cbiAgICBTY2FubmluZy5yZXNldF90b2tlbiBpYjtcbiAgICBtYXRjaCB0cnkgQXJncyAobWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycykgd2l0aFxuICAgICAgfCAoU2Nhbl9mYWlsdXJlIF8gfCBGYWlsdXJlIF8gfCBFbmRfb2ZfZmlsZSkgYXMgZXhjIC0+IEV4YyBleGNcbiAgICAgIHwgSW52YWxpZF9hcmd1bWVudCBtc2cgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgKG1zZyBeIFwiIGluIGZvcm1hdCBcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzdHIgXiBcIlxcXCJcIilcbiAgICB3aXRoXG4gICAgICB8IEFyZ3MgYXJncyAtPiBhcHBseSBmIGFyZ3NcbiAgICAgIHwgRXhjIGV4YyAtPiBlZiBpYiBleGNcbiAgaW5cbiAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIGZtdFxuXG4oKioqKVxuXG5sZXQga2JzY2FuZiA9IGtzY2FuZlxubGV0IGJzY2FuZiBpYiBmbXQgPSBrYnNjYW5mIGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxubGV0IGtzc2NhbmYgcyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBlZiBmbXRcbmxldCBzc2NhbmYgcyBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBzY2FuZiBmbXQgPSBrc2NhbmYgU2Nhbm5pbmcuc3RkaWIgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG4oKioqKVxuXG4oKiBTY2FubmluZyBmb3JtYXQgc3RyaW5ncy4gKilcbmxldCBic2NhbmZfZm9ybWF0IDpcbiAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIGliIGZvcm1hdCBmIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nIG1heF9pbnQgaWIgaW5cbiAgICBsZXQgc3RyID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCcgPVxuICAgICAgdHJ5IGZvcm1hdF9vZl9zdHJpbmdfZm9ybWF0IHN0ciBmb3JtYXRcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZyBpblxuICAgIGYgZm10J1xuXG5cbmxldCBzc2NhbmZfZm9ybWF0IDpcbiAgc3RyaW5nIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+XG4gICgoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAnZykgLT4gJ2cgPVxuICBmdW4gcyBmb3JtYXQgZiAtPiBic2NhbmZfZm9ybWF0IChTY2FubmluZy5mcm9tX3N0cmluZyBzKSBmb3JtYXQgZlxuXG5cbmxldCBzdHJpbmdfdG9fU3RyaW5nIHMgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgKGwgKyAyKSBpblxuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcIic7XG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIGxldCBjID0gcy5baV0gaW5cbiAgICBpZiBjID0gJ1xcXCInIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXFwnO1xuICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gIGRvbmU7XG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoc3RyaW5nX3RvX1N0cmluZyBzKSBmbXQgKGZ1biB4IC0+IHgpXG5cblxubGV0IHVuZXNjYXBlZCBzID1cbiAgc3NjYW5mIChcIlxcXCJcIiBeIHMgXiBcIlxcXCJcIikgXCIlUyUhXCIgKGZ1biB4IC0+IHgpXG5cblxuKCogRGVwcmVjYXRlZCAqKVxubGV0IGtmc2NhbmYgaWMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIGVmIGZtdFxubGV0IGZzY2FuZiBpYyBmbXQgPSBrc2NhbmYgKFNjYW5uaW5nLm1lbW9fZnJvbV9jaGFubmVsIGljKSBzY2FuZl9iYWRfaW5wdXQgZm10XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFJlZ2lzdGVyaW5nIE9DYW1sIHZhbHVlcyB3aXRoIHRoZSBDIHJ1bnRpbWUgZm9yIGxhdGVyIGNhbGxiYWNrcyAqKVxuXG5leHRlcm5hbCByZWdpc3Rlcl9uYW1lZF92YWx1ZSA6IHN0cmluZyAtPiBPYmoudCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZVwiXG5cbmxldCByZWdpc3RlciBuYW1lIHYgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIChPYmoucmVwciB2KVxuXG5sZXQgcmVnaXN0ZXJfZXhjZXB0aW9uIG5hbWUgKGV4biA6IGV4bikgPVxuICBsZXQgZXhuID0gT2JqLnJlcHIgZXhuIGluXG4gIGxldCBzbG90ID0gaWYgT2JqLnRhZyBleG4gPSBPYmoub2JqZWN0X3RhZyB0aGVuIGV4biBlbHNlIE9iai5maWVsZCBleG4gMCBpblxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBuYW1lIHNsb3RcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgIEplcm9tZSBWb3VpbGxvbiwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBPYmpcblxuKCoqKiogT2JqZWN0IHJlcHJlc2VudGF0aW9uICoqKiopXG5cbmV4dGVybmFsIHNldF9pZDogJ2EgLT4gJ2EgPSBcImNhbWxfc2V0X29vX2lkXCIgW0BAbm9hbGxvY11cblxuKCoqKiogT2JqZWN0IGNvcHkgKioqKilcblxubGV0IGNvcHkgbyA9XG4gIGxldCBvID0gKE9iai5vYmogKE9iai5kdXAgKE9iai5yZXByIG8pKSkgaW5cbiAgc2V0X2lkIG9cblxuKCoqKiogQ29tcHJlc3Npb24gb3B0aW9ucyAqKioqKVxuKCogUGFyYW1ldGVycyAqKVxudHlwZSBwYXJhbXMgPSB7XG4gICAgbXV0YWJsZSBjb21wYWN0X3RhYmxlIDogYm9vbDtcbiAgICBtdXRhYmxlIGNvcHlfcGFyZW50IDogYm9vbDtcbiAgICBtdXRhYmxlIGNsZWFuX3doZW5fY29weWluZyA6IGJvb2w7XG4gICAgbXV0YWJsZSByZXRyeV9jb3VudCA6IGludDtcbiAgICBtdXRhYmxlIGJ1Y2tldF9zbWFsbF9zaXplIDogaW50XG4gIH1cblxubGV0IHBhcmFtcyA9IHtcbiAgY29tcGFjdF90YWJsZSA9IHRydWU7XG4gIGNvcHlfcGFyZW50ID0gdHJ1ZTtcbiAgY2xlYW5fd2hlbl9jb3B5aW5nID0gdHJ1ZTtcbiAgcmV0cnlfY291bnQgPSAzO1xuICBidWNrZXRfc21hbGxfc2l6ZSA9IDE2XG59XG5cbigqKioqIFBhcmFtZXRlcnMgKioqKilcblxubGV0IGluaXRpYWxfb2JqZWN0X3NpemUgPSAyXG5cbigqKioqIEl0ZW1zICoqKiopXG5cbnR5cGUgaXRlbSA9IER1bW15QSB8IER1bW15QiB8IER1bW15QyBvZiBpbnRcbmxldCBfID0gW0R1bW15QTsgRHVtbXlCOyBEdW1teUMgMF0gKCogdG8gYXZvaWQgd2FybmluZ3MgKilcblxubGV0IGR1bW15X2l0ZW0gPSAobWFnaWMgKCkgOiBpdGVtKVxuXG4oKioqKiBUeXBlcyAqKioqKVxuXG50eXBlIHRhZ1xudHlwZSBsYWJlbCA9IGludFxudHlwZSBjbG9zdXJlID0gaXRlbVxudHlwZSB0ID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG50eXBlIG9iaiA9IHQgYXJyYXlcbmV4dGVybmFsIHJldCA6IChvYmogLT4gJ2EpIC0+IGNsb3N1cmUgPSBcIiVpZGVudGl0eVwiXG5cbigqKioqIExhYmVscyAqKioqKVxuXG5sZXQgcHVibGljX21ldGhvZF9sYWJlbCBzIDogdGFnID1cbiAgbGV0IGFjY3UgPSByZWYgMCBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgIGFjY3UgOj0gMjIzICogIWFjY3UgKyBDaGFyLmNvZGUgcy5baV1cbiAgZG9uZTtcbiAgKCogcmVkdWNlIHRvIDMxIGJpdHMgKilcbiAgYWNjdSA6PSAhYWNjdSBsYW5kICgxIGxzbCAzMSAtIDEpO1xuICAoKiBtYWtlIGl0IHNpZ25lZCBmb3IgNjQgYml0cyBhcmNoaXRlY3R1cmVzICopXG4gIGxldCB0YWcgPSBpZiAhYWNjdSA+IDB4M0ZGRkZGRkYgdGhlbiAhYWNjdSAtICgxIGxzbCAzMSkgZWxzZSAhYWNjdSBpblxuICAoKiBQcmludGYuZXByaW50ZiBcIiVzID0gJWRcXG5cIiBzIHRhZzsgZmx1c2ggc3RkZXJyOyAqKVxuICBtYWdpYyB0YWdcblxuKCoqKiogU3BhcnNlIGFycmF5ICoqKiopXG5cbm1vZHVsZSBWYXJzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHN0cmluZyBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSB2YXJzID0gaW50IFZhcnMudFxuXG5tb2R1bGUgTWV0aHMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIG1ldGhzID0gbGFiZWwgTWV0aHMudFxubW9kdWxlIExhYnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gbGFiZWwgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbGFicyA9IGJvb2wgTGFicy50XG5cbigqIFRoZSBjb21waWxlciBhc3N1bWVzIHRoYXQgdGhlIGZpcnN0IGZpZWxkIG9mIHRoaXMgc3RydWN0dXJlIGlzIFtzaXplXS4gKilcbnR5cGUgdGFibGUgPVxuIHsgbXV0YWJsZSBzaXplOiBpbnQ7XG4gICBtdXRhYmxlIG1ldGhvZHM6IGNsb3N1cmUgYXJyYXk7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbmFtZTogbWV0aHM7XG4gICBtdXRhYmxlIG1ldGhvZHNfYnlfbGFiZWw6IGxhYnM7XG4gICBtdXRhYmxlIHByZXZpb3VzX3N0YXRlczpcbiAgICAgKG1ldGhzICogbGFicyAqIChsYWJlbCAqIGl0ZW0pIGxpc3QgKiB2YXJzICpcbiAgICAgIGxhYmVsIGxpc3QgKiBzdHJpbmcgbGlzdCkgbGlzdDtcbiAgIG11dGFibGUgaGlkZGVuX21ldGhzOiAobGFiZWwgKiBpdGVtKSBsaXN0O1xuICAgbXV0YWJsZSB2YXJzOiB2YXJzO1xuICAgbXV0YWJsZSBpbml0aWFsaXplcnM6IChvYmogLT4gdW5pdCkgbGlzdCB9XG5cbmxldCBkdW1teV90YWJsZSA9XG4gIHsgbWV0aG9kcyA9IFt8IGR1bW15X2l0ZW0gfF07XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IDAgfVxuXG5sZXQgdGFibGVfY291bnQgPSByZWYgMFxuXG4oKiBkdW1teV9tZXQgc2hvdWxkIGJlIGEgcG9pbnRlciwgc28gdXNlIGFuIGF0b20gKilcbmxldCBkdW1teV9tZXQgOiBpdGVtID0gb2JqIChPYmoubmV3X2Jsb2NrIDAgMClcbigqIGlmIGRlYnVnZ2luZyBpcyBuZWVkZWQsIHRoaXMgY291bGQgYmUgYSBnb29kIGlkZWE6ICopXG4oKiBsZXQgZHVtbXlfbWV0ICgpID0gZmFpbHdpdGggXCJVbmRlZmluZWQgbWV0aG9kXCIgKilcblxubGV0IHJlYyBmaXRfc2l6ZSBuID1cbiAgaWYgbiA8PSAyIHRoZW4gbiBlbHNlXG4gIGZpdF9zaXplICgobisxKS8yKSAqIDJcblxubGV0IG5ld190YWJsZSBwdWJfbGFiZWxzID1cbiAgaW5jciB0YWJsZV9jb3VudDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBwdWJfbGFiZWxzIGluXG4gIGxldCBtZXRob2RzID0gQXJyYXkubWFrZSAobGVuKjIrMikgZHVtbXlfbWV0IGluXG4gIG1ldGhvZHMuKDApIDwtIG1hZ2ljIGxlbjtcbiAgbWV0aG9kcy4oMSkgPC0gbWFnaWMgKGZpdF9zaXplIGxlbiAqIFN5cy53b3JkX3NpemUgLyA4IC0gMSk7XG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvIG1ldGhvZHMuKGkqMiszKSA8LSBtYWdpYyBwdWJfbGFiZWxzLihpKSBkb25lO1xuICB7IG1ldGhvZHMgPSBtZXRob2RzO1xuICAgIG1ldGhvZHNfYnlfbmFtZSA9IE1ldGhzLmVtcHR5O1xuICAgIG1ldGhvZHNfYnlfbGFiZWwgPSBMYWJzLmVtcHR5O1xuICAgIHByZXZpb3VzX3N0YXRlcyA9IFtdO1xuICAgIGhpZGRlbl9tZXRocyA9IFtdO1xuICAgIHZhcnMgPSBWYXJzLmVtcHR5O1xuICAgIGluaXRpYWxpemVycyA9IFtdO1xuICAgIHNpemUgPSBpbml0aWFsX29iamVjdF9zaXplIH1cblxubGV0IHJlc2l6ZSBhcnJheSBuZXdfc2l6ZSA9XG4gIGxldCBvbGRfc2l6ZSA9IEFycmF5Lmxlbmd0aCBhcnJheS5tZXRob2RzIGluXG4gIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlbiBiZWdpblxuICAgIGxldCBuZXdfYnVjayA9IEFycmF5Lm1ha2UgbmV3X3NpemUgZHVtbXlfbWV0IGluXG4gICAgQXJyYXkuYmxpdCBhcnJheS5tZXRob2RzIDAgbmV3X2J1Y2sgMCBvbGRfc2l6ZTtcbiAgICBhcnJheS5tZXRob2RzIDwtIG5ld19idWNrXG4gZW5kXG5cbmxldCBwdXQgYXJyYXkgbGFiZWwgZWxlbWVudCA9XG4gIHJlc2l6ZSBhcnJheSAobGFiZWwgKyAxKTtcbiAgYXJyYXkubWV0aG9kcy4obGFiZWwpIDwtIGVsZW1lbnRcblxuKCoqKiogQ2xhc3NlcyAqKioqKVxuXG5sZXQgbWV0aG9kX2NvdW50ID0gcmVmIDBcbmxldCBpbnN0X3Zhcl9jb3VudCA9IHJlZiAwXG5cbigqIHR5cGUgdCAqKVxudHlwZSBtZXRoID0gaXRlbVxuXG5sZXQgbmV3X21ldGhvZCB0YWJsZSA9XG4gIGxldCBpbmRleCA9IEFycmF5Lmxlbmd0aCB0YWJsZS5tZXRob2RzIGluXG4gIHJlc2l6ZSB0YWJsZSAoaW5kZXggKyAxKTtcbiAgaW5kZXhcblxubGV0IGdldF9tZXRob2RfbGFiZWwgdGFibGUgbmFtZSA9XG4gIHRyeVxuICAgIE1ldGhzLmZpbmQgbmFtZSB0YWJsZS5tZXRob2RzX2J5X25hbWVcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgbGFiZWwgPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gICAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtIE1ldGhzLmFkZCBuYW1lIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYmVsIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbDtcbiAgICBsYWJlbFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbHMgdGFibGUgbmFtZXMgPVxuICBBcnJheS5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIG5hbWVzXG5cbmxldCBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGVsZW1lbnQgPVxuICBpbmNyIG1ldGhvZF9jb3VudDtcbiAgaWYgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgdGhlblxuICAgIHB1dCB0YWJsZSBsYWJlbCBlbGVtZW50XG4gIGVsc2VcbiAgICB0YWJsZS5oaWRkZW5fbWV0aHMgPC0gKGxhYmVsLCBlbGVtZW50KSA6OiB0YWJsZS5oaWRkZW5fbWV0aHNcblxubGV0IGdldF9tZXRob2QgdGFibGUgbGFiZWwgPVxuICB0cnkgTGlzdC5hc3NvYyBsYWJlbCB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgd2l0aCBOb3RfZm91bmQgLT4gdGFibGUubWV0aG9kcy4obGFiZWwpXG5cbmxldCB0b19saXN0IGFyciA9XG4gIGlmIGFyciA9PSBtYWdpYyAwIHRoZW4gW10gZWxzZSBBcnJheS50b19saXN0IGFyclxuXG5sZXQgbmFycm93IHRhYmxlIHZhcnMgdmlydF9tZXRocyBjb25jcl9tZXRocyA9XG4gIGxldCB2YXJzID0gdG9fbGlzdCB2YXJzXG4gIGFuZCB2aXJ0X21ldGhzID0gdG9fbGlzdCB2aXJ0X21ldGhzXG4gIGFuZCBjb25jcl9tZXRocyA9IHRvX2xpc3QgY29uY3JfbWV0aHMgaW5cbiAgbGV0IHZpcnRfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIHZpcnRfbWV0aHMgaW5cbiAgbGV0IGNvbmNyX21ldGhfbGFicyA9IExpc3QubWFwIChnZXRfbWV0aG9kX2xhYmVsIHRhYmxlKSBjb25jcl9tZXRocyBpblxuICB0YWJsZS5wcmV2aW91c19zdGF0ZXMgPC1cbiAgICAgKHRhYmxlLm1ldGhvZHNfYnlfbmFtZSwgdGFibGUubWV0aG9kc19ieV9sYWJlbCwgdGFibGUuaGlkZGVuX21ldGhzLFxuICAgICAgdGFibGUudmFycywgdmlydF9tZXRoX2xhYnMsIHZhcnMpXG4gICAgIDo6IHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgIFZhcnMuZm9sZFxuICAgICAgKGZ1biBsYWIgaW5mbyB0dmFycyAtPlxuICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmFycyB0aGVuIFZhcnMuYWRkIGxhYiBpbmZvIHR2YXJzIGVsc2UgdHZhcnMpXG4gICAgICB0YWJsZS52YXJzIFZhcnMuZW1wdHk7XG4gIGxldCBieV9uYW1lID0gcmVmIE1ldGhzLmVtcHR5IGluXG4gIGxldCBieV9sYWJlbCA9IHJlZiBMYWJzLmVtcHR5IGluXG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PVxuICAgICAgICAgIExhYnMuYWRkIGxhYmVsXG4gICAgICAgICAgICAodHJ5IExhYnMuZmluZCBsYWJlbCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIHdpdGggTm90X2ZvdW5kIC0+IHRydWUpXG4gICAgICAgICAgICAhYnlfbGFiZWwpXG4gICAgY29uY3JfbWV0aHMgY29uY3JfbWV0aF9sYWJzO1xuICBMaXN0Lml0ZXIyXG4gICAgKGZ1biBtZXQgbGFiZWwgLT5cbiAgICAgICBieV9uYW1lIDo9IE1ldGhzLmFkZCBtZXQgbGFiZWwgIWJ5X25hbWU7XG4gICAgICAgYnlfbGFiZWwgOj0gTGFicy5hZGQgbGFiZWwgZmFsc2UgIWJ5X2xhYmVsKVxuICAgIHZpcnRfbWV0aHMgdmlydF9tZXRoX2xhYnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSAhYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSAhYnlfbGFiZWw7XG4gIHRhYmxlLmhpZGRlbl9tZXRocyA8LVxuICAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgICAoZnVuICgobGFiLCBfKSBhcyBtZXQpIGhtIC0+XG4gICAgICAgICAgaWYgTGlzdC5tZW0gbGFiIHZpcnRfbWV0aF9sYWJzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIFtdXG5cbmxldCB3aWRlbiB0YWJsZSA9XG4gIGxldCAoYnlfbmFtZSwgYnlfbGFiZWwsIHNhdmVkX2hpZGRlbl9tZXRocywgc2F2ZWRfdmFycywgdmlydF9tZXRocywgdmFycykgPVxuICAgIExpc3QuaGQgdGFibGUucHJldmlvdXNfc3RhdGVzXG4gIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LSBMaXN0LnRsIHRhYmxlLnByZXZpb3VzX3N0YXRlcztcbiAgdGFibGUudmFycyA8LVxuICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgIChmdW4gcyB2IC0+IFZhcnMuYWRkIHYgKFZhcnMuZmluZCB2IHRhYmxlLnZhcnMpIHMpXG4gICAgICAgc2F2ZWRfdmFycyB2YXJzO1xuICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gYnlfbmFtZTtcbiAgdGFibGUubWV0aG9kc19ieV9sYWJlbCA8LSBieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRocyB0aGVuIGhtIGVsc2UgbWV0OjpobSlcbiAgICAgICB0YWJsZS5oaWRkZW5fbWV0aHNcbiAgICAgICBzYXZlZF9oaWRkZW5fbWV0aHNcblxubGV0IG5ld19zbG90IHRhYmxlID1cbiAgbGV0IGluZGV4ID0gdGFibGUuc2l6ZSBpblxuICB0YWJsZS5zaXplIDwtIGluZGV4ICsgMTtcbiAgaW5kZXhcblxubGV0IG5ld192YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnNcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgaW5kZXggPSBuZXdfc2xvdCB0YWJsZSBpblxuICAgIGlmIG5hbWUgPD4gXCJcIiB0aGVuIHRhYmxlLnZhcnMgPC0gVmFycy5hZGQgbmFtZSBpbmRleCB0YWJsZS52YXJzO1xuICAgIGluZGV4XG5cbmxldCB0b19hcnJheSBhcnIgPVxuICBpZiBhcnIgPSBPYmoubWFnaWMgMCB0aGVuIFt8fF0gZWxzZSBhcnJcblxubGV0IG5ld19tZXRob2RzX3ZhcmlhYmxlcyB0YWJsZSBtZXRocyB2YWxzID1cbiAgbGV0IG1ldGhzID0gdG9fYXJyYXkgbWV0aHMgaW5cbiAgbGV0IG5tZXRocyA9IEFycmF5Lmxlbmd0aCBtZXRocyBhbmQgbnZhbHMgPSBBcnJheS5sZW5ndGggdmFscyBpblxuICBsZXQgcmVzID0gQXJyYXkubWFrZSAobm1ldGhzICsgbnZhbHMpIDAgaW5cbiAgZm9yIGkgPSAwIHRvIG5tZXRocyAtIDEgZG9cbiAgICByZXMuKGkpIDwtIGdldF9tZXRob2RfbGFiZWwgdGFibGUgbWV0aHMuKGkpXG4gIGRvbmU7XG4gIGZvciBpID0gMCB0byBudmFscyAtIDEgZG9cbiAgICByZXMuKGkrbm1ldGhzKSA8LSBuZXdfdmFyaWFibGUgdGFibGUgdmFscy4oaSlcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBnZXRfdmFyaWFibGUgdGFibGUgbmFtZSA9XG4gIHRyeSBWYXJzLmZpbmQgbmFtZSB0YWJsZS52YXJzIHdpdGggTm90X2ZvdW5kIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgZ2V0X3ZhcmlhYmxlcyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X3ZhcmlhYmxlIHRhYmxlKSBuYW1lc1xuXG5sZXQgYWRkX2luaXRpYWxpemVyIHRhYmxlIGYgPVxuICB0YWJsZS5pbml0aWFsaXplcnMgPC0gZjo6dGFibGUuaW5pdGlhbGl6ZXJzXG5cbigqXG5tb2R1bGUgS2V5cyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSB0YWcgYXJyYXkgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbmxldCBrZXlfbWFwID0gcmVmIEtleXMuZW1wdHlcbmxldCBnZXRfa2V5IHRhZ3MgOiBpdGVtID1cbiAgdHJ5IG1hZ2ljIChLZXlzLmZpbmQgdGFncyAha2V5X21hcCA6IHRhZyBhcnJheSlcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBrZXlfbWFwIDo9IEtleXMuYWRkIHRhZ3MgdGFncyAha2V5X21hcDtcbiAgICBtYWdpYyB0YWdzXG4qKVxuXG5sZXQgY3JlYXRlX3RhYmxlIHB1YmxpY19tZXRob2RzID1cbiAgaWYgcHVibGljX21ldGhvZHMgPT0gbWFnaWMgMCB0aGVuIG5ld190YWJsZSBbfHxdIGVsc2VcbiAgKCogW3B1YmxpY19tZXRob2RzXSBtdXN0IGJlIGluIGFzY2VuZGluZyBvcmRlciBmb3IgYnl0ZWNvZGUgKilcbiAgbGV0IHRhZ3MgPSBBcnJheS5tYXAgcHVibGljX21ldGhvZF9sYWJlbCBwdWJsaWNfbWV0aG9kcyBpblxuICBsZXQgdGFibGUgPSBuZXdfdGFibGUgdGFncyBpblxuICBBcnJheS5pdGVyaVxuICAgIChmdW4gaSBtZXQgLT5cbiAgICAgIGxldCBsYWIgPSBpKjIrMiBpblxuICAgICAgdGFibGUubWV0aG9kc19ieV9uYW1lICA8LSBNZXRocy5hZGQgbWV0IGxhYiB0YWJsZS5tZXRob2RzX2J5X25hbWU7XG4gICAgICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIExhYnMuYWRkIGxhYiB0cnVlIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwpXG4gICAgcHVibGljX21ldGhvZHM7XG4gIHRhYmxlXG5cbmxldCBpbml0X2NsYXNzIHRhYmxlID1cbiAgaW5zdF92YXJfY291bnQgOj0gIWluc3RfdmFyX2NvdW50ICsgdGFibGUuc2l6ZSAtIDE7XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBMaXN0LnJldiB0YWJsZS5pbml0aWFsaXplcnM7XG4gIHJlc2l6ZSB0YWJsZSAoMyArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplKVxuXG5sZXQgaW5oZXJpdHMgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocyAoXywgc3VwZXIsIF8sIGVudikgdG9wID1cbiAgbmFycm93IGNsYSB2YWxzIHZpcnRfbWV0aHMgY29uY3JfbWV0aHM7XG4gIGxldCBpbml0ID1cbiAgICBpZiB0b3AgdGhlbiBzdXBlciBjbGEgZW52IGVsc2UgT2JqLnJlcHIgKHN1cGVyIGNsYSkgaW5cbiAgd2lkZW4gY2xhO1xuICBBcnJheS5jb25jYXRcbiAgICBbW3wgcmVwciBpbml0IHxdO1xuICAgICBtYWdpYyAoQXJyYXkubWFwIChnZXRfdmFyaWFibGUgY2xhKSAodG9fYXJyYXkgdmFscykgOiBpbnQgYXJyYXkpO1xuICAgICBBcnJheS5tYXBcbiAgICAgICAoZnVuIG5tIC0+IHJlcHIgKGdldF9tZXRob2QgY2xhIChnZXRfbWV0aG9kX2xhYmVsIGNsYSBubSkgOiBjbG9zdXJlKSlcbiAgICAgICAodG9fYXJyYXkgY29uY3JfbWV0aHMpIF1cblxubGV0IG1ha2VfY2xhc3MgcHViX21ldGhzIGNsYXNzX2luaXQgPVxuICBsZXQgdGFibGUgPSBjcmVhdGVfdGFibGUgcHViX21ldGhzIGluXG4gIGxldCBlbnZfaW5pdCA9IGNsYXNzX2luaXQgdGFibGUgaW5cbiAgaW5pdF9jbGFzcyB0YWJsZTtcbiAgKGVudl9pbml0IChPYmoucmVwciAwKSwgY2xhc3NfaW5pdCwgZW52X2luaXQsIE9iai5yZXByIDApXG5cbnR5cGUgaW5pdF90YWJsZSA9IHsgbXV0YWJsZSBlbnZfaW5pdDogdDsgbXV0YWJsZSBjbGFzc19pbml0OiB0YWJsZSAtPiB0IH1cblxubGV0IG1ha2VfY2xhc3Nfc3RvcmUgcHViX21ldGhzIGNsYXNzX2luaXQgaW5pdF90YWJsZSA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICBpbml0X3RhYmxlLmNsYXNzX2luaXQgPC0gY2xhc3NfaW5pdDtcbiAgaW5pdF90YWJsZS5lbnZfaW5pdCA8LSBlbnZfaW5pdFxuXG5sZXQgZHVtbXlfY2xhc3MgbG9jID1cbiAgbGV0IHVuZGVmID0gZnVuIF8gLT4gcmFpc2UgKFVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlIGxvYykgaW5cbiAgKE9iai5tYWdpYyB1bmRlZiwgdW5kZWYsIHVuZGVmLCBPYmoucmVwciAwKVxuXG4oKioqKiBPYmplY3RzICoqKiopXG5cbmxldCBjcmVhdGVfb2JqZWN0IHRhYmxlID1cbiAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAoKiBYWFggQXBwZWwgZGUgW2NhbWxfbW9kaWZ5XSB8IENhbGwgdG8gW2NhbWxfbW9kaWZ5XSAqKVxuICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgT2JqLm9iaiAoc2V0X2lkIG9iailcblxubGV0IGNyZWF0ZV9vYmplY3Rfb3B0IG9ial8wIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqXzAgZWxzZSBiZWdpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbb2JqX2Jsb2NrXSB8IENhbGwgdG8gW29ial9ibG9ja10gICopXG4gICAgbGV0IG9iaiA9IE9iai5uZXdfYmxvY2sgT2JqLm9iamVjdF90YWcgdGFibGUuc2l6ZSBpblxuICAgICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gICAgT2JqLnNldF9maWVsZCBvYmogMCAoT2JqLnJlcHIgdGFibGUubWV0aG9kcyk7XG4gICAgT2JqLm9iaiAoc2V0X2lkIG9iailcbiAgZW5kXG5cbmxldCByZWMgaXRlcl9mIG9iaiA9XG4gIGZ1bmN0aW9uXG4gICAgW10gICAtPiAoKVxuICB8IGY6OmwgLT4gZiBvYmo7IGl0ZXJfZiBvYmogbFxuXG5sZXQgcnVuX2luaXRpYWxpemVycyBvYmogdGFibGUgPVxuICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgaWYgaW5pdHMgPD4gW10gdGhlblxuICAgIGl0ZXJfZiBvYmogaW5pdHNcblxubGV0IHJ1bl9pbml0aWFsaXplcnNfb3B0IG9ial8wIG9iaiB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9iaiBlbHNlIGJlZ2luXG4gICAgbGV0IGluaXRzID0gdGFibGUuaW5pdGlhbGl6ZXJzIGluXG4gICAgaWYgaW5pdHMgPD4gW10gdGhlbiBpdGVyX2Ygb2JqIGluaXRzO1xuICAgIG9ialxuICBlbmRcblxubGV0IGNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaXplcnMgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgbGV0IG9iaiA9IGNyZWF0ZV9vYmplY3QgdGFibGUgaW5cbiAgICBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZTtcbiAgICBvYmpcbiAgZW5kXG5cbigqIEVxdWl2YWxlbnQgcHJpbWl0aXZlIGJlbG93XG5sZXQgc2VuZHNlbGYgb2JqIGxhYiA9XG4gIChtYWdpYyBvYmogOiAob2JqIC0+IHQpIGFycmF5IGFycmF5KS4oMCkuKGxhYikgb2JqXG4qKVxuZXh0ZXJuYWwgc2VuZCA6IG9iaiAtPiB0YWcgLT4gJ2EgPSBcIiVzZW5kXCJcbmV4dGVybmFsIHNlbmRjYWNoZSA6IG9iaiAtPiB0YWcgLT4gdCAtPiBpbnQgLT4gJ2EgPSBcIiVzZW5kY2FjaGVcIlxuZXh0ZXJuYWwgc2VuZHNlbGYgOiBvYmogLT4gbGFiZWwgLT4gJ2EgPSBcIiVzZW5kc2VsZlwiXG5leHRlcm5hbCBnZXRfcHVibGljX21ldGhvZCA6IG9iaiAtPiB0YWcgLT4gY2xvc3VyZVxuICAgID0gXCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kXCIgW0BAbm9hbGxvY11cblxuKCoqKiogdGFibGUgY29sbGVjdGlvbiBhY2Nlc3MgKioqKilcblxudHlwZSB0YWJsZXMgPVxuICB8IEVtcHR5XG4gIHwgQ29ucyBvZiB7a2V5IDogY2xvc3VyZTsgbXV0YWJsZSBkYXRhOiB0YWJsZXM7IG11dGFibGUgbmV4dDogdGFibGVzfVxuXG5sZXQgc2V0X2RhdGEgdGFibGVzIHYgPSBtYXRjaCB0YWJsZXMgd2l0aFxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5kYXRhIDwtIHZcbmxldCBzZXRfbmV4dCB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHQgPC0gdlxubGV0IGdldF9rZXkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICB8IENvbnMgdGFibGVzIC0+IHRhYmxlcy5rZXlcbmxldCBnZXRfZGF0YSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGFcbmxldCBnZXRfbmV4dCA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLm5leHRcblxubGV0IGJ1aWxkX3BhdGggbiBrZXlzIHRhYmxlcyA9XG4gIGxldCByZXMgPSBDb25zIHtrZXkgPSBPYmoubWFnaWMgMDsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gIGxldCByID0gcmVmIHJlcyBpblxuICBmb3IgaSA9IDAgdG8gbiBkb1xuICAgIHIgOj0gQ29ucyB7a2V5ID0ga2V5cy4oaSk7IGRhdGEgPSAhcjsgbmV4dCA9IEVtcHR5fVxuICBkb25lO1xuICBzZXRfZGF0YSB0YWJsZXMgIXI7XG4gIHJlc1xuXG5sZXQgcmVjIGxvb2t1cF9rZXlzIGkga2V5cyB0YWJsZXMgPVxuICBpZiBpIDwgMCB0aGVuIHRhYmxlcyBlbHNlXG4gIGxldCBrZXkgPSBrZXlzLihpKSBpblxuICBsZXQgcmVjIGxvb2t1cF9rZXkgKHRhYmxlczp0YWJsZXMpID1cbiAgICBpZiBnZXRfa2V5IHRhYmxlcyA9PSBrZXkgdGhlblxuICAgICAgbWF0Y2ggZ2V0X2RhdGEgdGFibGVzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IENvbnMgXyBhcyB0YWJsZXNfZGF0YSAtPlxuICAgICAgICAgIGxvb2t1cF9rZXlzIChpLTEpIGtleXMgdGFibGVzX2RhdGFcbiAgICBlbHNlXG4gICAgICBtYXRjaCBnZXRfbmV4dCB0YWJsZXMgd2l0aFxuICAgICAgfCBDb25zIF8gYXMgbmV4dCAtPiBsb29rdXBfa2V5IG5leHRcbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBsZXQgbmV4dCA6IHRhYmxlcyA9IENvbnMge2tleTsgZGF0YSA9IEVtcHR5OyBuZXh0ID0gRW1wdHl9IGluXG4gICAgICAgICAgc2V0X25leHQgdGFibGVzIG5leHQ7XG4gICAgICAgICAgYnVpbGRfcGF0aCAoaS0xKSBrZXlzIG5leHRcbiAgaW5cbiAgbG9va3VwX2tleSB0YWJsZXNcblxubGV0IGxvb2t1cF90YWJsZXMgcm9vdCBrZXlzID1cbiAgbWF0Y2ggZ2V0X2RhdGEgcm9vdCB3aXRoXG4gIHwgQ29ucyBfIGFzIHJvb3RfZGF0YSAtPlxuICAgIGxvb2t1cF9rZXlzIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdF9kYXRhXG4gIHwgRW1wdHkgLT5cbiAgICBidWlsZF9wYXRoIChBcnJheS5sZW5ndGgga2V5cyAtIDEpIGtleXMgcm9vdFxuXG4oKioqKiBidWlsdGluIG1ldGhvZHMgKioqKilcblxubGV0IGdldF9jb25zdCB4ID0gcmV0IChmdW4gX29iaiAtPiB4KVxubGV0IGdldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIC0+IEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pXG5sZXQgZ2V0X2VudiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKVxubGV0IGdldF9tZXRoIG4gID0gcmV0IChmdW4gb2JqIC0+IHNlbmRzZWxmIG9iaiBuKVxubGV0IHNldF92YXIgbiAgID0gcmV0IChmdW4gb2JqIHggLT4gQXJyYXkudW5zYWZlX3NldCBvYmogbiB4KVxubGV0IGFwcF9jb25zdCBmIHggPSByZXQgKGZ1biBfb2JqIC0+IGYgeClcbmxldCBhcHBfdmFyIGYgbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9lbnYgZiBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSlcbmxldCBhcHBfbWV0aCBmIG4gID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSlcbmxldCBhcHBfY29uc3RfY29uc3QgZiB4IHkgPSByZXQgKGZ1biBfb2JqIC0+IGYgeCB5KVxubGV0IGFwcF9jb25zdF92YXIgZiB4IG4gICA9IHJldCAoZnVuIG9iaiAtPiBmIHggKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9tZXRoIGYgeCBuID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF92YXJfY29uc3QgZiBuIHggPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikgeClcbmxldCBhcHBfbWV0aF9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChzZW5kc2VsZiBvYmogbikgeClcbmxldCBhcHBfY29uc3RfZW52IGYgeCBlIG4gPVxuICByZXQgKGZ1biBvYmogLT5cbiAgICBmIHggKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9lbnZfY29uc3QgZiBlIG4geCA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pIHgpXG5sZXQgbWV0aF9hcHBfY29uc3QgbiB4ID0gcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgeClcbmxldCBtZXRoX2FwcF92YXIgbiBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXykgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG0pKVxubGV0IG1ldGhfYXBwX2VudiBuIGUgbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbSkpXG5sZXQgbWV0aF9hcHBfbWV0aCBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoc2VuZHNlbGYgb2JqIG0pKVxubGV0IHNlbmRfY29uc3QgbSB4IGMgPVxuICByZXQgKGZ1biBvYmogLT4gc2VuZGNhY2hlIHggbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX3ZhciBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSA6IG9iaikgbVxuICAgICAgKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9lbnYgbSBlIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZVxuICAgICAgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldFxuICAgICAgICAgICAgICAgICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgOiBvYmopXG4gICAgICBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfbWV0aCBtIG4gYyA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIHNlbmRjYWNoZSAoc2VuZHNlbGYgb2JqIG4pIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgbmV3X2NhY2hlIHRhYmxlID1cbiAgbGV0IG4gPSBuZXdfbWV0aG9kIHRhYmxlIGluXG4gIGxldCBuID1cbiAgICBpZiBuIG1vZCAyID0gMCB8fCBuID4gMiArIG1hZ2ljIHRhYmxlLm1ldGhvZHMuKDEpICogMTYgLyBTeXMud29yZF9zaXplXG4gICAgdGhlbiBuIGVsc2UgbmV3X21ldGhvZCB0YWJsZVxuICBpblxuICB0YWJsZS5tZXRob2RzLihuKSA8LSBPYmoubWFnaWMgMDtcbiAgblxuXG50eXBlIGltcGwgPVxuICAgIEdldENvbnN0XG4gIHwgR2V0VmFyXG4gIHwgR2V0RW52XG4gIHwgR2V0TWV0aFxuICB8IFNldFZhclxuICB8IEFwcENvbnN0XG4gIHwgQXBwVmFyXG4gIHwgQXBwRW52XG4gIHwgQXBwTWV0aFxuICB8IEFwcENvbnN0Q29uc3RcbiAgfCBBcHBDb25zdFZhclxuICB8IEFwcENvbnN0RW52XG4gIHwgQXBwQ29uc3RNZXRoXG4gIHwgQXBwVmFyQ29uc3RcbiAgfCBBcHBFbnZDb25zdFxuICB8IEFwcE1ldGhDb25zdFxuICB8IE1ldGhBcHBDb25zdFxuICB8IE1ldGhBcHBWYXJcbiAgfCBNZXRoQXBwRW52XG4gIHwgTWV0aEFwcE1ldGhcbiAgfCBTZW5kQ29uc3RcbiAgfCBTZW5kVmFyXG4gIHwgU2VuZEVudlxuICB8IFNlbmRNZXRoXG4gIHwgQ2xvc3VyZSBvZiBjbG9zdXJlXG5cbmxldCBtZXRob2RfaW1wbCB0YWJsZSBpIGFyciA9XG4gIGxldCBuZXh0ICgpID0gaW5jciBpOyBtYWdpYyBhcnIuKCFpKSBpblxuICBtYXRjaCBuZXh0KCkgd2l0aFxuICAgIEdldENvbnN0IC0+IGxldCB4IDogdCA9IG5leHQoKSBpbiBnZXRfY29uc3QgeFxuICB8IEdldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIGdldF92YXIgblxuICB8IEdldEVudiAgIC0+IGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGdldF9lbnYgZSBuXG4gIHwgR2V0TWV0aCAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X21ldGggblxuICB8IFNldFZhciAgIC0+IGxldCBuID0gbmV4dCgpIGluIHNldF92YXIgblxuICB8IEFwcENvbnN0IC0+IGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGFwcF9jb25zdCBmIHhcbiAgfCBBcHBWYXIgICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX3ZhciBmIG5cbiAgfCBBcHBFbnYgICAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gIGxldCBlID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfZW52IGYgZSBuXG4gIHwgQXBwTWV0aCAgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIGFwcF9tZXRoIGYgblxuICB8IEFwcENvbnN0Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCB5ID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfY29uc3QgZiB4IHlcbiAgfCBBcHBDb25zdFZhciAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF92YXIgZiB4IG5cbiAgfCBBcHBDb25zdEVudiAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0ICgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfZW52IGYgeCBlIG5cbiAgfCBBcHBDb25zdE1ldGggLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluXG4gICAgICBhcHBfY29uc3RfbWV0aCBmIHggblxuICB8IEFwcFZhckNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX3Zhcl9jb25zdCBmIG4geFxuICB8IEFwcEVudkNvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnZfY29uc3QgZiBlIG4geFxuICB8IEFwcE1ldGhDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9tZXRoX2NvbnN0IGYgbiB4XG4gIHwgTWV0aEFwcENvbnN0IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBtZXRoX2FwcF9jb25zdCBuIHhcbiAgfCBNZXRoQXBwVmFyIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF92YXIgbiBtXG4gIHwgTWV0aEFwcEVudiAtPlxuICAgICAgbGV0IG4gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG0gPSBuZXh0KCkgaW5cbiAgICAgIG1ldGhfYXBwX2VudiBuIGUgbVxuICB8IE1ldGhBcHBNZXRoIC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpbiBtZXRoX2FwcF9tZXRoIG4gbVxuICB8IFNlbmRDb25zdCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gc2VuZF9jb25zdCBtIHggKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kVmFyIC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gc2VuZF92YXIgbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZEVudiAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIHNlbmRfZW52IG0gZSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgU2VuZE1ldGggLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX21ldGggbSBuIChuZXdfY2FjaGUgdGFibGUpXG4gIHwgQ2xvc3VyZSBfIGFzIGNsbyAtPiBtYWdpYyBjbG9cblxubGV0IHNldF9tZXRob2RzIHRhYmxlIG1ldGhvZHMgPVxuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIG1ldGhvZHMgaW4gbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IGxlbiBkb1xuICAgIGxldCBsYWJlbCA9IG1ldGhvZHMuKCFpKSBpbiBsZXQgY2xvID0gbWV0aG9kX2ltcGwgdGFibGUgaSBtZXRob2RzIGluXG4gICAgc2V0X21ldGhvZCB0YWJsZSBsYWJlbCBjbG87XG4gICAgaW5jciBpXG4gIGRvbmVcblxuKCoqKiogU3RhdGlzdGljcyAqKioqKVxuXG50eXBlIHN0YXRzID1cbiAgeyBjbGFzc2VzOiBpbnQ7IG1ldGhvZHM6IGludDsgaW5zdF92YXJzOiBpbnQ7IH1cblxubGV0IHN0YXRzICgpID1cbiAgeyBjbGFzc2VzID0gIXRhYmxlX2NvdW50O1xuICAgIG1ldGhvZHMgPSAhbWV0aG9kX2NvdW50OyBpbnN0X3ZhcnMgPSAhaW5zdF92YXJfY291bnQ7IH1cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0b2tlbiA9XG4gICAgS3dkIG9mIHN0cmluZ1xuICB8IElkZW50IG9mIHN0cmluZ1xuICB8IEludCBvZiBpbnRcbiAgfCBGbG9hdCBvZiBmbG9hdFxuICB8IFN0cmluZyBvZiBzdHJpbmdcbiAgfCBDaGFyIG9mIGNoYXJcblxuKCogVGhlIHN0cmluZyBidWZmZXJpbmcgbWFjaGluZXJ5ICopXG5cbmxldCBpbml0aWFsX2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAzMlxuXG5sZXQgYnVmZmVyID0gcmVmIGluaXRpYWxfYnVmZmVyXG5sZXQgYnVmcG9zID0gcmVmIDBcblxubGV0IHJlc2V0X2J1ZmZlciAoKSA9IGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgYnVmcG9zIDo9IDBcblxubGV0IHN0b3JlIGMgPVxuICBpZiAhYnVmcG9zID49IEJ5dGVzLmxlbmd0aCAhYnVmZmVyIHRoZW4gYmVnaW5cbiAgICBsZXQgbmV3YnVmZmVyID0gQnl0ZXMuY3JlYXRlICgyICogIWJ1ZnBvcykgaW5cbiAgICBCeXRlcy5ibGl0ICFidWZmZXIgMCBuZXdidWZmZXIgMCAhYnVmcG9zO1xuICAgIGJ1ZmZlciA6PSBuZXdidWZmZXJcbiAgZW5kO1xuICBCeXRlcy5zZXQgIWJ1ZmZlciAhYnVmcG9zIGM7XG4gIGluY3IgYnVmcG9zXG5cbmxldCBnZXRfc3RyaW5nICgpID1cbiAgbGV0IHMgPSBCeXRlcy5zdWJfc3RyaW5nICFidWZmZXIgMCAhYnVmcG9zIGluIGJ1ZmZlciA6PSBpbml0aWFsX2J1ZmZlcjsgc1xuXG4oKiBUaGUgbGV4ZXIgKilcblxubGV0IG1ha2VfbGV4ZXIga2V5d29yZHMgPVxuICBsZXQga3dkX3RhYmxlID0gSGFzaHRibC5jcmVhdGUgMTcgaW5cbiAgTGlzdC5pdGVyIChmdW4gcyAtPiBIYXNodGJsLmFkZCBrd2RfdGFibGUgcyAoS3dkIHMpKSBrZXl3b3JkcztcbiAgbGV0IGlkZW50X29yX2tleXdvcmQgaWQgPVxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIGlkIHdpdGhcbiAgICAgIE5vdF9mb3VuZCAtPiBJZGVudCBpZFxuICBhbmQga2V5d29yZF9vcl9lcnJvciBjID1cbiAgICBsZXQgcyA9IFN0cmluZy5tYWtlIDEgYyBpblxuICAgIHRyeSBIYXNodGJsLmZpbmQga3dkX3RhYmxlIHMgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgKFwiSWxsZWdhbCBjaGFyYWN0ZXIgXCIgXiBzKSlcbiAgaW5cbiAgbGV0IHJlYyBuZXh0X3Rva2VuIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcgJyB8ICdcXDAxMCcgfCAnXFwwMTMnIHwgJ1xcMDA5JyB8ICdcXDAyNicgfCAnXFwwMTInKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IG5leHRfdG9rZW4gc3RybV9fXG4gICAgfCBTb21lICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ18nIHwgJ1xcMTkyJy4uJ1xcMjU1JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQgc1xuICAgIHwgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHwgJz4nIHxcbiAgICAgICAgICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgYzsgaWRlbnQyIHNcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnXFwnJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgY2hhciBzdHJtX18gd2l0aFxuICAgICAgICAgICAgU3RyZWFtLkZhaWx1cmUgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICBpblxuICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgIFNvbWUgJ1xcJycgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChDaGFyIGMpXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSAnXFxcIicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IFNvbWUgKFN0cmluZyAoc3RyaW5nIHMpKVxuICAgIHwgU29tZSAnLScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBuZWdfbnVtYmVyIHN0cm1fX1xuICAgIHwgU29tZSAnKCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgU29tZSAoa2V5d29yZF9vcl9lcnJvciBjKVxuICAgIHwgXyAtPiBOb25lXG4gIGFuZCBpZGVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lXG4gICAgICAgICgnQScuLidaJyB8ICdhJy4uJ3onIHwgJ1xcMTkyJy4uJ1xcMjU1JyB8ICcwJy4uJzknIHwgJ18nIHwgJ1xcJycgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgaWRlbnQyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCchJyB8ICclJyB8ICcmJyB8ICckJyB8ICcjJyB8ICcrJyB8ICctJyB8ICcvJyB8ICc6JyB8ICc8JyB8ICc9JyB8XG4gICAgICAgICAnPicgfCAnPycgfCAnQCcgfCAnXFxcXCcgfCAnficgfCAnXicgfCAnfCcgfCAnKicgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgXyAtPiBTb21lIChpZGVudF9vcl9rZXl3b3JkIChnZXRfc3RyaW5nICgpKSlcbiAgYW5kIG5lZ19udW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgc3RvcmUgYzsgbnVtYmVyIHNcbiAgICB8IF8gLT4gbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSAnLSc7IGlkZW50MiBzXG4gIGFuZCBudW1iZXIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgU29tZSAnLicgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnLic7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoSW50IChpbnRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBkZWNpbWFsX3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBkZWNpbWFsX3BhcnQgc1xuICAgIHwgU29tZSAoJ2UnIHwgJ0UnKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICdFJzsgZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGV4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJysnIHwgJy0nIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBlbmRfZXhwb25lbnRfcGFydCBzdHJtX19cbiAgYW5kIGVuZF9leHBvbmVudF9wYXJ0IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgZW5kX2V4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChGbG9hdCAoZmxvYXRfb2Zfc3RyaW5nIChnZXRfc3RyaW5nICgpKSkpXG4gIGFuZCBzdHJpbmcgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnXFxcIicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBnZXRfc3RyaW5nICgpXG4gICAgfCBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBjID1cbiAgICAgICAgICB0cnkgZXNjYXBlIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBzdHJpbmcgc1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgY2hhciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFxcJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgZXNjYXBlIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ24nIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcbidcbiAgICB8IFNvbWUgJ3InIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xccidcbiAgICB8IFNvbWUgJ3QnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgJ1xcdCdcbiAgICB8IFNvbWUgKCcwJy4uJzknIGFzIGMxKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAoJzAnLi4nOScgYXMgYzIpIC0+XG4gICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMykgLT5cbiAgICAgICAgICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgICAgICAgICAgQ2hhci5jaHJcbiAgICAgICAgICAgICAgICAgICgoQ2hhci5jb2RlIGMxIC0gNDgpICogMTAwICsgKENoYXIuY29kZSBjMiAtIDQ4KSAqIDEwICtcbiAgICAgICAgICAgICAgICAgICAgIChDaGFyLmNvZGUgYzMgLSA0OCkpXG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgKFN0cmVhbS5FcnJvciBcIlwiKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGVuZFxuICAgIHwgU29tZSBjIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgbmV4dF90b2tlbiBzXG4gICAgfCBfIC0+IFNvbWUgKGtleXdvcmRfb3JfZXJyb3IgJygnKVxuICBhbmQgY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX25lc3RlZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9uZXN0ZWRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIGNvbW1lbnQgczsgY29tbWVudCBzXG4gICAgfCBTb21lIF8gLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjb21tZW50IHN0cm1fX1xuICAgIHwgXyAtPiByYWlzZSBTdHJlYW0uRmFpbHVyZVxuICBhbmQgbWF5YmVfZW5kX2NvbW1lbnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnKScgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAoKVxuICAgIHwgU29tZSAnKicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBtYXliZV9lbmRfY29tbWVudCBzdHJtX19cbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGluXG4gIGZ1biBpbnB1dCAtPiBTdHJlYW0uZnJvbSAoZnVuIF9jb3VudCAtPiBuZXh0X3Rva2VuIGlucHV0KVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgdHlwZSBTZWVkZWRTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TZWVkZWRTXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIGluY2x1ZGUgSGFzaHRibC5TXG4gIHZhbCBjbGVhbjogJ2EgdCAtPiB1bml0XG4gIHZhbCBzdGF0c19hbGl2ZTogJ2EgdCAtPiBIYXNodGJsLnN0YXRpc3RpY3NcbiAgICAoKiogc2FtZSBhcyB7IXN0YXRzfSBidXQgb25seSBjb3VudCB0aGUgYWxpdmUgYmluZGluZ3MgKilcbmVuZFxuXG5tb2R1bGUgR2VuSGFzaFRhYmxlID0gc3RydWN0XG5cbiAgdHlwZSBlcXVhbCA9XG4gIHwgRVRydWUgfCBFRmFsc2VcbiAgfCBFRGVhZCAoKiogdGhlIGdhcmJhZ2UgY29sbGVjdG9yIHJlY2xhaW1lZCB0aGUgZGF0YSAqKVxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkKEg6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgJ2EgY29udGFpbmVyXG4gICAgdmFsIGNyZWF0ZTogdCAtPiAnYSAtPiAnYSBjb250YWluZXJcbiAgICB2YWwgaGFzaDogaW50IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAnYSBjb250YWluZXIgLT4gdCAtPiBlcXVhbFxuICAgIHZhbCBnZXRfZGF0YTogJ2EgY29udGFpbmVyIC0+ICdhIG9wdGlvblxuICAgIHZhbCBnZXRfa2V5OiAnYSBjb250YWluZXIgLT4gdCBvcHRpb25cbiAgICB2YWwgc2V0X2tleV9kYXRhOiAnYSBjb250YWluZXIgLT4gdCAtPiAnYSAtPiB1bml0XG4gICAgdmFsIGNoZWNrX2tleTogJ2EgY29udGFpbmVyIC0+IGJvb2xcbiAgZW5kKSA6IFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudFxuICA9IHN0cnVjdFxuXG4gICAgdHlwZSAnYSB0ID1cbiAgICAgIHsgbXV0YWJsZSBzaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogbnVtYmVyIG9mIGVudHJpZXMgKilcbiAgICAgICAgbXV0YWJsZSBkYXRhOiAnYSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICAgICAgbXV0YWJsZSBzZWVkOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogZm9yIHJhbmRvbWl6YXRpb24gKilcbiAgICAgICAgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogaW5pdGlhbCBhcnJheSBzaXplICopXG4gICAgICB9XG5cbiAgICBhbmQgJ2EgYnVja2V0bGlzdCA9XG4gICAgfCBFbXB0eVxuICAgIHwgQ29ucyBvZiBpbnQgKCogaGFzaCBvZiB0aGUga2V5ICopICogJ2EgSC5jb250YWluZXIgKiAnYSBidWNrZXRsaXN0XG5cbiAgICAoKiogdGhlIGhhc2ggb2YgdGhlIGtleSBpcyBrZXB0IGluIG9yZGVyIHRvIHRlc3QgdGhlIGVxdWFsaXR5IG9mIHRoZSBoYXNoXG4gICAgICBiZWZvcmUgdGhlIGtleS4gU2FtZSByZWFzb24gYXMgZm9yIFdlYWsuTWFrZSAqKVxuXG4gICAgdHlwZSBrZXkgPSBILnRcblxuICAgIGxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICAgICAgaWYgeCA+PSBuIHRoZW4geFxuICAgICAgZWxzZSBpZiB4ICogMiA+IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4geFxuICAgICAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG4gICAgbGV0IHBybmcgPSBsYXp5IChSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQoKSlcblxuICAgIGxldCBjcmVhdGUgPyhyYW5kb20gPSAoSGFzaHRibC5pc19yYW5kb21pemVkICgpKSkgaW5pdGlhbF9zaXplID1cbiAgICAgIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgICAgIGxldCBzZWVkID0gaWYgcmFuZG9tIHRoZW4gUmFuZG9tLlN0YXRlLmJpdHMgKExhenkuZm9yY2UgcHJuZykgZWxzZSAwIGluXG4gICAgICB7IGluaXRpYWxfc2l6ZSA9IHM7IHNpemUgPSAwOyBzZWVkID0gc2VlZDsgZGF0YSA9IEFycmF5Lm1ha2UgcyBFbXB0eSB9XG5cbiAgICBsZXQgY2xlYXIgaCA9XG4gICAgICBoLnNpemUgPC0gMDtcbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgICBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICBkb25lXG5cbiAgICBsZXQgcmVzZXQgaCA9XG4gICAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIGguZGF0YSBpblxuICAgICAgaWYgbGVuID0gaC5pbml0aWFsX3NpemUgdGhlblxuICAgICAgICBjbGVhciBoXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgICBoLmRhdGEgPC0gQXJyYXkubWFrZSBoLmluaXRpYWxfc2l6ZSBFbXB0eVxuICAgICAgZW5kXG5cbiAgICBsZXQgY29weSBoID0geyBoIHdpdGggZGF0YSA9IEFycmF5LmNvcHkgaC5kYXRhIH1cblxuICAgIGxldCBrZXlfaW5kZXggaCBoa2V5ID1cbiAgICAgIGhrZXkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgY2xlYW4gaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIG5vdCAoSC5jaGVja19rZXkgYykgLT5cbiAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgfCBDb25zKGhrZXksIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBDb25zKGhrZXksIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgKCoqIHJlc2l6ZSBpcyB0aGUgb25seSBmdW5jdGlvbiB0byBkbyB0aGUgYWN0dWFsIGNsZWFuaW5nIG9mIGRlYWQga2V5c1xuICAgICAgICAocmVtb3ZlIGRvZXMgaXQganVzdCBiZWNhdXNlIGl0IGNvdWxkKS5cblxuICAgICAgICBUaGUgZ29hbCBpcyB0bzpcblxuICAgICAgICAtIG5vdCByZXNpemUgaW5maW5pdGVseSB3aGVuIHRoZSBhY3R1YWwgbnVtYmVyIG9mIGFsaXZlIGtleXMgaXNcbiAgICAgICAgYm91bmRlZCBidXQga2V5cyBhcmUgY29udGludW91c2x5IGFkZGVkLiBUaGF0IHdvdWxkIGhhcHBlbiBpZlxuICAgICAgICB0aGlzIGZ1bmN0aW9uIGFsd2F5cyByZXNpemUuXG4gICAgICAgIC0gbm90IGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBlYWNoIGFkZGl0aW9uLCB0aGF0IHdvdWxkIGhhcHBlbiBpZiB0aGlzXG4gICAgICAgIGZ1bmN0aW9uIGRvbid0IHJlc2l6ZSBldmVuIHdoZW4gb25seSBvbmUga2V5IGlzIGRlYWQuXG5cbiAgICAgICAgU28gdGhlIGFsZ29yaXRobTpcbiAgICAgICAgLSBjbGVhbiB0aGUga2V5cyBiZWZvcmUgcmVzaXppbmdcbiAgICAgICAgLSBpZiB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBrZXlzIGlzIGxlc3MgdGhhbiBoYWxmIHRoZSBzaXplIG9mIHRoZVxuICAgICAgICBhcnJheSwgZG9uJ3QgcmVzaXplLlxuICAgICAgICAtIGlmIGl0IGlzIG1vcmUsIHJlc2l6ZS5cblxuICAgICAgICBUaGUgc2Vjb25kIHByb2JsZW0gcmVtYWlucyBpZiB0aGUgdGFibGUgcmVhY2hlcyB7IVN5cy5tYXhfYXJyYXlfbGVuZ3RofS5cblxuICAgICopXG4gICAgbGV0IHJlc2l6ZSBoID1cbiAgICAgIGxldCBvZGF0YSA9IGguZGF0YSBpblxuICAgICAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gICAgICBsZXQgbnNpemUgPSBvc2l6ZSAqIDIgaW5cbiAgICAgIGNsZWFuIGg7XG4gICAgICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoICYmIGguc2l6ZSA+PSBvc2l6ZSBsc3IgMSB0aGVuIGJlZ2luXG4gICAgICAgIGxldCBuZGF0YSA9IEFycmF5Lm1ha2UgbnNpemUgRW1wdHkgaW5cbiAgICAgICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAoKiBzbyB0aGF0IGtleV9pbmRleCBzZWVzIHRoZSBuZXcgYnVja2V0IGNvdW50ICopXG4gICAgICAgIGxldCByZWMgaW5zZXJ0X2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgICAgIHwgQ29ucyhoa2V5LCBkYXRhLCByZXN0KSAtPlxuICAgICAgICAgICAgICBpbnNlcnRfYnVja2V0IHJlc3Q7ICgqIHByZXNlcnZlIG9yaWdpbmFsIG9yZGVyIG9mIGVsZW1lbnRzICopXG4gICAgICAgICAgICAgIGxldCBuaWR4ID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgICAgICAgICBuZGF0YS4obmlkeCkgPC0gQ29ucyhoa2V5LCBkYXRhLCBuZGF0YS4obmlkeCkpIGluXG4gICAgICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG9kYXRhLihpKVxuICAgICAgICBkb25lXG4gICAgICBlbmRcblxuICAgIGxldCBhZGQgaCBrZXkgaW5mbyA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgbGV0IGJ1Y2tldCA9IENvbnMoaGtleSwgY29udGFpbmVyLCBoLmRhdGEuKGkpKSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIHJlbW92ZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBoLnNpemUgPC0gaC5zaXplIC0gMTsgbmV4dFxuICAgICAgICAgICAgfCBFRmFsc2UgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KVxuICAgICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICAgICgqIFRoZSBkZWFkIGtleSBpcyBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuIEl0IGlzIGFjY2VwdGFibGVcbiAgICAgICAgICAgICAgICAgICAgZm9yIHRoaXMgZnVuY3Rpb24gc2luY2UgaXQgYWxyZWFkeSByZW1vdmVzIGEgYmluZGluZyAqKVxuICAgICAgICAgICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICAgICAgICAgIHJlbW92ZV9idWNrZXQgbmV4dFxuICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgQ29ucyhoayxjLG5leHQpIC0+IENvbnMoaGssIGMsIHJlbW92ZV9idWNrZXQgbmV4dCkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgaC5kYXRhLihpKSA8LSByZW1vdmVfYnVja2V0IGguZGF0YS4oaSlcblxuICAgICgqKiB7IWZpbmR9IGRvbid0IHJlbW92ZSBkZWFkIGtleXMgYmVjYXVzZSBpdCB3b3VsZCBiZSBzdXJwcmlzaW5nIGZvclxuICAgICAgICB0aGUgdXNlciB0aGF0IGEgcmVhZC1vbmx5IGZ1bmN0aW9uIG11dGF0ZXMgdGhlIHN0YXRlIChlZy4gY29uY3VycmVudFxuICAgICAgICBhY2Nlc3MpLiBTYW1lIGZvciB7IWl0ZXJ9LCB7IWZvbGR9LCB7IW1lbX0uXG4gICAgKilcbiAgICBsZXQgcmVjIGZpbmRfcmVjIGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgICAgIHwgU29tZSBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWMga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmQgaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgKCogVE9ETyBpbmxpbmUgMyBpdGVyYXRpb25zICopXG4gICAgICBmaW5kX3JlYyBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSBoa2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGtleSA9IGhrICAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT5cbiAgICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgICAgICAoKiBUaGlzIGNhc2UgaXMgbm90IGltcG9zc2libGUgYmVjYXVzZSB0aGUgZ2MgY2FuIHJ1biBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgICAgICAgSC5lcXVhbCBhbmQgSC5nZXRfZGF0YSAqKVxuICAgICAgICAgICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgZCAtPiBkXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgIHwgRUZhbHNlIC0+IGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSAoaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KSlcblxuICAgIGxldCBmaW5kX2FsbCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gW11cbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgIGZpbmRfaW5fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZDo6ZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIHwgRURlYWQgLT5cbiAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgIGVuZFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+XG4gICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVwbGFjZV9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICB8IENvbnMoaGssIGMsIG5leHQpIHdoZW4gaGtleSA9IGhrIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICAgIHwgRVRydWUgLT4gSC5zZXRfa2V5X2RhdGEgYyBrZXkgaW5mb1xuICAgICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKF8sXyxuZXh0KSAtPiByZXBsYWNlX2J1Y2tldCBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIHRyeVxuICAgICAgICByZXBsYWNlX2J1Y2tldCBsXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBsZXQgY29udGFpbmVyID0gSC5jcmVhdGUga2V5IGluZm8gaW5cbiAgICAgICAgaC5kYXRhLihpKSA8LSBDb25zKGhrZXksIGNvbnRhaW5lciwgbCk7XG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGhcblxuICAgIGxldCBtZW0gaCBrZXkgPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICBmYWxzZVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrID0gaGtleSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgIHwgRVRydWUgLT4gdHJ1ZVxuICAgICAgICAgIHwgRUZhbHNlIHwgRURlYWQgLT4gbWVtX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoX2hrLCBfYywgcmVzdCkgLT4gbWVtX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBtZW1faW5fYnVja2V0IGguZGF0YS4oa2V5X2luZGV4IGggaGtleSlcblxuICAgIGxldCBpdGVyIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgICgpXG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+ICgpXG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+IGYgayBkXG4gICAgICAgICAgICBlbmQ7IGRvX2J1Y2tldCByZXN0IGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBmb2xkIGYgaCBpbml0ID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0IGIgYWNjdSA9XG4gICAgICAgIG1hdGNoIGIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgICBhY2N1XG4gICAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSAtPlxuICAgICAgICAgICAgbGV0IGFjY3UgPSBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPiBhY2N1XG4gICAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGQgYWNjdVxuICAgICAgICAgICAgZW5kIGluXG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdCBhY2N1ICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgYWNjdSA6PSBkb19idWNrZXQgZC4oaSkgIWFjY3VcbiAgICAgIGRvbmU7XG4gICAgICAhYWNjdVxuXG4gICAgbGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgICBFbXB0eVxuICAgICAgICB8IENvbnMoaGssIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT5cbiAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPlxuICAgICAgICAgICAgICAgIG1hdGNoIGYgayBkIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICAgZG9fYnVja2V0IHJlc3RcbiAgICAgICAgICAgICAgICB8IFNvbWUgbmV3X2QgLT5cbiAgICAgICAgICAgICAgICAgICAgSC5zZXRfa2V5X2RhdGEgYyBrIG5ld19kO1xuICAgICAgICAgICAgICAgICAgICBDb25zKGhrLCBjLCBkb19idWNrZXQgcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBkLihpKSA8LSBkb19idWNrZXQgZC4oaSlcbiAgICAgIGRvbmVcblxuICAgIGxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG4gICAgbGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aCAoYWNjdSArIDEpIHJlc3RcblxuICAgIGxldCBzdGF0cyBoID1cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGggMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aCAwIGIgaW5cbiAgICAgICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgICAgIGguZGF0YTtcbiAgICAgIHsgSGFzaHRibC5udW1fYmluZGluZ3MgPSBoLnNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBjLCByZXN0KSB3aGVuIEguY2hlY2tfa2V5IGMgLT5cbiAgICAgICAgICBidWNrZXRfbGVuZ3RoX2FsaXZlIChhY2N1ICsgMSkgcmVzdFxuICAgICAgfCBDb25zKF8sIF8sIHJlc3QpIC0+IGJ1Y2tldF9sZW5ndGhfYWxpdmUgYWNjdSByZXN0XG5cbiAgICBsZXQgc3RhdHNfYWxpdmUgaCA9XG4gICAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG4gICAgICBsZXQgbWJsID1cbiAgICAgICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoX2FsaXZlIDAgYikpIDAgaC5kYXRhIGluXG4gICAgICBsZXQgaGlzdG8gPSBBcnJheS5tYWtlIChtYmwgKyAxKSAwIGluXG4gICAgICBBcnJheS5pdGVyXG4gICAgICAgIChmdW4gYiAtPlxuICAgICAgICAgICBsZXQgbCA9IGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiIGluXG4gICAgICAgICAgIHNpemUgOj0gIXNpemUgKyBsO1xuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9ICFzaXplO1xuICAgICAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgICAgIG1heF9idWNrZXRfbGVuZ3RoID0gbWJsO1xuICAgICAgICBidWNrZXRfaGlzdG9ncmFtID0gaGlzdG8gfVxuXG5cbiAgZW5kXG5lbmRcblxubW9kdWxlIE9iakVwaCA9IE9iai5FcGhlbWVyb25cblxubGV0IF9vYmpfb3B0IDogT2JqLnQgb3B0aW9uIC0+ICdhIG9wdGlvbiA9IGZ1biB4IC0+XG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4geFxuICB8IFNvbWUgdiAtPiBTb21lIChPYmoub2JqIHYpXG5cbigqKiBUaGUgcHJldmlvdXMgZnVuY3Rpb24gaXMgdHlwZWQgc28gdGhpcyBvbmUgaXMgYWxzbyBjb3JyZWN0ICopXG5sZXQgb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPiBPYmoubWFnaWMgeFxuXG5cbm1vZHVsZSBLMSA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgMVxuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChrOidrKSA6IHVuaXQgPSBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKHQyOignaywnZCkgdCk6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhIHQpXG4gIGxldCBnZXRfZGF0YV9jb3B5ICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSAoZDonZCkgOiB1bml0ID0gT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19kYXRhIHRcbiAgbGV0IGJsaXRfZGF0YSAodDE6KF8sJ2QpIHQpICh0MjooXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkIChIOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSC50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBILnRcbiAgICAgIGxldCBjcmVhdGUgayBkID1cbiAgICAgICAgbGV0IGMgPSBjcmVhdGUgKCkgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggPSBILmhhc2hcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICAoKiB7IWdldF9rZXlfY29weX0gaXMgbm90IHVzZWQgYmVjYXVzZSB0aGUgZXF1YWxpdHkgb2YgdGhlIHVzZXIgY2FuIGJlXG4gICAgICAgICAgICB0aGUgcGh5c2ljYWwgZXF1YWxpdHkgKilcbiAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgaycgLT5cbiAgICAgICAgICAgIGlmIEguZXF1YWwgayBrJyB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSA9IGdldF9rZXlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIHNldF9rZXkgYyBrO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgPSBjaGVja19rZXlcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDogSGFzaHRibC5IYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgSzIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2sxLCAnazIsICdkKSB0ID0gT2JqRXBoLnRcblxuICBsZXQgY3JlYXRlICgpIDogKCdrMSwnazIsJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDJcblxuICBsZXQgZ2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMClcbiAgbGV0IGdldF9rZXkxX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2sxIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDApXG4gIGxldCBzZXRfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2sxKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMCAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAwXG4gIGxldCBjaGVja19rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMFxuXG4gIGxldCBnZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAxKVxuICBsZXQgZ2V0X2tleTJfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnazIgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMSlcbiAgbGV0IHNldF9rZXkyICh0OignazEsJ2syLCdkKSB0KSAoazonazIpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCAxIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDFcbiAgbGV0IGNoZWNrX2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAxXG5cblxuICBsZXQgYmxpdF9rZXkxICh0MTooJ2sxLF8sXykgdCkgKHQyOignazEsXyxfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMVxuICBsZXQgYmxpdF9rZXkyICh0MTooXywnazIsXykgdCkgKHQyOihfLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAxIHQyIDEgMVxuICBsZXQgYmxpdF9rZXkxMiAodDE6KCdrMSwnazIsXykgdCkgKHQyOignazEsJ2syLF8pIHQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIDAgdDIgMCAyXG5cbiAgbGV0IGdldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgKGQ6J2QpIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9kYXRhIHQgKE9iai5yZXByIGQpXG4gIGxldCB1bnNldF9kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLF8sJ2QpIHQpICh0MjooXyxfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWRcbiAgICAgIChIMTpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpXG4gICAgICAoSDI6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChIMS50LEgyLnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgxLnQgKiBIMi50XG4gICAgICBsZXQgY3JlYXRlIChrMSxrMikgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgY1xuICAgICAgbGV0IGhhc2ggc2VlZCAoazEsazIpID1cbiAgICAgICAgSDEuaGFzaCBzZWVkIGsxICsgSDIuaGFzaCBzZWVkIGsyICogNjU1OTlcbiAgICAgIGxldCBlcXVhbCBjIChrMSxrMikgPVxuICAgICAgICBtYXRjaCBnZXRfa2V5MSBjLCBnZXRfa2V5MiBjIHdpdGhcbiAgICAgICAgfCBOb25lLCBfIHwgXyAsIE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+XG4gICAgICAgICAgICBpZiBIMS5lcXVhbCBrMSBrMScgJiYgSDIuZXF1YWwgazIgazInXG4gICAgICAgICAgICB0aGVuIEdlbkhhc2hUYWJsZS5FVHJ1ZSBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIGsxJywgU29tZSBrMicgLT4gU29tZSAoazEnLCBrMicpXG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgKGsxLGsyKSBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5MSBjIGsxOyBzZXRfa2V5MiBjIGsyO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9IGNoZWNrX2tleTEgYyAmJiBjaGVja19rZXkyIGNcbiAgICBlbmQpXG5cbiAgbW9kdWxlIE1ha2UoSDE6IEhhc2h0YmwuSGFzaGVkVHlwZSkoSDI6IEhhc2h0YmwuSGFzaGVkVHlwZSk6XG4gICAgKFMgd2l0aCB0eXBlIGtleSA9IEgxLnQgKiBIMi50KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZFxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDEudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgxLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMS5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgICAgICAoc3RydWN0XG4gICAgICAgICAgdHlwZSB0ID0gSDIudFxuICAgICAgICAgIGxldCBlcXVhbCA9IEgyLmVxdWFsXG4gICAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBIMi5oYXNoIHhcbiAgICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICBlbmRcblxuZW5kXG5cbm1vZHVsZSBLbiA9IHN0cnVjdFxuICB0eXBlICgnaywnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSBuIDogKCdrLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSBuXG4gIGxldCBsZW5ndGggKGs6KCdrLCdkKSB0KSA6IGludCA9IE9iakVwaC5sZW5ndGgga1xuXG4gIGxldCBnZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6ICdrIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgbilcbiAgbGV0IGdldF9rZXlfY29weSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCBuKVxuICBsZXQgc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgKGs6J2spIDogdW5pdCA9XG4gICAgT2JqRXBoLnNldF9rZXkgdCBuIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgblxuICBsZXQgY2hlY2tfa2V5ICh0OignaywnZCkgdCkgKG46aW50KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgblxuXG4gIGxldCBibGl0X2tleSAodDE6KCdrLCdkKSB0KSAobzE6aW50KSAodDI6KCdrLCdkKSB0KSAobzI6aW50KSAobDppbnQpIDogdW5pdCA9XG4gICAgT2JqRXBoLmJsaXRfa2V5IHQxIG8xIHQyIG8yIGxcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50IGFycmF5XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlIChBcnJheS5sZW5ndGggaykgaW5cbiAgICAgICAgc2V0X2RhdGEgYyBkO1xuICAgICAgICBmb3IgaT0wIHRvIEFycmF5Lmxlbmd0aCBrIC0xIGRvXG4gICAgICAgICAgc2V0X2tleSBjIGkgay4oaSk7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgayA9XG4gICAgICAgIGxldCBoID0gcmVmIDAgaW5cbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIGggOj0gSC5oYXNoIHNlZWQgay4oaSkgKiA2NTU5OSArICFoO1xuICAgICAgICBkb25lO1xuICAgICAgICAhaFxuICAgICAgbGV0IGVxdWFsIGMgayA9XG4gICAgICAgIGxldCBsZW4gID0gQXJyYXkubGVuZ3RoIGsgaW5cbiAgICAgICAgbGV0IGxlbicgPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gIT0gbGVuJyB0aGVuIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgZXF1YWxfYXJyYXkgayBjIGkgPVxuICAgICAgICAgICAgaWYgaSA8IDAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2tleSBjIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gR2VuSGFzaFRhYmxlLkVEZWFkXG4gICAgICAgICAgICAgIHwgU29tZSBraSAtPlxuICAgICAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrLihpKSBraVxuICAgICAgICAgICAgICAgICAgdGhlbiBlcXVhbF9hcnJheSBrIGMgKGktMSlcbiAgICAgICAgICAgICAgICAgIGVsc2UgR2VuSGFzaFRhYmxlLkVGYWxzZVxuICAgICAgICAgIGluXG4gICAgICAgICAgZXF1YWxfYXJyYXkgayBjIChsZW4tMSlcbiAgICAgIGxldCBnZXRfZGF0YSA9IGdldF9kYXRhXG4gICAgICBsZXQgZ2V0X2tleSBjID1cbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aCBjIGluXG4gICAgICAgIGlmIGxlbiA9IDAgdGhlbiBTb21lIFt8fF1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyAwIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgIHwgU29tZSBrMCAtPlxuICAgICAgICAgICAgICBsZXQgcmVjIGZpbGwgYSBpID1cbiAgICAgICAgICAgICAgICBpZiBpIDwgMSB0aGVuIFNvbWUgYVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgICAgICBhLihpKSA8LSBraTtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxsIGEgKGktMSlcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIGxlbiBrMCBpblxuICAgICAgICAgICAgICBmaWxsIGEgKGxlbi0xKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIGsgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBzZXRfZGF0YSBjIGRcbiAgICAgIGxldCBjaGVja19rZXkgYyA9XG4gICAgICAgIGxldCByZWMgY2hlY2sgYyBpID1cbiAgICAgICAgICBpIDwgMCB8fCAoY2hlY2tfa2V5IGMgaSAmJiBjaGVjayBjIChpLTEpKSBpblxuICAgICAgICBjaGVjayBjIChsZW5ndGggYyAtIDEpXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQgYXJyYXkpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gIGVuZFxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFyayBTaGlud2VsbCBhbmQgTGVvIFdoaXRlLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE1LS0yMDE2IEphbmUgU3RyZWV0IEdyb3VwIExMQyAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIHNwYWNldGltZV9lbmFibGVkIDogdW5pdCAtPiBib29sXG4gID0gXCJjYW1sX3NwYWNldGltZV9lbmFibGVkXCIgW0BAbm9hbGxvY11cblxubGV0IGVuYWJsZWQgPSBzcGFjZXRpbWVfZW5hYmxlZCAoKVxuXG5sZXQgaWZfc3BhY2V0aW1lX2VuYWJsZWQgZiA9XG4gIGlmIGVuYWJsZWQgdGhlbiBmICgpIGVsc2UgKClcblxubW9kdWxlIFNlcmllcyA9IHN0cnVjdFxuICB0eXBlIHQgPSB7XG4gICAgY2hhbm5lbCA6IG91dF9jaGFubmVsO1xuICAgIG11dGFibGUgY2xvc2VkIDogYm9vbDtcbiAgfVxuXG4gIGV4dGVybmFsIHdyaXRlX21hZ2ljX251bWJlciA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV93cml0ZV9tYWdpY19udW1iZXJcIlxuXG4gIGV4dGVybmFsIHJlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSA6IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWVcIlxuXG4gIGxldCBjcmVhdGUgfnBhdGggPVxuICAgIGlmIHNwYWNldGltZV9lbmFibGVkICgpIHRoZW4gYmVnaW5cbiAgICAgIGxldCBjaGFubmVsID0gb3Blbl9vdXQgcGF0aCBpblxuICAgICAgcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lIGNoYW5uZWw7XG4gICAgICBsZXQgdCA9XG4gICAgICAgIHsgY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgICAgY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIGluXG4gICAgICB3cml0ZV9tYWdpY19udW1iZXIgdC5jaGFubmVsO1xuICAgICAgdFxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICB7IGNoYW5uZWwgPSBzdGRvdXQ7ICAoKiBhcmJpdHJhcnkgdmFsdWUgKilcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICBleHRlcm5hbCBzYXZlX2V2ZW50IDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gZXZlbnRfbmFtZTpzdHJpbmcgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3NhdmVfZXZlbnRcIlxuXG4gIGxldCBzYXZlX2V2ZW50ID90aW1lIHQgfmV2ZW50X25hbWUgPVxuICAgIGlmX3NwYWNldGltZV9lbmFibGVkIChmdW4gKCkgLT5cbiAgICAgIHNhdmVfZXZlbnQgP3RpbWUgdC5jaGFubmVsIH5ldmVudF9uYW1lKVxuXG4gIGV4dGVybmFsIHNhdmVfdHJpZSA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX3RyaWVcIlxuXG4gIGxldCBzYXZlX2FuZF9jbG9zZSA/dGltZSB0ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiB0LmNsb3NlZCB0aGVuIGZhaWx3aXRoIFwiU2VyaWVzIGlzIGNsb3NlZFwiO1xuICAgICAgc2F2ZV90cmllID90aW1lIHQuY2hhbm5lbDtcbiAgICAgIGNsb3NlX291dCB0LmNoYW5uZWw7XG4gICAgICB0LmNsb3NlZCA8LSB0cnVlKVxuZW5kXG5cbm1vZHVsZSBTbmFwc2hvdCA9IHN0cnVjdFxuICBleHRlcm5hbCB0YWtlIDogP3RpbWU6ZmxvYXQgLT4gb3V0X2NoYW5uZWwgLT4gdW5pdFxuICAgID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgICBcImNhbWxfc3BhY2V0aW1lX3Rha2Vfc25hcHNob3RcIlxuXG4gIGxldCB0YWtlID90aW1lIHsgU2VyaWVzLmNsb3NlZDsgY2hhbm5lbCB9ID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBpZiBjbG9zZWQgdGhlbiBmYWlsd2l0aCBcIlNlcmllcyBpcyBjbG9zZWRcIjtcbiAgICAgIEdjLm1pbm9yICgpO1xuICAgICAgdGFrZSA/dGltZSBjaGFubmVsKVxuZW5kXG5cbmV4dGVybmFsIHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgOiBldmVudF9uYW1lOnN0cmluZyAtPiB1bml0XG4gID0gXCJjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZVwiXG4gICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzXCJcblxubGV0IHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgfmV2ZW50X25hbWUgPVxuICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90cyB+ZXZlbnRfbmFtZSlcbiIsIm1vZHVsZSB0eXBlIE9yZGVyZWRUeXBlID0gc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBjb21wYXJlIDogdCAtPiB0IC0+IGludFxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIuU2V4cC50XG5lbmRcblxubW9kdWxlIENDU3RyaW5nID0gc3RydWN0XG4gIGluY2x1ZGUgQ0NTdHJpbmdcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwbGliLlNleHAuQXRvbSB0XG5lbmRcblxubW9kdWxlIENDSW50ID0gc3RydWN0XG4gIGluY2x1ZGUgQ0NJbnRcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwbGliLlNleHAuQXRvbSAoc3RyaW5nX29mX2ludCB0KVxuZW5kXG5cbm1vZHVsZSBDQ01hcE1ha2UgKEtleSA6IE9yZGVyZWRUeXBlKSA9IHN0cnVjdFxuICBpbmNsdWRlIENDTWFwLk1ha2UgKEtleSlcblxuICBsZXQgc2V4cF9vZl90IChzZXhwX29mX3ZhbHVlIDogJ2EgLT4gU2V4cGxpYi5TZXhwLnQpICh0IDogJ2EgdCkgPVxuICAgIGxldCBvcGVuIFNleHBsaWIuU2V4cCBpblxuICAgIExpc3RcbiAgICAgIChmb2xkXG4gICAgICAgICAoZnVuIGtleSB2YWx1ZSBhdG1fbGlzIC0+XG4gICAgICAgICAgIExpc3QgW0tleS5zZXhwX29mX3Qga2V5OyBzZXhwX29mX3ZhbHVlIHZhbHVlXSA6OiBhdG1fbGlzIClcbiAgICAgICAgIHQgW10pXG5lbmRcblxubW9kdWxlIENDU2V0TWFrZSAoS2V5IDogT3JkZXJlZFR5cGUpID0gc3RydWN0XG4gIGluY2x1ZGUgQ0NTZXQuTWFrZSAoS2V5KVxuXG4gIGxldCBzZXhwX29mX3QgKHQgOiB0KSA9XG4gICAgbGV0IG9wZW4gU2V4cGxpYi5TZXhwIGluXG4gICAgTGlzdCAoZm9sZCAoZnVuIHZhbHVlIGF0bV9saXMgLT4gS2V5LnNleHBfb2ZfdCB2YWx1ZSA6OiBhdG1fbGlzKSB0IFtdKVxuZW5kXG5cbm1vZHVsZSBDQ0ZRdWV1ZVdpdGhTZXhwID0gc3RydWN0XG4gIGluY2x1ZGUgQ0NGUXVldWVcblxuICBsZXQgc2V4cF9vZl90IChzZXhwX29mX3ZhbHVlIDogJ2EgLT4gU2V4cGxpYi5TZXhwLnQpICh0IDogJ2EgdCkgPVxuICAgIFNleHBsaWIuU2V4cC5MaXN0IChDQ0xpc3QubWFwIHNleHBfb2ZfdmFsdWUgKENDRlF1ZXVlLnRvX2xpc3QgdCkpXG5lbmRcbiIsIm9wZW4gU2V4cGxpYi5Db252XG5vcGVuIERhdGFzdHJ1Y3R1cmVzXG5cbigqIFRPRE86IENhbiB3ZSBjcm9zcy1jb21waWxlIHRoaXMgZmlsZSBhbmQgdXNlIGl0IGluc3RlYWQgb2YgdGhlIG9wX3NldC5qcyBmaWxlIGluIGF1dG9tZXJnZSB0byBydW4gdGVzdHM/ICopXG4oKiBUT0RPOiBIb3cgZG9lcyBhdXRvbWVyZ2UgcGVyc2lzdCBkYXRhPyAqKVxuXG4oKiBsZXQgKCAkICkgZiBnIHggPSBmIChnIHgpICopXG5cbnR5cGUgZXhuICs9XG4gIHwgSW5jb25zaXN0ZW50X3JldXNlX29mX3NlcXVlbmNlXG4gIHwgTm90X3N1cHBvcnRlZFxuICB8IE1vZGlmaWNhdGlvbl9vZl91bmtub3duX29iamVjdFxuICB8IER1cGxpY2F0ZV9saXN0X2VsZW1lbnRfaWRcbiAgfCBVbmtub3duX29iamVjdF90eXBlXG4gIHwgVW5rbm93bl9hY3Rpb25fdHlwZVxuICB8IE1pc3NpbmdfaW5kZXhfZm9yX2xpc3RfZWxlbWVudFxuICB8IEFjY2Vzc2luZ191bmVmaW5lZF9lbGVtZW50X2luZGV4XG5cbmxldCBsb2cgbXNnIGNvbnYgc2V4cCA9XG4gIEZvcm1hdC5wcmludGYgXCJERUJVRzogJXMgJWFcXG4lIVwiIG1zZyBTZXhwbGliLlNleHAucHBfaHVtIChjb252IHNleHApXG5cbm1vZHVsZSBBY3Rvck1hcCA9IENDTWFwTWFrZSAoQ0NTdHJpbmcpXG5tb2R1bGUgU2VxTWFwID0gQ0NNYXBNYWtlIChDQ0ludClcbm1vZHVsZSBPYmplY3RJZE1hcCA9IENDTWFwTWFrZSAoQ0NTdHJpbmcpXG5tb2R1bGUgT2JqZWN0SWRTZXQgPSBDQ1NldC5NYWtlIChDQ1N0cmluZylcbm1vZHVsZSBFbGVtSWRNYXAgPSBDQ01hcE1ha2UgKENDU3RyaW5nKVxubW9kdWxlIEtleU1hcCA9IENDTWFwTWFrZSAoQ0NTdHJpbmcpXG5tb2R1bGUgS2V5U2V0ID0gQ0NTZXQuTWFrZSAoQ0NTdHJpbmcpXG5tb2R1bGUgT3BNYXAgPSBDQ01hcE1ha2UgKENDU3RyaW5nKVxubW9kdWxlIERpZmZNYXAgPSBDQ01hcE1ha2UgKENDU3RyaW5nKVxubW9kdWxlIENoaWxkTWFwID0gQ0NNYXBNYWtlIChDQ1N0cmluZylcblxubW9kdWxlIE9wU2V0QmFja2VuZCA9IHN0cnVjdFxuICBsZXQgcm9vdF9pZCA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCJcblxuICB0eXBlIGFjdG9yID0gc3RyaW5nIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgKCogR1VJRCAqKVxuICB0eXBlIHNlcSA9IGludCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgb2JqX2lkID0gc3RyaW5nIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSBrZXkgPSBzdHJpbmcgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGFjdGlvbiA9IE1ha2VNYXAgfCBNYWtlTGlzdCB8IE1ha2VUZXh0IHwgSW5zIHwgU2V0IHwgRGVsIHwgTGlua1xuICBbQEBkZXJpdmluZyBzZXhwXVxuXG4gIHR5cGUgb3BfdmFsID0gQm9vbFZhbHVlIG9mIGJvb2wgfCBTdHJWYWx1ZSBvZiBzdHJpbmcgfCBOdW1iZXJWYWx1ZSBvZiBmbG9hdFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgbWF0ZXJpYWxpemVkID0gVHlwZWRWYWx1ZSBvZiBvcF92YWwgfCBMaW5rVmFsdWUgb2Yge29ial9pZDogc3RyaW5nfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgdmFsdWUgPSBWYWx1ZSBvZiBvcF92YWwgfCBMaW5rIG9mIHtvYmo6IHZhbHVlfSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgZWxlbV9pZCA9IGtleSAqIHZhbHVlIG9wdGlvbiBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICgqIEluZWZpY2llbnQgYnV0IHNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBza2lwIGxpc3QgZnJvbSBvcmlnaW5hbCAqKVxuICBtb2R1bGUgU2tpcExpc3QgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBlbGVtX2lkIGxpc3RcblxuICAgIGxldCBlbXB0eSA9IFtdXG5cbiAgICBsZXQgaW5zZXJ0X2luZGV4IGluZGV4IGsgdiAodCA6IHQpID0gQ0NMaXN0Lmluc2VydF9hdF9pZHggaW5kZXggKGssIHYpIHRcblxuICAgIGxldCBpbmRleF9vZiBrIHQgPVxuICAgICAgbWF0Y2ggQ0NMaXN0LmZpbmRfaWR4IChmdW4gKGl0bWssIF8pIC0+IFN0cmluZy5lcXVhbCBpdG1rIGspIHQgd2l0aFxuICAgICAgfCBTb21lIChpZHgsIF8pIC0+IFNvbWUgaWR4XG4gICAgICB8IE5vbmUgLT4gTm9uZVxuXG4gICAgbGV0IGtleV9vZiBpZHggdCA9XG4gICAgICBtYXRjaCBDQ0xpc3QubnRoX29wdCB0IGlkeCB3aXRoXG4gICAgICB8IFNvbWUgKGtleSwgXykgLT4gU29tZSBrZXlcbiAgICAgIHwgTm9uZSAtPiBOb25lXG5cbiAgICBsZXQgc2V0X3ZhbHVlIGsgdiAodCA6IHQpID1cbiAgICAgIG1hdGNoIGluZGV4X29mIGsgdCB3aXRoXG4gICAgICB8IFNvbWUgaWR4IC0+IENDTGlzdC5zZXRfYXRfaWR4IGlkeCAoaywgdikgdFxuICAgICAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuXG4gICAgbGV0IHJlbW92ZV9pbmRleCBpbmRleCAodCA6IHQpID0gQ0NMaXN0LnJlbW92ZV9hdF9pZHggaW5kZXggdFxuICBlbmRcblxuICB0eXBlIG9wID1cbiAgICB7IGtleToga2V5XG4gICAgOyBhY3Rpb246IGFjdGlvblxuICAgIDsgYWN0b3I6IGFjdG9yXG4gICAgOyBzZXE6IHNlcVxuICAgIDsgb2JqOiBvYmpfaWRcbiAgICA7IGVsZW06IGludCBvcHRpb25cbiAgICA7IHZhbHVlOiBvcF92YWwgb3B0aW9uIH1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGNoYW5nZV9vcCA9XG4gICAgeyBrZXk6IGtleSBvcHRpb25cbiAgICA7IGFjdGlvbjogYWN0aW9uXG4gICAgOyBvYmo6IG9ial9pZFxuICAgIDsgZWxlbTogaW50IG9wdGlvblxuICAgIDsgdmFsdWU6IG9wX3ZhbCBvcHRpb24gfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgbGFtcG9ydF9vcCA9IHthY3RvcjogYWN0b3I7IGVsZW06IGludH0gW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgbGFtcG9ydF9jb21wYXJlIG9wMSBvcDIgPVxuICAgIGlmIG9wMS5lbGVtIDwgb3AyLmVsZW0gdGhlbiAtMVxuICAgIGVsc2UgaWYgb3AxLmVsZW0gPiBvcDIuZWxlbSB0aGVuIDFcbiAgICBlbHNlIGlmIG9wMS5hY3RvciA8IG9wMi5hY3RvciB0aGVuIC0xXG4gICAgZWxzZSBpZiBvcDEuYWN0b3IgPiBvcDIuYWN0b3IgdGhlbiAxXG4gICAgZWxzZSAwXG5cbiAgKCogVGhlIG9yaWdpbmFsIHVzZXMgYSBzaW5nbGUgb2JqZWN0IGZvciBhbGwgb3BzLCBhbmQgZGlzY3JpbWluYXRlcyBvcCB0eXBlIGJhc2VkIG9uIG9wLmFjdGlvbi5cbiAgICAgVGhpcyBpcyB1bnNhZmUgc2luY2UgdGhlIGludmFyaWFudCB0aGF0LCBmb3IgZXhhbXBsZSwgb3AuZWxlbSBtdXN0IGJlIGRlZmluZWQgZm9yIElucyBvcGVyYXRpb25zIGlzIGltcGxpY2l0IGluIHRoZSBBUEkgYW5kIG5vdCBhY3R1YWxseSBlbmZvcmNlZC5cbiAgICAgV2UgYXQgbGVhc3QgbWFrZSB0aGUgZWxlbSBmaWVsZCBvcHRpb25hbCwgdG8gZW5jb2RlIGl0cyBwb3RlbnRpYWxseSB1bmRlZmluZWQgbmF0dXJlLlxuICAgICBXZSB1c2UgdGhlIGdldF9vcF9lbGVtIGZ1bmN0aW9uIHRvIGFjY2VzcyB0aGUgZWxlbSBmaWVsZCBhbmQgY2F0Y2ggdGhlIGludmFyaWFudCB2aW9sYXRpb24gYXQgcnVudGltZS5cbiAgKilcbiAgbGV0IGdldF9vcF9lbGVtIChvcCA6IG9wKSA9XG4gICAgbWF0Y2ggb3AuZWxlbSB3aXRoXG4gICAgfCBTb21lIGlkeCAtPiBpZHhcbiAgICB8IE5vbmUgLT4gcmFpc2UgQWNjZXNzaW5nX3VuZWZpbmVkX2VsZW1lbnRfaW5kZXhcblxuICBtb2R1bGUgT3BTZXQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIENDU2V0TWFrZSAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBvcFxuXG4gICAgICAoKiBUT0RPOiBJcyB0aGlzIHRoZSByaWdodCBjb21wYXJlIGZ1bj8gU2hvdWxkIHdlIGJlIGNvbXBhcmluZyBzZXEgaW5zdGVhZCBvZiBlbGVtPyAqKVxuICAgICAgbGV0IGNvbXBhcmUgKG9wMSA6IG9wKSAob3AyIDogb3ApID1cbiAgICAgICAgbGV0IGxvcDEgPSB7YWN0b3I9IG9wMS5hY3RvcjsgZWxlbT0gZ2V0X29wX2VsZW0gb3AxfSBpblxuICAgICAgICBsZXQgbG9wMiA9IHthY3Rvcj0gb3AxLmFjdG9yOyBlbGVtPSBnZXRfb3BfZWxlbSBvcDJ9IGluXG4gICAgICAgIGxhbXBvcnRfY29tcGFyZSBsb3AxIGxvcDJcblxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2Zfb3BcbiAgICBlbmQpXG4gIGVuZFxuXG4gIHR5cGUgY2hhbmdlID1cbiAgICB7IGFjdG9yOiBhY3RvclxuICAgIDsgc2VxOiBzZXFcbiAgICA7ICgqIExpc3Qgb2YgZGVwZW5kZWQgb3Agc2VxdWVuY2VzIGJ5IGFjdG9yLiAqKVxuICAgICAgZGVwczogc2VxIEFjdG9yTWFwLnRcbiAgICA7IG9wczogY2hhbmdlX29wIGxpc3QgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgc3RhdGUgPSB7Y2hhbmdlOiBjaGFuZ2U7IGFsbERlcHM6IHNlcSBBY3Rvck1hcC50fSBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgZWRpdF9hY3Rpb24gPSBDcmVhdGUgfCBJbnNlcnQgfCBSZW1vdmUgfCBTZXQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGVkaXRfdHlwZSA9IE1hcCB8IFRleHQgfCBMaXN0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSBjb25mbGljdCA9IHthY3RvcjogYWN0b3I7IHZhbHVlOiBvcF92YWwgb3B0aW9uOyBsaW5rOiBib29sIG9wdGlvbn1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGVkaXQgPVxuICAgIHsgX3R5cGU6IGVkaXRfdHlwZVxuICAgIDsgYWN0aW9uOiBlZGl0X2FjdGlvblxuICAgIDsgZWxlbV9pZF9fa2V5OiBrZXkgb3B0aW9uXG4gICAgOyBrZXk6IHN0cmluZyBvcHRpb25cbiAgICA7IHZhbHVlOiB2YWx1ZSBvcHRpb25cbiAgICA7IG9iajogb2JqX2lkXG4gICAgOyBsaW5rOiBib29sXG4gICAgOyBpbmRleDogaW50IG9wdGlvblxuICAgIDsgY29uZmxpY3RzOiBjb25mbGljdCBsaXN0IG9wdGlvblxuICAgIDsgcGF0aDogW2BJbnRQYXRoIG9mIGludCB8IGBTdHJQYXRoIG9mIGtleV0gbGlzdCBvcHRpb24gfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgcmVmID0ge2FjdGlvbjogYWN0aW9uOyBvYmo6IG9ial9pZDsga2V5OiBrZXk7IHZhbHVlOiB2YWx1ZSBvcHRpb259XG5cbiAgdHlwZSBvYmpfYXV4ID1cbiAgICB7IF9tYXhfZWxlbTogaW50XG4gICAgOyBfZm9sbG93aW5nOiBvcCBsaXN0IEtleU1hcC50XG4gICAgOyBfaW5pdDogb3BcbiAgICA7IF9pbmJvdW5kOiBPcFNldC50XG4gICAgOyBfZWxlbV9pZHM6IFNraXBMaXN0LnQgb3B0aW9uIHNleHBfb3BhcXVlXG4gICAgOyBfaW5zZXJ0aW9uOiBvcCBFbGVtSWRNYXAudCB9XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSBvYmogPSBvcCBsaXN0IEtleU1hcC50ICogb2JqX2F1eCBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgZGlmZl90eXBlID0gRGlmZk1hcCB8IERpZmZMaXN0IHwgRGlmZlRleHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGRpZmZfYWN0aW9uID0gRGlmZkNyZWF0ZSB8IERpZmZTZXQgfCBEaWZmSW5zZXJ0IFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSBkaWZmID1cbiAgICB7IG9iajogc3RyaW5nXG4gICAgOyB0eXBlXzogZGlmZl90eXBlXG4gICAgOyBhY3Rpb246IGRpZmZfYWN0aW9uXG4gICAgOyBrZXk6IGtleSBvcHRpb25cbiAgICA7IHZhbHVlOiBvcF92YWwgb3B0aW9uXG4gICAgOyBsaW5rOiBib29sIG9wdGlvblxuICAgIDsgaW5kZXg6IGludCBvcHRpb25cbiAgICA7IGVsZW1faWQ6IHN0cmluZyBvcHRpb25cbiAgICA7IGNvbmZsaWN0czogY29uZmxpY3QgbGlzdCBvcHRpb24gfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgY2hpbGQgPSBzdHJpbmcgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGNvbnRleHQgPSBkaWZmIGxpc3QgRGlmZk1hcC50ICogY2hpbGQgbGlzdCBDaGlsZE1hcC50XG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSB0ID1cbiAgICB7IHN0YXRlczpcbiAgICAgICAgc3RhdGUgbGlzdCBBY3Rvck1hcC50XG4gICAgICAgICgqIExpc3Qgb2Ygc3RhdGVzIGZvciBldmVyeSBhY3RvciBmb3IgZXZlcnkgc2VxICopXG4gICAgOyBoaXN0b3J5OiBjaGFuZ2UgbGlzdFxuICAgIDsgYnlfb2JqZWN0OiBvYmogT2JqZWN0SWRNYXAudFxuICAgIDsgY2xvY2s6XG4gICAgICAgIHNlcSBBY3Rvck1hcC50XG4gICAgICAgICgqIEFsbCBvYnNlcnZlZCBhY3RvciBjbG9ja3MuICopXG4gICAgICAgICgqIEFzIHlvdSByZWNlaWV2ZSBuZXcgb3BzLCB0aGUgY29ycmVzcG9uZGluZyBhY3RvciBjbG9jayBpcyB1cGRhdGVkLiAqKVxuICAgIDsgZGVwczogc2VxIEFjdG9yTWFwLnRcbiAgICA7IHVuZG9fcG9zOiBpbnRcbiAgICA7IHVuZG9fc3RhY2s6IHJlZiBsaXN0IGxpc3Qgc2V4cF9vcGFxdWVcbiAgICA7IHJlZG9fc3RhY2s6IHJlZiBsaXN0IGxpc3Qgc2V4cF9vcGFxdWVcbiAgICA7IHF1ZXVlOiBjaGFuZ2UgQ0NGUXVldWVXaXRoU2V4cC50XG4gICAgOyB1bmRvX2xvY2FsOiByZWYgbGlzdCBvcHRpb24gc2V4cF9vcGFxdWUgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gICgqIERlYnVnIGxvZ2dnZXJzICopXG5cbiAgbW9kdWxlIExMb2cgPSBzdHJ1Y3RcbiAgICBsZXQgc3RhdGVzICh0IDogdCkgPVxuICAgICAgbG9nIFwic3RhdGVzXCIgKEFjdG9yTWFwLnNleHBfb2ZfdCAoc2V4cF9vZl9saXN0IHNleHBfb2Zfc3RhdGUpKSB0LnN0YXRlc1xuXG4gICAgbGV0IHNlcV9hY3Rvcl9tYXAgbSA9IGxvZyBcImFjdG9yX21hcFwiIChBY3Rvck1hcC5zZXhwX29mX3Qgc2V4cF9vZl9pbnQpIG1cbiAgZW5kXG5cbiAgKCogSGVscGVycyBub3QgZm91bmQgaW4gb3JpZ2luYWwgKilcbiAgbGV0IGdldF9vYmpfYXV4IHQgb2JqX2lkID0gQ0NPcHQubWFwIHNuZCAoT2JqZWN0SWRNYXAuZ2V0IG9ial9pZCB0LmJ5X29iamVjdClcblxuICBsZXQgZ2V0X29ial9hdXhfZXhuIHQgb2JqX2lkID0gQ0NPcHQuZ2V0X2V4biAoZ2V0X29ial9hdXggdCBvYmpfaWQpXG5cbiAgbGV0IGdldF9vcF92YWx1ZV9hc19zdHJpbmdfZXhuID0gZnVuY3Rpb25cbiAgICB8IFN0clZhbHVlIHMgLT4gc1xuICAgIHwgQm9vbFZhbHVlIF8gfCBOdW1iZXJWYWx1ZSBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwib3AudmFsdWVcIilcblxuICBsZXQgZ2V0X29ial9hY3Rpb24gdCBvYmpfaWQgPSAoZ2V0X29ial9hdXhfZXhuIHQgb2JqX2lkKS5faW5pdC5hY3Rpb25cblxuICAoKiBSZXR1cm5zIHRydWUgaWYgYWxsIGNoYW5nZXMgdGhhdCBjYXVzYWxseSBwcmVjZWRlIHRoZSBnaXZlbiBjaGFuZ2UgKilcbiAgKCogaGF2ZSBhbHJlYWR5IGJlZW4gYXBwbGllZCBpbiBgb3BTZXRgLiAqKVxuICAoKiBBbGwgY2hhbmdlcyBhcmUgY2F1c2FsbHkgKGFuZCB0b3RhbGx5KSBvcmRlcmVkIHVzaW5nIGxhbXBvcnQgdGltZXN0YW1wcyAqKVxuICAoKiBXaGVuIGEgbmV3IG9wIGxhbmRzIGluIHRoZSBvcCBzZXQsIGNoZWNrIGlmIGFsbCBwcmVjZWVkaW5nIG9wcyBoYXZlIGJlZW4gYXBwbGllZCAqKVxuICAoKiBJZiB3ZSBzdG9yZSBvcHMgaW4gSXJtaW4sIGNhdXNhbGl0eSBpcyBlbmZvcmNlZCBieSBoaXN0b3J5LCBha2EgdGhlIE1lcmtsZSBEQUcuICopXG4gIGxldCBjYXVzYWx5X3JlYWR5IHQgKGNoYW5nZSA6IGNoYW5nZSkgPVxuICAgIGNoYW5nZS5kZXBzXG4gICAgfD4gQWN0b3JNYXAudXBkYXRlIGNoYW5nZS5hY3RvciAoZnVuY3Rpb25cbiAgICAgICAgIHwgU29tZSBzZXEgLT4gU29tZSAoc2VxIC0gMSlcbiAgICAgICAgIHwgTm9uZSAtPiBOb25lIClcbiAgICB8PiBBY3Rvck1hcC5mb3JfYWxsIChmdW4gZGVwQWN0b3IgZGVwU2VxIC0+XG4gICAgICAgICAgIG1hdGNoIEFjdG9yTWFwLmZpbmRfb3B0IGRlcEFjdG9yIHQuY2xvY2sgd2l0aFxuICAgICAgICAgICB8IFNvbWUgZGVwQ2xvY2sgLT4gZGVwQ2xvY2sgPj0gZGVwU2VxXG4gICAgICAgICAgIHwgTm9uZSAtPiBkZXBTZXEgPj0gMCApXG5cbiAgKCpcbiAgICAgQWxsIGNoYW5nZSBvcHMgKyBhbGxEZXBzIG9mIGV2ZXJ5IGFjdG9yIHN0YXRlIGF0IGN1cnJlbnQgc2VxP1xuICAgICBTb21ldGhpbmcgbGlrZSB0aGF0Li4uIGllXG4gICAgIEZvciBldmVyeSBhY3RvciBvcCB0aGF0IGEgY2hhbmdlIGRlcGVuZHMgb25cbiAgICAgZ2V0IGFsbCBkZXBzIG9mIHRoZSBhY3RvcnMgY3VycmVudCBzdGF0ZT9cbiAgKilcbiAgbGV0IHRyYW5zaXRpdmVfZGVwcyB0IGJhc2VEZXBzID1cbiAgICBBY3Rvck1hcC5mb2xkXG4gICAgICAoZnVuIGRlcEFjdG9yIGRlcFNlcSBkZXBzIC0+XG4gICAgICAgIGlmIGRlcFNlcSA8PSAwIHRoZW4gZGVwc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggQWN0b3JNYXAuZmluZF9vcHQgZGVwQWN0b3IgdC5zdGF0ZXMgd2l0aFxuICAgICAgICAgIHwgU29tZSBzdGF0ZXMgLT4gKFxuICAgICAgICAgICAgbWF0Y2ggTGlzdC5udGhfb3B0IHN0YXRlcyAoZGVwU2VxIC0gMSkgd2l0aFxuICAgICAgICAgICAgfCBTb21lIHN0YXRlIC0+XG4gICAgICAgICAgICAgICAgQWN0b3JNYXAubWVyZ2VcbiAgICAgICAgICAgICAgICAgIChmdW4gXyBsIHIgLT5cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBTb21lIGwsIFNvbWUgciAtPiBTb21lIChDQ0ludC5tYXggbCByKVxuICAgICAgICAgICAgICAgICAgICB8IFNvbWUgbCwgTm9uZSAtPiBTb21lIGxcbiAgICAgICAgICAgICAgICAgICAgfCBOb25lLCBTb21lIHIgLT4gU29tZSByXG4gICAgICAgICAgICAgICAgICAgIHwgTm9uZSwgTm9uZSAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcImtleVwiKSApXG4gICAgICAgICAgICAgICAgICBkZXBzIHN0YXRlLmFsbERlcHNcbiAgICAgICAgICAgICAgICB8PiBBY3Rvck1hcC5hZGQgZGVwQWN0b3IgZGVwU2VxXG4gICAgICAgICAgICB8IE5vbmUgLT4gZGVwcyApXG4gICAgICAgICAgfCBOb25lIC0+IGRlcHMgKVxuICAgICAgYmFzZURlcHMgQWN0b3JNYXAuZW1wdHlcblxuICBsZXQgYXBwbHlfbWFrZSB0IChvcCA6IG9wKSA9XG4gICAgbGV0IGVkaXQsIG9ial9hdXggPVxuICAgICAgbWF0Y2ggb3AuYWN0aW9uIHdpdGhcbiAgICAgIHwgTWFrZU1hcCAtPlxuICAgICAgICAgIGxldCBlID1cbiAgICAgICAgICAgIHsgYWN0aW9uPSBDcmVhdGVcbiAgICAgICAgICAgIDsgX3R5cGU9IE1hcFxuICAgICAgICAgICAgOyBvYmo9IG9wLm9ialxuICAgICAgICAgICAgOyBrZXk9IE5vbmVcbiAgICAgICAgICAgIDsgaW5kZXg9IE5vbmVcbiAgICAgICAgICAgIDsgcGF0aD0gTm9uZVxuICAgICAgICAgICAgOyBjb25mbGljdHM9IE5vbmVcbiAgICAgICAgICAgIDsgbGluaz0gZmFsc2VcbiAgICAgICAgICAgIDsgZWxlbV9pZF9fa2V5PSBOb25lXG4gICAgICAgICAgICA7IHZhbHVlPSBOb25lIH1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBvID1cbiAgICAgICAgICAgIHsgX21heF9lbGVtPSAwXG4gICAgICAgICAgICA7IF9mb2xsb3dpbmc9IEtleU1hcC5lbXB0eVxuICAgICAgICAgICAgOyBfaW5zZXJ0aW9uPSBFbGVtSWRNYXAuZW1wdHlcbiAgICAgICAgICAgIDsgX2luaXQ9IG9wXG4gICAgICAgICAgICA7IF9pbmJvdW5kPSBPcFNldC5lbXB0eVxuICAgICAgICAgICAgOyBfZWxlbV9pZHM9IE5vbmUgfVxuICAgICAgICAgIGluXG4gICAgICAgICAgKGUsIG8pXG4gICAgICB8IE1ha2VUZXh0IC0+XG4gICAgICAgICAgbGV0IGUgPVxuICAgICAgICAgICAgeyBhY3Rpb249IENyZWF0ZVxuICAgICAgICAgICAgOyBfdHlwZT0gVGV4dFxuICAgICAgICAgICAgOyBvYmo9IG9wLm9ialxuICAgICAgICAgICAgOyBpbmRleD0gTm9uZVxuICAgICAgICAgICAgOyBjb25mbGljdHM9IE5vbmVcbiAgICAgICAgICAgIDsgcGF0aD0gTm9uZVxuICAgICAgICAgICAgOyBsaW5rPSBmYWxzZVxuICAgICAgICAgICAgOyBrZXk9IE5vbmVcbiAgICAgICAgICAgIDsgZWxlbV9pZF9fa2V5PSBOb25lXG4gICAgICAgICAgICA7IHZhbHVlPSBOb25lIH1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBvID1cbiAgICAgICAgICAgIHsgX21heF9lbGVtPSAwXG4gICAgICAgICAgICA7IF9mb2xsb3dpbmc9IEtleU1hcC5lbXB0eVxuICAgICAgICAgICAgOyBfaW5zZXJ0aW9uPSBFbGVtSWRNYXAuZW1wdHlcbiAgICAgICAgICAgIDsgX2luaXQ9IG9wXG4gICAgICAgICAgICA7IF9pbmJvdW5kPSBPcFNldC5lbXB0eVxuICAgICAgICAgICAgOyBfZWxlbV9pZHM9IFNvbWUgW10gfVxuICAgICAgICAgIGluXG4gICAgICAgICAgKGUsIG8pXG4gICAgICB8IE1ha2VMaXN0IC0+XG4gICAgICAgICAgbGV0IGUgPVxuICAgICAgICAgICAgeyBhY3Rpb249IENyZWF0ZVxuICAgICAgICAgICAgOyBrZXk9IE5vbmVcbiAgICAgICAgICAgIDsgX3R5cGU9IExpc3RcbiAgICAgICAgICAgIDsgY29uZmxpY3RzPSBOb25lXG4gICAgICAgICAgICA7IG9iaj0gb3Aub2JqXG4gICAgICAgICAgICA7IGluZGV4PSBOb25lXG4gICAgICAgICAgICA7IHBhdGg9IE5vbmVcbiAgICAgICAgICAgIDsgbGluaz0gZmFsc2VcbiAgICAgICAgICAgIDsgZWxlbV9pZF9fa2V5PSBOb25lXG4gICAgICAgICAgICA7IHZhbHVlPSBOb25lIH1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBvID1cbiAgICAgICAgICAgIHsgX21heF9lbGVtPSAwXG4gICAgICAgICAgICA7IF9mb2xsb3dpbmc9IEtleU1hcC5lbXB0eVxuICAgICAgICAgICAgOyBfaW5zZXJ0aW9uPSBFbGVtSWRNYXAuZW1wdHlcbiAgICAgICAgICAgIDsgX2luaXQ9IG9wXG4gICAgICAgICAgICA7IF9pbmJvdW5kPSBPcFNldC5lbXB0eVxuICAgICAgICAgICAgOyBfZWxlbV9pZHM9IFNvbWUgW10gfVxuICAgICAgICAgIGluXG4gICAgICAgICAgKGUsIG8pXG4gICAgICB8IF8gLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgIGluXG4gICAgbGV0IGJ5X29iamVjdCA9XG4gICAgICBPYmplY3RJZE1hcC5hZGQgb3Aub2JqIChLZXlNYXAuZW1wdHksIG9ial9hdXgpIHQuYnlfb2JqZWN0XG4gICAgaW5cbiAgICAoe3Qgd2l0aCBieV9vYmplY3R9LCBbZWRpdF0pXG5cbiAgbGV0IGFwcGx5X2luc2VydCB0IChvcCA6IG9wKSA9XG4gICAgbGV0IGVsZW1faWQgPSBvcC5hY3RvciBeIFwiOlwiIF4gQ0NJbnQudG9fc3RyaW5nIChnZXRfb3BfZWxlbSBvcCkgaW5cbiAgICAoIG1hdGNoIE9iamVjdElkTWFwLmZpbmRfb3B0IG9wLm9iaiB0LmJ5X29iamVjdCB3aXRoXG4gICAgfCBTb21lIChfLCBvYmpfYXV4KSAtPlxuICAgICAgICBpZiBFbGVtSWRNYXAubWVtIGVsZW1faWQgb2JqX2F1eC5faW5zZXJ0aW9uIHRoZW5cbiAgICAgICAgICByYWlzZSBEdXBsaWNhdGVfbGlzdF9lbGVtZW50X2lkXG4gICAgICAgIGVsc2UgKClcbiAgICB8IE5vbmUgLT4gcmFpc2UgTW9kaWZpY2F0aW9uX29mX3Vua25vd25fb2JqZWN0ICkgO1xuICAgIGxldCBieV9vYmplY3QgPVxuICAgICAgT2JqZWN0SWRNYXAudXBkYXRlIG9wLm9ialxuICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgKG9iaiwgb2JqX2F1eCkgLT5cbiAgICAgICAgICAgICAgbGV0IF9mb2xsb3dpbmcgPVxuICAgICAgICAgICAgICAgIEtleU1hcC51cGRhdGUgb3Aua2V5XG4gICAgICAgICAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfCBTb21lIGwgLT4gU29tZSAoTGlzdC5hcHBlbmQgbCBbb3BdKSB8IE5vbmUgLT4gU29tZSBbb3BdKVxuICAgICAgICAgICAgICAgICAgb2JqX2F1eC5fZm9sbG93aW5nXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBfbWF4X2VsZW0gPSBtYXggKGdldF9vcF9lbGVtIG9wKSBvYmpfYXV4Ll9tYXhfZWxlbSBpblxuICAgICAgICAgICAgICBsZXQgX2luc2VydGlvbiA9IEVsZW1JZE1hcC5hZGQgZWxlbV9pZCBvcCBvYmpfYXV4Ll9pbnNlcnRpb24gaW5cbiAgICAgICAgICAgICAgU29tZSAob2JqLCB7b2JqX2F1eCB3aXRoIF9mb2xsb3dpbmc7IF9tYXhfZWxlbTsgX2luc2VydGlvbn0pXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmUpXG4gICAgICAgIHQuYnlfb2JqZWN0XG4gICAgaW5cbiAgICBsZXQgdCA9IHt0IHdpdGggYnlfb2JqZWN0fSBpblxuICAgICh0LCBbXSlcblxuICBsZXQgZ2V0X2NvbmZsaWN0cyAob3BzIDogb3AgbGlzdCkgPVxuICAgIG1hdGNoIG9wcyB3aXRoXG4gICAgfCBfIDo6IG9wc19yZXN0IC0+XG4gICAgICAgIENDTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgICAoZnVuIGNvbmZsaWN0cyAob3AgOiBvcCkgLT5cbiAgICAgICAgICAgIGxldCBsaW5rID0gbWF0Y2ggb3AuYWN0aW9uIHdpdGggTGluayAtPiB0cnVlIHwgXyAtPiBmYWxzZSBpblxuICAgICAgICAgICAgbGV0IGNvbmYgOiBjb25mbGljdCA9XG4gICAgICAgICAgICAgIHthY3Rvcj0gb3AuYWN0b3I7IHZhbHVlPSBvcC52YWx1ZTsgbGluaz0gU29tZSBsaW5rfVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIENDT3B0Lm1hcCAoZnVuIGNzIC0+IGNzIEAgW2NvbmZdKSBjb25mbGljdHMgKVxuICAgICAgICAgIChTb21lIFtdKSBvcHNfcmVzdFxuICAgIHwgW10gLT4gTm9uZVxuXG4gICgqIFJldHVybnMgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvYmplY3QgdG8gdGhlIGdpdmVuIG9iamVjdElkLCBhcyBhbiBhcnJheSBvZiBzdHJpbmcga2V5c1xuICAgICAoZm9yIGFuY2VzdG9yIG1hcHMpIGFuZCBpbnRlZ2VyIGluZGV4ZXMgKGZvciBhbmNlc3RvciBsaXN0cykuIElmIHRoZXJlIGFyZSBzZXZlcmFsIHBhdGhzXG4gICAgIHRvIHRoZSBzYW1lIG9iamVjdCwgcmV0dXJucyBvbmUgb2YgdGhlIHBhdGhzIGFyYml0cmFyaWx5LiBJZiB0aGUgb2JqZWN0IGlzIG5vdCByZWFjaGFibGVcbiAgICAgZnJvbSB0aGUgcm9vdCwgcmV0dXJucyBudWxsLiAqKVxuICBsZXQgcmVjIGdldF9wYXRoIHQgb2JqX2lkIHBhdGggPVxuICAgIGlmIFN0cmluZy5lcXVhbCBvYmpfaWQgcm9vdF9pZCB0aGVuIHBhdGhcbiAgICBlbHNlXG4gICAgICBtYXRjaCBPYmplY3RJZE1hcC5nZXQgb2JqX2lkIHQuYnlfb2JqZWN0IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICB8IFNvbWUgKF8sIG9ial9hdXgpIC0+IChcbiAgICAgICAgbWF0Y2ggT3BTZXQuY2hvb3NlX29wdCBvYmpfYXV4Ll9pbmJvdW5kIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgfCBTb21lIHJlZiAtPiAoXG4gICAgICAgICAgbWF0Y2ggT2JqZWN0SWRNYXAuZ2V0IHJlZi5vYmogdC5ieV9vYmplY3Qgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIChfLCBvYmpfYXV4KSAtPiAoXG4gICAgICAgICAgICBtYXRjaCBvYmpfYXV4Ll9pbml0LmFjdGlvbiB3aXRoXG4gICAgICAgICAgICB8IE1ha2VMaXN0IHwgTWFrZVRleHQgLT4gKFxuICAgICAgICAgICAgICAgIGxldCBlbGVtX2lkcyA9IENDT3B0LmdldF9leG4gb2JqX2F1eC5fZWxlbV9pZHMgaW5cbiAgICAgICAgICAgICAgICBtYXRjaCBTa2lwTGlzdC5pbmRleF9vZiByZWYua2V5IGVsZW1faWRzIHdpdGhcbiAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgIHwgU29tZSBpbmRleCAtPlxuICAgICAgICAgICAgICAgICAgICBnZXRfcGF0aCB0IHJlZi5vYmpcbiAgICAgICAgICAgICAgICAgICAgICAoQ0NPcHQubWFwIChmdW4gcCAtPiBgSW50UGF0aCBpbmRleCA6OiBwKSBwYXRoKSApXG4gICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAgICBnZXRfcGF0aCB0IHJlZi5vYmpcbiAgICAgICAgICAgICAgICAgIChDQ09wdC5tYXAgKGZ1biBwIC0+IGBTdHJQYXRoIHJlZi5rZXkgOjogcCkgcGF0aCkgKSApIClcblxuICBsZXQgcGF0Y2hfbGlzdCAodCA6IHQpIG9ial9pZCBpbmRleCAoZWxlbV9pZF9fa2V5IDoga2V5KVxuICAgICAgKGFjdGlvbiA6IGVkaXRfYWN0aW9uKSAob3BzIDogb3AgbGlzdCBvcHRpb24pID1cbiAgICBsZXQgX3R5cGUgPVxuICAgICAgbGV0IF8sIG9ial9hdXggPSBPYmplY3RJZE1hcC5nZXQgb2JqX2lkIHQuYnlfb2JqZWN0IHw+IENDT3B0LmdldF9leG4gaW5cbiAgICAgIG1hdGNoIG9ial9hdXguX2luaXQuYWN0aW9uIHdpdGggTWFrZVRleHQgLT4gVGV4dCB8IF8gLT4gTGlzdFxuICAgIGluXG4gICAgbGV0IGZpcnN0X29wID0gQ0NPcHQuZmxhdF9tYXAgKGZ1biBvcHMgLT4gQ0NMaXN0Lm50aF9vcHQgb3BzIDApIG9wcyBpblxuICAgIGxldCBlbGVtX2lkcyA9IENDT3B0LmdldF9leG4gKGdldF9vYmpfYXV4X2V4biB0IG9ial9pZCkuX2VsZW1faWRzIGluXG4gICAgbGV0IHZhbHVlID0gQ0NPcHQuZmxhdF9tYXAgKGZ1biAoZm9wIDogb3ApIC0+IGZvcC52YWx1ZSkgZmlyc3Rfb3AgaW5cbiAgICBsZXQgdmFsdWUgPSBDQ09wdC5tYXAgKGZ1biB2IC0+IFZhbHVlIHYpIHZhbHVlIGluXG4gICAgbGV0IHBhdGggPSBnZXRfcGF0aCB0IG9ial9pZCAoU29tZSBbXSkgaW5cbiAgICBsZXQgZWRpdCA6IGVkaXQgPVxuICAgICAgeyBhY3Rpb25cbiAgICAgIDsgX3R5cGVcbiAgICAgIDsgb2JqPSBvYmpfaWRcbiAgICAgIDsgaW5kZXg9IFNvbWUgaW5kZXhcbiAgICAgIDsga2V5PSBOb25lXG4gICAgICA7IHBhdGhcbiAgICAgIDsgbGluaz0gZmFsc2VcbiAgICAgIDsgdmFsdWU9IE5vbmVcbiAgICAgIDsgY29uZmxpY3RzPSBOb25lXG4gICAgICA7IGVsZW1faWRfX2tleT0gTm9uZSB9XG4gICAgaW5cbiAgICBsZXQgZWRpdCwgdmFsdWUgPVxuICAgICAgbWF0Y2ggZmlyc3Rfb3Agd2l0aFxuICAgICAgfCBTb21lIGZvcCB3aGVuIGZvcC5hY3Rpb24gPSBMaW5rIC0+XG4gICAgICAgICAgKCB7ZWRpdCB3aXRoIGxpbms9IHRydWV9XG4gICAgICAgICAgLCBTb21lIChMaW5rIHtvYmo9IFZhbHVlIChDQ09wdC5nZXRfZXhuIGZvcC52YWx1ZSl9KSApXG4gICAgICB8IF8gLT4gKGVkaXQsIHZhbHVlKVxuICAgIGluXG4gICAgbGV0IGVsZW1faWRzLCBlZGl0ID1cbiAgICAgIG1hdGNoIGFjdGlvbiB3aXRoXG4gICAgICB8IEluc2VydCAtPlxuICAgICAgICAgIGxldCBlbGVtX2lkcyA9XG4gICAgICAgICAgICBTa2lwTGlzdC5pbnNlcnRfaW5kZXggaW5kZXggKENDT3B0LmdldF9leG4gZmlyc3Rfb3ApLmtleSB2YWx1ZVxuICAgICAgICAgICAgICBlbGVtX2lkc1xuICAgICAgICAgIGluXG4gICAgICAgICAgKGVsZW1faWRzLCB7ZWRpdCB3aXRoIGVsZW1faWRfX2tleT0gU29tZSBlbGVtX2lkX19rZXk7IHZhbHVlfSlcbiAgICAgIHwgU2V0IC0+XG4gICAgICAgICAgbGV0IGVsZW1faWRzID1cbiAgICAgICAgICAgIFNraXBMaXN0LnNldF92YWx1ZSAoQ0NPcHQuZ2V0X2V4biBmaXJzdF9vcCkua2V5IHZhbHVlIGVsZW1faWRzXG4gICAgICAgICAgaW5cbiAgICAgICAgICAoZWxlbV9pZHMsIHtlZGl0IHdpdGggdmFsdWV9KVxuICAgICAgfCBSZW1vdmUgLT4gKFNraXBMaXN0LnJlbW92ZV9pbmRleCBpbmRleCBlbGVtX2lkcywgZWRpdClcbiAgICAgIHwgQ3JlYXRlIC0+IHJhaXNlIFVua25vd25fYWN0aW9uX3R5cGVcbiAgICBpblxuICAgIGxldCBlZGl0ID1cbiAgICAgIG1hdGNoIG9wcyB3aXRoXG4gICAgICB8IFNvbWUgb3BzIHdoZW4gTGlzdC5sZW5ndGggb3BzID4gMSAtPlxuICAgICAgICAgIHtlZGl0IHdpdGggY29uZmxpY3RzPSBnZXRfY29uZmxpY3RzIG9wc31cbiAgICAgIHwgXyAtPiBlZGl0XG4gICAgaW5cbiAgICBsZXQgYnlfb2JqZWN0ID1cbiAgICAgIE9iamVjdElkTWFwLnVwZGF0ZSBvYmpfaWRcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTb21lIChvYmpfbWFwLCBvYmpfYXV4KSAtPlxuICAgICAgICAgICAgICBTb21lIChvYmpfbWFwLCB7b2JqX2F1eCB3aXRoIF9lbGVtX2lkcz0gU29tZSBlbGVtX2lkc30pXG4gICAgICAgICAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZClcbiAgICAgICAgdC5ieV9vYmplY3RcbiAgICBpblxuICAgICh7dCB3aXRoIGJ5X29iamVjdH0sIFtlZGl0XSlcblxuICAoKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBvcGVyYXRpb25zIGFyZSBjb25jdXJyZW50LCB0aGF0IGlzLCB0aGV5IGhhcHBlbmVkIHdpdGhvdXQgYmVpbmcgYXdhcmUgb2ZcbiAgICAgZWFjaCBvdGhlciAobmVpdGhlciBoYXBwZW5lZCBiZWZvcmUgdGhlIG90aGVyKS4gUmV0dXJucyBmYWxzZSBpZiBvbmUgc3VwZXJzZWRlcyB0aGUgb3RoZXIuICopXG4gIGxldCBpc19jb25jdXJyZW50IHQgKG9wMSA6IG9wKSAob3AyIDogb3ApID1cbiAgICBsZXQgYWN0b3IxLCBzZXExID0gKG9wMS5hY3Rvciwgb3AxLnNlcSkgaW5cbiAgICBsZXQgYWN0b3IyLCBzZXEyID0gKG9wMi5hY3Rvciwgb3AyLnNlcSkgaW5cbiAgICBsZXQgY2xvY2sxID1cbiAgICAgIChDQ0xpc3QubnRoIChBY3Rvck1hcC5maW5kIGFjdG9yMSB0LnN0YXRlcykgKHNlcTEgLSAxKSkuYWxsRGVwc1xuICAgIGluXG4gICAgbGV0IGNsb2NrMiA9XG4gICAgICAoQ0NMaXN0Lm50aCAoQWN0b3JNYXAuZmluZCBhY3RvcjIgdC5zdGF0ZXMpIChzZXEyIC0gMSkpLmFsbERlcHNcbiAgICBpblxuICAgIEFjdG9yTWFwLmdldF9vciBhY3RvcjIgfmRlZmF1bHQ6MCBjbG9jazEgPCBzZXEyXG4gICAgJiYgQWN0b3JNYXAuZ2V0X29yIGFjdG9yMSB+ZGVmYXVsdDowIGNsb2NrMiA8IHNlcTFcblxuICBsZXQgZ2V0X2ZpZWxkX29wcyB0IG9ial9pZCAoa2V5IDoga2V5KSA9XG4gICAgbWF0Y2ggT2JqZWN0SWRNYXAuZ2V0IG9ial9pZCB0LmJ5X29iamVjdCB3aXRoXG4gICAgfCBTb21lIChvYmpfbWFwLCBfKSAtPiBLZXlNYXAuZ2V0X29yIGtleSBvYmpfbWFwIH5kZWZhdWx0OltdXG4gICAgfCBOb25lIC0+IFtdXG5cbiAgbGV0IGdldF9wYXJlbnQgdCBvYmpfaWQgKGtleSA6IGtleSBvcHRpb24pID1cbiAgICBtYXRjaCBrZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGtleSB3aGVuIFN0cmluZy5lcXVhbCBrZXkgXCJfaGVhZFwiIC0+IE5vbmVcbiAgICB8IFNvbWUga2V5IC0+IChcbiAgICAgICAgbGV0IG9wZW4gQ0NPcHQuSW5maXggaW5cbiAgICAgICAgbGV0IGluc2VydGlvbiA9XG4gICAgICAgICAgT2JqZWN0SWRNYXAuZ2V0IG9ial9pZCB0LmJ5X29iamVjdFxuICAgICAgICAgID4+PSBmdW4gKF8sIG9ial9hdXgpIC0+XG4gICAgICAgICAgRWxlbUlkTWFwLmdldCBrZXkgb2JqX2F1eC5faW5zZXJ0aW9uID58PSBmdW4gb3AgLT4gb3Aua2V5XG4gICAgICAgIGluXG4gICAgICAgIG1hdGNoIGluc2VydGlvbiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiByYWlzZSBNaXNzaW5nX2luZGV4X2Zvcl9saXN0X2VsZW1lbnRcbiAgICAgICAgfCBTb21lIGsgLT4gU29tZSBrIClcblxuICBsZXQgaW5zZXJ0aW9uc19hZnRlciB0IG9ial9pZCAocGFyZW50X2lkIDoga2V5IG9wdGlvbilcbiAgICAgIChjaGlsZF9pZCA6IGtleSBvcHRpb24pID1cbiAgICBsZXQgY2hpbGRfa2V5ID1cbiAgICAgIG1hdGNoIGNoaWxkX2lkIHdpdGhcbiAgICAgIHwgU29tZSBjaGlsZF9pZCAtPlxuICAgICAgICAgICgqIENoaWxkIGlkIGlzIG9mIHRoZSBmb3JtYXQgYGFjdG9yOmVsZW1fZGlnaXRzYCAqKVxuICAgICAgICAgIGlmIENDU3RyaW5nLmNvbnRhaW5zIGNoaWxkX2lkICc6JyB0aGVuXG4gICAgICAgICAgICBsZXQgcGFydHMgPSBDQ1N0cmluZy5zcGxpdF9vbl9jaGFyICc6JyBjaGlsZF9pZCBpblxuICAgICAgICAgICAgbGV0IGFjdG9yID0gQ0NMaXN0Lm50aCBwYXJ0cyAwIGluXG4gICAgICAgICAgICBsZXQgZWxlbSA9IGludF9vZl9zdHJpbmcgKENDTGlzdC5udGggcGFydHMgMSkgaW5cbiAgICAgICAgICAgIFNvbWUge2FjdG9yOyBlbGVtfVxuICAgICAgICAgIGVsc2UgTm9uZVxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICBpblxuICAgIGxldCBmb2xsb3dpbmcgPVxuICAgICAgbWF0Y2ggZ2V0X29ial9hdXggdCBvYmpfaWQgd2l0aFxuICAgICAgfCBTb21lIG9ial9hdXggLT4gKFxuICAgICAgICBtYXRjaCBwYXJlbnRfaWQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gW11cbiAgICAgICAgfCBTb21lIHBhcmVudF9pZCAtPlxuICAgICAgICAgICAgS2V5TWFwLmdldF9vciB+ZGVmYXVsdDpbXSBwYXJlbnRfaWQgb2JqX2F1eC5fZm9sbG93aW5nIClcbiAgICAgIHwgTm9uZSAtPiBbXVxuICAgIGluXG4gICAgQ0NMaXN0LmZpbHRlclxuICAgICAgKGZ1biAob3AgOiBvcCkgLT4gbWF0Y2ggb3AuYWN0aW9uIHdpdGggSW5zIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgZm9sbG93aW5nXG4gICAgfD4gQ0NMaXN0LmZpbHRlciAoZnVuIChvcCA6IG9wKSAtPlxuICAgICAgICAgICBtYXRjaCBjaGlsZF9rZXkgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICAgICB8IFNvbWUgY2hpbGRfa2V5IC0+XG4gICAgICAgICAgICAgICBsYW1wb3J0X2NvbXBhcmVcbiAgICAgICAgICAgICAgICAge2FjdG9yPSBvcC5hY3RvcjsgZWxlbT0gZ2V0X29wX2VsZW0gb3B9XG4gICAgICAgICAgICAgICAgIGNoaWxkX2tleVxuICAgICAgICAgICAgICAgPCAwIClcbiAgICB8PiBDQ0xpc3Quc29ydCAoZnVuIChvcDEgOiBvcCkgKG9wMiA6IG9wKSAtPlxuICAgICAgICAgICBsYW1wb3J0X2NvbXBhcmVcbiAgICAgICAgICAgICB7YWN0b3I9IG9wMS5hY3RvcjsgZWxlbT0gZ2V0X29wX2VsZW0gb3AxfVxuICAgICAgICAgICAgIHthY3Rvcj0gb3AyLmFjdG9yOyBlbGVtPSBnZXRfb3BfZWxlbSBvcDJ9IClcbiAgICB8PiBDQ0xpc3QucmV2XG4gICAgfD4gQ0NMaXN0Lm1hcCAoZnVuIChvcCA6IG9wKSAtPlxuICAgICAgICAgICBvcC5hY3RvciBeIFwiOlwiIF4gc3RyaW5nX29mX2ludCAoZ2V0X29wX2VsZW0gb3ApIClcblxuICAoKiAgR2l2ZW4gdGhlIElEIG9mIGEgbGlzdCBlbGVtZW50LCByZXR1cm5zIHRoZSBJRCBvZiB0aGUgaW1tZWRpYXRlIHByZWRlY2Vzc29yIGxpc3QgZWxlbWVudCwgKilcbiAgKCogIG9yIG51bGwgaWYgdGhlIGdpdmVuIGxpc3QgZWxlbWVudCBpcyBhdCB0aGUgaGVhZC4gKilcbiAgbGV0IGdldF9wcmV2aW91cyB0IG9ial9pZCBrZXkgPVxuICAgIGxldCBwYXJlbnRfaWQgPSBnZXRfcGFyZW50IHQgb2JqX2lkIChTb21lIGtleSkgaW5cbiAgICBsZXQgY2hpbGRyZW4gPSBpbnNlcnRpb25zX2FmdGVyIHQgb2JqX2lkIHBhcmVudF9pZCBOb25lIGluXG4gICAgaWYgQ0NMaXN0Lmxlbmd0aCBjaGlsZHJlbiA+IDAgJiYgU3RyaW5nLmVxdWFsIChDQ0xpc3QuaGQgY2hpbGRyZW4pIGtleSB0aGVuXG4gICAgICBtYXRjaCBwYXJlbnRfaWQgd2l0aCBTb21lIFwiX2hlYWRcIiAtPiBOb25lIHwgXyAtPiBwYXJlbnRfaWRcbiAgICBlbHNlXG4gICAgICAoKiBJbiB0aGUgb3JpZ2luYWwgY29kZSwgdGhlcmUgc2VlbXMgdG8gYmUgYSBidWcgaGVyZSwgd2hlcmUgcHJldl9pZCB3aWxsIHN0aWxsIGJlIHVuZGVmaW5lZCB3aGVuIGZpc3QgY2hpbGQgaXMgZXF1YWwgdG8ga2V5LlxuICAgICAgICAgV2UgcmVwbGljYXRlIHRoZSBiZWhhdmlvciBhbnl3YXkgdG8gcHJlc2VydmUgdGhlIHNlbWFudGljcy4gKilcbiAgICAgIGxldCBwcmV2X2lkID1cbiAgICAgICAgbWF0Y2hcbiAgICAgICAgICBDQ0xpc3QuZmluZF9pZHggKGZ1biBjaGlsZCAtPiBTdHJpbmcuZXF1YWwgY2hpbGQga2V5KSBjaGlsZHJlblxuICAgICAgICB3aXRoXG4gICAgICAgIHwgU29tZSAoaWR4LCBfKSAtPlxuICAgICAgICAgICAgaWYgaWR4ID0gMCB0aGVuIE5vbmUgZWxzZSBTb21lIChDQ0xpc3QubnRoIGNoaWxkcmVuIChpZHggLSAxKSlcbiAgICAgICAgfCBOb25lIC0+IENDTGlzdC5sYXN0X29wdCBjaGlsZHJlblxuICAgICAgaW5cbiAgICAgIGxldCByZWMgbG9vcCBjaGlsZHJlbiBwcmV2X2lkID1cbiAgICAgICAgbGV0IGNoaWxkcmVuID0gaW5zZXJ0aW9uc19hZnRlciB0IG9ial9pZCBwcmV2X2lkIE5vbmUgaW5cbiAgICAgICAgaWYgQ0NMaXN0LmlzX2VtcHR5IGNoaWxkcmVuIHRoZW4gcHJldl9pZFxuICAgICAgICBlbHNlIGxvb3AgY2hpbGRyZW4gKENDTGlzdC5sYXN0X29wdCBjaGlsZHJlbilcbiAgICAgIGluXG4gICAgICBsb29wIGNoaWxkcmVuIHByZXZfaWRcblxuICBsZXQgdXBkYXRlX2xpc3RfZWxlbWVudCB0IG9ial9pZCAoZWxlbV9pZF9fa2V5IDoga2V5KSA9XG4gICAgbGV0IG9wcyA9IGdldF9maWVsZF9vcHMgdCBvYmpfaWQgZWxlbV9pZF9fa2V5IGluXG4gICAgbGV0IF8sIHtfZWxlbV9pZHN9ID0gT2JqZWN0SWRNYXAuZmluZCBvYmpfaWQgdC5ieV9vYmplY3QgaW5cbiAgICBsZXQgZWxlbV9pZHMgPSBDQ09wdC5nZXRfZXhuIF9lbGVtX2lkcyBpblxuICAgIGxldCBpbmRleCA9IFNraXBMaXN0LmluZGV4X29mIGVsZW1faWRfX2tleSBlbGVtX2lkcyBpblxuICAgIG1hdGNoIGluZGV4IHdpdGhcbiAgICB8IFNvbWUgaW5kZXggLT5cbiAgICAgICAgaWYgQ0NMaXN0LmlzX2VtcHR5IG9wcyB0aGVuXG4gICAgICAgICAgcGF0Y2hfbGlzdCB0IG9ial9pZCBpbmRleCBlbGVtX2lkX19rZXkgUmVtb3ZlIE5vbmVcbiAgICAgICAgZWxzZSBwYXRjaF9saXN0IHQgb2JqX2lkIGluZGV4IGVsZW1faWRfX2tleSBTZXQgKFNvbWUgb3BzKVxuICAgIHwgTm9uZSAtPlxuICAgICAgICAoKiBEZWxldGluZyBhIG5vbi1leGlzdGVudCBlbGVtZW50ID0gbm8tb3AgKilcbiAgICAgICAgaWYgQ0NMaXN0LmlzX2VtcHR5IG9wcyB0aGVuICh0LCBbXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCByZWMgbG9vcCBwcmV2X2lkID1cbiAgICAgICAgICAgIG1hdGNoIGdldF9wcmV2aW91cyB0IG9ial9pZCBwcmV2X2lkIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiAtMVxuICAgICAgICAgICAgfCBTb21lIHByZXZfaWQgLT4gKFxuICAgICAgICAgICAgICBtYXRjaCBTa2lwTGlzdC5pbmRleF9vZiBwcmV2X2lkIGVsZW1faWRzIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIGluZGV4IC0+IGluZGV4XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIHByZXZfaWQgKVxuICAgICAgICAgIGluXG4gICAgICAgICAgKCogSW5kZXggY2FuIGJlIC0xIGhlcmUsIHRoaXMgZmVlbHMgbGlrZSBhbiBlcnJvciwgYnV0IHdlIGtlZXAgZ29pbmcgdG8gcHJlc2VydmUgc2VtYW50aWNzICopXG4gICAgICAgICAgbGV0IGluZGV4ID0gbG9vcCBlbGVtX2lkX19rZXkgaW5cbiAgICAgICAgICBwYXRjaF9saXN0IHQgb2JqX2lkIChpbmRleCArIDEpIGVsZW1faWRfX2tleSBJbnNlcnQgKFNvbWUgb3BzKVxuXG4gIGxldCB1cGRhdGVfbWFwX2tleSB0IG9ial9pZCBrZXkgPVxuICAgIGxldCBvcHMgPSBnZXRfZmllbGRfb3BzIHQgb2JqX2lkIGtleSBpblxuICAgIGxldCBwYXRoID0gZ2V0X3BhdGggdCBvYmpfaWQgKFNvbWUgW10pIGluXG4gICAgbGV0IGVkaXQgPVxuICAgICAgaWYgQ0NMaXN0LmlzX2VtcHR5IG9wcyB0aGVuXG4gICAgICAgIHsgYWN0aW9uPSBSZW1vdmVcbiAgICAgICAgOyBrZXk9IFNvbWUga2V5XG4gICAgICAgIDsgX3R5cGU9IE1hcFxuICAgICAgICA7IGNvbmZsaWN0cz0gTm9uZVxuICAgICAgICA7IG9iaj0gb2JqX2lkXG4gICAgICAgIDsgaW5kZXg9IE5vbmVcbiAgICAgICAgOyBwYXRoXG4gICAgICAgIDsgbGluaz0gZmFsc2VcbiAgICAgICAgOyBlbGVtX2lkX19rZXk9IE5vbmVcbiAgICAgICAgOyB2YWx1ZT0gTm9uZSB9XG4gICAgICBlbHNlXG4gICAgICAgIGxldCBmc3QgPSBDQ0xpc3QuaGQgb3BzIGluXG4gICAgICAgIGxldCB2YWx1ZSA9IENDT3B0Lm1hcCAoZnVuIHMgLT4gVmFsdWUgcykgZnN0LnZhbHVlIGluXG4gICAgICAgIGxldCBjb25mbGljdHMgPVxuICAgICAgICAgIGlmIENDTGlzdC5sZW5ndGggb3BzID4gMSB0aGVuIGdldF9jb25mbGljdHMgb3BzIGVsc2UgTm9uZVxuICAgICAgICBpblxuICAgICAgICB7IGFjdGlvbj0gU2V0XG4gICAgICAgIDsgX3R5cGU9IE1hcFxuICAgICAgICA7IG9iaj0gb2JqX2lkXG4gICAgICAgIDsga2V5PSBTb21lIGtleVxuICAgICAgICA7IHBhdGhcbiAgICAgICAgOyB2YWx1ZVxuICAgICAgICA7IGxpbms9IGZzdC5hY3Rpb24gPSBMaW5rXG4gICAgICAgIDsgY29uZmxpY3RzXG4gICAgICAgIDsgaW5kZXg9IE5vbmVcbiAgICAgICAgOyBlbGVtX2lkX19rZXk9IE5vbmUgfVxuICAgIGluXG4gICAgKHQsIFtlZGl0XSlcblxuICAoKiBQcm9jZXNzZXMgYSAnc2V0JywgJ2RlbCcsIG9yICdsaW5rJyBvcGVyYXRpb24gKilcbiAgbGV0IGFwcGx5X2Fzc2lnbiB0IChvcCA6IG9wKSBpc190b3BfbGV2ZWwgPVxuICAgIGlmIG5vdCAoT2JqZWN0SWRNYXAubWVtIG9wLm9iaiB0LmJ5X29iamVjdCkgdGhlblxuICAgICAgcmFpc2UgTW9kaWZpY2F0aW9uX29mX3Vua25vd25fb2JqZWN0XG4gICAgZWxzZVxuICAgICAgbGV0IHQgPVxuICAgICAgICBtYXRjaCB0LnVuZG9fbG9jYWwgd2l0aFxuICAgICAgICB8IFNvbWUgdWxvYyB3aGVuIGlzX3RvcF9sZXZlbCAtPlxuICAgICAgICAgICAgbGV0IG9ial9tYXAsIG9ial9hdXggPSBPYmplY3RJZE1hcC5maW5kIG9wLm9iaiB0LmJ5X29iamVjdCBpblxuICAgICAgICAgICAgbGV0IHVuZG9fb3BzID1cbiAgICAgICAgICAgICAgS2V5TWFwLmdldF9vciBvcC5rZXkgfmRlZmF1bHQ6W10gb2JqX21hcFxuICAgICAgICAgICAgICB8PiBDQ0xpc3QubWFwIChmdW4gKG9wIDogb3ApIC0+XG4gICAgICAgICAgICAgICAgICAgICB7IGFjdGlvbj0gb3AuYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICA7IG9iaj0gb3Aub2JqXG4gICAgICAgICAgICAgICAgICAgICA7IGtleT0gb3Aua2V5XG4gICAgICAgICAgICAgICAgICAgICA7IHZhbHVlPSBDQ09wdC5tYXAgKGZ1biB2IC0+IFZhbHVlIHYpIG9wLnZhbHVlIH0gKVxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGxldCB1bmRvX29wcyA9XG4gICAgICAgICAgICAgIGlmIENDTGlzdC5pc19lbXB0eSB1bmRvX29wcyB0aGVuXG4gICAgICAgICAgICAgICAgW3thY3Rpb249IERlbDsgb2JqPSBvcC5vYmo7IGtleT0gb3Aua2V5OyB2YWx1ZT0gTm9uZX1dXG4gICAgICAgICAgICAgIGVsc2UgdW5kb19vcHNcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBsZXQgdWxvYyA9IENDTGlzdC5jb25jYXQgW3Vsb2M7IHVuZG9fb3BzXSBpblxuICAgICAgICAgICAge3Qgd2l0aCB1bmRvX2xvY2FsPSBTb21lIHVsb2N9XG4gICAgICAgIHwgXyAtPiB0XG4gICAgICBpblxuICAgICAgbGV0IG92ZXJ3cml0dGVuLCByZW1haW5pbmcgPVxuICAgICAgICBsZXQgb2JqX21hcCwgXyA9IE9iamVjdElkTWFwLmZpbmQgb3Aub2JqIHQuYnlfb2JqZWN0IGluXG4gICAgICAgIGxldCByZWZzID0gS2V5TWFwLmdldF9vciBvcC5rZXkgfmRlZmF1bHQ6W10gb2JqX21hcCBpblxuICAgICAgICBDQ0xpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biAob3ZlciwgcmVtKSByZWYgLT5cbiAgICAgICAgICAgIGlmIGlzX2NvbmN1cnJlbnQgdCByZWYgb3AgdGhlbiAob3ZlciwgcmVmIDo6IHJlbSlcbiAgICAgICAgICAgIGVsc2UgKHJlZiA6OiBvdmVyLCByZW0pIClcbiAgICAgICAgICAoW10sIFtdKSByZWZzXG4gICAgICBpblxuICAgICAgKCogSWYgYW55IGxpbmtzIHdlcmUgb3ZlcndyaXR0ZW4sIHJlbW92ZSB0aGVtIGZyb20gdGhlIGluZGV4IG9mIGluYm91bmQgbGlua3MgKilcbiAgICAgIGxldCBvdmVyd3JpdHRlbl9saW5rcyA9XG4gICAgICAgIENDTGlzdC5maWx0ZXJcbiAgICAgICAgICAoZnVuIChvcCA6IG9wKSAtPiBtYXRjaCBvcC5hY3Rpb24gd2l0aCBMaW5rIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICAgICAgICAgIG92ZXJ3cml0dGVuXG4gICAgICBpblxuICAgICAgbGV0IHQgPVxuICAgICAgICBDQ0xpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgKGZ1biB0IChvcCA6IG9wKSAtPlxuICAgICAgICAgICAgbGV0IGJ5X29iamVjdCA9XG4gICAgICAgICAgICAgIE9iamVjdElkTWFwLnVwZGF0ZVxuICAgICAgICAgICAgICAgIChnZXRfb3BfdmFsdWVfYXNfc3RyaW5nX2V4biAoQ0NPcHQuZ2V0X2V4biBvcC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICB8IFNvbWUgKG9ial9tYXAsIG9ial9hdXgpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgU29tZVxuICAgICAgICAgICAgICAgICAgICAgICAgKCBvYmpfbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICAsIHsgb2JqX2F1eCB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2luYm91bmQ9IE9wU2V0LnJlbW92ZSBvcCBvYmpfYXV4Ll9pbmJvdW5kIH0gKVxuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZClcbiAgICAgICAgICAgICAgICB0LmJ5X29iamVjdFxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIHt0IHdpdGggYnlfb2JqZWN0fSApXG4gICAgICAgICAgdCBvdmVyd3JpdHRlbl9saW5rc1xuICAgICAgaW5cbiAgICAgIGxldCB0ID1cbiAgICAgICAgbWF0Y2ggb3AuYWN0aW9uIHdpdGhcbiAgICAgICAgfCBMaW5rIC0+XG4gICAgICAgICAgICBsZXQgYnlfb2JqZWN0ID1cbiAgICAgICAgICAgICAgT2JqZWN0SWRNYXAudXBkYXRlXG4gICAgICAgICAgICAgICAgKGdldF9vcF92YWx1ZV9hc19zdHJpbmdfZXhuIChDQ09wdC5nZXRfZXhuIG9wLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgIHwgU29tZSAob2JqX21hcCwgb2JqX2F1eCkgLT5cbiAgICAgICAgICAgICAgICAgICAgICBTb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAoIG9ial9tYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICwge29ial9hdXggd2l0aCBfaW5ib3VuZD0gT3BTZXQuYWRkIG9wIG9ial9hdXguX2luYm91bmR9XG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgTm90X2ZvdW5kKVxuICAgICAgICAgICAgICAgIHQuYnlfb2JqZWN0XG4gICAgICAgICAgICBpblxuICAgICAgICAgICAge3Qgd2l0aCBieV9vYmplY3R9XG4gICAgICAgIHwgXyAtPiB0XG4gICAgICBpblxuICAgICAgbGV0IHJlbWFpbmluZyA9XG4gICAgICAgIG1hdGNoIG9wLmFjdGlvbiB3aXRoXG4gICAgICAgIHwgRGVsIC0+IHJlbWFpbmluZ1xuICAgICAgICB8IF8gLT4gQ0NMaXN0LmFwcGVuZCByZW1haW5pbmcgW29wXVxuICAgICAgaW5cbiAgICAgIGxldCByZW1haW5pbmcgPVxuICAgICAgICBDQ0xpc3Quc29ydFxuICAgICAgICAgIChmdW4gKG9wMSA6IG9wKSAob3AyIDogb3ApIC0+IFN0cmluZy5jb21wYXJlIG9wMS5hY3RvciBvcDIuYWN0b3IpXG4gICAgICAgICAgcmVtYWluaW5nXG4gICAgICAgIHw+IENDTGlzdC5yZXZcbiAgICAgIGluXG4gICAgICBsZXQgYnlfb2JqZWN0ID1cbiAgICAgICAgT2JqZWN0SWRNYXAudXBkYXRlIG9wLm9ialxuICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICAgfCBTb21lIChvYmpfbWFwLCBvYmpfYXV4KSAtPlxuICAgICAgICAgICAgICAgIFNvbWUgKE9iamVjdElkTWFwLmFkZCBvcC5rZXkgcmVtYWluaW5nIG9ial9tYXAsIG9ial9hdXgpXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgTm90X2ZvdW5kKVxuICAgICAgICAgIHQuYnlfb2JqZWN0XG4gICAgICBpblxuICAgICAgbGV0IHQgPSB7dCB3aXRoIGJ5X29iamVjdH0gaW5cbiAgICAgIGxldCBvYmpfdHlwZSA9XG4gICAgICAgIChzbmQgKE9iamVjdElkTWFwLmZpbmQgb3Aub2JqIHQuYnlfb2JqZWN0KSkuX2luaXQuYWN0aW9uXG4gICAgICBpblxuICAgICAgbWF0Y2ggb2JqX3R5cGUgd2l0aFxuICAgICAgfCBNYWtlTGlzdCB8IE1ha2VUZXh0IC0+IHVwZGF0ZV9saXN0X2VsZW1lbnQgdCBvcC5vYmogb3Aua2V5XG4gICAgICB8IF8gLT4gdXBkYXRlX21hcF9rZXkgdCBvcC5vYmogb3Aua2V5XG5cbiAgbGV0IGFwcGx5X29wcyB0IG9wcyA9XG4gICAgbGV0IHQsIGFsbF9kaWZmcywgXyA9XG4gICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAoZnVuICh0LCBhbGxfZGlmZnMsIG5ld19vYmpzKSAob3AgOiBvcCkgLT5cbiAgICAgICAgICBtYXRjaCBvcC5hY3Rpb24gd2l0aFxuICAgICAgICAgIHwgTWFrZU1hcCB8IE1ha2VMaXN0IHwgTWFrZVRleHQgLT5cbiAgICAgICAgICAgICAgbGV0IG5ld19vYmpzID0gT2JqZWN0SWRTZXQuYWRkIG9wLm9iaiBuZXdfb2JqcyBpblxuICAgICAgICAgICAgICBsZXQgdCwgZGlmZnMgPSBhcHBseV9tYWtlIHQgb3AgaW5cbiAgICAgICAgICAgICAgKHQsIExpc3QuYXBwZW5kIGFsbF9kaWZmcyBkaWZmcywgbmV3X29ianMpXG4gICAgICAgICAgfCBJbnMgLT5cbiAgICAgICAgICAgICAgbGV0IHQsIGRpZmZzID0gYXBwbHlfaW5zZXJ0IHQgb3AgaW5cbiAgICAgICAgICAgICAgKHQsIExpc3QuYXBwZW5kIGFsbF9kaWZmcyBkaWZmcywgbmV3X29ianMpXG4gICAgICAgICAgfCBTZXQgfCBEZWwgfCBMaW5rIC0+XG4gICAgICAgICAgICAgIGxldCB0LCBkaWZmcyA9XG4gICAgICAgICAgICAgICAgYXBwbHlfYXNzaWduIHQgb3AgKG5vdCAoT2JqZWN0SWRTZXQubWVtIG9wLm9iaiBuZXdfb2JqcykpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICh0LCBMaXN0LmFwcGVuZCBhbGxfZGlmZnMgZGlmZnMsIG5ld19vYmpzKSApXG4gICAgICAgICh0LCBbXSwgT2JqZWN0SWRTZXQuZW1wdHkpIG9wc1xuICAgIGluXG4gICAgKHQsIGFsbF9kaWZmcylcblxuICBsZXQgYXBwbHlfY2hhbmdlIHQgKGNoYW5nZSA6IGNoYW5nZSkgPVxuICAgICgqIFByaW9yIHN0YXRlIGJ5IHNlcXVlbmNlICopXG4gICAgTExvZy5zdGF0ZXMgdCA7XG4gICAgbGV0IHByaW9yID0gQWN0b3JNYXAuZ2V0X29yIH5kZWZhdWx0OltdIGNoYW5nZS5hY3RvciB0LnN0YXRlcyBpblxuICAgIGlmIGNoYW5nZS5zZXEgPD0gTGlzdC5sZW5ndGggcHJpb3IgdGhlblxuICAgICAgbWF0Y2ggTGlzdC5udGhfb3B0IHByaW9yIChjaGFuZ2Uuc2VxIC0gMSkgd2l0aFxuICAgICAgKCogVE9ETzogTk9UIEEgU0FGRSBDT01QQVJFICopXG4gICAgICB8IFNvbWUgc3RhdGUgd2hlbiBzdGF0ZS5jaGFuZ2UgPSBjaGFuZ2UgLT5cbiAgICAgICAgICAoKiBsb2cgXCJDSDFcIiBzZXhwX29mX2NoYW5nZSBzdGF0ZS5jaGFuZ2UgOyAqKVxuICAgICAgICAgICgqIGxvZyBcIkNIMlwiIHNleHBfb2ZfY2hhbmdlIGNoYW5nZSA7ICopXG4gICAgICAgICAgSnMuZGVidWdnZXIgKCkgO1xuICAgICAgICAgIHJhaXNlIEluY29uc2lzdGVudF9yZXVzZV9vZl9zZXF1ZW5jZVxuICAgICAgfCBfIC0+ICh0LCBbXSlcbiAgICBlbHNlXG4gICAgICBsZXQgYWxsRGVwcyA9XG4gICAgICAgIEFjdG9yTWFwLmFkZCBjaGFuZ2UuYWN0b3IgKGNoYW5nZS5zZXEgLSAxKSBjaGFuZ2UuZGVwc1xuICAgICAgICB8PiB0cmFuc2l0aXZlX2RlcHMgdFxuICAgICAgaW5cbiAgICAgIGxldCBuZXdfcHJpb3IgPSBMaXN0LmFwcGVuZCBwcmlvciBbe2NoYW5nZTsgYWxsRGVwc31dIGluXG4gICAgICBsZXQgdCA9IHt0IHdpdGggc3RhdGVzPSBBY3Rvck1hcC5hZGQgY2hhbmdlLmFjdG9yIG5ld19wcmlvciB0LnN0YXRlc30gaW5cbiAgICAgICgqIE5PVEU6IFRoZSBvcmlnaW5hbCBjb2RlIHNldHMgYWN0b3IgYW5kIHNlcXVlbmNlIGVxdWFsIHRvIGNoYW5nZSBhY3RvciBhbmQgc2VxLCBmb3IgZWFjaCBvcC5cbiAgICAgICAgICAgICAgIFdlIGNob29zZSB0byBrZWVwIHRoZSBhY3RvciBhbmQgc2VxIGF0dGFjaGVkIHRvIGV2ZXJ5IG9wIGluIHRoZSBkYXRhIHR5cGUuICopXG4gICAgICBsZXQgb3BzID1cbiAgICAgICAgQ0NMaXN0Lm1hcFxuICAgICAgICAgIChmdW4gKGNoX29wIDogY2hhbmdlX29wKSAtPlxuICAgICAgICAgICAgeyBhY3Rvcj0gY2hhbmdlLmFjdG9yXG4gICAgICAgICAgICA7IHNlcT0gY2hhbmdlLnNlcVxuICAgICAgICAgICAgOyBhY3Rpb249IGNoX29wLmFjdGlvbiAoKiBUT0RPOiBPcCBrZXkgc2hvdWxkIGJlIGFuIG9wdGlvbi4gKilcbiAgICAgICAgICAgIDsga2V5PSAobWF0Y2ggY2hfb3Aua2V5IHdpdGggU29tZSBrIC0+IGsgfCBOb25lIC0+IFwiXCIpXG4gICAgICAgICAgICA7IG9iaj0gY2hfb3Aub2JqXG4gICAgICAgICAgICA7IGVsZW09IGNoX29wLmVsZW1cbiAgICAgICAgICAgIDsgdmFsdWU9IGNoX29wLnZhbHVlIH0gKVxuICAgICAgICAgIGNoYW5nZS5vcHNcbiAgICAgIGluXG4gICAgICBsZXQgdCwgZGlmZnMgPSBhcHBseV9vcHMgdCBvcHMgaW5cbiAgICAgIGxldCByZW1haW5pbmdfZGVwcyA9XG4gICAgICAgIEFjdG9yTWFwLmZpbHRlclxuICAgICAgICAgIChmdW4gZGVwQWN0b3IgZGVwU2VxIC0+XG4gICAgICAgICAgICBkZXBTZXEgPiBBY3Rvck1hcC5nZXRfb3IgZGVwQWN0b3IgfmRlZmF1bHQ6MCBhbGxEZXBzIClcbiAgICAgICAgICB0LmRlcHNcbiAgICAgICAgfD4gQWN0b3JNYXAuYWRkIGNoYW5nZS5hY3RvciBjaGFuZ2Uuc2VxXG4gICAgICBpblxuICAgICAgTExvZy5zZXFfYWN0b3JfbWFwIHJlbWFpbmluZ19kZXBzIDtcbiAgICAgIGxldCBjbG9jayA9IEFjdG9yTWFwLmFkZCBjaGFuZ2UuYWN0b3IgY2hhbmdlLnNlcSB0LmNsb2NrIGluXG4gICAgICBsZXQgaGlzdG9yeSA9IExpc3QuYXBwZW5kIHQuaGlzdG9yeSBbY2hhbmdlXSBpblxuICAgICAgKHt0IHdpdGggZGVwcz0gcmVtYWluaW5nX2RlcHM7IGNsb2NrOyBoaXN0b3J5fSwgZGlmZnMpXG5cbiAgKCogU2ltb24gc2F5cy4uLlxuXG4gICAgIGRvIGRyYWluIG9wL2NoYW5nZSBxdWV1ZVxuICAgICAgaWYgY2hhbmdlIHJlYWR5XG4gICAgICAgIGFwcGx5IGFuZCBhY2N1bXVsYXRlIGRpZmZzXG4gICAgICBlbHNlXG4gICAgICAgIHB1dCBjaGFuZ2UgaW50byBuZXcgcXVldWVcbiAgICAgc3RvcCB3aGVuIG5ldyBxdWV1ZSBzaXplID09IHN0YXJ0aW5nIHF1ZXVlIHNpemVcbiAgICAgIChpZS4gbm8gb3BzIHdlcmUgcmVhZHkgdG8gYXBwbHkpXG4gICAgIG90aGVyd2lzZSByZWN1cnNlIHRvIHJldHJ5IG9wcyB0aGF0IHdlcmVuJ3QgcmVhZHlcblxuICAqKVxuICBsZXQgcmVjIGFwcGx5X3F1ZXVlZF9vcHMgdCBkaWZmcyA9XG4gICAgbGV0IHQsIGRpZmZzLCBxdWV1ZSA9XG4gICAgICBDQ0ZRdWV1ZS5mb2xkXG4gICAgICAgIChmdW4gKHQsIGRpZmZzLCBxdWV1ZSkgY2hhbmdlIC0+XG4gICAgICAgICAgaWYgY2F1c2FseV9yZWFkeSB0IGNoYW5nZSB0aGVuXG4gICAgICAgICAgICBsZXQgdCwgZGlmZiA9IGFwcGx5X2NoYW5nZSB0IGNoYW5nZSBpblxuICAgICAgICAgICAgKHQsIENDTGlzdC5jb25jYXQgW2RpZmZzOyBkaWZmXSwgcXVldWUpXG4gICAgICAgICAgZWxzZSAodCwgZGlmZnMsIENDRlF1ZXVlLnNub2MgdC5xdWV1ZSBjaGFuZ2UpIClcbiAgICAgICAgKHQsIGRpZmZzLCBDQ0ZRdWV1ZVdpdGhTZXhwLmVtcHR5KVxuICAgICAgICB0LnF1ZXVlXG4gICAgaW5cbiAgICBpZiBDQ0ludC5lcXVhbCAoQ0NGUXVldWUuc2l6ZSBxdWV1ZSkgKENDRlF1ZXVlLnNpemUgdC5xdWV1ZSkgdGhlbiAodCwgZGlmZnMpXG4gICAgZWxzZSBhcHBseV9xdWV1ZWRfb3BzIHt0IHdpdGggcXVldWV9IGRpZmZzXG5cbiAgbGV0IHB1c2hfdW5kb19oaXN0b3J5IHQgPVxuICAgIGxldCB1bmRvX3N0YWNrID1cbiAgICAgIENDTGlzdC5hcHBlbmRcbiAgICAgICAgKENDTGlzdC50YWtlIHQudW5kb19wb3MgdC51bmRvX3N0YWNrKVxuICAgICAgICBbQ0NPcHQuZ2V0X2V4biB0LnVuZG9fbG9jYWxdXG4gICAgaW5cbiAgICB7IHQgd2l0aFxuICAgICAgdW5kb19zdGFjazsgdW5kb19wb3M9IHQudW5kb19wb3MgKyAxOyByZWRvX3N0YWNrPSBbXTsgdW5kb19sb2NhbD0gTm9uZSB9XG5cbiAgbGV0IGFkZF9jaGFuZ2UgdCBjaGFuZ2UgaXNVbmRvYWJsZSA9XG4gICAgbGV0IHQgPSB7dCB3aXRoIHF1ZXVlPSBDQ0ZRdWV1ZS5zbm9jIHQucXVldWUgY2hhbmdlfSBpblxuICAgIGlmIGlzVW5kb2FibGUgdGhlblxuICAgICAgbGV0IHQgPSB7dCB3aXRoIHVuZG9fbG9jYWw9IFNvbWUgW119IGluXG4gICAgICBsZXQgdCwgZGlmZnMgPSBhcHBseV9xdWV1ZWRfb3BzIHQgW10gaW5cbiAgICAgIGxldCB0ID0gcHVzaF91bmRvX2hpc3RvcnkgdCBpblxuICAgICAgKHQsIGRpZmZzKVxuICAgIGVsc2UgYXBwbHlfcXVldWVkX29wcyB0IFtdXG5cbiAgbGV0IGluaXQgKCkgPVxuICAgIGxldCByb290X29wID1cbiAgICAgIHsga2V5PSBcIlwiXG4gICAgICA7IGFjdGlvbj0gU2V0XG4gICAgICA7IGFjdG9yPSBcIlwiXG4gICAgICA7IHNlcT0gMFxuICAgICAgOyBvYmo9IFwiXCJcbiAgICAgIDsgZWxlbT0gTm9uZVxuICAgICAgOyB2YWx1ZT0gTm9uZSB9XG4gICAgaW5cbiAgICBsZXQgcm9vdF9vYmogPVxuICAgICAgKCBLZXlNYXAuZW1wdHlcbiAgICAgICwgeyBfbWF4X2VsZW09IDBcbiAgICAgICAgOyBfZm9sbG93aW5nPSBLZXlNYXAuZW1wdHlcbiAgICAgICAgOyBfaW5pdD0gcm9vdF9vcFxuICAgICAgICA7IF9pbmJvdW5kPSBPcFNldC5lbXB0eVxuICAgICAgICA7IF9lbGVtX2lkcz0gTm9uZVxuICAgICAgICA7IF9pbnNlcnRpb249IEVsZW1JZE1hcC5lbXB0eSB9IClcbiAgICBpblxuICAgIHsgc3RhdGVzPSBBY3Rvck1hcC5lbXB0eVxuICAgIDsgaGlzdG9yeT0gW11cbiAgICA7IGJ5X29iamVjdD0gT2JqZWN0SWRNYXAuYWRkIHJvb3RfaWQgcm9vdF9vYmogT2JqZWN0SWRNYXAuZW1wdHlcbiAgICA7IGNsb2NrPSBBY3Rvck1hcC5lbXB0eVxuICAgIDsgZGVwcz0gQWN0b3JNYXAuZW1wdHlcbiAgICA7IHVuZG9fcG9zPSAwXG4gICAgOyB1bmRvX3N0YWNrPSBbXVxuICAgIDsgcmVkb19zdGFjaz0gW11cbiAgICA7IHF1ZXVlPSBDQ0ZRdWV1ZS5lbXB0eVxuICAgIDsgdW5kb19sb2NhbD0gTm9uZSB9XG5cbiAgKCogVGhlIGZvbGxvd2luZyBmb3JtIHRoZSBwdWJsaWMgQVBJICopXG5cbiAgbGV0IGdldF9taXNzaW5nX2NoYW5nZXMgdCBoYXZlX2RlcHMgPVxuICAgIGxldCBhbGxfZGVwcyA9IHRyYW5zaXRpdmVfZGVwcyB0IGhhdmVfZGVwcyBpblxuICAgIEFjdG9yTWFwLm1hcGlcbiAgICAgIChmdW4gYWN0b3Igc3RhdGVzIC0+XG4gICAgICAgIENDTGlzdC5kcm9wIChBY3Rvck1hcC5nZXRfb3IgfmRlZmF1bHQ6MCBhY3RvciBhbGxfZGVwcykgc3RhdGVzIClcbiAgICAgIHQuc3RhdGVzXG4gICAgfD4gQWN0b3JNYXAudmFsdWVzIHw+IENDTGlzdC5vZl9zZXEgfD4gQ0NMaXN0LmZsYXR0ZW5cbiAgICB8PiBDQ0xpc3QubWFwIChmdW4gc3RhdGUgLT4gc3RhdGUuY2hhbmdlKVxuXG4gIGxldCBnZXRfY2hhbmdlc19mb3JfYWN0b3IgdCA/KGFmdGVyX3NlcSA9IDApIGZvcl9hY3RvciA9XG4gICAgQWN0b3JNYXAuZmlsdGVyIChmdW4gYWN0b3Igc3RhdGVzIC0+IFN0cmluZy5lcXVhbCBhY3RvciBmb3JfYWN0b3IpIHQuc3RhdGVzXG4gICAgfD4gQWN0b3JNYXAubWFwIChmdW4gc3RhdGVzIC0+IENDTGlzdC5kcm9wIGFmdGVyX3NlcSBzdGF0ZXMpXG4gICAgfD4gQWN0b3JNYXAudmFsdWVzIHw+IENDTGlzdC5vZl9zZXEgfD4gQ0NMaXN0LmZsYXR0ZW5cbiAgICB8PiBDQ0xpc3QubWFwIChmdW4gc3RhdGUgLT4gc3RhdGUuY2hhbmdlKVxuXG4gIGxldCBnZXRfbWlzc2luZ19kZXBzIHQgPVxuICAgIENDRlF1ZXVlLmZvbGRcbiAgICAgIChmdW4gbWlzc2luZyAoY2hhbmdlIDogY2hhbmdlKSAtPlxuICAgICAgICBsZXQgZGVwcyA9IEFjdG9yTWFwLmFkZCBjaGFuZ2UuYWN0b3IgKGNoYW5nZS5zZXEgLSAxKSBjaGFuZ2UuZGVwcyBpblxuICAgICAgICBBY3Rvck1hcC5mb2xkXG4gICAgICAgICAgKGZ1biBkZXBBY3RvciBkZXBTZXEgbWlzc2luZyAtPlxuICAgICAgICAgICAgaWYgQWN0b3JNYXAuZ2V0X29yIGRlcEFjdG9yIHQuY2xvY2sgfmRlZmF1bHQ6MCA8IGRlcFNlcSB0aGVuXG4gICAgICAgICAgICAgIGxldCBjdXJyID0gQWN0b3JNYXAuZ2V0X29yIGRlcEFjdG9yIG1pc3NpbmcgfmRlZmF1bHQ6MCBpblxuICAgICAgICAgICAgICBBY3Rvck1hcC5hZGQgZGVwQWN0b3IgKG1heCBkZXBTZXEgY3VycikgbWlzc2luZ1xuICAgICAgICAgICAgZWxzZSBtaXNzaW5nIClcbiAgICAgICAgICBtaXNzaW5nIGRlcHMgKVxuICAgICAgQWN0b3JNYXAuZW1wdHkgdC5xdWV1ZVxuXG4gICgqIEkgZG9udCB0aGluayB0aGlzIGZ1bmN0aW9uIGlzIG5lZWRlZCwgc2luY2UsIHVubGlrZSB0aGUgb3JpZ2luYWwgd2hpY2ggdXNlcyB1bmRlcnNjb3JlIGZpZWxkcyB0byBrZWVwIGF1eHVsYXJ5IGluZm9ybWF0aW9uLCB3ZSB1c2UgYSBzZXBhcmF0ZSBgb2JqX2F1eGAgcmVjb3JkLiAqKVxuICBsZXQgdmFsaWRfZmllbGRfbmFtZSBrZXkgPSBrZXkgIT0gXCJcIiAmJiBTdHIuZmlyc3RfY2hhcnMga2V5IDEgIT0gXCJfXCJcblxuICBsZXQgaXNfZmllbGRfcHJlc2VudCB0IG9ial9pZCBrZXkgPVxuICAgIHZhbGlkX2ZpZWxkX25hbWUga2V5ICYmIG5vdCAoQ0NMaXN0LmlzX2VtcHR5IChnZXRfZmllbGRfb3BzIHQgb2JqX2lkIGtleSkpXG5cbiAgbGV0IHVucGFja192YWx1ZSBwYXJlbnRfaWQgcGF0Y2hfZGlmZiBjaGlsZHJlbiB2YWx1ZSA9XG4gICAgbWF0Y2ggdmFsdWUgd2l0aFxuICAgIHwgTGlua1ZhbHVlIGwgLT5cbiAgICAgICAgbGV0IHBhdGNoX2RpZmYgPVxuICAgICAgICAgIHtwYXRjaF9kaWZmIHdpdGggbGluaz0gU29tZSB0cnVlOyB2YWx1ZT0gU29tZSAoU3RyVmFsdWUgbC5vYmpfaWQpfVxuICAgICAgICBpblxuICAgICAgICBsZXQgY2hpbGRyZW4gPVxuICAgICAgICAgIENoaWxkTWFwLnVwZGF0ZSBwYXJlbnRfaWRcbiAgICAgICAgICAgIChmdW5jdGlvblxuICAgICAgICAgICAgICB8IFNvbWUgY2hpbGRzIC0+IFNvbWUgKENDTGlzdC5hcHBlbmQgY2hpbGRzIFtsLm9ial9pZF0pXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcImNoaWxkIGlkXCIpKVxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgaW5cbiAgICAgICAgKHBhdGNoX2RpZmYsIGNoaWxkcmVuKVxuICAgIHwgVHlwZWRWYWx1ZSB2IC0+ICh7cGF0Y2hfZGlmZiB3aXRoIHZhbHVlPSBTb21lIHZ9LCBjaGlsZHJlbilcblxuICBsZXQgdW5wYWNrX2NvbmZsaWN0X3ZhbHVlIHBhcmVudF9pZCAoY29uZmxpY3QgOiBjb25mbGljdCkgY2hpbGRyZW4gdmFsdWUgPVxuICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICB8IExpbmtWYWx1ZSBsIC0+XG4gICAgICAgIGxldCBwYXRjaF9kaWZmID1cbiAgICAgICAgICB7Y29uZmxpY3Qgd2l0aCBsaW5rPSBTb21lIHRydWU7IHZhbHVlPSBTb21lIChTdHJWYWx1ZSBsLm9ial9pZCl9XG4gICAgICAgIGluXG4gICAgICAgIGxldCBjaGlsZHJlbiA9XG4gICAgICAgICAgQ2hpbGRNYXAudXBkYXRlIHBhcmVudF9pZFxuICAgICAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHwgU29tZSBjaGlsZHMgLT4gU29tZSAoQ0NMaXN0LmFwcGVuZCBjaGlsZHMgW2wub2JqX2lkXSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiY2hpbGQgaWRcIikpXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICBpblxuICAgICAgICAocGF0Y2hfZGlmZiwgY2hpbGRyZW4pXG4gICAgfCBUeXBlZFZhbHVlIHYgLT4gKHtjb25mbGljdCB3aXRoIHZhbHVlPSBTb21lIHZ9LCBjaGlsZHJlbilcblxuICBsZXQgdW5wYWNrX2NvbmZsaWN0cyBwYXJlbnRfaWQgKHBhdGNoX2RpZmYgOiBkaWZmKSBjaGlsZHJlbiBjb25mbGljdHMgPVxuICAgIGxldCBjb25mbGljdHMsIGNoaWxkcmVuID1cbiAgICAgIE9wTWFwLmZvbGRcbiAgICAgICAgKGZ1biBhY3RvciB2YWx1ZSAoY29uZmxpY3RzLCBjaGlsZHJlbikgLT5cbiAgICAgICAgICBsZXQgY29uZmxpY3QgPSB7YWN0b3I7IGxpbms9IE5vbmU7IHZhbHVlPSBOb25lfSBpblxuICAgICAgICAgIGxldCBjb25mbGljdCwgY2hpbGRyZW4gPVxuICAgICAgICAgICAgdW5wYWNrX2NvbmZsaWN0X3ZhbHVlIHBhcmVudF9pZCBjb25mbGljdCBjaGlsZHJlbiB2YWx1ZVxuICAgICAgICAgIGluXG4gICAgICAgICAgKENDTGlzdC5hcHBlbmQgY29uZmxpY3RzIFtjb25mbGljdF0sIGNoaWxkcmVuKSApXG4gICAgICAgIGNvbmZsaWN0cyAoW10sIGNoaWxkcmVuKVxuICAgIGluXG4gICAgKHtwYXRjaF9kaWZmIHdpdGggY29uZmxpY3RzPSBTb21lIGNvbmZsaWN0c30sIGNoaWxkcmVuKVxuXG4gIGxldCBnZXRfb2JqZWN0X2ZpZWxkcyB0IG9ial9pZCA9XG4gICAgbGV0IG9wZW4gQ0NPcHQuSW5maXggaW5cbiAgICBPYmplY3RJZE1hcC5nZXQgb2JqX2lkIHQuYnlfb2JqZWN0XG4gICAgPnw9IGZzdCA+fD0gS2V5TWFwLmtleXMgPnw9IENDTGlzdC5vZl9zZXFcbiAgICA+fD0gQ0NMaXN0LmZpbHRlciAoZnVuIGtleSAtPiBpc19maWVsZF9wcmVzZW50IHQgb2JqX2lkIGtleSlcbiAgICA+fD0gS2V5U2V0Lm9mX2xpc3RcblxuICB0eXBlIGl0ZXJhdG9yX21vZGUgPSBLZXlzIHwgVmFsdWVzIHwgRW50cmllcyB8IEVsZW1zIHwgQ29uZmxpY3RzXG4gIFtAQGRlcml2aW5nIHNleHBfb2ZdXG5cbiAgdHlwZSBpdGVyYXRvcl92YWwgPVxuICAgIHwgS2V5VmFsdWUgb2YgaW50XG4gICAgfCBWYWx1ZVZhbHVlIG9mIG1hdGVyaWFsaXplZCBvcHRpb25cbiAgICB8IEVudHJ5VmFsdWUgb2YgaW50ICogbWF0ZXJpYWxpemVkIG9wdGlvblxuICAgIHwgRWxlbVZhbHVlIG9mIGludCAqIHN0cmluZ1xuICAgIHwgQ29uZmxpY3RWYWx1ZSBvZiBtYXRlcmlhbGl6ZWQgT3BNYXAudFxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIHR5cGUgaXRlcmF0b3JfcmVzID0ge2RvbmVfOiBib29sOyB2YWx1ZTogaXRlcmF0b3JfdmFsIG9wdGlvbn1cbiAgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICB0eXBlIGl0ZXJhdG9yID1cbiAgICB7IG5leHQ6XG4gICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgLT4gZGlmZiBsaXN0IERpZmZNYXAudCAqIGNoaWxkIGxpc3QgQ2hpbGRNYXAudCAqIGl0ZXJhdG9yX3JlcyBvcHRpb24gfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCByZWMgaW5zdGFudGlhdGVfb2JqZWN0IHQgb2JqX2lkIChkaWZmcywgY2hpbGRyZW4pID1cbiAgICBtYXRjaCBEaWZmTWFwLmZpbmRfb3B0IG9ial9pZCBkaWZmcyB3aXRoXG4gICAgfCBTb21lIF8gLT4gKGRpZmZzLCBjaGlsZHJlbiwgTGlua1ZhbHVlIHtvYmpfaWR9KVxuICAgIHwgTm9uZSAtPlxuICAgICAgICBsZXQgaXNfcm9vdCA9IFN0cmluZy5lcXVhbCBvYmpfaWQgcm9vdF9pZCBpblxuICAgICAgICBsZXQgb2JqX3R5cCA9IGdldF9vYmpfYWN0aW9uIHQgb2JqX2lkIGluXG4gICAgICAgIGxldCBjb250ZXh0ID1cbiAgICAgICAgICAoRGlmZk1hcC5hZGQgb2JqX2lkIFtdIGRpZmZzLCBDaGlsZE1hcC5hZGQgb2JqX2lkIFtdIGNoaWxkcmVuKVxuICAgICAgICBpblxuICAgICAgICBsZXQgZGlmZnMsIGNoaWxkcmVuID1cbiAgICAgICAgICBpZiBpc19yb290IHRoZW4gaW5zdGFudGlhdGVfbWFwIHQgb2JqX2lkIGNvbnRleHRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBvYmpfdHlwIHdpdGhcbiAgICAgICAgICAgIHwgTWFrZU1hcCAtPiBpbnN0YW50aWF0ZV9tYXAgdCBvYmpfaWQgY29udGV4dFxuICAgICAgICAgICAgfCBNYWtlTGlzdCAtPiBpbnN0YW50aWF0ZV9saXN0IHQgb2JqX2lkIERpZmZMaXN0IGNvbnRleHRcbiAgICAgICAgICAgIHwgTWFrZVRleHQgLT4gaW5zdGFudGlhdGVfbGlzdCB0IG9ial9pZCBEaWZmVGV4dCBjb250ZXh0XG4gICAgICAgICAgICB8IF8gLT4gcmFpc2UgVW5rbm93bl9vYmplY3RfdHlwZVxuICAgICAgICBpblxuICAgICAgICAoZGlmZnMsIGNoaWxkcmVuLCBMaW5rVmFsdWUge29ial9pZH0pXG5cbiAgYW5kIGluc3RhbnRpYXRlX2xpc3QgdCBvYmpfaWQgdHlwICgoZGlmZnMsIGNoaWxkcmVuKSA6IGNvbnRleHQpID1cbiAgICBsZXQgcGF0Y2hfZGlmZnMgPSBEaWZmTWFwLmZpbmQgb2JqX2lkIGRpZmZzIGluXG4gICAgbGV0IHBhdGNoX2RpZmZzID1cbiAgICAgIENDTGlzdC5hcHBlbmQgcGF0Y2hfZGlmZnNcbiAgICAgICAgWyB7IGNvbmZsaWN0cz0gTm9uZVxuICAgICAgICAgIDsgdmFsdWU9IE5vbmVcbiAgICAgICAgICA7IGxpbms9IE5vbmVcbiAgICAgICAgICA7IG9iaj0gb2JqX2lkXG4gICAgICAgICAgOyB0eXBlXz0gdHlwXG4gICAgICAgICAgOyBhY3Rpb249IERpZmZDcmVhdGVcbiAgICAgICAgICA7IGtleT0gTm9uZVxuICAgICAgICAgIDsgZWxlbV9pZD0gTm9uZVxuICAgICAgICAgIDsgaW5kZXg9IE5vbmUgfSBdXG4gICAgaW5cbiAgICBsZXQgY29uZmxpY3RzID0gbGlzdF9pdGVyYXRvciB0IG9ial9pZCBDb25mbGljdHMgKGRpZmZzLCBjaGlsZHJlbikgaW5cbiAgICBsZXQgdmFsdWVzID0gbGlzdF9pdGVyYXRvciB0IG9ial9pZCBWYWx1ZXMgKGRpZmZzLCBjaGlsZHJlbikgaW5cbiAgICBsZXQgZWxlbXMgPSBsaXN0X2l0ZXJhdG9yIHQgb2JqX2lkIEVsZW1zIChkaWZmcywgY2hpbGRyZW4pIGluXG4gICAgbGV0IHJlYyBfbG9vcCBwYXRjaF9kaWZmcyAoZGlmZnMsIGNoaWxkcmVuKSA9XG4gICAgICBsZXQgZGlmZnMsIGNoaWxkcmVuLCBlbCA9IGVsZW1zLm5leHQgKGRpZmZzLCBjaGlsZHJlbikgaW5cbiAgICAgIG1hdGNoIGVsIHdpdGhcbiAgICAgIHwgU29tZSB7ZG9uZV89IGZhbHNlOyB2YWx1ZT0gU29tZSAoRWxlbVZhbHVlIChpbmRleCwgZWxlbV9pZCkpfSAtPlxuICAgICAgICAgIGxldCBwYXRjaF9kaWZmID1cbiAgICAgICAgICAgIHsgb2JqPSBvYmpfaWRcbiAgICAgICAgICAgIDsgdHlwZV89IHR5cFxuICAgICAgICAgICAgOyBhY3Rpb249IERpZmZJbnNlcnRcbiAgICAgICAgICAgIDsga2V5PSBOb25lXG4gICAgICAgICAgICA7IHZhbHVlPSBOb25lXG4gICAgICAgICAgICA7IGxpbms9IE5vbmVcbiAgICAgICAgICAgIDsgY29uZmxpY3RzPSBOb25lXG4gICAgICAgICAgICA7IGluZGV4PSBTb21lIGluZGV4XG4gICAgICAgICAgICA7IGVsZW1faWQ9IFNvbWUgZWxlbV9pZCB9XG4gICAgICAgICAgaW5cbiAgICAgICAgICAoKiB1bnBhY2sgdmFsdWUgKilcbiAgICAgICAgICBsZXQgZGlmZnMsIGNoaWxkcmVuLCBuZXh0X3ZhbHVlID0gdmFsdWVzLm5leHQgKGRpZmZzLCBjaGlsZHJlbikgaW5cbiAgICAgICAgICBsZXQgY2hpbGRyZW4sIHBhdGNoX2RpZmYgPVxuICAgICAgICAgICAgbWF0Y2ggbmV4dF92YWx1ZSB3aXRoXG4gICAgICAgICAgICB8IFNvbWUge2RvbmVfPSBmYWxzZTsgdmFsdWU9IFNvbWUgKFZhbHVlVmFsdWUgKFNvbWUgbWF0X3ZhbHVlKSl9IC0+XG4gICAgICAgICAgICAgICAgbGV0IHBhdGNoX2RpZmYsIGNoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIHVucGFja192YWx1ZSBvYmpfaWQgcGF0Y2hfZGlmZiBjaGlsZHJlbiBtYXRfdmFsdWVcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiwgcGF0Y2hfZGlmZilcbiAgICAgICAgICAgIHwgU29tZSB7ZG9uZV89IHRydWU7IF99IC0+IChjaGlsZHJlbiwgcGF0Y2hfZGlmZilcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm5leHQgdmFsdWVcIilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIHVucGFjayBjb25mbGljdCAqKVxuICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIG5leHRfY29uZmxpY3QgPVxuICAgICAgICAgICAgY29uZmxpY3RzLm5leHQgKGRpZmZzLCBjaGlsZHJlbilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBjaGlsZHJlbiwgcGF0Y2hfZGlmZiA9XG4gICAgICAgICAgICBtYXRjaCBuZXh0X2NvbmZsaWN0IHdpdGhcbiAgICAgICAgICAgIHwgU29tZSB7ZG9uZV89IGZhbHNlOyB2YWx1ZT0gU29tZSAoQ29uZmxpY3RWYWx1ZSBjb25mbGljdHMpfSAtPlxuICAgICAgICAgICAgICAgIGxldCBwYXRjaF9kaWZmLCBjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICB1bnBhY2tfY29uZmxpY3RzIG9ial9pZCBwYXRjaF9kaWZmIGNoaWxkcmVuIGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLCBwYXRjaF9kaWZmKVxuICAgICAgICAgICAgfCBTb21lIHtkb25lXz0gZmFsc2U7IHZhbHVlPSBOb25lfSB8IFNvbWUge2RvbmVfPSB0cnVlOyBffSAtPlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiwgcGF0Y2hfZGlmZilcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm5leHQgY29uZmxpY3RcIilcbiAgICAgICAgICBpblxuICAgICAgICAgIF9sb29wIChDQ0xpc3QuYXBwZW5kIHBhdGNoX2RpZmZzIFtwYXRjaF9kaWZmXSkgKGRpZmZzLCBjaGlsZHJlbilcbiAgICAgIHwgXyAtPiAoZGlmZnMsIGNoaWxkcmVuLCBwYXRjaF9kaWZmcylcbiAgICBpblxuICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIHBhdGNoX2RpZmZzID0gX2xvb3AgcGF0Y2hfZGlmZnMgKGRpZmZzLCBjaGlsZHJlbikgaW5cbiAgICAoRGlmZk1hcC5hZGQgb2JqX2lkIHBhdGNoX2RpZmZzIGRpZmZzLCBjaGlsZHJlbilcblxuICBhbmQgaW5zdGFudGlhdGVfbWFwIHQgb2JqX2lkICgoZGlmZnMsIGNoaWxkcmVuKSA6IGNvbnRleHQpID1cbiAgICBsZXQgcGF0Y2hfZGlmZnMgPSBEaWZmTWFwLmZpbmQgb2JqX2lkIGRpZmZzIGluXG4gICAgbGV0IHBhdGNoX2RpZmZzID1cbiAgICAgIGlmIG5vdCAoQ0NTdHJpbmcuZXF1YWwgb2JqX2lkIHJvb3RfaWQpIHRoZW5cbiAgICAgICAgQ0NMaXN0LmFwcGVuZCBwYXRjaF9kaWZmc1xuICAgICAgICAgIFsgeyBjb25mbGljdHM9IE5vbmVcbiAgICAgICAgICAgIDsgdmFsdWU9IE5vbmVcbiAgICAgICAgICAgIDsgbGluaz0gTm9uZVxuICAgICAgICAgICAgOyBvYmo9IG9ial9pZFxuICAgICAgICAgICAgOyB0eXBlXz0gRGlmZk1hcFxuICAgICAgICAgICAgOyBhY3Rpb249IERpZmZDcmVhdGVcbiAgICAgICAgICAgIDsgZWxlbV9pZD0gTm9uZVxuICAgICAgICAgICAgOyBpbmRleD0gTm9uZVxuICAgICAgICAgICAgOyBrZXk9IE5vbmUgfSBdXG4gICAgICBlbHNlIHBhdGNoX2RpZmZzXG4gICAgaW5cbiAgICBsZXQgZGlmZnMsIGNoaWxkcmVuLCBjb25mbGljdHMgPVxuICAgICAgZ2V0X29iamVjdF9jb25mbGljdHMgdCBvYmpfaWQgKGRpZmZzLCBjaGlsZHJlbilcbiAgICBpblxuICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIHBhdGNoX2RpZmZzID1cbiAgICAgIG1hdGNoIGdldF9vYmplY3RfZmllbGRzIHQgb2JqX2lkIHdpdGhcbiAgICAgIHwgU29tZSBmaWVsZHMgLT5cbiAgICAgICAgICBLZXlTZXQuZm9sZFxuICAgICAgICAgICAgKGZ1biBrZXkgKGRpZmZzLCBjaGlsZHJlbiwgcGF0Y2hfZGlmZnMpIC0+XG4gICAgICAgICAgICAgIGxldCBwYXRjaF9kaWZmID1cbiAgICAgICAgICAgICAgICB7IGNvbmZsaWN0cz0gTm9uZVxuICAgICAgICAgICAgICAgIDsgdmFsdWU9IE5vbmVcbiAgICAgICAgICAgICAgICA7IGxpbms9IE5vbmVcbiAgICAgICAgICAgICAgICA7IG9iaj0gb2JqX2lkXG4gICAgICAgICAgICAgICAgOyB0eXBlXz0gRGlmZk1hcFxuICAgICAgICAgICAgICAgIDsgZWxlbV9pZD0gTm9uZVxuICAgICAgICAgICAgICAgIDsgaW5kZXg9IE5vbmVcbiAgICAgICAgICAgICAgICA7IGFjdGlvbj0gRGlmZlNldFxuICAgICAgICAgICAgICAgIDsga2V5PSBTb21lIGtleSB9XG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICgqIHVucGFjayB2YWx1ZSAqKVxuICAgICAgICAgICAgICBsZXQgZGlmZnMsIGNoaWxkcmVuLCBwYXRjaF9kaWZmID1cbiAgICAgICAgICAgICAgICBtYXRjaCBnZXRfb2JqZWN0X2ZpZWxkIHQgb2JqX2lkIGtleSAoZGlmZnMsIGNoaWxkcmVuKSB3aXRoXG4gICAgICAgICAgICAgICAgfCBkaWZmcywgY2hpbGRyZW4sIFNvbWUgbWF0X3ZhbHVlIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXRjaF9kaWZmLCBjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICAgICAgdW5wYWNrX3ZhbHVlIG9ial9pZCBwYXRjaF9kaWZmIGNoaWxkcmVuIG1hdF92YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAoZGlmZnMsIGNoaWxkcmVuLCBwYXRjaF9kaWZmKVxuICAgICAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm9iaiBrZXlcIilcbiAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgbGV0IHBhdGNoX2RpZmYsIGNoaWxkcmVuID1cbiAgICAgICAgICAgICAgICBtYXRjaCBjb25mbGljdHMgd2l0aFxuICAgICAgICAgICAgICAgIHwgU29tZSBhbGxfY29uZiAtPiAoXG4gICAgICAgICAgICAgICAgICBtYXRjaCBLZXlNYXAuZ2V0IGtleSBhbGxfY29uZiB3aXRoXG4gICAgICAgICAgICAgICAgICB8IFNvbWUgY3MgLT4gdW5wYWNrX2NvbmZsaWN0cyBvYmpfaWQgcGF0Y2hfZGlmZiBjaGlsZHJlbiBjc1xuICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IChwYXRjaF9kaWZmLCBjaGlsZHJlbikgKVxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPiAocGF0Y2hfZGlmZiwgY2hpbGRyZW4pXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4sIENDTGlzdC5hcHBlbmQgcGF0Y2hfZGlmZnMgW3BhdGNoX2RpZmZdKSApXG4gICAgICAgICAgICBmaWVsZHNcbiAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4sIHBhdGNoX2RpZmZzKVxuICAgICAgfCBOb25lIC0+IChkaWZmcywgY2hpbGRyZW4sIHBhdGNoX2RpZmZzKVxuICAgIGluXG4gICAgKERpZmZNYXAuYWRkIG9ial9pZCBwYXRjaF9kaWZmcyBkaWZmcywgY2hpbGRyZW4pXG5cbiAgYW5kIGdldF9vYmplY3RfY29uZmxpY3RzIHQgb2JqX2lkIChkaWZmcywgY2hpbGRyZW4pID1cbiAgICBsZXQgb3BlbiBDQ09wdC5JbmZpeCBpblxuICAgIGxldCBmaWx0ZXJlZCA9XG4gICAgICBPYmplY3RJZE1hcC5nZXQgb2JqX2lkIHQuYnlfb2JqZWN0XG4gICAgICA+fD0gZnN0XG4gICAgICA+fD0gS2V5TWFwLmZpbHRlciAoZnVuIGtleSBmaWVsZCAtPlxuICAgICAgICAgICAgICB2YWxpZF9maWVsZF9uYW1lIGtleVxuICAgICAgICAgICAgICAmJiBDQ0xpc3QubGVuZ3RoIChnZXRfZmllbGRfb3BzIHQgb2JqX2lkIGtleSkgPiAxIClcbiAgICBpblxuICAgIG1hdGNoIGZpbHRlcmVkIHdpdGhcbiAgICB8IFNvbWUgZmlsIC0+XG4gICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIGNvbmZsaWN0cyA9XG4gICAgICAgICAgS2V5TWFwLmZvbGRcbiAgICAgICAgICAgIChmdW4ga2V5IGZpZWxkIChkaWZmcywgY2hpbGRyZW4sIHJlcykgLT5cbiAgICAgICAgICAgICAgbGV0IGRpZmZzLCBjaGlsZHJlbiwgY29uZmxpY3RzID1cbiAgICAgICAgICAgICAgICBDQ0xpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgICAgICAgICAoZnVuIChkaWZmcywgY2hpbGRyZW4sIGNvbmZsaWN0cykgKG9wIDogb3ApIC0+XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIChtYXRlcmlhbGl6ZWQgOiBtYXRlcmlhbGl6ZWQgb3B0aW9uKSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0X29wX3ZhbHVlIHQgb3AgKGRpZmZzLCBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZsaWN0cyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggbWF0ZXJpYWxpemVkIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICB8IFNvbWUgbWF0IC0+IE9wTWFwLmFkZCBvcC5hY3RvciBtYXQgY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgICAgICAgfCBOb25lIC0+IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAoZGlmZnMsIGNoaWxkcmVuLCBjb25mbGljdHMpIClcbiAgICAgICAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4sIE9wTWFwLmVtcHR5KVxuICAgICAgICAgICAgICAgICAgKENDTGlzdC5kcm9wIDEgZmllbGQpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4sIEtleU1hcC5hZGQga2V5IGNvbmZsaWN0cyByZXMpIClcbiAgICAgICAgICAgIGZpbFxuICAgICAgICAgICAgKGRpZmZzLCBjaGlsZHJlbiwgS2V5TWFwLmVtcHR5KVxuICAgICAgICBpblxuICAgICAgICAoZGlmZnMsIGNoaWxkcmVuLCBTb21lIGNvbmZsaWN0cylcbiAgICB8IE5vbmUgLT4gKGRpZmZzLCBjaGlsZHJlbiwgTm9uZSlcblxuICBhbmQgZ2V0X29wX3ZhbHVlIHQgKG9wIDogb3ApICgoZGlmZnMsIGNoaWxkcmVuKSA6IGNvbnRleHQpID1cbiAgICBsZXQgdmFsdWUgPVxuICAgICAgQ0NPcHQuZmxhdF9tYXBcbiAgICAgICAgKGZ1biB2YWx1ZSAtPlxuICAgICAgICAgIG1hdGNoIG9wLmFjdGlvbiB3aXRoXG4gICAgICAgICAgfCBTZXQgLT4gU29tZSAoZGlmZnMsIGNoaWxkcmVuLCBUeXBlZFZhbHVlIHZhbHVlKVxuICAgICAgICAgIHwgTGluayAtPlxuICAgICAgICAgICAgICBTb21lXG4gICAgICAgICAgICAgICAgKGluc3RhbnRpYXRlX29iamVjdCB0XG4gICAgICAgICAgICAgICAgICAgKGdldF9vcF92YWx1ZV9hc19zdHJpbmdfZXhuIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4pKVxuICAgICAgICAgIHwgXyAtPiBOb25lIClcbiAgICAgICAgb3AudmFsdWVcbiAgICBpblxuICAgIG1hdGNoIHZhbHVlIHdpdGhcbiAgICB8IFNvbWUgKGRpZmZzLCBjaGlsZHJlbiwgdmFsdWUpIC0+IChkaWZmcywgY2hpbGRyZW4sIFNvbWUgdmFsdWUpXG4gICAgfCBOb25lIC0+IChkaWZmcywgY2hpbGRyZW4sIE5vbmUpXG5cbiAgYW5kIGdldF9vYmplY3RfZmllbGQgdCBvYmpfaWQga2V5ICgoZGlmZnMsIGNoaWxkcmVuKSA6IGNvbnRleHQpID1cbiAgICBpZiBub3QgKHZhbGlkX2ZpZWxkX25hbWUga2V5KSB0aGVuIChkaWZmcywgY2hpbGRyZW4sIE5vbmUpXG4gICAgZWxzZVxuICAgICAgbWF0Y2ggZ2V0X2ZpZWxkX29wcyB0IG9ial9pZCBrZXkgd2l0aFxuICAgICAgfCBbXSAtPiAoZGlmZnMsIGNoaWxkcmVuLCBOb25lKVxuICAgICAgfCBoZCA6OiBfIC0+IGdldF9vcF92YWx1ZSB0IGhkIChkaWZmcywgY2hpbGRyZW4pXG5cbiAgYW5kIGxpc3RfaXRlcmF0b3IgdCBsaXN0X2lkIG1vZGUgY29udGV4dCA9XG4gICAgbGV0IGVsZW0gPSByZWYgKFNvbWUgXCJfaGVhZFwiKSBpblxuICAgIGxldCBpbmRleCA9IHJlZiAoLTEpIGluXG4gICAgbGV0IG5leHQgKGRpZmZzLCBjaGlsZHJlbikgPVxuICAgICAgbGV0IHJlYyBfbmV4dCAoZGlmZnMsIGNoaWxkcmVuKSA9XG4gICAgICAgIG1hdGNoICFlbGVtIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IChkaWZmcywgY2hpbGRyZW4sIE5vbmUpXG4gICAgICAgIHwgU29tZSBfIC0+IChcbiAgICAgICAgICAgIGVsZW0gOj0gZ2V0X25leHQgdCBsaXN0X2lkICFlbGVtIDtcbiAgICAgICAgICAgIG1hdGNoICFlbGVtIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiAoZGlmZnMsIGNoaWxkcmVuLCBTb21lIHtkb25lXz0gdHJ1ZTsgdmFsdWU9IE5vbmV9KVxuICAgICAgICAgICAgfCBTb21lIGVsZW0nIC0+IChcbiAgICAgICAgICAgICAgbWF0Y2ggZ2V0X2ZpZWxkX29wcyB0IGxpc3RfaWQgZWxlbScgd2l0aFxuICAgICAgICAgICAgICB8IFtdIC0+IF9uZXh0IChkaWZmcywgY2hpbGRyZW4pXG4gICAgICAgICAgICAgIHwgaGQgOjogdGwgYXMgb3BzIC0+IChcbiAgICAgICAgICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgZ2V0X29wX3ZhbHVlIHQgaGQgKGRpZmZzLCBjaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICBpbmRleCA6PSAhaW5kZXggKyAxIDtcbiAgICAgICAgICAgICAgICAgIG1hdGNoIG1vZGUgd2l0aFxuICAgICAgICAgICAgICAgICAgfCBLZXlzIC0+XG4gICAgICAgICAgICAgICAgICAgICAgKCBkaWZmc1xuICAgICAgICAgICAgICAgICAgICAgICwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAsIFNvbWUge2RvbmVfPSBmYWxzZTsgdmFsdWU9IFNvbWUgKEtleVZhbHVlICFpbmRleCl9IClcbiAgICAgICAgICAgICAgICAgIHwgVmFsdWVzIC0+XG4gICAgICAgICAgICAgICAgICAgICAgKCBkaWZmc1xuICAgICAgICAgICAgICAgICAgICAgICwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAsIFNvbWUge2RvbmVfPSBmYWxzZTsgdmFsdWU9IFNvbWUgKFZhbHVlVmFsdWUgdmFsdWUpfSApXG4gICAgICAgICAgICAgICAgICB8IEVudHJpZXMgLT5cbiAgICAgICAgICAgICAgICAgICAgICAoIGRpZmZzXG4gICAgICAgICAgICAgICAgICAgICAgLCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICwgU29tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRvbmVfPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZhbHVlPSBTb21lIChFbnRyeVZhbHVlICghaW5kZXgsIHZhbHVlKSkgfSApXG4gICAgICAgICAgICAgICAgICB8IEVsZW1zIC0+XG4gICAgICAgICAgICAgICAgICAgICAgKCBkaWZmc1xuICAgICAgICAgICAgICAgICAgICAgICwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAsIFNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeyBkb25lXz0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOyB2YWx1ZT0gU29tZSAoRWxlbVZhbHVlICghaW5kZXgsIGVsZW0nKSkgfSApXG4gICAgICAgICAgICAgICAgICB8IENvbmZsaWN0cyAtPlxuICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIGNvbmZsaWN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIENDTGlzdC5sZW5ndGggb3BzID4gMSB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIGNvbmZsaWN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDQ0xpc3QuZm9sZF9sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuIChkaWZmcywgY2hpbGRyZW4sIG9wX21hcCkgKG9wIDogb3ApIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmcywgY2hpbGRyZW4sIG9wX3ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRfb3BfdmFsdWUgdCBvcCAoZGlmZnMsIGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIGRpZmZzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBPcE1hcC5hZGQgb3AuYWN0b3IgKENDT3B0LmdldF9leG4gb3BfdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcF9tYXAgKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZnMsIGNoaWxkcmVuLCBPcE1hcC5lbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChkaWZmcywgY2hpbGRyZW4sIFNvbWUgKENvbmZsaWN0VmFsdWUgY29uZmxpY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAoZGlmZnMsIGNoaWxkcmVuLCBOb25lKVxuICAgICAgICAgICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgICAgICAgICAgKCogbGV0IGNvbmZsaWN0ID0gKilcbiAgICAgICAgICAgICAgICAgICAgICAoKiAgIENDT3B0Lm1hcCAoZnVuIGMgLT4gQ29uZmxpY3RWYWx1ZSBjKSBjb25mbGljdCAqKVxuICAgICAgICAgICAgICAgICAgICAgICgqIGluICopXG4gICAgICAgICAgICAgICAgICAgICAgKGRpZmZzLCBjaGlsZHJlbiwgU29tZSB7ZG9uZV89IGZhbHNlOyB2YWx1ZT0gY29uZmxpY3R9KSApXG4gICAgICAgICAgICAgICkgKVxuICAgICAgaW5cbiAgICAgIF9uZXh0IChkaWZmcywgY2hpbGRyZW4pXG4gICAgaW5cbiAgICB7bmV4dH1cblxuICBhbmQgZ2V0X25leHQgdCBvYmpfaWQga2V5ID1cbiAgICBtYXRjaCBpbnNlcnRpb25zX2FmdGVyIHQgb2JqX2lkIGtleSBOb25lIHdpdGhcbiAgICB8IGhkIDo6IF8gLT4gU29tZSBoZFxuICAgIHwgW10gLT5cbiAgICAgICAgbGV0IHJlYyBmaW5kX2FuY2VzdG9yIChrZXkgOiBrZXkgb3B0aW9uKSA9XG4gICAgICAgICAgbWF0Y2ggZ2V0X3BhcmVudCB0IG9ial9pZCBrZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgICAgfCBTb21lIGFuY2VzdG9yIC0+IChcbiAgICAgICAgICAgIG1hdGNoIGluc2VydGlvbnNfYWZ0ZXIgdCBvYmpfaWQgKFNvbWUgYW5jZXN0b3IpIGtleSB3aXRoXG4gICAgICAgICAgICB8IGhkIDo6IF8gLT4gU29tZSBoZFxuICAgICAgICAgICAgfCBbXSAtPiBmaW5kX2FuY2VzdG9yIChTb21lIGFuY2VzdG9yKSApXG4gICAgICAgIGluXG4gICAgICAgIGZpbmRfYW5jZXN0b3Iga2V5XG5cbiAgdHlwZSBwYXRjaCA9XG4gICAgeyBjYW5fdW5kbzogYm9vbFxuICAgIDsgY2FuX3JlZG86IGJvb2xcbiAgICA7IGNsb2NrOiBzZXEgQWN0b3JNYXAudFxuICAgIDsgZGVwczogc2VxIEFjdG9yTWFwLnRcbiAgICA7IGRpZmZzOiBkaWZmIGxpc3QgfVxuICBbQEBkZXJpdmluZyBzZXhwX29mXVxuXG4gIGxldCByZWMgbWFrZV9wYXRjaCB0IChvYmpfaWQgOiBzdHJpbmcpIHBhdGNoX2RpZmZzIChkaWZmcywgY2hpbGRyZW4pID1cbiAgICBsZXQgZGlmZnMsIHBhdGNoX2RpZmZzID1cbiAgICAgIENDTGlzdC5mb2xkX2xlZnRcbiAgICAgICAgKGZ1biAoZGlmZnMsIHBhdGNoX2RpZmZzKSBjaGlsZF9pZCAtPlxuICAgICAgICAgIG1ha2VfcGF0Y2ggdCBjaGlsZF9pZCBwYXRjaF9kaWZmcyAoZGlmZnMsIGNoaWxkcmVuKSApXG4gICAgICAgIChkaWZmcywgcGF0Y2hfZGlmZnMpXG4gICAgICAgIChDaGlsZE1hcC5maW5kIG9ial9pZCBjaGlsZHJlbilcbiAgICBpblxuICAgIChkaWZmcywgQ0NMaXN0LmFwcGVuZCBwYXRjaF9kaWZmcyAoRGlmZk1hcC5maW5kIG9ial9pZCBkaWZmcykpXG5cbiAgbGV0IGdldF9wYXRjaCB0ID1cbiAgICBsZXQgZGlmZnMsIGNoaWxkcmVuLCBfID1cbiAgICAgIGluc3RhbnRpYXRlX29iamVjdCB0IHJvb3RfaWQgKERpZmZNYXAuZW1wdHksIENoaWxkTWFwLmVtcHR5KVxuICAgIGluXG4gICAgbGV0IGRpZmZzLCBwYXRjaF9kaWZmcyA9IG1ha2VfcGF0Y2ggdCByb290X2lkIFtdIChkaWZmcywgY2hpbGRyZW4pIGluXG4gICAgeyBjYW5fdW5kbz0gdC51bmRvX3BvcyA+IDBcbiAgICA7IGNhbl9yZWRvPSBub3QgKENDTGlzdC5pc19lbXB0eSB0LnJlZG9fc3RhY2spXG4gICAgOyBjbG9jaz0gdC5jbG9ja1xuICAgIDsgZGVwcz0gdC5kZXBzXG4gICAgOyBkaWZmcz0gcGF0Y2hfZGlmZnMgfVxuXG4gIGxldCBsaXN0X2xlbmd0aCB0IG9ial9pZCA9XG4gICAgbGV0IG9wZW4gQ0NPcHQuSW5maXggaW5cbiAgICBnZXRfb2JqX2F1eCB0IG9ial9pZCA+Pj0gZnVuIG9ial9hdXggLT4gb2JqX2F1eC5fZWxlbV9pZHMgPnw9IENDTGlzdC5sZW5ndGhcblxuICBsZXQgZ2V0X2Nsb2NrICh7Y2xvY2t9IDogdCkgPSBjbG9ja1xuXG4gIGxldCBnZXRfZGVwcyAoe2RlcHN9IDogdCkgPSBkZXBzXG5cbiAgbGV0IGNhbl91bmRvIHt1bmRvX3Bvc30gPSB1bmRvX3BvcyA+IDBcblxuICBsZXQgY2FuX3JlZG8ge3JlZG9fc3RhY2t9ID0gbm90IChDQ0xpc3QuaXNfZW1wdHkgcmVkb19zdGFjaylcbmVuZFxuIiwib3BlbiBTZXhwbGliLkNvbnZcbm9wZW4gT3Bfc2V0XG5vcGVuIERhdGFzdHJ1Y3R1cmVzXG5cbmxldCAoICQgKSBmIGcgeCA9IGYgKGcgeClcblxudHlwZSBleG4gKz0gTm90X3N1cHBvcnRlZCB8IFVua25vd25fcmVxdWVzdF90eXBlXG5cbmxldCBmcmVlemUgKG8gOiAnYSkgOiAnYSA9XG4gIEpzLlVuc2FmZS5mdW5fY2FsbCAoSnMuVW5zYWZlLmpzX2V4cHIgXCJPYmplY3QuZnJlZXplXCIpIFt8SnMuVW5zYWZlLmluamVjdCBvfF1cblxudHlwZSB0ID0ge29wX3NldDogT3BTZXRCYWNrZW5kLnR9XG5cbm1vZHVsZSBCRSA9IE9wU2V0QmFja2VuZFxuXG5sZXQgY2xvY2sgdCA9IE9wU2V0QmFja2VuZC5nZXRfY2xvY2sgdC5vcF9zZXRcblxubGV0IGxpc3RfdG9fanNfYXJyYXkgbGlzID1cbiAgbGV0IGFyciA9IG5ldyVqcyBKcy5hcnJheV9sZW5ndGggKExpc3QubGVuZ3RoIGxpcykgaW5cbiAgQ0NMaXN0Lml0ZXJpIChmdW4gaSBlbCAtPiBKcy5hcnJheV9zZXQgYXJyIGkgKEpzLlVuc2FmZS5pbmplY3QgZWwpKSBsaXMgO1xuICBhcnJcblxubGV0IG9ial9zZXQgP2NvbnYgbmFtZSB2YWx1ZSBvYmpfa3YgPVxuICBtYXRjaCBjb252IHdpdGhcbiAgfCBTb21lIGNvbnYgLT4gQ0NBcnJheS5hcHBlbmQgb2JqX2t2IFt8KG5hbWUsIEpzLlVuc2FmZS5pbmplY3QgKGNvbnYgdmFsdWUpKXxdXG4gIHwgTm9uZSAtPiBDQ0FycmF5LmFwcGVuZCBvYmpfa3YgW3wobmFtZSwgSnMuVW5zYWZlLmluamVjdCB2YWx1ZSl8XVxuXG5sZXQgb2JqX3NldF9vcHRkZWYgY29udiBuYW1lIHZhbHVlIG9ial9rdiA9XG4gIG1hdGNoIHZhbHVlIHdpdGhcbiAgfCBTb21lIHYgLT4gQ0NBcnJheS5hcHBlbmQgb2JqX2t2IFt8KG5hbWUsIEpzLlVuc2FmZS5pbmplY3QgKGNvbnYgdikpfF1cbiAgfCBOb25lIC0+IG9ial9rdlxuXG5sZXQgb2JqX3NldF9vcHQgY29udiBuYW1lIHZhbHVlIG9ial9rdiA9XG4gIG1hdGNoIHZhbHVlIHdpdGhcbiAgfCBTb21lIHYgLT4gQ0NBcnJheS5hcHBlbmQgb2JqX2t2IFt8KG5hbWUsIEpzLlVuc2FmZS5pbmplY3QgKGNvbnYgdikpfF1cbiAgfCBOb25lIC0+IENDQXJyYXkuYXBwZW5kIG9ial9rdiBbfChuYW1lLCBKcy5VbnNhZmUuaW5qZWN0IEpzLm51bGwpfF1cblxubGV0IGVkaXRfYWN0aW9uX3RvX2pzX2VkaXRfYWN0aW9uIHYgPVxuICBKcy5zdHJpbmdcbiAgICBPcFNldEJhY2tlbmQuKFxuICAgICAgbWF0Y2ggdiB3aXRoXG4gICAgICB8IENyZWF0ZSAtPiBcImNyZWF0ZVwiXG4gICAgICB8IFNldCAtPiBcInNldFwiXG4gICAgICB8IEluc2VydCAtPiBcImluc2VydFwiXG4gICAgICB8IFJlbW92ZSAtPiBcInJlbW92ZVwiKVxuXG5sZXQgdHlwZV90b19qc190eXBlIHYgPVxuICBKcy5zdHJpbmdcbiAgICBPcFNldEJhY2tlbmQuKFxuICAgICAgbWF0Y2ggdiB3aXRoIE1hcCAtPiBcIm1hcFwiIHwgVGV4dCAtPiBcInRleHRcIiB8IExpc3QgLT4gXCJsaXN0XCIpXG5cbmxldCBwYXRoX3RvX2pzX3BhdGggdiA9XG4gIGxpc3RfdG9fanNfYXJyYXlcbiAgICAoQ0NMaXN0Lm1hcFxuICAgICAgIE9wU2V0QmFja2VuZC4oXG4gICAgICAgICBmdW5jdGlvblxuICAgICAgICAgfCBgU3RyUGF0aCBzIC0+IEpzLlVuc2FmZS5pbmplY3QgKEpzLnN0cmluZyBzKVxuICAgICAgICAgfCBgSW50UGF0aCBpIC0+IEpzLlVuc2FmZS5pbmplY3QgKEpzLm51bWJlcl9vZl9mbG9hdCAoZmxvYXRfb2ZfaW50IGkpKSlcbiAgICAgICB2KVxuXG5sZXQgYWN0b3JfdG9fanNfYWN0b3IgYWN0b3IgPSBKcy5VbnNhZmUuaW5qZWN0IChKcy5zdHJpbmcgYWN0b3IpXG5cbmxldCBhcnJheV90b19saXN0IGFyciA9IENDQXJyYXkudG9fbGlzdCAoSnMudG9fYXJyYXkgYXJyKVxuXG5sZXQganNfYWN0aW9uX3RvX2FjdGlvbiA6IEpzLmpzX3N0cmluZyBKcy50IC0+IE9wU2V0QmFja2VuZC5hY3Rpb24gPVxuIGZ1biBqc19zIC0+XG4gIGxldCBzID0gSnMudG9fc3RyaW5nIGpzX3MgaW5cbiAgaWYgU3RyaW5nLmVxdWFsIHMgXCJzZXRcIiB0aGVuIE9wU2V0QmFja2VuZC5TZXRcbiAgZWxzZSBpZiBTdHJpbmcuZXF1YWwgcyBcImRlbFwiIHRoZW4gT3BTZXRCYWNrZW5kLkRlbFxuICBlbHNlIGlmIFN0cmluZy5lcXVhbCBzIFwibWFrZU1hcFwiIHRoZW4gT3BTZXRCYWNrZW5kLk1ha2VNYXBcbiAgZWxzZSBpZiBTdHJpbmcuZXF1YWwgcyBcIm1ha2VMaXN0XCIgdGhlbiBPcFNldEJhY2tlbmQuTWFrZUxpc3RcbiAgZWxzZSBpZiBTdHJpbmcuZXF1YWwgcyBcIm1ha2VUZXh0XCIgdGhlbiBPcFNldEJhY2tlbmQuTWFrZVRleHRcbiAgZWxzZSBpZiBTdHJpbmcuZXF1YWwgcyBcImxpbmtcIiB0aGVuIE9wU2V0QmFja2VuZC5MaW5rXG4gIGVsc2UgaWYgU3RyaW5nLmVxdWFsIHMgXCJpbnNcIiB0aGVuIE9wU2V0QmFja2VuZC5JbnNcbiAgZWxzZSByYWlzZSBOb3Rfc3VwcG9ydGVkXG5cbmxldCBhY3Rpb25fdG9fanNfYWN0aW9uIGEgPVxuICBKcy5zdHJpbmdcbiAgICBPcFNldEJhY2tlbmQuKFxuICAgICAgbWF0Y2ggYSB3aXRoXG4gICAgICB8IE1ha2VNYXAgLT4gXCJtYWtlTWFwXCJcbiAgICAgIHwgTWFrZVRleHQgLT4gXCJtYWtlVGV4dFwiXG4gICAgICB8IE1ha2VMaXN0IC0+IFwibWFrZUxpc3RcIlxuICAgICAgfCBMaW5rIC0+IFwibGlua1wiXG4gICAgICB8IElucyAtPiBcImluc1wiXG4gICAgICB8IERlbCAtPiBcImRlbFwiXG4gICAgICB8IFNldCAtPiBcInNldFwiKVxuXG5sZXQgb3BfdmFsX3RvX2pzX3ZhbHVlID0gZnVuY3Rpb25cbiAgfCBPcFNldEJhY2tlbmQuQm9vbFZhbHVlIGIgLT4gSnMuVW5zYWZlLmluamVjdCAoSnMuYm9vbCBiKVxuICB8IE9wU2V0QmFja2VuZC5TdHJWYWx1ZSBzIC0+IEpzLlVuc2FmZS5pbmplY3QgKEpzLnN0cmluZyBzKVxuICB8IE9wU2V0QmFja2VuZC5OdW1iZXJWYWx1ZSBuIC0+IEpzLlVuc2FmZS5pbmplY3QgKEpzLm51bWJlcl9vZl9mbG9hdCBuKVxuXG5sZXQgcmVjIHZhbHVlX3RvX2pzX3ZhbHVlICh2YWx1ZSA6IE9wU2V0QmFja2VuZC52YWx1ZSkgPVxuICBtYXRjaCB2YWx1ZSB3aXRoXG4gIHwgVmFsdWUgcyAtPiBvcF92YWxfdG9fanNfdmFsdWUgc1xuICB8IExpbmsgbCAtPlxuICAgICAgSnMuVW5zYWZlLmluamVjdFxuICAgICAgICAob2JqZWN0JWpzXG4gICAgICAgICAgIHZhbCBvYmogPSB2YWx1ZV90b19qc192YWx1ZSBsLm9ialxuICAgICAgICBlbmQpXG5cbmxldCByZWMganNfdmFsdWVfdG9fb3BfdmFsIGpzX3ZhbHVlID1cbiAgbGV0IHR5cCA9IEpzLnRvX3N0cmluZyAoSnMudHlwZW9mIGpzX3ZhbHVlKSBpblxuICBtYXRjaCB0eXAgd2l0aFxuICB8IFwic3RyaW5nXCIgLT5cbiAgICAgIE9wU2V0QmFja2VuZC5TdHJWYWx1ZSAoSnMudG9fc3RyaW5nIChKcy5VbnNhZmUuY29lcmNlIGpzX3ZhbHVlKSlcbiAgfCBcImJvb2xlYW5cIiAtPlxuICAgICAgT3BTZXRCYWNrZW5kLkJvb2xWYWx1ZSAoSnMudG9fYm9vbCAoSnMuVW5zYWZlLmNvZXJjZSBqc192YWx1ZSkpXG4gIHwgXCJudW1iZXJcIiAtPlxuICAgICAgT3BTZXRCYWNrZW5kLk51bWJlclZhbHVlIChKcy5mbG9hdF9vZl9udW1iZXIgKEpzLlVuc2FmZS5jb2VyY2UganNfdmFsdWUpKVxuICB8IF8gLT4gcmFpc2UgTm90X3N1cHBvcnRlZFxuXG5sZXQgdG9fb3BfbGlzdCBhcnIgPVxuICBhcnJheV90b19saXN0IGFyclxuICB8PiBDQ0xpc3QubWFwIChmdW4ganNfb3AgLT5cbiAgICAgICAgICggeyBhY3Rpb249IGpzX2FjdGlvbl90b19hY3Rpb24ganNfb3AjIy5hY3Rpb25cbiAgICAgICAgICAgOyBrZXk9IEpzLk9wdGRlZi4odG9fb3B0aW9uIChtYXAganNfb3AjIy5rZXkgSnMudG9fc3RyaW5nKSlcbiAgICAgICAgICAgOyBlbGVtPVxuICAgICAgICAgICAgICAgSnMuT3B0ZGVmLihcbiAgICAgICAgICAgICAgICAgdG9fb3B0aW9uIChtYXAganNfb3AjIy5lbGVtIChpbnRfb2ZfZmxvYXQgJCBKcy50b19mbG9hdCkpKVxuICAgICAgICAgICA7IHZhbHVlPVxuICAgICAgICAgICAgICAgSnMuT3B0ZGVmLih0b19vcHRpb24gKG1hcCBqc19vcCMjLnZhbHVlIGpzX3ZhbHVlX3RvX29wX3ZhbCkpXG4gICAgICAgICAgIDsgb2JqPSBKcy50b19zdHJpbmcganNfb3AjIy5vYmogfVxuICAgICAgICAgICA6IE9wU2V0QmFja2VuZC5jaGFuZ2Vfb3AgKSApXG5cbmxldCBjb25mbGljdHNfdG9fanNfY29uZmxpY3RzICh2IDogT3BTZXRCYWNrZW5kLmNvbmZsaWN0IGxpc3QpID1cbiAgbGlzdF90b19qc19hcnJheVxuICAgIChDQ0xpc3QubWFwXG4gICAgICAgKGZ1biAoY29uZmwgOiBPcFNldEJhY2tlbmQuY29uZmxpY3QpIC0+XG4gICAgICAgICBDQ0FycmF5LmVtcHR5XG4gICAgICAgICB8PiBvYmpfc2V0IH5jb252OmFjdG9yX3RvX2pzX2FjdG9yIFwiYWN0b3JcIiBjb25mbC5hY3RvclxuICAgICAgICAgfD4gb2JqX3NldF9vcHRkZWYgb3BfdmFsX3RvX2pzX3ZhbHVlIFwidmFsdWVcIiBjb25mbC52YWx1ZVxuICAgICAgICAgfD4gSnMuVW5zYWZlLm9iaiApXG4gICAgICAgdilcblxubGV0IG51bWJlcl9vZl9pbnQgaSA9IEpzLm51bWJlcl9vZl9mbG9hdCAoZmxvYXRfb2ZfaW50IGkpXG5cbmxldCBvYmpfc2V0X3BhdGggKGVkaXQgOiBPcFNldEJhY2tlbmQuZWRpdCkgb2JqX2t2ID1cbiAgbWF0Y2ggZWRpdC5hY3Rpb24gd2l0aFxuICB8IE9wU2V0QmFja2VuZC5TZXQgfCBPcFNldEJhY2tlbmQuUmVtb3ZlIHwgT3BTZXRCYWNrZW5kLkluc2VydCAtPiAoXG4gICAgbWF0Y2ggZWRpdC5wYXRoIHdpdGhcbiAgICB8IFNvbWUgdiAtPlxuICAgICAgICBDQ0FycmF5LmFwcGVuZCBvYmpfa3YgW3woXCJwYXRoXCIsIEpzLlVuc2FmZS5pbmplY3QgKHBhdGhfdG9fanNfcGF0aCB2KSl8XVxuICAgIHwgTm9uZSAtPiBDQ0FycmF5LmFwcGVuZCBvYmpfa3YgW3woXCJwYXRoXCIsIEpzLlVuc2FmZS5pbmplY3QgSnMubnVsbCl8XSApXG4gIHwgXyAtPiBvYmpfa3ZcblxubGV0IGVkaXRfdG9fanNfZWRpdCAoZWRpdCA6IE9wU2V0QmFja2VuZC5lZGl0KSA9XG4gIENDQXJyYXkuZW1wdHlcbiAgfD4gb2JqX3NldCB+Y29udjplZGl0X2FjdGlvbl90b19qc19lZGl0X2FjdGlvbiBcImFjdGlvblwiIGVkaXQuYWN0aW9uXG4gIHw+IG9ial9zZXQgfmNvbnY6SnMuc3RyaW5nIFwib2JqXCIgZWRpdC5vYmpcbiAgfD4gb2JqX3NldF9vcHRkZWYgSnMuc3RyaW5nIFwia2V5XCIgZWRpdC5rZXlcbiAgfD4gb2JqX3NldF9vcHRkZWYgdmFsdWVfdG9fanNfdmFsdWUgXCJ2YWx1ZVwiIGVkaXQudmFsdWVcbiAgfD4gb2JqX3NldCB+Y29udjp0eXBlX3RvX2pzX3R5cGUgXCJ0eXBlXCIgZWRpdC5fdHlwZVxuICB8PiBvYmpfc2V0X29wdGRlZiBKcy5ib29sIFwibGlua1wiIChpZiBlZGl0LmxpbmsgdGhlbiBTb21lIGVkaXQubGluayBlbHNlIE5vbmUpXG4gIHw+IG9ial9zZXRfcGF0aCBlZGl0XG4gIHw+IG9ial9zZXRfb3B0ZGVmIGNvbmZsaWN0c190b19qc19jb25mbGljdHMgXCJjb25mbGljdHNcIiBlZGl0LmNvbmZsaWN0c1xuICB8PiBvYmpfc2V0X29wdGRlZiBudW1iZXJfb2ZfaW50IFwiaW5kZXhcIiBlZGl0LmluZGV4XG4gIHw+IG9ial9zZXRfb3B0ZGVmIEpzLnN0cmluZyBcImVsZW1JZFwiIGVkaXQuZWxlbV9pZF9fa2V5XG4gIHw+IEpzLlVuc2FmZS5vYmpcblxubGV0IGNoYW5nZV9vcF90b19qc19jaGFuZ2Vfb3AgKG9wIDogT3BTZXRCYWNrZW5kLmNoYW5nZV9vcCkgPVxuICBDQ0FycmF5LmVtcHR5XG4gIHw+IG9ial9zZXQgXCJhY3Rpb25cIiAoYWN0aW9uX3RvX2pzX2FjdGlvbiBvcC5hY3Rpb24pXG4gIHw+IG9ial9zZXRfb3B0ZGVmIEpzLnN0cmluZyBcImtleVwiIG9wLmtleVxuICB8PiBvYmpfc2V0X29wdGRlZiAoSnMubnVtYmVyX29mX2Zsb2F0ICQgZmxvYXRfb2ZfaW50KSBcImVsZW1cIiBvcC5lbGVtXG4gIHw+IG9ial9zZXRfb3B0ZGVmIG9wX3ZhbF90b19qc192YWx1ZSBcInZhbHVlXCIgb3AudmFsdWVcbiAgfD4gb2JqX3NldCBcIm9ialwiIChKcy5zdHJpbmcgb3Aub2JqKVxuICB8PiBKcy5VbnNhZmUub2JqXG5cbmxldCBhY3Rvcl9tYXBfb2ZfanNfb2JqIGpzX29iaiA9XG4gIEpzLnRvX2FycmF5IChKcy5vYmplY3Rfa2V5cyBqc19vYmopXG4gIHw+IENDQXJyYXkuZm9sZFxuICAgICAgIChmdW4gYW1hcCBqc19hY3RvciAtPlxuICAgICAgICAgbGV0IHZhbHVlID0gSnMuVW5zYWZlLmdldCBqc19vYmoganNfYWN0b3IgaW5cbiAgICAgICAgIEFjdG9yTWFwLmFkZCAoSnMudG9fc3RyaW5nIGpzX2FjdG9yKSB2YWx1ZSBhbWFwIClcbiAgICAgICBBY3Rvck1hcC5lbXB0eVxuXG5sZXQganNfb2JqX29mX2FjdG9yX21hcCBjb252IG0gPVxuICAoKiBzdHJpbmcsIGFueSBhcnJheSAqKVxuICBsZXQga3YgPVxuICAgIENDQXJyYXkub2ZfbGlzdCAoQWN0b3JNYXAudG9fbGlzdCBtKVxuICAgIHw+IENDQXJyYXkubWFwIChmdW4gKGssIHYpIC0+IChrLCBKcy5VbnNhZmUuaW5qZWN0IChjb252IHYpKSlcbiAgaW5cbiAgSnMuVW5zYWZlLm9iaiBrdlxuXG5sZXQgaW50X29mX2pzX251bWJlciBuID0gaW50X29mX2Zsb2F0IChKcy5mbG9hdF9vZl9udW1iZXIgbilcblxubGV0IGpzX2NoYW5nZV90b19jaGFuZ2UganNfY2hhbmdlIDogT3BTZXRCYWNrZW5kLmNoYW5nZSA9XG4gIHsgYWN0b3I9IEpzLnRvX3N0cmluZyBqc19jaGFuZ2UjIy5hY3RvclxuICA7IHNlcT0gaW50X29mX2pzX251bWJlciBqc19jaGFuZ2UjIy5zZXFcbiAgOyBkZXBzPSBhY3Rvcl9tYXBfb2ZfanNfb2JqIGpzX2NoYW5nZSMjLmRlcHNcbiAgOyBvcHM9IHRvX29wX2xpc3QganNfY2hhbmdlIyMub3BzIH1cblxubGV0IGpzX251bWJlcl9vZl9pbnQgaSA9IEpzLm51bWJlcl9vZl9mbG9hdCAoZmxvYXRfb2ZfaW50IGkpXG5cbmxldCBjaGFuZ2VfdG9fanNfY2hhbmdlIChjaGFuZ2UgOiBPcFNldEJhY2tlbmQuY2hhbmdlKSA9XG4gIENDQXJyYXkuZW1wdHlcbiAgfD4gb2JqX3NldCB+Y29udjpKcy5zdHJpbmcgXCJhY3RvclwiIGNoYW5nZS5hY3RvclxuICB8PiBvYmpfc2V0IH5jb252OihKcy5udW1iZXJfb2ZfZmxvYXQgJCBmbG9hdF9vZl9pbnQpIFwic2VxXCIgY2hhbmdlLnNlcVxuICB8PiBvYmpfc2V0IH5jb252Oihqc19vYmpfb2ZfYWN0b3JfbWFwIGpzX251bWJlcl9vZl9pbnQpIFwiZGVwc1wiIGNoYW5nZS5kZXBzXG4gIHw+IG9ial9zZXRcbiAgICAgICB+Y29udjooSnMuYXJyYXkgJCBDQ0FycmF5Lm9mX2xpc3QgJCBDQ0xpc3QubWFwIGNoYW5nZV9vcF90b19qc19jaGFuZ2Vfb3ApXG4gICAgICAgXCJvcHNcIiBjaGFuZ2Uub3BzXG4gIHw+IEpzLlVuc2FmZS5vYmpcblxubW9kdWxlIFRvSnMgPSBzdHJ1Y3RcbiAgbGV0IHJlcXVpcmVfbW9kdWxlIHMgPVxuICAgIEpzLlVuc2FmZS5mdW5fY2FsbFxuICAgICAgKEpzLlVuc2FmZS5qc19leHByIFwicmVxdWlyZVwiKVxuICAgICAgW3xKcy5VbnNhZmUuaW5qZWN0IChKcy5zdHJpbmcgcyl8XVxuXG4gIGxldCBudW1iZXIgPSBKcy5udW1iZXJfb2ZfZmxvYXQgJCBmbG9hdF9vZl9pbnRcblxuICBsZXQgY2xvY2sgKGNsb2NrIDogQkUuc2VxIEFjdG9yTWFwLnQpID0ganNfb2JqX29mX2FjdG9yX21hcCBudW1iZXIgY2xvY2tcblxuICBsZXQgY2hhbmdlX2xpc3QgbGlzID0gQ0NMaXN0Lm1hcCBjaGFuZ2VfdG9fanNfY2hhbmdlIGxpcyB8PiBsaXN0X3RvX2pzX2FycmF5XG5cbiAgbGV0IGltbV9NYXAgX2t2ID1cbiAgICBsZXQgaW1tdXRhYmxlID0gcmVxdWlyZV9tb2R1bGUgXCJpbW11dGFibGVcIiBpblxuICAgIGxldCBfTWFwID0gKEpzLlVuc2FmZS5jb2VyY2UgaW1tdXRhYmxlKSAjIy4gTWFwIGluXG4gICAgSnMuVW5zYWZlLihmdW5fY2FsbCAoaW5qZWN0IF9NYXApIFt8aW5qZWN0IF9rdnxdKVxuXG4gIGxldCBpbW0gbyA9XG4gICAgbGV0IGlzX2ltbSA9IChKcy5VbnNhZmUuY29lcmNlIG8pIyMudG9KUyBpblxuICAgIEpzLk9wdGRlZi5jYXNlIGlzX2ltbVxuICAgICAgKGZ1biAoKSAtPiBvKVxuICAgICAgKGZ1biBfIC0+IEpzLlVuc2FmZS4obWV0aF9jYWxsIChpbmplY3QgbykgXCJ0b0pTXCIgW3x8XSkpXG5lbmRcblxubW9kdWxlIEZyb21KcyA9IHN0cnVjdFxuICBsZXQgZnJvbV9pbW0gaW1tX29iaiA9IEpzLlVuc2FmZS4obWV0aF9jYWxsIChpbmplY3QgaW1tX29iaikgXCJ0b0pTXCIgW3x8XSlcblxuICBsZXQgY2xvY2sgX2Nsb2NrID1cbiAgICBsZXQgX3NpbXBsZSA9IGZyb21faW1tIF9jbG9jayBpblxuICAgIGxldCBfYWN0b3JzID0gSnMub2JqZWN0X2tleXMgX3NpbXBsZSB8PiBKcy50b19hcnJheSBpblxuICAgIENDQXJyYXkuZm9sZFxuICAgICAgKGZ1biBjbG9jayBfYWN0b3IgLT5cbiAgICAgICAgbGV0IF9zZXEgPSBKcy5VbnNhZmUuKGdldCAoaW5qZWN0IF9zaW1wbGUpIF9hY3RvcikgaW5cbiAgICAgICAgbGV0IHNlcSA6IEJFLnNlcSA9IGludF9vZl9mbG9hdCAoSnMuZmxvYXRfb2ZfbnVtYmVyIF9zZXEpIGluXG4gICAgICAgIEFjdG9yTWFwLmFkZCAoSnMudG9fc3RyaW5nIF9hY3Rvcikgc2VxIGNsb2NrIClcbiAgICAgIEFjdG9yTWFwLmVtcHR5IF9hY3RvcnNcbmVuZFxuXG4oKiBDb25zdHJ1Y3RzIGEgcGF0Y2ggb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgbm9kZSBzdGF0ZSBgc3RhdGVgIGFuZCB0aGUgbGlzdCAqKVxuKCogb2Ygb2JqZWN0IG1vZGlmaWNhdGlvbnMgYGRpZmZzYC4gKilcbmxldCBtYWtlX3BhdGNoIHQgZGlmZnMgPVxuICBsZXQgY2xvY2sgPSBPcFNldEJhY2tlbmQuZ2V0X2Nsb2NrIHQub3Bfc2V0IGluXG4gIG9iamVjdCVqc1xuICAgIHZhbCBjbG9jayA9IGpzX29ial9vZl9hY3Rvcl9tYXAganNfbnVtYmVyX29mX2ludCBjbG9ja1xuXG4gICAgdmFsIGRlcHMgPVxuICAgICAganNfb2JqX29mX2FjdG9yX21hcCBqc19udW1iZXJfb2ZfaW50IChPcFNldEJhY2tlbmQuZ2V0X2RlcHMgdC5vcF9zZXQpXG5cbiAgICB2YWwgY2FuVW5kbyA9IEpzLmJvb2wgKE9wU2V0QmFja2VuZC5jYW5fdW5kbyB0Lm9wX3NldClcblxuICAgIHZhbCBjYW5SZWRvID0gSnMuYm9vbCAoT3BTZXRCYWNrZW5kLmNhbl9yZWRvIHQub3Bfc2V0KVxuXG4gICAgdmFsIGRpZmZzID0gZGlmZnNcbiAgZW5kXG5cbmxldCBpbml0ICgpID0ge29wX3NldD0gT3BTZXRCYWNrZW5kLmluaXQgKCl9XG5cbmxldCBhcHBseSB0IGNoYW5nZXMgdW5kb2FibGUgPVxuICBsZXQgdCwgZGlmZnMgPVxuICAgIENDTGlzdC5mb2xkX2xlZnRcbiAgICAgIChmdW4gKHQsIGRpZmZzKSBjaGFuZ2UgLT5cbiAgICAgICAgbGV0IG9wX3NldCwgbmV3X2RpZmZzID1cbiAgICAgICAgICBPcFNldEJhY2tlbmQuYWRkX2NoYW5nZSB0Lm9wX3NldCBjaGFuZ2UgdW5kb2FibGVcbiAgICAgICAgaW5cbiAgICAgICAgKHtvcF9zZXR9LCBDQ0xpc3QuY29uY2F0IFtkaWZmczsgbmV3X2RpZmZzXSkgKVxuICAgICAgKHQsIFtdKSBjaGFuZ2VzXG4gIGluXG4gICh0LCBkaWZmcylcblxubGV0IGFwcGx5X2NoYW5nZXMgdCBjaGFuZ2VzID0gYXBwbHkgdCBjaGFuZ2VzIGZhbHNlXG5cbmxldCBfYXBwbHlfY2hhbmdlcyB0IGpzX2NoYW5nZXMgPVxuICBsZXQganNfY2hhbmdlcyA9IFRvSnMuaW1tIGpzX2NoYW5nZXMgaW5cbiAgbGV0IGNoYW5nZXMgPVxuICAgIENDQXJyYXkudG9fbGlzdCAoSnMudG9fYXJyYXkganNfY2hhbmdlcykgfD4gQ0NMaXN0Lm1hcCBqc19jaGFuZ2VfdG9fY2hhbmdlXG4gIGluXG4gIGxldCB0LCBkaWZmcyA9IGFwcGx5X2NoYW5nZXMgdCBjaGFuZ2VzIGluXG4gIGxldCBqc19kaWZmcyA9IGxpc3RfdG9fanNfYXJyYXkgKENDTGlzdC5tYXAgZWRpdF90b19qc19lZGl0IGRpZmZzKSBpblxuICBsZXQganNfcGF0Y2ggPSBtYWtlX3BhdGNoIHQganNfZGlmZnMgaW5cbiAgbGV0IHJldCA9IG5ldyVqcyBKcy5hcnJheV9sZW5ndGggMiBpblxuICBKcy5hcnJheV9zZXQgcmV0IDAgKEpzLlVuc2FmZS5pbmplY3QgdCkgO1xuICBKcy5hcnJheV9zZXQgcmV0IDEgKEpzLlVuc2FmZS5pbmplY3QganNfcGF0Y2gpIDtcbiAgcmV0XG5cbmxldCBhcHBseV9sb2NhbF9jaGFuZ2UgdCBqc19jaGFuZ2UgPVxuICBsZXQgY2hhbmdlID0ganNfY2hhbmdlX3RvX2NoYW5nZSBqc19jaGFuZ2UgaW5cbiAgbGV0IHJlcXVlc3RfdHlwZSA9IEpzLnRvX3N0cmluZyBqc19jaGFuZ2UjIy5yZXF1ZXN0VHlwZSBpblxuICBsZXQgdCwgZGlmZnMgPVxuICAgIGlmIENDU3RyaW5nLmVxdWFsIHJlcXVlc3RfdHlwZSBcImNoYW5nZVwiIHRoZW4gYXBwbHkgdCBbY2hhbmdlXSB0cnVlXG4gICAgZWxzZSByYWlzZSBVbmtub3duX3JlcXVlc3RfdHlwZVxuICBpblxuICBsZXQganNfZGlmZnMgPSBsaXN0X3RvX2pzX2FycmF5IChDQ0xpc3QubWFwIGVkaXRfdG9fanNfZWRpdCBkaWZmcykgaW5cbiAgbGV0IGpzX3BhdGNoID0gbWFrZV9wYXRjaCB0IGpzX2RpZmZzIGluXG4gIChKcy5VbnNhZmUuY29lcmNlIGpzX3BhdGNoKSMjLmFjdG9yIDo9IGpzX2NoYW5nZSMjLmFjdG9yIDtcbiAgKEpzLlVuc2FmZS5jb2VyY2UganNfcGF0Y2gpIyMuc2VxIDo9IGpzX2NoYW5nZSMjLnNlcSA7XG4gIGxldCByZXQgPSBuZXclanMgSnMuYXJyYXlfbGVuZ3RoIDIgaW5cbiAgSnMuYXJyYXlfc2V0IHJldCAwIChKcy5VbnNhZmUuaW5qZWN0IHQpIDtcbiAgSnMuYXJyYXlfc2V0IHJldCAxIChKcy5VbnNhZmUuaW5qZWN0IGpzX3BhdGNoKSA7XG4gIHJldFxuXG5sZXQgZGlmZl90b19qc19kaWZmIChkaWZmIDogT3BTZXRCYWNrZW5kLmRpZmYpID1cbiAgbGV0IGFjdGlvbiA9XG4gICAgSnMuc3RyaW5nXG4gICAgICAoIG1hdGNoIGRpZmYuYWN0aW9uIHdpdGhcbiAgICAgIHwgRGlmZlNldCAtPiBcInNldFwiXG4gICAgICB8IERpZmZDcmVhdGUgLT4gXCJjcmVhdGVcIlxuICAgICAgfCBEaWZmSW5zZXJ0IC0+IFwiaW5zZXJ0XCIgKVxuICBpblxuICBsZXQgdHlwZV8gPVxuICAgIEpzLnN0cmluZ1xuICAgICAgKCBtYXRjaCBkaWZmLnR5cGVfIHdpdGhcbiAgICAgIHwgRGlmZk1hcCAtPiBcIm1hcFwiXG4gICAgICB8IERpZmZUZXh0IC0+IFwidGV4dFwiXG4gICAgICB8IERpZmZMaXN0IC0+IFwibGlzdFwiIClcbiAgaW5cbiAgQ0NBcnJheS5lbXB0eSB8PiBvYmpfc2V0IFwiYWN0aW9uXCIgYWN0aW9uXG4gIHw+IG9ial9zZXRfb3B0ZGVmIEpzLnN0cmluZyBcImtleVwiIGRpZmYua2V5XG4gIHw+IG9ial9zZXQgfmNvbnY6SnMuc3RyaW5nIFwib2JqXCIgZGlmZi5vYmpcbiAgfD4gb2JqX3NldCBcInR5cGVcIiB0eXBlX1xuICB8PiBvYmpfc2V0X29wdGRlZiBKcy5ib29sIFwibGlua1wiIGRpZmYubGlua1xuICB8PiBvYmpfc2V0X29wdGRlZiBvcF92YWxfdG9fanNfdmFsdWUgXCJ2YWx1ZVwiIGRpZmYudmFsdWVcbiAgfD4gb2JqX3NldF9vcHRkZWYgKEpzLm51bWJlcl9vZl9mbG9hdCAkIGZsb2F0X29mX2ludCkgXCJpbmRleFwiIGRpZmYuaW5kZXhcbiAgfD4gb2JqX3NldF9vcHRkZWYgSnMuc3RyaW5nIFwiZWxlbUlkXCIgZGlmZi5lbGVtX2lkXG4gIHw+IG9ial9zZXRfb3B0ZGVmIGNvbmZsaWN0c190b19qc19jb25mbGljdHMgXCJjb25mbGljdHNcIiBkaWZmLmNvbmZsaWN0c1xuICB8PiBKcy5VbnNhZmUub2JqXG5cbmxldCBnZXRfcGF0Y2ggdCA9XG4gIGxldCBwYXRjaCA9IE9wU2V0QmFja2VuZC5nZXRfcGF0Y2ggdC5vcF9zZXQgaW5cbiAgbGV0IGRpZmZzID0gbGlzdF90b19qc19hcnJheSAoQ0NMaXN0Lm1hcCBkaWZmX3RvX2pzX2RpZmYgcGF0Y2guZGlmZnMpIGluXG4gIG9iamVjdCVqc1xuICAgIHZhbCBjYW5VbmRvID0gSnMuYm9vbCBwYXRjaC5jYW5fdW5kb1xuXG4gICAgdmFsIGNhblJlZG8gPSBKcy5ib29sIHBhdGNoLmNhbl9yZWRvXG5cbiAgICB2YWwgY2xvY2sgPSBqc19vYmpfb2ZfYWN0b3JfbWFwIGpzX251bWJlcl9vZl9pbnQgcGF0Y2guY2xvY2tcblxuICAgIHZhbCBkZXBzID0ganNfb2JqX29mX2FjdG9yX21hcCBqc19udW1iZXJfb2ZfaW50IHBhdGNoLmRlcHNcblxuICAgIHZhbCBkaWZmcyA9IGRpZmZzXG4gIGVuZFxuXG5sZXQgbWVyZ2UgbG9jYWwgcmVtb3RlID1cbiAgbGV0IGNoYW5nZXMgPVxuICAgIE9wU2V0QmFja2VuZC5nZXRfbWlzc2luZ19jaGFuZ2VzIHJlbW90ZS5vcF9zZXRcbiAgICAgIChPcFNldEJhY2tlbmQuZ2V0X2Nsb2NrIGxvY2FsLm9wX3NldClcbiAgaW5cbiAgbGV0IHQsIGRpZmZzID0gYXBwbHlfY2hhbmdlcyBsb2NhbCBjaGFuZ2VzIGluXG4gIGxldCBqc19kaWZmcyA9IGxpc3RfdG9fanNfYXJyYXkgKENDTGlzdC5tYXAgZWRpdF90b19qc19lZGl0IGRpZmZzKSBpblxuICBsZXQganNfcGF0Y2ggPSBtYWtlX3BhdGNoIHQganNfZGlmZnMgaW5cbiAgbGV0IHJldCA9IG5ldyVqcyBKcy5hcnJheV9sZW5ndGggMiBpblxuICBKcy5hcnJheV9zZXQgcmV0IDAgKEpzLlVuc2FmZS5pbmplY3QgdCkgO1xuICBKcy5hcnJheV9zZXQgcmV0IDEgKEpzLlVuc2FmZS5pbmplY3QganNfcGF0Y2gpIDtcbiAgcmV0XG5cbmxldCBnZXRfY2hhbmdlc19mb3JfYWN0b3IgdCBqc19hY3Rvcl9pZCA9XG4gIE9wU2V0QmFja2VuZC5nZXRfY2hhbmdlc19mb3JfYWN0b3IgdC5vcF9zZXQgKEpzLnRvX3N0cmluZyBqc19hY3Rvcl9pZClcbiAgfD4gQ0NMaXN0Lm1hcCBjaGFuZ2VfdG9fanNfY2hhbmdlXG4gIHw+IENDQXJyYXkub2ZfbGlzdCB8PiBKcy5hcnJheVxuXG5sZXQgZ2V0X2NoYW5nZXMgb2xkX3N0YXRlIG5ld19zdGF0ZSA9XG4gIGxldCBvbGRfY2xvY2sgPSBjbG9jayBvbGRfc3RhdGUgaW5cbiAgKCogZnVuY3Rpb24gbGVzc09yRXF1YWwoY2xvY2sxLCBjbG9jazIpIHsgKilcbiAgKCogICByZXR1cm4gY2xvY2sxLmtleVNlcSgpLmNvbmNhdChjbG9jazIua2V5U2VxKCkpLnJlZHVjZSggKilcbiAgKCogICAgIChyZXN1bHQsIGtleSkgPT4gKHJlc3VsdCAmJiBjbG9jazEuZ2V0KGtleSwgMCkgPD0gY2xvY2syLmdldChrZXksIDApKSwgKilcbiAgKCogICAgIHRydWUpICopXG4gICgqIH0gKilcbiAgQkUuZ2V0X21pc3NpbmdfY2hhbmdlcyBuZXdfc3RhdGUub3Bfc2V0IG9sZF9jbG9ja1xuICB8PiBDQ0xpc3QubWFwIGNoYW5nZV90b19qc19jaGFuZ2VcbiAgfD4gbGlzdF90b19qc19hcnJheVxuXG5sZXQgZ2V0X21pc3NpbmdfY2hhbmdlcyB0IF9jbG9jayA9XG4gIGxldCBjbG9jayA9IEZyb21Kcy5jbG9jayBfY2xvY2sgaW5cbiAgbGV0IGNoYW5nZXMgPSBCRS5nZXRfbWlzc2luZ19jaGFuZ2VzIHQub3Bfc2V0IGNsb2NrIGluXG4gIFRvSnMuY2hhbmdlX2xpc3QgY2hhbmdlc1xuXG5sZXQgZ2V0X2Nsb2NrIHQgPVxuICBsZXQgaW1tdXRhYmxlID0gVG9Kcy5yZXF1aXJlX21vZHVsZSBcImltbXV0YWJsZVwiIGluXG4gIGxldCBtYXAgPSAoSnMuVW5zYWZlLmNvZXJjZSBpbW11dGFibGUpICMjLiBNYXAgaW5cbiAgbGV0IGNsb2NrID0gVG9Kcy5jbG9jayAoT3BTZXRCYWNrZW5kLmdldF9jbG9jayB0Lm9wX3NldCkgaW5cbiAgSnMuVW5zYWZlLmZ1bl9jYWxsIChKcy5VbnNhZmUuaW5qZWN0IG1hcCkgW3xKcy5VbnNhZmUuaW5qZWN0IGNsb2NrfF1cblxubGV0IF8gPVxuICBKcy5leHBvcnQgXCJpbml0XCIgaW5pdCA7XG4gIEpzLmV4cG9ydCBcImFwcGx5Q2hhbmdlc1wiIF9hcHBseV9jaGFuZ2VzIDtcbiAgSnMuZXhwb3J0IFwiYXBwbHlMb2NhbENoYW5nZVwiIGFwcGx5X2xvY2FsX2NoYW5nZSA7XG4gIEpzLmV4cG9ydCBcImdldFBhdGNoXCIgZ2V0X3BhdGNoIDtcbiAgSnMuZXhwb3J0IFwibWVyZ2VcIiBtZXJnZSA7XG4gIEpzLmV4cG9ydCBcImdldENoYW5nZXNGb3JBY3RvclwiIGdldF9jaGFuZ2VzX2Zvcl9hY3RvciA7XG4gIEpzLmV4cG9ydCBcImdldENoYW5nZXNcIiBnZXRfY2hhbmdlcyA7XG4gIEpzLmV4cG9ydCBcImdldE1pc3NpbmdDaGFuZ2VzXCIgZ2V0X21pc3NpbmdfY2hhbmdlcyA7XG4gIEpzLmV4cG9ydCBcImdldENsb2NrXCIgZ2V0X2Nsb2NrXG4iXX0=